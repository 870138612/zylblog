import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as o,e as c,a as n,b as a,f as t}from"./app-d9396490.js";const p="/markdown/0518153127.jpg",d="/markdown/518153216.jpg",i={},l=n("p",null,[a("AQS的全称为 "),n("code",null,"AbstractQueuedSynchronizer"),a(" ，翻译过来的意思就是抽象队列同步器。这个类在 "),n("code",null,"java.util.concurrent.locks"),a(" 包下面。")],-1),r=t('<p>AQS就是一个抽象类，主要用来构建锁和同步器。</p><p>比如 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于AQS实现的。</p><h2 id="aqs-原理" tabindex="-1"><a class="header-anchor" href="#aqs-原理" aria-hidden="true">#</a> AQS 原理</h2><h3 id="aqs-核心思想" tabindex="-1"><a class="header-anchor" href="#aqs-核心思想" aria-hidden="true">#</a> AQS 核心思想</h3><p>AQS的核心思想是如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源的状态设置为锁定状态。如果资源被占用，则需要一套线程阻塞等待以及被唤醒分配的机制，这个机制AQS是基于<strong>CLH</strong>锁实现的。</p><p>CLH锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS将每条请求共享资源的线程封装成一个CLH队列锁的一个节点（Node）来实现锁的分配。在CLH队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p><p>CLH锁的结构如下：</p><p><img src="'+p+'" alt="0518153127"></p><p>AQS的核心原理图如下：</p><p><img src="'+d+`" alt="518153216"></p><p><strong>AQS使用 <code>int</code> 成员变量 <code>state</code> 表示同步状态，通过内置的线程等待队列来完成获取资源线程的排队工作。</strong></p><p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况，保证可见性和有序性。</p><h3 id="aqs-资源共享方式" tabindex="-1"><a class="header-anchor" href="#aqs-资源共享方式" aria-hidden="true">#</a> AQS 资源共享方式</h3><p>AQS定义两种资源共享方式：<code>Exclusive</code>（独占，只有一个线程能执行，如<code>ReentrantLock</code>）和<code>Share</code>（共享，多个线程可同时执行，如 <code>Semaphore</code> / <code>CountDownLatch</code>）。</p><h2 id="semaphore-信号量" tabindex="-1"><a class="header-anchor" href="#semaphore-信号量" aria-hidden="true">#</a> Semaphore（信号量）</h2><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而 <code>Semaphore</code>（信号量）可以用来控制同时访问特定资源的线程数量。</p><p>Semaphore的使用简单，假设有N(N&gt;5)个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻N个线程中只有5个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取1个许可，相当于P操作</span>
semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 释放1个许可，相当于V操作</span>
semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Semaphore</code> 有两种模式：</p><ul><li><strong>公平模式</strong>：调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循FIFO；</li><li><strong>非公平模式</strong>：抢占式的，默认模式。</li></ul><p><strong>原理：</strong></p><p><code>Semaphore</code> 是共享锁的一种实现，它默认构造AQS的 <code>state</code> 值为 <code>permits</code>，可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p><ul><li><p><strong>P操作</strong>：调用 <code>semaphore.acquire()</code>，线程尝试获取许可证，如果 <code>state &gt; 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用CAS操作去修改<code>state</code>的值 <code>state=state-1</code>。如果 <code>state &lt;= 0</code> 的话，则表示许可证数量不足。此时会创建一个Node节点加入阻塞队列，挂起当前线程。</p></li><li><p><strong>V操作</strong>：调用<code>semaphore.release()</code> ，线程尝试释放许可证，并使用CAS操作去修改 <code>state</code> 的值 <code>state = state + 1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state = state - 1</code>，如果 <code>state &gt; 0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p></li></ul><p>除了 <code>acquire()</code> 方法之外，另一个比较常用的与之对应的方法是 <code>tryAcquire()</code> 方法，该方法如果获取不到许可就立即返回false。</p><h2 id="countdownlatch-倒计时器" tabindex="-1"><a class="header-anchor" href="#countdownlatch-倒计时器" aria-hidden="true">#</a> CountDownLatch（倒计时器）</h2><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><p><code>CountDownLatch</code> 是共享锁的一种实现，它默认构造AQS的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时，其实使用了 <code>tryReleaseShared</code> 方法以CAS的操作来减少 <code>state</code>,直至 <code>state</code> 为0。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞。然后 <code>CountDownLatch</code> 会自旋CAS判断 <code>state == 0</code>，如果 <code>state == 0</code> 就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p><p><strong>两种典型用法</strong></p><ol><li>等待n个线程完成任务之后，主线程继续工作。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
子线程<span class="token number">1</span>：
    <span class="token comment">//业务代码</span>
    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将state值-1</span>
子线程<span class="token number">2</span>：
    <span class="token comment">//业务代码</span>
    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将state值-1</span>
<span class="token operator">--</span><span class="token operator">--</span>
主线程：countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等到state值为0的时候才不会被阻塞，等待两个线程执行完成</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>等待n个线程准备，在执行任务前先<code>countDownLatch.awit()</code>，然后主线程调用<code>countDown()</code>计数值变0，n个线程同时被唤醒。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>子线程<span class="token number">1</span>：countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待state值变为0</span>
<span class="token comment">//业务代码</span>
子线程<span class="token number">2</span>：countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//业务代码</span>
<span class="token operator">--</span><span class="token operator">--</span>
主线程：countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将state值变为0，类似信号枪响</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="cyclicbarrier-循环栅栏" tabindex="-1"><a class="header-anchor" href="#cyclicbarrier-循环栅栏" aria-hidden="true">#</a> CyclicBarrier（循环栅栏）</h2><p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏，就将计数器减1，并将自身阻塞。如果count值为0了，表示最后一个线程到达栅栏，此时才会将栅栏放开，让所有线程继续执行下去。</p><p>使用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 已经到达了屏障，然后当前线程被阻塞。当 <code>count</code> 值为0则会将被阻塞的线程唤醒。</p>`,36);function u(m,k){return s(),o("div",null,[l,c(" more "),r])}const b=e(i,[["render",u],["__file","5aqs.html.vue"]]);export{b as default};
