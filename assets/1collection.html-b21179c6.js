import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,f as t,e}from"./app-924598b8.js";const o={},c=e("<p>Java集合由两大接口派生而来，分别是用来存放单一元素的 <code>Collection</code> 和用来存放键值对的 <code>Map</code> 接口。对于 <code>Collection</code> 接口有三个子接口，分别是 <code>List</code>、<code>Set</code>、<code>Queue</code>。</p><p>💡 <code>Map</code> 不是集合接口。</p>",2),i=e(`<h3 id="说说-list-set-queue-map-四者的区别" tabindex="-1"><a class="header-anchor" href="#说说-list-set-queue-map-四者的区别" aria-hidden="true">#</a> 说说 List，Set，Queue，Map 四者的区别？</h3><ul><li><code>List</code> （顺序存储）存储的元素是有序的，可以重复；</li><li><code>Set</code> （独一无二）存储的元素无序，不可重复；</li><li><code>Queue</code> （排队）按特定的排队规则确定元素先后顺序，元素是有序的，可重复的；</li><li><code>Map</code> （用 key 搜索）使用键值对存储，key 是无序的，不可重复的，value 是无序的，可重复的。</li></ul><h3 id="集合框架底层数据结构" tabindex="-1"><a class="header-anchor" href="#集合框架底层数据结构" aria-hidden="true">#</a> 集合框架底层数据结构</h3><p><strong>List</strong></p><ul><li><code>ArrayList</code>：<code>Object[]</code> 数组；</li><li><code>Vector</code>：<code>Object[]</code> 数组；</li><li><code>LinkedList</code>：双向链表（JDK 1.6 之前为循环链表，JDK 1.7 取消）。</li></ul><p><strong>Set</strong></p><ul><li><code>HashSet</code>（无序，唯一）：基于 <code>HashMap</code> 实现，底层使用 <code>HashMap</code> 保存数据；</li><li><code>LinkedHashMap</code> ：<code>LinkedHashSet</code> 是 <code>HashSet</code> 子类，内部都是通过 <code>LinkedHashMap</code> 实现；</li><li><code>TreeSet</code>（有序，唯一）：红黑树（自平衡的排序二叉树）。</li></ul><p><strong>Queue</strong></p><ul><li><code>PriorityQueue</code>：<code>Object[]</code> 数组来实现二叉堆；</li><li><code>ArrayQueue</code>：<code>Object[]</code> 数组 + 双指针。</li></ul><p><strong>Map</strong></p><ul><li><code>HashMap</code> ：JDK 1.8 之前 <code>HashMap</code> 由数组 + 链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在。JDK 1.8 以后由数组 + 链表/红黑树组成，当链表长度大于阈值（默认为 8），数组长度大于等于 64 的时候会进行树化，转化为红黑树加快查找。</li><li><code>LinkedHashMap</code> ：<code>LinkedHashMap</code> 继承自 <code>HashMap</code> ，底层是数组 + 链表/红黑树。<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><code>Hashtable</code> ：数组 + 链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在。</li></ul><h2 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h2><h3 id="说说-arraylist" tabindex="-1"><a class="header-anchor" href="#说说-arraylist" aria-hidden="true">#</a> 说说 ArrayList</h3><ul><li><code>ArrayList</code> 存储元素的特点是顺序，可重复；</li><li><code>ArrayList</code> 会根据实际存储的元素动态扩容或者缩容；</li><li><code>ArrayList</code> 只能存储对象，不能存储基本类型，需要使用包装类；</li><li><code>ArrayList</code> 支持插入、删除、遍历等操作；</li><li><code>ArrayList</code> 能插入 <code>null</code> ；</li><li>超过容量之后触发扩容；</li><li>扩容后大小为 <code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code> ;</li><li>JDK 1.8 以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</li><li>在多线程下插入元素会出现数组越界的情况，插入操作是 <code>elementData[size++] = e</code>，如果两个线程都在数组的最后一个位置插入，则当中一个操作就会出现数组越界，因为检查数组是否已经满了和插入操作不是原子操作。</li></ul><h3 id="arrylist-和-vector-区别" tabindex="-1"><a class="header-anchor" href="#arrylist-和-vector-区别" aria-hidden="true">#</a> ArryList 和 Vector 区别？</h3><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层用 <code>Object[]</code> 存储，适用于频繁查找的场景，线程不安全；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层用 <code>Object[]</code> 存储，线程安全。</li></ul><h3 id="arraylist-与-linkedlist-区别" tabindex="-1"><a class="header-anchor" href="#arraylist-与-linkedlist-区别" aria-hidden="true">#</a> ArrayList 与 LinkedList 区别？</h3><ul><li>首先两者都不是线程安全的实现；</li><li><code>ArrayList</code> 底层使用 <code>Object[]</code> 存储元素，<code>LinkedList</code> 底层使用双向链表存储数据（JDK 1.6 之前为循环链表，1.7 取消循环）；</li><li><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，可以随机访问，<code>LinkedList</code> 不支持随机访问；</li><li>由于 <code>LinkedList</code> 内部包含前驱和后继，占用内存比 <code>ArrayList</code> 大。</li></ul><h2 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h2><h3 id="比较-hashset、linkedhashset-和-treeset-三者的异同" tabindex="-1"><a class="header-anchor" href="#比较-hashset、linkedhashset-和-treeset-三者的异同" aria-hidden="true">#</a> 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li><code>HashSet</code> 、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code> 底层是哈希表， <code>LinkedHashSet</code> 底层是链表和哈希表，元素的插入满足队列特性，<code>TreeSet</code> 底层是红黑树，元素是有序的。</li><li>根据应用场景不同，对元素顺序无要求则用 <code>HashSet</code> ，有要求使用 <code>TreeSet</code> ，需要满足 FIFO 使用 <code>LinkedHashSet</code> 。</li></ul><h2 id="queue" tabindex="-1"><a class="header-anchor" href="#queue" aria-hidden="true">#</a> Queue</h2><p>队列满足 FIFO 性质，<code>Queue</code> 因为容量问题导致操作失败后的处理方式不同分为两类方法；</p><table><thead><tr><th style="text-align:center;"><code>Queue</code></th><th style="text-align:center;">抛出异常</th><th style="text-align:center;">返回特殊值</th></tr></thead><tbody><tr><td style="text-align:center;">插入队尾</td><td style="text-align:center;">add(E e)</td><td style="text-align:center;">offer(E e)</td></tr><tr><td style="text-align:center;">删除队首</td><td style="text-align:center;">remove()</td><td style="text-align:center;">poll()</td></tr><tr><td style="text-align:center;">查询队首元素</td><td style="text-align:center;">element()</td><td style="text-align:center;">peek()</td></tr></tbody></table><p><code>Deque</code> 是双端队列，在队列两端都能插入和删除元素，同样根据返回值不同分为两类方法；</p><table><thead><tr><th style="text-align:center;"><code>Deque</code></th><th style="text-align:center;">抛出异常</th><th style="text-align:center;">返回特殊值</th></tr></thead><tbody><tr><td style="text-align:center;">插入队尾</td><td style="text-align:center;">addFirst(E e)</td><td style="text-align:center;">offerFirst(E e)</td></tr><tr><td style="text-align:center;">插入队首</td><td style="text-align:center;">addLast(E e)</td><td style="text-align:center;">offerLast(E e)</td></tr><tr><td style="text-align:center;">删除队首</td><td style="text-align:center;">removeFirst()</td><td style="text-align:center;">pollFirst()</td></tr><tr><td style="text-align:center;">删除队尾</td><td style="text-align:center;">removeLast()</td><td style="text-align:center;">pollLast()</td></tr><tr><td style="text-align:center;">查询队首元素</td><td style="text-align:center;">getFirst()</td><td style="text-align:center;">peekFirst()</td></tr><tr><td style="text-align:center;">查询队尾元素</td><td style="text-align:center;">getLast()</td><td style="text-align:center;">peekLast()</td></tr></tbody></table><h3 id="arraydeque-与-linkedlist-的区别" tabindex="-1"><a class="header-anchor" href="#arraydeque-与-linkedlist-的区别" aria-hidden="true">#</a> ArrayDeque 与 LinkedList 的区别</h3><ul><li><p><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现；</p></li><li><p><code>ArrayDeque</code> 不支持存储 <code>null</code> 数据，但 <code>LinkedList</code> 支持；</p></li><li><p><code>ArrayDeque</code> 是在 JDK 1.6 才被引入的，而<code>LinkedList</code> 早在 JDK 1.2 时就已经存在；</p></li><li><p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p></li></ul><h3 id="priorityqueue" tabindex="-1"><a class="header-anchor" href="#priorityqueue" aria-hidden="true">#</a> PriorityQueue</h3><p><code>PriorityQueue</code> 是在JDK 1.5中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><ul><li><code>PriorityQueue</code> 使用变长数组存储元素，使用二叉堆实现结构；</li><li><code>PriorityQueue</code> 使用堆实现了在 <code>O(logn)</code> 的时间复杂度内插入和删除元素；</li><li><code>PriorityQueue</code> 是线程不安全的，不支持存储 <code>null</code> 和 <code>non-comparable</code> 对象；</li><li><code>PriorityQueue</code> 默认是小顶堆。</li></ul><p><strong>堆排序的伪代码（重要）元素下标从 1 开始</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//调整函数 建立大顶堆</span>
<span class="token keyword">void</span> <span class="token class-name">Sift</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> <span class="token class-name">R</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token class-name">R</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token operator">++</span>j<span class="token punctuation">;</span><span class="token comment">//j指向左右孩子中大的那个</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> <span class="token class-name">R</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">R</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            i <span class="token operator">=</span> j<span class="token punctuation">;</span>
            j <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">R</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//堆排序</span>
<span class="token keyword">void</span> <span class="token function">headSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Sift</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        temp <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">R</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">R</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token class-name">Sift</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="blockingqueue" tabindex="-1"><a class="header-anchor" href="#blockingqueue" aria-hidden="true">#</a> BlockingQueue</h3><p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code> 。<code>BlockingQueue</code> 阻塞的原因是其支持当队列没有元素时一直阻塞，直到有有元素；如果队列已满，一直等到队列可以放入新元素时再放入。</p><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p><h3 id="arrayblockingqueue-和-linkedblockingqueue-有什么区别" tabindex="-1"><a class="header-anchor" href="#arrayblockingqueue-和-linkedblockingqueue-有什么区别" aria-hidden="true">#</a> ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？</h3><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 是 Java 并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别：</p><ul><li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li><li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是 <code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li><li>锁是否分离：<code>ArrayBlockingQueue</code> 中的锁是没有分离的，即生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code> 中的锁是分离的，即生产用的是 <code>putLock</code>，消费是 <code>takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺。</li><li>内存占用：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。这意味着 <code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而 <code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li></ul>`,39);function l(p,d){return a(),s("div",null,[c,t(" more "),i])}const k=n(o,[["render",l],["__file","1collection.html.vue"]]);export{k as default};
