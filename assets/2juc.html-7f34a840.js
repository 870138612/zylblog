const l=JSON.parse('{"key":"v-6a5c135d","path":"/java/3juc/2juc.html","title":"并发编程二","lang":"zh-CN","frontmatter":{"title":"并发编程二","icon":"page","category":["Java"],"tag":["并发编程"]},"headers":[{"level":2,"title":"Java 内存模型","slug":"java-内存模型","link":"#java-内存模型","children":[{"level":3,"title":"指令重排序","slug":"指令重排序","link":"#指令重排序","children":[]},{"level":3,"title":"什么是 Java 内存模型？为什么需要 Java 内存模型？","slug":"什么是-java-内存模型-为什么需要-java-内存模型","link":"#什么是-java-内存模型-为什么需要-java-内存模型","children":[]},{"level":3,"title":"什么是主内存？什么是本地内存？","slug":"什么是主内存-什么是本地内存","link":"#什么是主内存-什么是本地内存","children":[]},{"level":3,"title":"Java 内存结构和 Java 内存模型的区别","slug":"java-内存结构和-java-内存模型的区别","link":"#java-内存结构和-java-内存模型的区别","children":[]},{"level":3,"title":"happens-before","slug":"happens-before","link":"#happens-before","children":[]},{"level":3,"title":"happens-before 常见规则","slug":"happens-before-常见规则","link":"#happens-before-常见规则","children":[]},{"level":3,"title":"fail-safe 和 fail-fast","slug":"fail-safe-和-fail-fast","link":"#fail-safe-和-fail-fast","children":[]}]},{"level":2,"title":"并发编程的三个特性","slug":"并发编程的三个特性","link":"#并发编程的三个特性","children":[]},{"level":2,"title":"volatile 关键字","slug":"volatile-关键字","link":"#volatile-关键字","children":[{"level":3,"title":"volatile 如何禁止指令重排序？","slug":"volatile-如何禁止指令重排序","link":"#volatile-如何禁止指令重排序","children":[]}]},{"level":2,"title":"乐观锁和悲观锁","slug":"乐观锁和悲观锁","link":"#乐观锁和悲观锁","children":[{"level":3,"title":"什么是乐观锁？","slug":"什么是乐观锁","link":"#什么是乐观锁","children":[]},{"level":3,"title":"什么是悲观锁？","slug":"什么是悲观锁","link":"#什么是悲观锁","children":[]},{"level":3,"title":"CAS","slug":"cas","link":"#cas","children":[]},{"level":3,"title":"ABA 问题","slug":"aba-问题","link":"#aba-问题","children":[]},{"level":3,"title":"CAS 问题","slug":"cas-问题","link":"#cas-问题","children":[]}]},{"level":2,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[{"level":3,"title":"synchronized 是什么？有什么用？","slug":"synchronized-是什么-有什么用","link":"#synchronized-是什么-有什么用","children":[]},{"level":3,"title":"sychronized 修饰方法","slug":"sychronized-修饰方法","link":"#sychronized-修饰方法","children":[]},{"level":3,"title":"synchronized 底层原理","slug":"synchronized-底层原理","link":"#synchronized-底层原理","children":[]},{"level":3,"title":"synchronized 和 volatile 有什么区别？","slug":"synchronized-和-volatile-有什么区别","link":"#synchronized-和-volatile-有什么区别","children":[]},{"level":3,"title":"Lock 和 synchronized 有什么区别？","slug":"lock-和-synchronized-有什么区别","link":"#lock-和-synchronized-有什么区别","children":[]},{"level":3,"title":"wait 和 notify 为什么要在 synchronized 代码块中？","slug":"wait-和-notify-为什么要在-synchronized-代码块中","link":"#wait-和-notify-为什么要在-synchronized-代码块中","children":[]}]},{"level":2,"title":"ReentrantLock","slug":"reentrantlock","link":"#reentrantlock","children":[{"level":3,"title":"ReentrantLock 是什么？","slug":"reentrantlock-是什么","link":"#reentrantlock-是什么","children":[]},{"level":3,"title":"公平锁和非公平锁有什么区别？","slug":"公平锁和非公平锁有什么区别","link":"#公平锁和非公平锁有什么区别","children":[]},{"level":3,"title":"ReentrantLock 加锁解锁原理","slug":"reentrantlock-加锁解锁原理","link":"#reentrantlock-加锁解锁原理","children":[]},{"level":3,"title":"synchronized 和 ReentrantLock 有什么区别？","slug":"synchronized-和-reentrantlock-有什么区别","link":"#synchronized-和-reentrantlock-有什么区别","children":[]},{"level":3,"title":"可中断锁和不可中断锁有什么区别？","slug":"可中断锁和不可中断锁有什么区别","link":"#可中断锁和不可中断锁有什么区别","children":[]}]}],"git":{"createdTime":1684306897000,"updatedTime":1695735858000,"contributors":[{"name":"ZYL1210","email":"870138612@qq.com","commits":37}]},"readingTime":{"minutes":15.73,"words":4719},"filePathRelative":"java/3juc/2juc.md","localizedDate":"2023年5月17日","excerpt":"<h2> Java 内存模型</h2>\\n<h3> 指令重排序</h3>\\n<ul>\\n<li>编译器优化重排：编译器在不改变单线程程序语义的前提下，重新安排语句执行顺序。</li>\\n<li>指令并行重排：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>\\n</ul>\\n<p>指令重排序可以保证串行语义的一致，但是没义务保证多线程之间语义的一致，在多线程下，指令重排可能会导致问题。</p>\\n"}');export{l as data};
