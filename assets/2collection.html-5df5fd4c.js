import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as o,f as s,e}from"./app-4fa48032.js";const c={},d=e('<h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2><h3 id="hashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#hashmap-和-hashtable-的区别" aria-hidden="true">#</a> HashMap 和 Hashtable 的区别</h3><ul><li><strong>线程是否安全</strong>：<code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的，内部方法使用 <code>synchronized</code> 修饰。</li><li><strong>效率</strong>：由于不需要加锁，<code>HashMap</code> 的效率要稍微好点。</li><li><strong>是否能存储 Null Key 和 Value</strong>：<code>HashMap</code> 能存储 <code>null</code> 的 key 和 value，但是作为 <code>null</code> 的 key 只能有一个，<code>Hashtable</code> 不能有 <code>null</code> key 和 value。</li><li><strong>扩容</strong>：<code>Hashtable</code> 默认初始大小是 11，扩容之后变为 2n+1。<code>HashMap</code> 默认大小是 16，当元素个数超过<strong>负载因子*表长</strong>时扩容，每次扩容变为原来的两倍。</li><li><strong>底层</strong>：JDK 1.8 之后 <code>HashMap</code> 底层使用数组 + 链表/红黑树，特定条件链表转化为红黑树，<code>Hashtable</code> 则没有转化为红黑树的机制。</li></ul>',3),t=e(`<h3 id="hashmap-和-treemap-区别" tabindex="-1"><a class="header-anchor" href="#hashmap-和-treemap-区别" aria-hidden="true">#</a> HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和 <code>HashMap</code> 都继承自 <code>AbstractMap</code>，<code>TreeMap</code> 还实现了 <code>NavigableMap</code> 接口和 <code>SortedMap</code> 接口。实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。实现 <code>SortedMap</code> 接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序。</p><h3 id="hashmap-的底层实现" tabindex="-1"><a class="header-anchor" href="#hashmap-的底层实现" aria-hidden="true">#</a> HashMap 的底层实现</h3><h4 id="jdk-1-8-之前" tabindex="-1"><a class="header-anchor" href="#jdk-1-8-之前" aria-hidden="true">#</a> JDK 1.8 之前</h4><p>JDK 1.8之前 <code>HashMap</code> 底层是数组和链表集合一起，通过 key 的 <code>hashcode</code> 经过扰动函数之后获得 hash 值，通过 <code>(n-1)&amp;hash</code> 计算元素存放的位置。</p><p>找到存放位置之后判断当前位置元素和要存入的元素 hash 值和 key 是否相同，相同则直接覆盖，否则通过链表法解决冲突。</p><p>JDK 1.8 中的扰动函数源码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token comment">// key.hashCode()：返回散列值也就是hashcode</span>
    <span class="token comment">// ^：按位异或</span>
    <span class="token comment">// &gt;&gt;&gt;：无符号右移，忽略符号位，空位都以0补齐</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="jdk-1-8-之后" tabindex="-1"><a class="header-anchor" href="#jdk-1-8-之后" aria-hidden="true">#</a> JDK 1.8 之后</h4><p>JDK 1.8 之后 <code>HashMap</code> 使用数组 + 链表/红黑树作为底层，当单个链表的长度<strong>大于 8</strong>（默认 8），数组长度<strong>大于等于 64</strong> 的时候就会触发树化，将链表转化为红黑树，以此减少查找时间。</p><h3 id="hashmap-的长度为什么是-2-的幂次方" tabindex="-1"><a class="header-anchor" href="#hashmap-的长度为什么是-2-的幂次方" aria-hidden="true">#</a> HashMap 的长度为什么是 2 的幂次方？</h3><p>Hash值的取值为 32 位补码的取值范围，一般情况很难出现碰撞。但是范围过大不可能直接放入内存中进行计算，因此需要先通过取模运算（数据结构散列表中除留余数法），通过位运算实现取模。</p><p>假设数组长度 n 为 16；Hash 值为 <code>0111 0000 1001 0000 0000 1001 1110 1101</code></p><table><thead><tr><th style="text-align:center;"><strong>Hash</strong></th><th style="text-align:center;"><strong>0111 0000 1001 0000 0000 1001 1110 1101</strong></th></tr></thead><tbody><tr><td style="text-align:center;"><strong>n-1</strong></td><td style="text-align:center;"><strong>0000 0000 0000 0000 0000 0000 0000 1111</strong></td></tr><tr><td style="text-align:center;"><strong>Hash&amp;(n-1)</strong></td><td style="text-align:center;"><strong>0000 0000 0000 0000 0000 0000 0000 1101</strong></td></tr></tbody></table><h3 id="hashmap-多线程操作导致死链问题" tabindex="-1"><a class="header-anchor" href="#hashmap-多线程操作导致死链问题" aria-hidden="true">#</a> HashMap 多线程操作导致死链问题</h3><p>JDK 1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，<strong>头插法</strong>可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p><p>JDK 1.8 之后通过尾插法解决上述问题。但是在多线程下还是会出现数据覆盖问题，推荐使用线程安全的<code>CucurrentHashMap</code>。</p><h3 id="concurrenthashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-和-hashtable-的区别" aria-hidden="true">#</a> ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构</strong>：JDK 1.7 的 <code>ConcurrentHashMap</code> 底层采用分段的 <code>Segment</code>、<code>HashEntry</code> 数组 + 链表实现，JDK 1.8 时采用 <code>Node</code> + 链表/红黑二叉树。<code>Hashtable</code> 和 JDK 1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用<strong>数组+链表</strong>的形式，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><strong>实现线程安全的方式（重要）</strong>： <ul><li>JDK 1.7 的时候，<code>ConcurrentHashMap</code> 底层采用分段的 <code>Segment</code>、<code>HashEntry</code> 数组 + 链表实现，每一把锁锁住一个 <code>Segment</code>，<code>Segment</code> 的个数固定默认 16，也就是并发度固定为 16。</li><li>到了 JDK 1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，改用 <code>Node</code> 数组 + 链表/红黑树，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。（CAS 在当前的 Node 下没有元素时使用 CAS 添加元素，而不是使用 <code>synchronized</code>）</li><li><code>Hashtable</code> 使用同一个锁进行并发控制，效率低下。</li></ul></li></ul><h3 id="jdk-1-7-和-jdk-1-8-的-concurrenthashmap-实现有什么不同" tabindex="-1"><a class="header-anchor" href="#jdk-1-7-和-jdk-1-8-的-concurrenthashmap-实现有什么不同" aria-hidden="true">#</a> JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3><ul><li><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全，<code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK 1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li><li><strong>Hash 解决碰撞办法</strong>：JDK 1.7 采用拉链法，JDK 1.8 采用拉链法 + 红黑树。</li><li><strong>并发度</strong>：JDK 1.7 中最大的并发度是 <code>Segment</code> 的个数，默认是 16。JDK 1.8 最大并发度是 <code>Node</code> 的个数，并发度更大。</li></ul><h3 id="jdk-8-中的-concurrenthashmap-是怎么保证并发安全的" tabindex="-1"><a class="header-anchor" href="#jdk-8-中的-concurrenthashmap-是怎么保证并发安全的" aria-hidden="true">#</a> JDK 8 中的 ConcurrentHashMap 是怎么保证并发安全的？</h3><p>主要利用 <code>Unsafe</code> 操作 + <code>synchronized</code> 关键字。</p><p><code>synchronized</code> 主要负责在需要操作某个位置时进行加锁（该位置不为空），比如向某个位置的链表插入结点，向某个位置的红黑树插入结点。</p><p>JDK 8 中其实仍然有分段锁的思想，JDK 8 中是 <code>Node</code> 数组的每一个位置都有一把锁。</p><p>当向 <code>ConcurrentHashMap</code> 中 <code>put</code> 一个 <code>key,value</code> 时，</p><ol><li>首先根据 <code>key</code> 计算对应的 <code>Node</code> 数组下表，如果该位置没有元素，则通过自旋的方式 CAS 去向该位置赋值。</li><li>如果该位置有元素，则会通过 <code>synchronized</code> 对第一个 <code>Node</code> 进行加锁。</li><li>加锁成功之后，找到空位插入新的 <code>Node</code>。</li><li>添加成功之后判断是否需要树化（节点个数<strong>大于</strong> 8，元素总个数<strong>大于等于</strong> 64）。</li><li><code>addCount</code>，此方法将总元素的计数值 + 1，之后判断是否需要扩容。</li><li>同时在一个线程 <code>put</code> 时发现当前 <code>ConcurrentHashMap</code> 正在扩容则会去帮助扩容。</li></ol>`,28);function r(h,p){return n(),o("div",null,[d,s(" more "),t])}const u=a(c,[["render",r],["__file","2collection.html.vue"]]);export{u as default};
