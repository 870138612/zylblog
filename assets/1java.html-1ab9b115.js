import{_ as e,X as c,Y as o,a2 as d,Z as a,a3 as i}from"./framework-a3ecc17a.js";const l={},t=a("div",{class:"hint-container tip"},[a("p",{class:"hint-container-title"},"提示"),a("p",null,"知识点都是来自网络整理的，不保证完全正确")],-1),r=i('<hr><h2 id="jvm-jre-jdk" tabindex="-1"><a class="header-anchor" href="#jvm-jre-jdk" aria-hidden="true">#</a> JVM JRE JDK</h2><p>JVM是java虚拟机，针对不同系统有不同的实现，常用的为HotSpot VM。</p><p>JDK是功能齐全的SDK，包含JRE和一些其他的工具，例如javac，java等。</p><p>JRE是Java运行时环境，仅包含Java应用程序运行时的必要环境。</p><p><img src="https://blog-1312634242.cos.ap-shanghai.myqcloud.com/markdown/image-20230514210704461.png" alt="image-20230514210704461"></p><h2 id="什么是字节码-采用字节码的好处" tabindex="-1"><a class="header-anchor" href="#什么是字节码-采用字节码的好处" aria-hidden="true">#</a> 什么是字节码？采用字节码的好处？</h2><p>JVM能理解的代码就是字节码，字节码解决了传统解释语言运行效率低的问题，还具有很好的可移植性，一次编译，任何地方运行。</p><p><code>.java</code>文件经过javac编译之后变成<code>.class</code>文件，<code>.class</code>通过解释器和JIT（运行时编译器）编译成机器可以理解的代码，JIT完成一次编译之后，就会将对应的机器码保存下来，之后复用，其中编译的是热点代码。所以Java也是编译与解释共存的语言。</p><h2 id="java-和-c-的区别" tabindex="-1"><a class="header-anchor" href="#java-和-c-的区别" aria-hidden="true">#</a> Java 和 C++ 的区别</h2><p>Java和C++都是面向对象的语言，都支持封装继承多态。</p><p>Java不支持通过指针来直接访问内存，程序内存更加安全。</p><p>Java的类是单继承的，C++支持多继承。</p><p>Java有自动的垃圾回收机制，不需要手动释放内存。</p><h2 id="基本数据类型" tabindex="-1"><a class="header-anchor" href="#基本数据类型" aria-hidden="true">#</a> 基本数据类型</h2><p>Java有8种基本数据类型</p><ul><li>6种数字类型 <ul><li>4种整数类型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2种浮点数类型：<code>float</code>、<code>double</code></li></ul></li><li>1种字符类型：<code>char</code></li><li>1种布尔类型：<code>boolean</code></li></ul><h3 id="基本类型和包装类型" tabindex="-1"><a class="header-anchor" href="#基本类型和包装类型" aria-hidden="true">#</a> 基本类型和包装类型</h3><ul><li>包装类型能用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在Java虚拟机栈中的局部变量表中（线程私有），基本数据类型的成员变量放在堆中。而包装类型属于对象类型。</li><li>包装类型占用的空间比基本类型要大。</li><li>成员包装类型不赋值就是<code>null</code>，而基本类型有默认值并且不是<code>null</code></li><li>基本数据类型使用<code>==</code>进行比较，而包装类型通过<code>equals()</code>进行比较</li></ul><p>在HotSpot虚拟机中引入JIT优化之后，会对对象进行逃逸分析，如果对象的作用范围没有超过当前方法，则可能通过标量替换来实现栈（线程私有）上分配，避免堆上分配对象</p>',20);function n(h,s){return c(),o("div",null,[t,d(" more "),r])}const v=e(l,[["render",n],["__file","1java.html.vue"]]);export{v as default};
