import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as l,e as a}from"./app-4ef30b87.js";const t={},s=a('<h3 id="cpu-飙高系统反应慢怎么排查" tabindex="-1"><a class="header-anchor" href="#cpu-飙高系统反应慢怎么排查" aria-hidden="true">#</a> CPU 飙高系统反应慢怎么排查？</h3><ul><li>CPU 是整个电脑的核心计算资源，对于一个应用进程来说，CPU 的最小执行单元是线程。</li><li>导致 CPU 占用率较高的原因是因为频繁的上下文切换或者 CPU 资源过度消耗，导致应用中的线程无法获得 CPU 的调度，从而影响效率。</li><li>可以通过 top 命令找到利用率较高的线程。 <ul><li>如果是利用过高的线程一直是同一个，则说明长时间 CPU 没有释放，通过 jstack 获得线程的 dump 日志，定位到日志就可以找到问题代码。</li><li>CPU 利用率过高的线程 id 不断变化，说明线程创建过多，需要挑选几个线程 id，通过 jstack 去线程 dump 日志中排查。</li></ul></li></ul><h3 id="在-2g-大小的文件中-找出高频-top100-的单词" tabindex="-1"><a class="header-anchor" href="#在-2g-大小的文件中-找出高频-top100-的单词" aria-hidden="true">#</a> 在 2G 大小的文件中，找出高频 top100 的单词</h3><ol><li>把 2G 的文件进行分割成大小为 512KB 小文件，总共得到 2048 个小文件，避免一 次性读入整个文件造成内存不足。</li><li>定义一个长度为 2048 的 hash 表数组，用来统计每个小文件中单词出现的频率。</li><li>使用多线程并行遍历 2048 个小文件，针对每个单词进行 hash 取模运算分别存储到长度为 2048 的 hash 表数组中。</li><li>接着再遍历这 2048 个 hash 表，把频率前 100 的单词存入小顶堆中。</li><li>最后，小顶堆中最终得到的 100 个单词，就是 top 100 了。这种解决方案的核心思想是将大文件分割为多个小文件，然后采用分治和堆的算法，来解决这个问题。</li></ol>',4),c=[s];function o(h,r){return e(),l("div",null,c)}const _=i(t,[["render",o],["__file","scenes.html.vue"]]);export{_ as default};
