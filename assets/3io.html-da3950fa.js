import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as r,e as n,f as o}from"./app-175e9d13.js";const t="/markdown/24215217.jpg",i={},s=o('<h3 id="何为io" tabindex="-1"><a class="header-anchor" href="#何为io" aria-hidden="true">#</a> 何为IO？</h3><p>I/O（<strong>I</strong>nput/<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p><p>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol>',5),c=o('<h3 id="有哪些常见的-io-模型" tabindex="-1"><a class="header-anchor" href="#有哪些常见的-io-模型" aria-hidden="true">#</a> 有哪些常见的 IO 模型?</h3><p>UNIX 系统下， IO 模型一共有 5 种：<strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p><h2 id="java-中-3-种常见-io-模型" tabindex="-1"><a class="header-anchor" href="#java-中-3-种常见-io-模型" aria-hidden="true">#</a> Java 中 3 种常见 IO 模型</h2><h3 id="bio-blocking-i-o" tabindex="-1"><a class="header-anchor" href="#bio-blocking-i-o" aria-hidden="true">#</a> BIO (Blocking I/O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞IO模型中，应用程序发起read调用后，会一直阻塞，知道内核把数据拷贝到用户空间。</p><p>在客户端连接数量不高的情况下是没有问题的，但是当并发数量增大的时候，传统的BIO模型是无能为力的，会导致多线程阻塞，响应不了其他请求。</p><h3 id="nio-non-blocking-new-i-o" tabindex="-1"><a class="header-anchor" href="#nio-non-blocking-new-i-o" aria-hidden="true">#</a> NIO (Non-blocking/New I/O)</h3><p>Java中的NIO于Java 1.4中引入，对应<code>Java.nio</code>包，提供了<code>Channel</code>,<code>Selector</code>,<code>Buffer</code>等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。支持面向缓冲，基于通道的I/O操作方法。对于高负载、高并发的应用，应使用NIO。</p><p><strong>Java中的NIO可以看做是I/O多路复用模型。</strong></p><blockquote><p>在同步非阻塞IO模型中，应用程序会一直发起read调用，等待数据从内核空间拷贝到用户空间的这段时间，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。相比于同步阻塞IO模型，同步非阻塞IO模型确实有很大的改进，通过轮训操作避免了一直阻塞。但是这种IO模型仍然存在问题：应用程序不断进行I/O系统调用论文数据是否已经准备好的过程是很消耗CPU资源的。</p></blockquote><p>IO多路复用模型中，线程首先发起select调用，查询内核数据是否准备就绪，等内核把数据准备好了，用户再发起read调用。read调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p><p><strong>IO多路复用模型，通过减少无效的系统调用，减少了对CPU资源的消耗。</strong></p><p>Java中的NIO有一个非常重要的<strong>选择器（Selector）<strong>概念，称为</strong>多路复用器</strong>。通过它只需要一个线程便可以管理多个客户端连接，当客户端数据到了之后才会为其服务。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image" alt="03600"></p><h3 id="aio-asynchronous-i-o" tabindex="-1"><a class="header-anchor" href="#aio-asynchronous-i-o" aria-hidden="true">#</a> AIO (Asynchronous I/O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2，它是<strong>异步 IO 模型</strong>。</p><p>异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><h3 id="比较" tabindex="-1"><a class="header-anchor" href="#比较" aria-hidden="true">#</a> 比较</h3><p><img src="'+t+'" alt="24215217"></p>',20);function d(h,p){return e(),r("div",null,[s,n(" more "),c])}const g=a(i,[["render",d],["__file","3io.html.vue"]]);export{g as default};
