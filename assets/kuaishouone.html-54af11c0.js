import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,f as d}from"./app-474a1abd.js";const l={},c=d('<p>⁉️ 个人回答不保证正确</p><h2 id="一面" tabindex="-1"><a class="header-anchor" href="#一面" aria-hidden="true">#</a> 一面</h2><h4 id="自我介绍" tabindex="-1"><a class="header-anchor" href="#自我介绍" aria-hidden="true">#</a> 自我介绍</h4><h4 id="对电商项目的优化" tabindex="-1"><a class="header-anchor" href="#对电商项目的优化" aria-hidden="true">#</a> 对电商项目的优化</h4><ul><li>更改了 JVM 中的老年代和新生代的内存分布，将秒杀的并发量提高。</li><li>使用 <code>CompletableFuture</code> 对 SKU 数据进行异步查询，提高了查询速度。</li><li>登录部分由原来的手动查询用户数据密码比对，改为了使用 <code>SpringSecurity</code> 进行登录认证，简化了开发步骤，另外使用 Redis 解决分布式下的用户数据共享。</li><li>使用 Sentinel 限制后端并发数，熔断降级保证服务安全可用。</li></ul><h3 id="虚拟内存的概念" tabindex="-1"><a class="header-anchor" href="#虚拟内存的概念" aria-hidden="true">#</a> 虚拟内存的概念</h3><ul><li>虚拟内存是解决内存紧张的问题，对应于操作系统调度中的中级调度，在程序运行时并不要把所有的数据都放入内存，并且在内存紧张时将部分暂时不会执行的进程放入到磁盘中，等到内存够用时再将其调回内存。</li></ul><h3 id="操作系统中文件的实现" tabindex="-1"><a class="header-anchor" href="#操作系统中文件的实现" aria-hidden="true">#</a> 操作系统中文件的实现</h3><ul><li>单级目录结构和多级目录结构以及图形目录结构的优缺点。</li></ul><blockquote><p>现在想起来面试官问的应该是文件的逻辑结构和物理结构。</p><p>逻辑结构分为顺序，索引和顺序索引结构。</p><p>物理结构的实现分为</p><ul><li><p>连续分配，在目录中设置对应文件的开始块号和结束块号。</p></li><li><p>链接分配分为隐式链接和显式链接，隐式链接可靠性差，显示连接的指针占用空间，并且可靠性也不好。</p></li><li><p>索引分配，为每个文件分配一个索引分配表，表中记录了属于这个文件的磁盘块，不仅支持随机访问，而且不会产生外部碎片。</p></li><li><p>混合索引分配，既有直接地址分配，又有多级索引分配。</p></li></ul></blockquote><h3 id="多级缓存的作用" tabindex="-1"><a class="header-anchor" href="#多级缓存的作用" aria-hidden="true">#</a> 多级缓存的作用</h3><ul><li>（这玩意书上怎么没看到），我说我对硬件有所了解，CPU 中的缓存就是多级缓存，现在的 CPU 一般包含三级缓存，分别是 l1，l2，l3，速度逐渐降低，容量逐渐扩大，使用多级缓存能很好的解决 CPU 速度和主存速度不匹配的问题，就像主存用来解决 CPU 和 磁盘之间的速度差异一样。</li></ul><h3 id="访问一个网址的过程" tabindex="-1"><a class="header-anchor" href="#访问一个网址的过程" aria-hidden="true">#</a> 访问一个网址的过程</h3><ul><li>首先通过 DNS 解析为 IP 地址，再和 IP 地址进行 TCP 三次握手，将请求发送给服务器，服务器处理之后返回解析的数据，浏览器展示。</li></ul><h3 id="tcp-三次握手说说" tabindex="-1"><a class="header-anchor" href="#tcp-三次握手说说" aria-hidden="true">#</a> TCP 三次握手说说</h3><ul><li>首先客户端发送数据到客户端，当中有 <code>SYN=1,seq=x</code>，服务器收到数据之后返回确认 <code>SYN=1,ack=x+1,seq=y</code>，客户端收到确认之后返回确认<code>ack=y+1,seq=x+1</code>。</li></ul><h3 id="http-和-https-的区别" tabindex="-1"><a class="header-anchor" href="#http-和-https-的区别" aria-hidden="true">#</a> HTTP 和 HTTPS 的区别</h3><ul><li><p><strong>端口号</strong>：HTTP 默认是 <code>80</code>，HTTPS 默认是 <code>443</code>。</p></li><li><p><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</p></li><li><p><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p></li></ul><h3 id="常见的-request-header" tabindex="-1"><a class="header-anchor" href="#常见的-request-header" aria-hidden="true">#</a> 常见的 Request Header</h3><ul><li><code>Accept</code>：请求报头域，用于指定客户端能接受哪些类型的信息。</li><li><code>Host</code>：用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关的地址。</li><li><code>Referer</code>：表示当前的请求是从哪个 URL 过来的，一般可以用来做反爬虫，不是本站发送的请求就不会响应。</li><li><code>Connection</code>：分为 <code>close</code> 和 <code>keep-alive</code> 用来表示发送完请求的对象之后是关闭连接还是持续的连接。</li><li><code>Access-Control-Allow-Origin</code>：允许跨域时添加的参数，用来表示哪个源地址发来的请求允许跨域。</li><li><code>Cache-Control</code>：控制是否能缓存数据。</li><li><code>Accept-Language</code>：浏览器支持的语言。</li><li><code>Accept-Encoding</code>：浏览器支持的编码方案。</li></ul><h3 id="数据库为什么比-redis-慢" tabindex="-1"><a class="header-anchor" href="#数据库为什么比-redis-慢" aria-hidden="true">#</a> 数据库为什么比 Redis 慢？</h3><ul><li>数据库需要从磁盘中读取页来进行查询，而 Redis 是在内存中操作，所以速度更快，另外 Redis 使用多路复用技术使得并发量进一步提高。</li></ul><h3 id="如果一张表中有太多的列和太多的行-怎么进行优化" tabindex="-1"><a class="header-anchor" href="#如果一张表中有太多的列和太多的行-怎么进行优化" aria-hidden="true">#</a> 如果一张表中有太多的列和太多的行，怎么进行优化？</h3><ul><li>水平分表和垂直分表，将数据分散到多张表中以解决单表的并发度问题。</li></ul><h3 id="算法题" tabindex="-1"><a class="header-anchor" href="#算法题" aria-hidden="true">#</a> 算法题</h3><ul><li>链表右移，右移的元素放入到头部</li><li>例如 1-&gt;2-&gt;3-&gt;4，右移 1 次之后变成 4-&gt;1-&gt;2-&gt;3，求出右移 k 次之后的链表，秒了。</li></ul>',26),r=[c];function h(o,t){return i(),a("div",null,r)}const u=e(l,[["render",h],["__file","kuaishouone.html.vue"]]);export{u as default};
