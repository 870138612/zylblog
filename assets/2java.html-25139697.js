import{_ as u}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as r,c as d,f as k,b as n,d as s,a as o,w as a,e as c}from"./app-85e1fb10.js";const v="/markdown/image-20230515171640642.png",m={},h=n("h3",{id:"面向对象和面向过程的区别",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#面向对象和面向过程的区别","aria-hidden":"true"},"#"),s(" 面向对象和面向过程的区别")],-1),b=n("ul",null,[n("li",null,"面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。"),n("li",null,"面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。")],-1),g=n("p",null,"一个注重过程，一个注重内部属性。",-1),f=c(`<h3 id="对象的相等和引用的相等" tabindex="-1"><a class="header-anchor" href="#对象的相等和引用的相等" aria-hidden="true">#</a> 对象的相等和引用的相等</h3><p>对象的相等是是比较内存中存放的对象是否相等。</p><p>引用相等是指向的内存地址是否相等。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false	</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true	</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4),S={href:"https://ylzhong.top/java/1java/2java.html#string",target:"_blank",rel:"noopener noreferrer"},y=c('<h3 id="如果没有声明构造方法-程序能正确执行吗" tabindex="-1"><a class="header-anchor" href="#如果没有声明构造方法-程序能正确执行吗" aria-hidden="true">#</a> 如果没有声明构造方法，程序能正确执行吗？</h3><p>如果类没有声明构造方法则会默认生成一个不带参数的构造方法。</p><p>如果自己添加了构造方法无论是否有参数都不会再自动生成无参构造方法。</p><p>构造方法不能被重写 <code>@Override</code>，但是能重载（有参构造和无参构造）。</p><h3 id="面向对象的三个特征" tabindex="-1"><a class="header-anchor" href="#面向对象的三个特征" aria-hidden="true">#</a> 面向对象的三个特征</h3><p><strong>封装</strong></p><p>封装是将一个对象的状态信息隐藏在内部，不允许外部直接访问这些属性，但是会提供方法来操作属性。</p><p><strong>继承</strong></p><p>不同类型的对象可能会具有相似特点，例如游戏中的每一个英雄都有血量，移速等基础属性，但是每一个英雄的技能各有不同，则可以通过继承复用减少开发难度。</p>',9),q=n("div",{class:"language-java line-numbers-mode","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"class"),s(),n("span",{class:"token class-name"},"Hero"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"private"),s(),n("span",{class:"token keyword"},"int"),s(" hp"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token keyword"},"private"),s(),n("span",{class:"token keyword"},"int"),s(" speed"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),w=n("div",{class:"language-java line-numbers-mode","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"class"),s(),n("span",{class:"token class-name"},"Hero1"),s(),n("span",{class:"token keyword"},"extends"),s(),n("span",{class:"token class-name"},"Hero"),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"void"),s(),n("span",{class:"token function"},"skill1"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"{"),s(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),s("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"技能1"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),j=n("div",{class:"language-java line-numbers-mode","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"class"),s(),n("span",{class:"token class-name"},"Hero2"),s(),n("span",{class:"token keyword"},"extends"),s(),n("span",{class:"token class-name"},"Hero"),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"void"),s(),n("span",{class:"token function"},"skill2"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"{"),s(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),s("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"技能2"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),x=n("ol",null,[n("li",null,"子类拥有父类的所有属性和方法（包括私有属性和私有方法）。"),n("li",null,"子类能对父类进行扩展。")],-1),_=n("p",null,[n("strong",null,"多态")],-1),H=n("p",null,"表示一个对象具有多种状态，上述代码中创建对象：",-1),B=n("div",{class:"language-java line-numbers-mode","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"class"),s(),n("span",{class:"token class-name"},"Hero"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"void"),s(),n("span",{class:"token function"},"skill"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"{"),n("span",{class:"token punctuation"},"}"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),C=n("div",{class:"language-java line-numbers-mode","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"class"),s(),n("span",{class:"token class-name"},"Hero1"),s(),n("span",{class:"token keyword"},"extends"),s(),n("span",{class:"token class-name"},"Hero"),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token annotation punctuation"},"@Override"),s(`
    `),n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"void"),s(),n("span",{class:"token function"},"skill"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"{"),s(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),s("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"技能1"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),J=n("div",{class:"language-java line-numbers-mode","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"class"),s(),n("span",{class:"token class-name"},"Hero2"),s(),n("span",{class:"token keyword"},"extends"),s(),n("span",{class:"token class-name"},"Hero"),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token annotation punctuation"},"@Override"),s(`
    `),n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"void"),s(),n("span",{class:"token function"},"skill"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"{"),s(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),s("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"技能2"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),V=c(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Hero</span> hero <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hero1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
hero<span class="token punctuation">.</span><span class="token function">skill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印技能1，编译是否能通过看左边，执行结果看右边。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对象类型和引用类型之间具有继承/实现关系；</li><li>引用类型变量发出的方法调用到底是哪个类中的方法，在程序运行的时候才能确定；</li><li>多态不能调用只在子类中存在，但是父类中不存在的方法，也就是 <code>hero</code> 对象能调用的方法是看父类 <code>Hero</code> 的，执行的结果看子类 <code>Hero1</code>；</li><li>如果子类重写了父类方法，则执行的是子类中的方法，如果没有重写则执行的是父类中的方法。</li></ul><h3 id="接口和抽象类的共同点" tabindex="-1"><a class="header-anchor" href="#接口和抽象类的共同点" aria-hidden="true">#</a> 接口和抽象类的共同点</h3><p><strong>共同点</strong></p><ul><li>都不能被实例化；</li><li>都可以包含抽象方法；</li><li>都可以有默认的实现方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>不同点</strong></p><ul><li>接口强调行为的约束，实现某个接口就相当于有某个责任，必须实现对应的方法，继承则是强调复用，子类继承父类并不一定要重写父类方法；</li><li>一个类只能 <code>extends</code> 一个类，但是能 <code>implements</code> 多个接口；</li><li>接口中的成员变量只能是 <code>public static final</code> 类型，不能被修改而且必须有初始值，抽象类中的成员变量默认 <code>default</code>，可以在子类中被重新定义，重新赋值。</li></ul><h3 id="浅拷贝-深拷贝-引用拷贝" tabindex="-1"><a class="header-anchor" href="#浅拷贝-深拷贝-引用拷贝" aria-hidden="true">#</a> 浅拷贝，深拷贝，引用拷贝</h3><p><strong>浅拷贝</strong></p><p>在堆上创建一个新对象 <code>N</code>，<code>N</code> 对象中的内部对象是引用类型的话，会直接复制原本类 <code>O</code> 的内部对象引用地址；</p><p>也就是新对象 <code>N</code> 内部对象和原来的对象 <code>O</code> 的内部对象是同一个。</p><p><strong>深拷贝</strong></p><p>不仅仅拷贝对象，将原本对象内部的所有属性都单独复制一份；</p><p>新对象的内部引用对象不再是原来对象的内部引用对象。</p><p><strong>引用拷贝</strong></p><p>两个不同对象的引用指向同一个对象。</p><h3 id="finally-块一定会执行吗" tabindex="-1"><a class="header-anchor" href="#finally-块一定会执行吗" aria-hidden="true">#</a> finally 块一定会执行吗？</h3><p><code>finally</code> 语句块在以下两种情况下不会执行：</p><ul><li>程序没有到达 <code>try</code> 语句块而因为异常被终止，主要问题在于异常捕获的范围不够。</li><li>在 <code>try</code> 或者 <code>catch</code> 语句块中，使用了 <code>System.exit(0)</code> 导致 JVM 直接退出。</li></ul><h2 id="object" tabindex="-1"><a class="header-anchor" href="#object" aria-hidden="true">#</a> Object</h2><h3 id="和-equals-区别" tabindex="-1"><a class="header-anchor" href="#和-equals-区别" aria-hidden="true">#</a> == 和 equals 区别</h3><ul><li>对于基本类型来说 <code>==</code> 是比较值；</li><li>对于引用类型来说 <code>==</code> 是比较地址。</li></ul><p><code>equals</code> 存在两种情况：</p><ul><li>类没有重写 <code>equals</code> 方法：则通过 <code>equals</code> 比较两个对象的时候等价于 <code>==</code>；</li><li>重写了 <code>equals</code> 方法：则是比较两个对象内部的属性是否相等。</li></ul><p>创建 <code>String</code> 类型的对象 <code>new String(&quot;abc&quot;)</code>，虚拟机会在字符串常量池中查找有没有相同值的对象，如果有则直接返回这个对象的引用，如果没有就创建一个 <code>String</code> 对象。</p><h3 id="hashcode-作用" tabindex="-1"><a class="header-anchor" href="#hashcode-作用" aria-hidden="true">#</a> hashCode() 作用</h3><p><code>hashCode()</code> 方法用来获哈希码，作用是确定在哈希表中的位置。</p><p><code>hashCode()</code> 定义在 <code>Object</code> 类中，所以所有的对象都有这个方法。<code>hashCode()</code> 是本地方法，也就是通过 C 或者是 C++ 实现的。</p><p><code>HashMap</code> 通过计算 <code>Hash</code> 值使得查找元素的时间复杂度为 1，数据结构散列表。</p><h3 id="为什么重写-equals-时必须重写-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#为什么重写-equals-时必须重写-hashcode-方法" aria-hidden="true">#</a> 为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>Java 中的对象满足以下：</p><ul><li>Java 中两个对象相同则 <code>HashCode</code> 必须相等；</li><li><code>HashCode</code> 相同，但对象不一定相等；</li><li>两个对象的 <code>HashCode</code> 不同则对象一定不同。</li></ul><p>重写 <code>equals()</code> 代表这个方法是用来比较两个对象是否相等，如果不重写 <code>hashCode()</code> 方法可能会导致判断是相等的两个对象但是 <code>HashCode</code> 不等，则 HashMap 这样的数据结构无法正常工作。</p><h2 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h2><h3 id="string、stringbuffer、stringbuilder-的区别" tabindex="-1"><a class="header-anchor" href="#string、stringbuffer、stringbuilder-的区别" aria-hidden="true">#</a> String、StringBuffer、StringBuilder 的区别？</h3><ul><li><code>String</code> 是不可变的，可以看成常量，线程安全。<code>StringBuffer</code> 对内部方法加了同步锁，是线程安全的。<code>StringBuilder</code> 没有添加同步锁，所以是线程不安全的。</li><li>每次对 <code>String</code> 类型进行修改的时候，都会新生成一个 <code>String</code> 类型，然后将引用指向新的 <code>String</code> 对象。<code>StringBuffer</code> 和 <code>StringBuilder</code> 是对对象本身进行操作，不会生成新的对象，相同情况下使用 <code>StringBuilder</code> 会带来一点性能提升，但是线程不安全。</li><li>少量数据使用 <code>String</code>，单线程下大量数据使用 <code>StringBuilder</code>，多线程下使用 <code>StringBuffer</code>。</li><li><code>toString</code> 方法。<code>StringBuffer</code> 中保存了一个缓冲区 <code>toStringCache</code>。会保存之前 <code>toString</code> 的结果，只要在两次调用 <code>toString</code> 期间没有修改 <code>StringBuffer</code>，那么可以加快返回的速度，发生了修改，缓冲区就会被清空。<code>StringBuilder</code> 没有缓冲区，每次都是重新拷贝一次数组。</li></ul><h3 id="string-为何不可变" tabindex="-1"><a class="header-anchor" href="#string-为何不可变" aria-hidden="true">#</a> String 为何不可变？</h3><p>JDK 8 中的源码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>保存字符串的数组是 <code>final</code> 修饰的，并且内部没有暴露能修改这个数组的方法；</li><li><code>String</code> 类本身也被 <code>final</code> 修饰导致不能被继承，从而避免子类破坏 <code>String</code> 的不变性。</li></ul><h3 id="字符串拼接用-还是-stringbuilder" tabindex="-1"><a class="header-anchor" href="#字符串拼接用-还是-stringbuilder" aria-hidden="true">#</a> 字符串拼接用 &quot;+&quot; 还是 &quot;StringBuilder&quot;？</h3><p><code>+</code> 和 <code>+=</code> 是 Java 中唯二为 <code>String</code> 重载过的运算符。</p><p><code>String</code> 对象使用 <code>+</code> 进行拼接，实际就是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法，拼完之后调用 <code>toString()</code> 方法返回 <code>String</code> 对象。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>如果在循环内使用 <code>+</code> 进行拼接多个字符串，编译器不会复用 <code>StringBuilder</code>，而是每次循环都创建一个 <code>StringBuilder</code>。</p><p>直接使用 <code>StringBuilder</code> 进行拼接就能解决这个问题。</p></div><h3 id="string-s1-new-string-abc-这句话创建了几个字符串对象" tabindex="-1"><a class="header-anchor" href="#string-s1-new-string-abc-这句话创建了几个字符串对象" aria-hidden="true">#</a> String s1 = new String(&quot;abc&quot;) 这句话创建了几个字符串对象？</h3><p>会创建 1 个或者 2 个字符串对象。</p><p>String str = new String(&quot;abc&quot;);</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果字符串常量池中不存在 <code>&quot;abc&quot;</code> 的引用，则会在堆中创建 2 个字符串对象 <code>&quot;abc&quot;</code>。一个是在字符串常量池中创建的 <code>&quot;abc&quot;</code>，另外是 <code>new</code> 在堆中创建的对象。</p><p>如果字符串常量池中存在 <code>&quot;abc&quot;</code> 的引用，则会在堆中创建 1 个字符串对象 <code>&quot;abc&quot;</code>。也就是 <code>new</code> 在堆中创建的对象。</p><p><img src="`+v+`" alt="image-20230515171640642"></p><h3 id="string-intern-方法有什么作用" tabindex="-1"><a class="header-anchor" href="#string-intern-方法有什么作用" aria-hidden="true">#</a> String#intern 方法有什么作用？</h3><p><code>String.intern()</code> 是一个本地方法，作用是将指定的字符串对象保存到字符串常量池中。</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，则返回引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 在堆中创建字符串对象”Java“</span>
<span class="token comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span>
<span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">&quot;Java&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 会在堆中在单独创建一个字符串对象</span>
<span class="token class-name">String</span> s3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;Java&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span>
<span class="token class-name">String</span> s4 <span class="token operator">=</span> s3<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// s1 和 s2 指向的是堆中的同一个对象</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// s3 和 s4 指向的是堆中不同的对象</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token comment">// s1 和 s4 指向的是堆中的同一个对象</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="编译器对字符串拼接的优化" tabindex="-1"><a class="header-anchor" href="#编译器对字符串拼接的优化" aria-hidden="true">#</a> 编译器对字符串拼接的优化</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">;</span><span class="token comment">//常量池中创建的对象</span>
<span class="token class-name">String</span> str4 <span class="token operator">=</span> str1 <span class="token operator">+</span> str2<span class="token punctuation">;</span><span class="token comment">//堆中创建的对象</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 <code>String str3 = &quot;a&quot; + &quot;b&quot;</code> 等价于 <code>String str3 = &quot;ab&quot;</code>；对于在编译期间就能确定的字符串，编译器会在编译期间直接放入字符串常量池中。</p><p><code>String str4 = str1 + str2</code> 则不会在编译期间确定结果，不会产生优化。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">&quot;str&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">final</span> <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">&quot;ing&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 下面两个表达式其实是等价的</span>
<span class="token class-name">String</span> c <span class="token operator">=</span> <span class="token string">&quot;str&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;ing&quot;</span><span class="token punctuation">;</span><span class="token comment">// 常量池中的对象</span>
<span class="token class-name">String</span> d <span class="token operator">=</span> str1 <span class="token operator">+</span> str2<span class="token punctuation">;</span> <span class="token comment">// 常量池中的对象</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>final</code> 修饰则看成常量，在编译期间就会优化放入字符串常量池中。</p><h2 id="java-值传递" tabindex="-1"><a class="header-anchor" href="#java-值传递" aria-hidden="true">#</a> Java 值传递</h2><h3 id="形参和实参" tabindex="-1"><a class="header-anchor" href="#形参和实参" aria-hidden="true">#</a> 形参和实参</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
<span class="token comment">//s 为实参</span>
<span class="token function">method</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//str 为形参</span>
<span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="值传递-引用传递" tabindex="-1"><a class="header-anchor" href="#值传递-引用传递" aria-hidden="true">#</a> 值传递 &amp; 引用传递</h3><ul><li>值传递：方法接收的是实参的拷贝，会创建副本；</li><li>引用传递：方法接收的直接是实参所引用对象在堆中的地址，不会创建副本，对形参的修改将会影响到实参。</li></ul><h3 id="java-只有值传递" tabindex="-1"><a class="header-anchor" href="#java-只有值传递" aria-hidden="true">#</a> Java 只有值传递</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">change</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出为 0</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 将数组的第一个元素变为0</span>
    array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>array 为引用类型，但是不称为引用传递，案例中仍然是值传递，值是实参的地址。</p><p>引用传递值得是：对形参本身修改会导致实参变化。</p><h2 id="java-序列化" tabindex="-1"><a class="header-anchor" href="#java-序列化" aria-hidden="true">#</a> Java 序列化</h2><ul><li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程；</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。</li></ul><p>序列化协议属于 TCP/IP 中的应用层。</p><p>Java中通过实现 <code>Serializable</code> 接口实现序列化功能。</p><h3 id="serialversionuid-有什么作用" tabindex="-1"><a class="header-anchor" href="#serialversionuid-有什么作用" aria-hidden="true">#</a> serialVersionUID 有什么作用？</h3><p><code>serialVersionUID</code> 的作用是版本控制，反序列化的时候会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 相同，如果不同则会抛出 <code>InvalidClassException</code> 异常。如果不指定 <code>serialVersionUID</code>，编译器会自动生成。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1905122041950251207L</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>serialVersionUID</code> 用来给 JVM 识别的，并不会被序列化。</p>`,78);function A(I,D){const i=l("ExternalLinkIcon"),p=l("Tabs");return r(),d("div",null,[h,b,g,k(" more "),f,n("p",null,[s("☀️详见 "),n("a",S,[s("String"),o(i)])]),y,o(p,{id:"59",data:[{id:"HeroTemplate"},{id:"Hero1"},{id:"Hero2"}],active:0},{title0:a(({value:e,isActive:t})=>[s("HeroTemplate")]),title1:a(({value:e,isActive:t})=>[s("Hero1")]),title2:a(({value:e,isActive:t})=>[s("Hero2")]),tab0:a(({value:e,isActive:t})=>[q]),tab1:a(({value:e,isActive:t})=>[w]),tab2:a(({value:e,isActive:t})=>[j]),_:1}),x,_,H,o(p,{id:"88",data:[{id:"HeroTemplate"},{id:"Hero1"},{id:"Hero2"}],active:0},{title0:a(({value:e,isActive:t})=>[s("HeroTemplate")]),title1:a(({value:e,isActive:t})=>[s("Hero1")]),title2:a(({value:e,isActive:t})=>[s("Hero2")]),tab0:a(({value:e,isActive:t})=>[B]),tab1:a(({value:e,isActive:t})=>[C]),tab2:a(({value:e,isActive:t})=>[J]),_:1}),V])}const O=u(m,[["render",A],["__file","2java.html.vue"]]);export{O as default};
