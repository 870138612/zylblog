import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,f as e}from"./app-b091839a.js";const t="/markdown/image-20230619153337460.png",p="/markdown/image-20230619212929209.png",i={},o=e(`<h2 id="spring是什么" tabindex="-1"><a class="header-anchor" href="#spring是什么" aria-hidden="true">#</a> Spring是什么</h2><p>Spring是一个轻量级的控制反转（Ioc）和面向切面（AOP）的容器框架。</p><ul><li>从大小和开销两方面而言Spring是轻量级的。</li><li>通过控制反转的技术达到松耦合。</li><li>提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发。</li><li>包含和管理应用对象的配置和声明周期，通过容器实现。</li><li>将简单的配置组件组合成复杂的应用。</li></ul><h2 id="单例bean是单例设计模式吗" tabindex="-1"><a class="header-anchor" href="#单例bean是单例设计模式吗" aria-hidden="true">#</a> 单例Bean是单例设计模式吗？</h2><p>单例模式指的是在JVM中一个类只能构造出一个实例对象，有很多单例模式的实现方法例如双检查法（懒汉式），静态代码块（饿汉式）。</p><p>而Spring中的单例Bean也是一种单例模式，只不过范围比较小，范围是beanName，一个beanName对应同一个Bean对象，不同的beanName对应不同的Bean对象。</p><p>也就是说同一个类可以创建多个实例，但是名称必须是不同的。</p><h2 id="什么是单例池-作用是什么" tabindex="-1"><a class="header-anchor" href="#什么是单例池-作用是什么" aria-hidden="true">#</a> 什么是单例池？作用是什么？</h2><p><strong>单例Bean</strong>通过多次<code>getBean</code>方法都会获得同一个实例。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">&quot;com.zyl&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">AnnotationConfigApplicationContext</span> applicationContext <span class="token operator">=</span>
                <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">AppConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> userService1 <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;userService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> userService2 <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;userService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userService1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userService2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建容器之后获取userService得到的是同一个实例。而这个实例就是放入单例池中，单例池可以看成是一个Map，保证Bean是单例。</p><h2 id="spring中的设计模式" tabindex="-1"><a class="header-anchor" href="#spring中的设计模式" aria-hidden="true">#</a> Spring中的设计模式</h2><p><strong>工厂设计模式</strong>：Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</p><p><strong>代理设计模式</strong>：Spring AOP 功能的实现。</p><p><strong>单例设计模式</strong>：Spring 中的 Bean 默认都是单例的。</p><p><strong>模板方法模式</strong>：Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</p><p><strong>观察者模式</strong>：各种监听器就是使用观察者模式。</p><p><strong>适配器模式</strong>：Spring AOP 的增强或通知（Advice）使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</p><p><strong>包装器设计模式</strong>：构造数据库查询条件的Wrapper就是包装器模式。</p><p>。。。</p><h2 id="spring中bean创建的生命周期" tabindex="-1"><a class="header-anchor" href="#spring中bean创建的生命周期" aria-hidden="true">#</a> Spring中Bean创建的生命周期</h2><p>Spring中一个Bean的创建大概分为以下几个步骤：</p><ul><li>推断构造方法</li><li>实例化</li><li>依赖注入</li><li>初始化前，处理@PostConstruct注解</li><li>初始化，处理Initializing接口</li><li>初始化后，进行AOP</li><li>放入单例池</li></ul><h3 id="bean初始化和实例化的区别是什么" tabindex="-1"><a class="header-anchor" href="#bean初始化和实例化的区别是什么" aria-hidden="true">#</a> Bean初始化和实例化的区别是什么？</h3><p>Bean的实例化就是步骤<strong>UserService类--&gt;无参构造方法--&gt;对象</strong>，而初始化就是调用<code>afterPropertiesSet()</code>（类需要实现<code>InitializingBean</code>接口）。</p><p>初始化过程其实就是对应<code>afterPropertiesSet()</code>方法，通过判断</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> isInitializingBean <span class="token operator">=</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>bean实现了<code>InitializingBean</code>则调用<code>afterPropertiesSet()</code>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>
    <span class="token comment">//想加入一个特定的User对象到UserService</span>
    <span class="token keyword">private</span> <span class="token class-name">User</span> admin<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">//mysql -&gt;管理员的信息-&gt;User对象-&gt;admin</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="初始化后是什么" tabindex="-1"><a class="header-anchor" href="#初始化后是什么" aria-hidden="true">#</a> 初始化后是什么？</h3><p>初始化后做的事情就是执行AOP，生成代理对象，并将代理对象放入单例池中。</p><h3 id="bean对象和普通对象之间的区别是什么" tabindex="-1"><a class="header-anchor" href="#bean对象和普通对象之间的区别是什么" aria-hidden="true">#</a> Bean对象和普通对象之间的区别是什么</h3><p>Bean对象本身就是普通对象，不过可能会经过初始化前和初始化后的增强。</p><h3 id="postconstruct是如何工作的" tabindex="-1"><a class="header-anchor" href="#postconstruct是如何工作的" aria-hidden="true">#</a> @PostConstruct是如何工作的</h3><p>创建Bean的过程：UserService类--&gt;无参构造方法--&gt;对象--&gt;依赖注入--&gt;初始化前（@PostConstruct）--&gt;初始化（InitializingBean）--&gt;初始化后（AOP）--&gt;放入Map单例池--&gt;Bean对象。</p><p><img src="`+t+`" alt="image-20230619153337460"></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
    <span class="token comment">//想加入一个特定的User对象到UserService</span>
    <span class="token keyword">private</span> <span class="token class-name">User</span> admin<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@PostConstruct</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//mysql -&gt;管理员的信息-&gt;User对象-&gt;admin</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>@PostConstruct</code>，让Bean在初始化前进行增强。对应于创建Bean过程中的<strong>初始化前（调用@PostConstruct修饰的方法）</strong>，再通过反射去调用方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> method <span class="token operator">:</span> userService1<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">PostConstruct</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>userService1<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="构造方法推断" tabindex="-1"><a class="header-anchor" href="#构造方法推断" aria-hidden="true">#</a> 构造方法推断</h3><p>Spring发现有多个构造方法的时候，<strong>如果有无参构造方法则调用无参构造，如果没有无参构造，并且有参构造不止一个则会报错</strong>。（例如不存在无参构造，但是存在多个不同参数的有参构造方法）</p><p>可以使用<code>@Autowired</code>注解默认使用的构造方法。</p><h3 id="先bytype再byname" tabindex="-1"><a class="header-anchor" href="#先bytype再byname" aria-hidden="true">#</a> 先ByType再ByName</h3><p>在单例池Map中会存在多个类型相同的Bean。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token class-name">UserService</span> <span class="token function">userService1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token class-name">UserService</span> <span class="token function">userService2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会产生两个UserService类型的Bean，但是名字不同。</p><p>依赖注入时，如果执行有参构造方法，发现UserService类型的Bean只有一个则直接注入（ByType），发现有多个则根据名称注入（ByName）。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Autowired</span> 
<span class="token keyword">public</span> <span class="token class-name">OrderService</span><span class="token punctuation">(</span><span class="token class-name">UserService</span> userService2<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>userService <span class="token operator">=</span> userService2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//注入的是第二个名为“userService2”的Bean</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>@Autowired</code>只能根据类型注入的，可以使用<code>@Qualifier(&quot;userService1&quot;)</code>指定名称。</p><h2 id="spring事务" tabindex="-1"><a class="header-anchor" href="#spring事务" aria-hidden="true">#</a> Spring事务</h2><h3 id="事务实现原理" tabindex="-1"><a class="header-anchor" href="#事务实现原理" aria-hidden="true">#</a> 事务实现原理</h3><p>事务<code>Transactional</code>本质也是通过代理对象调用普通对象的方法，并在前后做增强。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">UserServiceProxy</span> <span class="token keyword">extends</span> <span class="token class-name">UserService</span><span class="token punctuation">{</span>
	<span class="token class-name">UserService</span> target<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//@Transactional</span>
        <span class="token comment">//事务管理器新建一个数据库连接conn;ThreadLocal&lt;Map,conn&gt;</span>
		<span class="token comment">//conn.autocommit=false;//关闭自动提交</span>
        <span class="token comment">//target.test();//执行数据库操作</span>
        <span class="token comment">//没有出现异常则提交conn.commit();否则回滚conn.rollBack();</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="spring事务传播机制" tabindex="-1"><a class="header-anchor" href="#spring事务传播机制" aria-hidden="true">#</a> Spring事务传播机制</h3><p>多个事务方法相互调用的时候，事务包含以下的转播机制。</p><ul><li><strong>REQUIRED</strong>（默认）：如果当前没有事务则开启一个新的事务，如果存在事务则加入。</li><li><strong>SUPPORTS</strong>：如果存在事务则加入，否则以非事务模式运行。</li><li><strong>MANDATORY</strong>：如果存在事务则加入，如果不存在事务则抛出异常。</li><li><strong>REQUIRED_NEW</strong>：创建一个新的事务，如果已经存在事务，则将该事务挂起。</li><li><strong>NEVER</strong>：从来不使用事务。</li><li><strong>NESTED</strong>：如果存在事务则将当前事务嵌套进去，否则开启一个新的事务。</li></ul><h3 id="spring事务失效的原因" tabindex="-1"><a class="header-anchor" href="#spring事务失效的原因" aria-hidden="true">#</a> Spring事务失效的原因</h3><p>1、<strong>方法异常没有抛出</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Transactional</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">try</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Spring事务&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正常代码执行</span>
		<span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//异常代码  被捕获</span>
	<span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;出现异常&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里并没有抛出异常，而是自己处理了 因此Spring无法感知</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>异常不能被Spring感知就不会执行<code>rollBack</code>。</p><p>2、<strong>使用<code>@Transactional</code>修饰的方法不是public方法</strong></p><p>通过实现类或者是父类生成代理对象，代理对象不能调用子类private方法。</p><p>3、<strong>自身调用</strong></p><p>事务是通过代理对象调用才能生效，如果在一个类里面调用本类的方法就相当于<code>this</code>调用，事务不会生效。</p><p>4、<strong>propagation事务传播机制设置错误</strong></p><p>如果内部方法的事务传播类型为不支持事务的传播类型，那么，内部方法的事务在Spring中会失效。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">NEVER</span><span class="token punctuation">)</span>
<span class="token comment">//如果有一个事务已经存在则会抛出异常</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>5、<strong>数据库不支持事务</strong></p><p>6、<strong>异常类型错误</strong></p><p>7、<strong>没有被Spring管理</strong></p><h2 id="springaop怎么工作的" tabindex="-1"><a class="header-anchor" href="#springaop怎么工作的" aria-hidden="true">#</a> SpringAOP怎么工作的？</h2><p>SpringAOP是通过动态代理机制，如果Bean实现了接口，就会采用JDK动态代理来生成该接口的代理对象（实现类），如果没有实现接口，则通过CGLIB来生成当前类的一个代理对象（父类）。</p><p>AOP表示面向切面编程，是一个思想，AspectJ就是其中的一种实现方式，会在编译器对类进行增强，需要使用AspectJ提供的编译器，提供了例如<code>@Before</code>、<code>@After</code>、<code>@Around</code>等注解，而SpringAOP是采用动态代理的方式实现AOP，同样也使用了这些注解但是实现方式是完全不同的。</p><h2 id="spring为什么要使用三级缓存来解决循环依赖" tabindex="-1"><a class="header-anchor" href="#spring为什么要使用三级缓存来解决循环依赖" aria-hidden="true">#</a> Spring为什么要使用三级缓存来解决循环依赖？</h2><p>Bean的创建生命周期</p><ol><li>创建普通对象；</li><li>填充属性；</li><li>填充其他属性；</li><li>其他操作；</li><li>初始化后；</li><li>放入单例池。</li></ol><p>三级缓存，就是三个Map集合。</p><p><strong>第一级缓存</strong>：singletonObjects，它用来存放经过完整Bean生命周期过程的单例Bean对象；</p><p><strong>第二级缓存</strong>：earlySingletonObjects，它用来保存哪些没有经过完整Bean生命周期的单例Bean对象，用来保证不完整的bean也是单例；</p><p><strong>第三级缓存</strong>：singletonFactories，它保存的就是一个lambda表达式，它主要的作用就是bean出现循环依赖后，某一个bean到底会不会进行AOP操作。</p><div class="hint-container info"><p class="hint-container-title">循环依赖为什么用三级缓存</p><p>AService和BService相互依赖。</p><p>如果采用以下方法：</p><p>创建AService普通对象之后放入二级缓存，注入BService时发现没有，转而去创建BService对象，BService对象需要依赖注入AService对象，因此从二级缓存中拿去AService进行依赖注入，完成创建周期后将BService放入一级缓存中，返回AService的创建过程就能进行BService的依赖注入，之后AService也完成创建周期。</p><p><strong>二级缓存就能解决普通对象的循环依赖问题，那三级缓存的作用？</strong></p><p>比如，可能AService会进行AOP操作，会创建AServiceProxy代理对象（<strong>正常情况是在属性注入之后进行AOP</strong>），然后将代理对象放入单例池中，但是BService进行属性赋值，依赖注入的时候是把二级缓存中的AService的普通对象进行赋值，同时存在普通对象和代理对象违背了单例池规则。</p><p>解决办法就是在AService创建普通对象之后存入一个Lamda表达式到三级缓存中。</p><ul><li><p>创建AService普通对象；</p></li><li><p>放入Lambda表达式到三级缓存中；</p></li><li><p>尝试注入BService发现没有；</p></li><li><p>创建BService普通对象，尝试注入AService属性；</p></li><li><p>发现一二级缓存都没有；</p></li><li><p>执行三级缓存中的Lambda表达式返回AService普通对象或者代理对象；</p></li><li><p>将返回的对象放入二级缓存中，称为早期Bean对象；</p></li><li><p>将二级缓存中的AService对象或者AService代理对象注入到BService中；</p></li><li><p>BService完成创建周期放入一级缓存；</p></li><li><p>AService普通对象注入一级缓存中的BService完整对象；</p></li><li><p>根据是否需要AOP决定最后放入单例池中的对象是普通对象还是代理对象。</p></li></ul><p><img src="`+p+'" alt="image-20230619212929209"></p><p>通过对注入属性添加<code>@Lazy</code>实现懒惰式加载，只有在调用方法用到属性的时候才会进行初始化，此时本类已经完成创建周期，因此不会出现循环依赖。</p></div><h2 id="spring框架中的bean是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#spring框架中的bean是线程安全的吗" aria-hidden="true">#</a> Spring框架中的Bean是线程安全的吗？</h2><p>Spring本身没有提供Bean的线程安全策略，也就是说Bean是线程不安全的。</p><p>Bean有多种作用域：</p><ul><li><p><strong>singleton</strong>：容器中仅存在一个实例。</p></li><li><p><strong>prototype</strong>：为每个Bean请求创建实例。不存在线程安全问题。</p></li><li><p><strong>request</strong>：为每个request创建实例，请求完成之后失效。</p></li><li><p><strong>session</strong>：每次session才会创建实例，会话断开后失效。</p></li><li><p><strong>global-session</strong>：全局作用域。</p></li></ul><p>默认是<strong>singleton</strong>但是对于开发中大部分的Bean是无状态的，因此不需要保证线程安全。如果要保证线程安全可以将作用域改为<strong>Prototype</strong>，另外还能使用<code>ThreadLocal</code>解决线程安全问题。</p><blockquote><p>无状态表示这个实例没有属性对象，不能保存数据，是不变的类，例如：Controller、Service、Dao。</p></blockquote><h2 id="applicationcontext和beanfactory有什么区别" tabindex="-1"><a class="header-anchor" href="#applicationcontext和beanfactory有什么区别" aria-hidden="true">#</a> ApplicationContext和BeanFactory有什么区别？</h2><p><code>BeanFactory</code>是Spring中非常核心的组件，表示Bean工厂，可以生成和维护Bean，而<code>ApplicationContext</code>继承了<code>BeanFactory</code>，所以<code>ApplicationContext</code>拥有<code>BeanFactory</code>的所有特点，也是一个Bean工厂，另外还继承了其他接口例如<code>EnvironmentCapable</code>、<code>MessageSourse</code>、<code>ApplicationEventPublisher</code>等接口，从而让<code>ApplicationContext</code>具有<code>BeanFactory</code>不具备的功能。</p><h2 id="spring容器的启动流程" tabindex="-1"><a class="header-anchor" href="#spring容器的启动流程" aria-hidden="true">#</a> Spring容器的启动流程</h2><ol><li>创建Spring容器时会先进行扫描，得到所有的<code>BeanDefinition</code>对象，并放在一个Map中。</li><li>然后筛选出非懒加载的单例<code>BeanDefinition</code>进行创建Bean，对于多例Bean不需要在启动过程中取创建，而是每次获取的时候才会创建。</li><li>利用<code>BeanDefinition</code>创建Bean就是Bean的创建生命周期，包括了合并<code>BeanDefinition</code>、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP发生在初始化后这个步骤。</li><li>单例Bean创建完成之后Spring发布一个容器启动事件。</li><li>Spring启动结束。</li></ol>',91),c=[o];function l(r,u){return a(),s("div",null,c)}const v=n(i,[["render",l],["__file","0spring.html.vue"]]);export{v as default};
