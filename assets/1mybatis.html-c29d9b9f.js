import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as s,f as t}from"./app-16cb6cfe.js";const e={},p=t(`<h3 id="和-的区别是什么" tabindex="-1"><a class="header-anchor" href="#和-的区别是什么" aria-hidden="true">#</a> #{} 和 \${} 的区别是什么？</h3><ul><li><p><code>\${}</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，<strong>属于静态文本替换</strong>，比如\${driver}会被静态替换为<code>com.mysql.jdbc. Driver</code>。</p></li><li><p><code>#{}</code>是 <strong>sql 的参数占位符</strong>，MyBatis 会将 sql 中的<code>#{}</code>替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#{item.name}</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。可以有效防止sql注入问题。</p></li></ul><h3 id="dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗" tabindex="-1"><a class="header-anchor" href="#dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗" aria-hidden="true">#</a> Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h3><p>通常一个 xml 映射文件，都会写一个 Dao 接口与之对应。Dao 接口就是人们常说的 <code>Mapper</code> 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 <code>MappedStatement</code> 的 id 值，接口方法内的参数，就是传递给 sql 的参数。</p><p>在 MyBatis 中，每一个 <code>&lt;select&gt;</code>、 <code>&lt;insert&gt;</code>、 <code>&lt;update&gt;</code>、 <code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象。</p><p>Dao 接口里的方法可以重载（多个同名方法，但是参数不同），但是 MyBatis 的 xml 里面的 id 不允许重复。</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>getAllStu<span class="token punctuation">&quot;</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.pojo.Student<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  select * from student
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>id != null<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      id = #{id}
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Dao接口方法名对应 <code>MappedStatement</code> 的 <code>id</code>；</li><li>Dao接口参数对应 <code>#{id}</code>；</li><li>Dao接口返回值类型对应 <code>MappedStatement</code> 的<code>resultType</code>。</li><li>Dao接口的全路径名对应xml文件中的<code>namespace</code>。</li></ul><p><strong>MyBatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p><p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 <code>MappedStatement</code> 所代表的 sql，然后将 sql 执行结果返回。如果有多个sql则不知道执行哪个了。</p><h3 id="mybatis的xml映射文件中-不同的xml映射文件-id是否可以重复" tabindex="-1"><a class="header-anchor" href="#mybatis的xml映射文件中-不同的xml映射文件-id是否可以重复" aria-hidden="true">#</a> MyBatis的xml映射文件中，不同的xml映射文件，id是否可以重复？</h3><p>不同的xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复。</p><p>namespace+id是作为 <code>Map&lt;String,MappedStatement&gt;</code>的key使用的，如果没有namespace，就剩下id，id重复就会导致数据覆盖，有了namespace，并且不同，则可以使用相同的id，因为key不再重复。</p><h3 id="mybatis的xml映射文件和mybatis内部数据结构的映射关系" tabindex="-1"><a class="header-anchor" href="#mybatis的xml映射文件和mybatis内部数据结构的映射关系" aria-hidden="true">#</a> MyBatis的xml映射文件和MyBatis内部数据结构的映射关系？</h3><p>MyBatis 将所有 xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 xml 映射文件中， <code>&lt;parameterMap&gt;</code> 标签会被解析为 <code>ParameterMap</code> 对象，其每个子元素会被解析为 <code>ParameterMapping</code> 对象。 <code>&lt;resultMap&gt;</code> 标签会被解析为 <code>ResultMap</code> 对象，其每个子元素会被解析为 <code>ResultMapping</code> 对象。每一个 <code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code> 标签均会被解析为 <code>MappedStatement</code> 对象，标签内的 sql 会被解析为 <code>BoundSql</code> 对象。</p><h3 id="属性名和字段名不一致如何解决" tabindex="-1"><a class="header-anchor" href="#属性名和字段名不一致如何解决" aria-hidden="true">#</a> 属性名和字段名不一致如何解决？</h3><ol><li>查询的SQL语句使用别名处理。</li><li>通过resultMap来设置字段和属性的映射关系。以下列举将表中<code>level_id</code>字段映射为属性名levelId。</li></ol><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.member.entity.MemberEntity<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>memberMap<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>id<span class="token punctuation">&quot;</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>id<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>levelId<span class="token punctuation">&quot;</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>level_id<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mybatis中的分页" tabindex="-1"><a class="header-anchor" href="#mybatis中的分页" aria-hidden="true">#</a> MyBatis中的分页</h3><p>分页分为逻辑分页和物理分页两种。</p><p>逻辑分页：在服务器返回给客户端的时候进行分页，实际查询的仍然是所有的数据。</p><p>物理分页：从数据查询的时候就进行分页，查询的数据不是全部。</p><ul><li>MyBatis 使用<strong>RowBounds</strong>对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页；</li><li>可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</li></ul><p>物理分页就是对SQL进行改造：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> xxx <span class="token comment">--&gt; select t.* from (select * from xxx) t limit 0,10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过添加插件的方式进行分页：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">MybatisPlusInterceptor</span> <span class="token function">mybatisPlusInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">MybatisPlusInterceptor</span> interceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MybatisPlusInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PaginationInnerInterceptor</span><span class="token punctuation">(</span><span class="token class-name">DbType</span><span class="token punctuation">.</span><span class="token constant">MYSQL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> interceptor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mybatis中的执行器有哪些" tabindex="-1"><a class="header-anchor" href="#mybatis中的执行器有哪些" aria-hidden="true">#</a> MyBatis中的执行器有哪些？</h3><ul><li><strong>SimpleExecutor</strong>：简单的执行器，每次执行操作都会开启一个新的Statement对象，用完就会立即关闭。</li><li><strong>ReuseExecutor</strong>：复用的执行器，实现了对Statement对象的复用。</li><li><strong>BatchExecutor</strong>：可执行批处理任务的执行器。</li></ul><p>每一个执行器都是在SqlSession执行的生命周期内拿到的。</p>`,30),o=[p];function l(c,i){return n(),s("div",null,o)}const r=a(e,[["render",l],["__file","1mybatis.html.vue"]]);export{r as default};
