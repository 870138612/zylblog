const t=JSON.parse('{"key":"v-42365a57","path":"/framework/1spring/0spring.html","title":"Spring面试题一","lang":"zh-CN","frontmatter":{"title":"Spring面试题一","icon":"page","category":["框架"],"tag":["Spring","SpringWeb","SpringBoot","八股"]},"headers":[{"level":3,"title":"3NF","slug":"_3nf","link":"#_3nf","children":[]},{"level":2,"title":"drop、delete 与 truncate 区别？","slug":"drop、delete-与-truncate-区别","link":"#drop、delete-与-truncate-区别","children":[]},{"level":2,"title":"DML 语句和 DDL 语句区别","slug":"dml-语句和-ddl-语句区别","link":"#dml-语句和-ddl-语句区别","children":[]}],"git":{"createdTime":1687158105000,"updatedTime":1687167889000,"contributors":[{"name":"ZYL1210","email":"870138612@qq.com","commits":2}]},"readingTime":{"minutes":3.1,"words":931},"filePathRelative":"framework/1spring/0spring.md","localizedDate":"2023年6月19日","excerpt":"<p>@Transactionl\\npublic void test(){\\ntry {\\nSystem.out.println(\\"Spring事务\\"); //正常代码执行\\nint a=1/0;  //异常代码  被捕获\\n}catch (Exception e){\\nSystem.out.println(\\"出现异常\\");//这里并没有抛出异常，而是自己处理了 因此Spring无法感知\\n}\\n}\\n一些概念：</p>\\n<ul>\\n<li>函数依赖：若在一张表中，在属性X（或属性组）的值确定的情况下，必定能确定属性Y的值，那么可以说Y函数依赖于X，写作X-&gt;Y。</li>\\n<li>部分函数依赖：如果X-&gt;Y，并且存在X的一个真子集X0，是的X0-&gt;Y，则Y对X部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）<strong>当然学号属性取值是唯一的</strong>，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号），因为确定了学号或者是身份证就能确定姓名。</li>\\n<li>完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）<strong>假设不同的班级学号有相同的</strong>，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li>\\n<li>传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖于 X。传递函数依赖会导致数据冗余和异常。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性<strong>系主任</strong>对于<strong>学号</strong>的传递函数依赖。</li>\\n</ul>"}');export{t as data};
