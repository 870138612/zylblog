import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as l,c as i,d as n,a,b as s,e as r}from"./app-3efd297e.js";const t={},d=a("h3",{id:"确定目标",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#确定目标","aria-hidden":"true"},"#"),s(" 确定目标")],-1),c=a("p",null,"需要低延时使用：",-1),o=a("ul",null,[a("li",null,"CMS"),a("li",null,"G1"),a("li",null,"ZGC")],-1),p=a("p",null,"需要吞吐量使用：",-1),u=a("ul",null,[a("li",null,"ParallelGC")],-1),h=r(`<h3 id="最快的gc是不发生gc" tabindex="-1"><a class="header-anchor" href="#最快的gc是不发生gc" aria-hidden="true">#</a> 最快的GC是不发生GC</h3><ul><li><p>查看FullGC前后的内存占用，考虑以下几个问题：</p><ul><li><p>数据是不是太多</p><ul><li>resultSet = statement.executeQuery(&quot;select *from 大表 limit n&quot;)；</li><li>查询应该避免使用*查询过多的数据。</li></ul></li><li><p>数据表示是否太臃肿</p><ul><li>数据库查询需要什么字段就返回对应字段，不应该查询所有返回再筛选。</li><li>Java对象最小是16字节，如果使用包装类（例如Integer对象头就已经占用16字节），则占用的内存比基本数据类型大很多，所以能使用基本数据类型的情况下不要使用包装类型。</li></ul></li><li><p>是否存在内存泄露</p><ul><li>例如使用一个<code>static Map map</code>不断的放入对象，就会导致内存泄漏。<code>ThreadLocal</code>中就存在内存泄漏。</li><li>不建议使用Java中的数据结构作为缓存实现。</li></ul></li></ul></li></ul><h2 id="新生代gc调优" tabindex="-1"><a class="header-anchor" href="#新生代gc调优" aria-hidden="true">#</a> 新生代GC调优</h2><ul><li><p>新生代的特点：</p><ul><li><p>所有的new操作的内存分配非常廉价；</p><ul><li>TLAB 线程本地分配缓存，new对象手下会在TLAB中分配，由于是线程私有的，所以同时也解决了并发问题；</li></ul></li><li><p>死亡对象的回收代价是零;<code>标记复制算法</code></p></li><li><p>大部分对象用过即死；</p></li><li><p>Minor GC的时间远低于Full GC。</p></li></ul><p>总空间不变的情况下，新生代越大，老年代越小，引发的Full GC的概率就更大，推荐新生代大小占整个堆的百分之25到百分之50。新生代的空间越大也会导致每次MinorGC的时间变长。</p></li></ul><h3 id="幸存区" tabindex="-1"><a class="header-anchor" href="#幸存区" aria-hidden="true">#</a> 幸存区</h3><ul><li>幸存区大到能保留【当前活跃对象+需要晋升的对象】。</li><li>调节晋升阈值，让长时间存活的对象尽快晋升</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxTenuringThreshold</span><span class="token operator">=</span>threshold
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">PrintTenuringDistribution</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="老年代调优" tabindex="-1"><a class="header-anchor" href="#老年代调优" aria-hidden="true">#</a> 老年代调优</h3><p>以CMS为例：</p><ul><li>CMS的老年代内存越大越好；</li><li>观察发生Full GC时老年代内存占用，将老年代内存预设调大1/4~1/3</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">CMSInitiatingOccupancyFraction</span><span class="token operator">=</span>percent
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="案例" tabindex="-1"><a class="header-anchor" href="#案例" aria-hidden="true">#</a> 案例</h2><h3 id="案例1" tabindex="-1"><a class="header-anchor" href="#案例1" aria-hidden="true">#</a> 案例1</h3><p>FullGC和MinorGC频繁。</p><ul><li>尝试增大新生代，MinorGC次数就会减少，增加晋升阈值，让新生代的对象晋升时间更长，进一步让老年代FullGC不再频繁。</li></ul><h3 id="案例2" tabindex="-1"><a class="header-anchor" href="#案例2" aria-hidden="true">#</a> 案例2</h3><p>请求高峰期发生FullGC，单次暂停时间特别长（CMS）。</p><ul><li>业务需求低延时所以选择了CMS。</li><li>查看CMS四个阶段中哪个阶段花的时间太长。 <ul><li>重新标记阶段会花费很长的时间，重新标记会扫描所有新生代对象，而在请求高峰期会产生很多新生代对象。</li></ul></li><li>可以在重新标记前进行一次垃圾回收，存活对象少了，重新标记花的时间就少了。</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>-XX:+CMSScavengeBeforeRemark
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参数表示在重新标记之前先对新生代进行垃圾清理。</p><h3 id="案例3" tabindex="-1"><a class="header-anchor" href="#案例3" aria-hidden="true">#</a> 案例3</h3><p>老年代充裕的情况下，发生FullGC（1.7）。</p><p>1.7采用永久代，之后变成元空间使用操作系统的空间。</p><p>则这种情况属于永久代内存不足导致FullGC。</p>`,24);function m(v,C){return l(),i("div",null,[d,c,o,p,u,n(" more "),h])}const b=e(t,[["render",m],["__file","7gcoptimize.html.vue"]]);export{b as default};
