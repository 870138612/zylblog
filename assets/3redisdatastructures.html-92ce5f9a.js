import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as d,c as r,e as a,b as t,f as i}from"./app-88446bd7.js";const o="/markdown/image-20230607205223121.png",s="/markdown/image-20230608171725873.png",h="/markdown/image-20230608172142206.png",n="/markdown/image-20230608172937070.png",l="/markdown/image-20230608173432109.png",c="/markdown/image-20230608173918450.png",y={},p=t("p",null,"Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。",-1),k=t("p",null,"这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。",-1),g=i('<p>Redis 基本数据结构的底层数据结构实现如下：</p><table><thead><tr><th style="text-align:left;">String</th><th style="text-align:left;">List</th><th style="text-align:left;">Hash</th><th style="text-align:left;">Set</th><th style="text-align:left;">Zset</th></tr></thead><tbody><tr><td style="text-align:left;">SDS</td><td style="text-align:left;">LinkedList/ZipList/QuickList</td><td style="text-align:left;">Hash Table、ZipList</td><td style="text-align:left;">ZipList、Intset</td><td style="text-align:left;">ZipList、SkipList</td></tr></tbody></table><h2 id="string-字符串" tabindex="-1"><a class="header-anchor" href="#string-字符串" aria-hidden="true">#</a> String（字符串）</h2><p>String 是 Redis 中最简单同时也是最常用的一个数据结构。</p><p>String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p><p><img src="'+o+'" alt="image-20230607205223121"></p><p>Redis自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p><h3 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SET key value</td><td>设置指定 key 的值</td></tr><tr><td>SETNX key value</td><td>只有在 key 不存在时设置 key 的值</td></tr><tr><td>GET key</td><td>获取指定 key 的值</td></tr><tr><td>MSET key1 value1 key2 value2 …</td><td>设置一个或多个指定 key 的值</td></tr><tr><td>MGET key1 key2 ...</td><td>获取一个或多个指定 key 的值</td></tr><tr><td>STRLEN key</td><td>返回 key 所储存的字符串值的长度</td></tr><tr><td>INCR key</td><td>将 key 中储存的数字值增一</td></tr><tr><td>DECR key</td><td>将 key 中储存的数字值减一</td></tr><tr><td>EXISTS key</td><td>判断指定 key 是否存在</td></tr><tr><td>DEL key（通用）</td><td>删除指定的 key</td></tr><tr><td>EXPIRE key seconds（通用）</td><td>给指定 key 设置过期时间</td></tr></tbody></table><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h3><p><strong>需要存储常规数据的场景</strong></p><ul><li>举例：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li><li>相关命令：<code>SET</code>、<code>GET</code>。</li></ul><p><strong>需要计数的场景</strong></p><ul><li>举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li><li>相关命令：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li></ul><p><strong>分布式锁</strong></p><p>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。</p><h2 id="list-列表" tabindex="-1"><a class="header-anchor" href="#list-列表" aria-hidden="true">#</a> List（列表）</h2><p>Redis 中的 List 其实就是链表数据结构的实现，Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p><img src="'+s+'" alt="image-20230608171725873"></p><h3 id="常用命令-1" tabindex="-1"><a class="header-anchor" href="#常用命令-1" aria-hidden="true">#</a> 常用命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>RPUSH key value1 value2 ...</td><td>在指定列表的尾部（右边）添加一个或多个元素</td></tr><tr><td>LPUSH key value1 value2 ...</td><td>在指定列表的头部（左边）添加一个或多个元素</td></tr><tr><td>LSET key index value</td><td>将指定列表索引 index 位置的值设置为 value</td></tr><tr><td>LPOP key</td><td>移除并获取指定列表的第一个元素(最左边)</td></tr><tr><td>RPOP key</td><td>移除并获取指定列表的最后一个元素(最右边)</td></tr><tr><td>LLEN key</td><td>获取列表元素数量</td></tr><tr><td>LRANGE key start end</td><td>获取列表 start 和 end 之间 的元素</td></tr></tbody></table><h3 id="应用场景-1" tabindex="-1"><a class="header-anchor" href="#应用场景-1" aria-hidden="true">#</a> 应用场景</h3><p><strong>信息流展示</strong></p><ul><li>举例：最新文章、最新动态。</li><li>相关命令：<code>LPUSH</code>、<code>LRANGE</code>。</li></ul><p><strong>消息队列</strong></p><p>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</p><p>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p><h2 id="hash-哈希" tabindex="-1"><a class="header-anchor" href="#hash-哈希" aria-hidden="true">#</a> Hash（哈希）</h2><p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象。</p><p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p><p><img src="'+h+'" alt="image-20230608172142206"></p><h3 id="常用命令-2" tabindex="-1"><a class="header-anchor" href="#常用命令-2" aria-hidden="true">#</a> 常用命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>HSET key field value</td><td>设置指定哈希表中指定字段的值</td></tr><tr><td>HSETNX key field value</td><td>只有指定字段不存在时设置指定字段的值</td></tr><tr><td>HMSET key field1 value1 field2 value2 ...</td><td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td></tr><tr><td>HGET key field</td><td>获取指定哈希表中指定字段的值</td></tr><tr><td>HMGET key field1 field2 ...</td><td>获取指定哈希表中一个或者多个指定字段的值</td></tr><tr><td>HGETALL key</td><td>获取指定哈希表中所有的键值对</td></tr><tr><td>HEXISTS key field</td><td>查看指定哈希表中指定的字段是否存在</td></tr><tr><td>HDEL key field1 field2 ...</td><td>删除一个或多个哈希表字段</td></tr><tr><td>HLEN key</td><td>获取指定哈希表中字段的数量</td></tr><tr><td>HINCRBY key field increment</td><td>对指定哈希中的指定字段做运算操作（正数为加，负数为减）</td></tr></tbody></table><blockquote><p>Hash数据结构添加需要三个参数，分别是hash的key、键、值，而String类型是两个参数。</p></blockquote><h3 id="应用场景-2" tabindex="-1"><a class="header-anchor" href="#应用场景-2" aria-hidden="true">#</a> 应用场景</h3><p><strong>对象数据存储场景</strong></p><ul><li>举例：用户信息、商品信息、文章信息、购物车信息。</li><li>相关命令：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li></ul><h2 id="set-集合" tabindex="-1"><a class="header-anchor" href="#set-集合" aria-hidden="true">#</a> Set（集合）</h2><p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。基于 Set 能轻易实现交集、并集、差集的操作，比如可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。</p><p><img src="'+n+'" alt="image-20230608172937070"></p><h3 id="常用命令-3" tabindex="-1"><a class="header-anchor" href="#常用命令-3" aria-hidden="true">#</a> 常用命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SADD key member1 member2 ...</td><td>向指定集合添加一个或多个元素</td></tr><tr><td>SMEMBERS key</td><td>获取指定集合中的所有元素</td></tr><tr><td>SCARD key</td><td>获取指定集合的元素数量</td></tr><tr><td>SISMEMBER key member</td><td>判断指定元素是否在指定集合中</td></tr><tr><td>SINTER key1 key2 ...</td><td>获取给定所有集合的交集</td></tr><tr><td>SINTERSTORE destination key1 key2 ...</td><td>将给定所有集合的交集存储在 destination 中</td></tr><tr><td>SUNION key1 key2 ...</td><td>获取给定所有集合的并集</td></tr><tr><td>SUNIONSTORE destination key1 key2 ...</td><td>将给定所有集合的并集存储在 destination 中</td></tr><tr><td>SDIFF key1 key2 ...</td><td>获取给定所有集合的差集</td></tr><tr><td>SDIFFSTORE destination key1 key2 ...</td><td>将给定所有集合的差集存储在 destination 中</td></tr><tr><td>SPOP key count</td><td>随机移除并获取指定集合中一个或多个元素</td></tr><tr><td>SRANDMEMBER key count</td><td>随机获取指定集合中指定数量的元素</td></tr></tbody></table><h3 id="应用场景-3" tabindex="-1"><a class="header-anchor" href="#应用场景-3" aria-hidden="true">#</a> 应用场景</h3><p><strong>需要存放的数据不能重复的场景</strong></p><ul><li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li><li>相关命令：<code>SCARD</code>（获取集合数量） 。</li></ul><p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p><ul><li>举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。</li><li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li></ul><p><strong>需要随机获取数据源中的元素的场景</strong></p><ul><li>举例：抽奖系统、随机点名等场景。</li><li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li></ul><h2 id="sorted-set-有序集合" tabindex="-1"><a class="header-anchor" href="#sorted-set-有序集合" aria-hidden="true">#</a> Sorted Set（有序集合）</h2><p>Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p><p><img src="'+l+'" alt="image-20230608173432109"></p><h3 id="常用命令-4" tabindex="-1"><a class="header-anchor" href="#常用命令-4" aria-hidden="true">#</a> 常用命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>ZADD key score1 member1 score2 member2 ...</td><td>向指定有序集合添加一个或多个元素</td></tr><tr><td>ZCARD KEY</td><td>获取指定有序集合的元素数量</td></tr><tr><td>ZSCORE key member</td><td>获取指定有序集合中指定元素的 score 值</td></tr><tr><td>ZINTERSTORE destination numkeys key1 key2 ...</td><td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td></tr><tr><td>ZUNIONSTORE destination numkeys key1 key2 ...</td><td>求并集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZDIFFSTORE destination numkeys key1 key2 ...</td><td>求差集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td></tr><tr><td>ZREVRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td></tr><tr><td>ZREVRANK key member</td><td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td></tr></tbody></table><h3 id="应用场景-4" tabindex="-1"><a class="header-anchor" href="#应用场景-4" aria-hidden="true">#</a> 应用场景</h3><p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p><ul><li>举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、游戏中的段位排行榜、话题热度排行榜等等。</li><li>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul><p><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</p><ul><li>举例：优先级任务队列。</li><li>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul><h2 id="bitmap" tabindex="-1"><a class="header-anchor" href="#bitmap" aria-hidden="true">#</a> Bitmap</h2><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p><p><img src="'+c+'" alt="image-20230608173918450"></p><h3 id="常用命令-5" tabindex="-1"><a class="header-anchor" href="#常用命令-5" aria-hidden="true">#</a> 常用命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SETBIT key offset value</td><td>设置指定 offset 位置的值</td></tr><tr><td>GETBIT key offset</td><td>获取指定 offset 位置的值</td></tr><tr><td>BITCOUNT key start end</td><td>获取 start 和 end 之前值为 1 的元素个数</td></tr><tr><td>BITOP operation destkey key1 key2 ...</td><td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td></tr></tbody></table><h3 id="应用场景-5" tabindex="-1"><a class="header-anchor" href="#应用场景-5" aria-hidden="true">#</a> 应用场景</h3><p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p><ul><li>举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li><li>相关命令：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li></ul><h2 id="hyperloglog" tabindex="-1"><a class="header-anchor" href="#hyperloglog" aria-hidden="true">#</a> HyperLogLog</h2><p>HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</p><p>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p><ul><li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li><li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li></ul><p>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> ）。</p><h3 id="常用命令-6" tabindex="-1"><a class="header-anchor" href="#常用命令-6" aria-hidden="true">#</a> 常用命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>PFADD key element1 element2 ...</td><td>添加一个或多个元素到 HyperLogLog 中</td></tr><tr><td>PFCOUNT key1 key2</td><td>获取一个或者多个 HyperLogLog 的唯一计数。</td></tr><tr><td>PFMERGE destkey sourcekey1 sourcekey2 ...</td><td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td></tr></tbody></table><h3 id="应用场景-6" tabindex="-1"><a class="header-anchor" href="#应用场景-6" aria-hidden="true">#</a> 应用场景</h3><p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p><ul><li>举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</li><li>相关命令：<code>PFADD</code>、<code>PFCOUNT</code> 。</li></ul><h2 id="geospatial-index" tabindex="-1"><a class="header-anchor" href="#geospatial-index" aria-hidden="true">#</a> Geospatial index</h2><p>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</p><p>通过 GEO 可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p><h3 id="常用命令-7" tabindex="-1"><a class="header-anchor" href="#常用命令-7" aria-hidden="true">#</a> 常用命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>GEOADD key longitude1 latitude1 member1 ...</td><td>添加一个或多个元素对应的经纬度信息到 GEO 中</td></tr><tr><td>GEOPOS key member1 member2 ...</td><td>返回给定元素的经纬度信息</td></tr><tr><td>GEODIST key member1 member2 M/KM/FT/MI</td><td>返回两个给定元素之间的距离</td></tr><tr><td>GEORADIUS key longitude latitude radius distance</td><td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数</td></tr><tr><td>GEORADIUSBYMEMBER key member radius distance</td><td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td></tr></tbody></table><p>GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。</p><h3 id="应用场景-7" tabindex="-1"><a class="header-anchor" href="#应用场景-7" aria-hidden="true">#</a> 应用场景</h3><p><strong>需要管理使用地理空间数据的场景</strong></p><ul><li>举例：查找附近商铺。</li><li>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code> 。</li></ul>',86);function S(u,E){return d(),r("div",null,[p,k,a(" more "),g])}const R=e(y,[["render",S],["__file","3redisdatastructures.html.vue"]]);export{R as default};
