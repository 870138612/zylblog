---
title: 计算机组成原理
icon: organization 
order: 1
cover: /discoverybackground/ocean1.jpg
category:
  - 计算机组成原理
tag:
  - 计算机组成原理
---


## 计算机系统概述

#### 冯诺依曼计算机的特点

- 计算机由运算器，存储器，控制器，输入设备，输出设备构成，

    - 运算器核心是算数逻辑单元$\text{ALU}$，加减乘除，移位操作，运算器包含了一些寄存器，用来存储中间数据，$\text{ACC}$，运算器里面还有程序状态寄存器$\text{PSW}$.

    - 控制器里面有程序计数器PC，指令寄存器IR和控制单元$\text{CU}$，$\text{PC}$是用来表示下一条将要执行指令的地址，当存储单元的大小和指令字长相同的时候，每一条指令的执行都会伴随$\text{PC}+1\rightarrow \text{PC}$，$\text{IR}$用来暂存当时正在执行的程序，$\text{CU}$用来发出控制信号.

    - 存储器包含$\text{MDR}$，$\text{MAR}$，$\text{MDR}$暂存需要传输的数据，$\text{MAR}$用来存储地址.

- 指令和数据以同等地位存放在存储器中.

    - 计算机如何区分取出的是数据还是指令：取指阶段取出的是指令，间址阶段取出的是数据，所以根据指令执行的不同阶段区分.

- 指令和数据以二进制存储.

- 指令由操作码和地址码构成，操作码表示这个指令的操作（区分指令不同），地址码用来表示数据存储的位置.

#### 计算机性能指标

- 机器字长，又叫做字长，表示计算机进行一次整数运算能处理的数据总长.

- 数据通路的带宽，数据线的根数，一般等于$\text{MDR}$.

- 主存容量=地址总数（$2^{地址线的根数}$ $\text{MAR}$的位数等于地址线的根数（一般情况））*每一个地址的大小（存储字长）.

- 吞吐量，单位时间内计算机能处理的指令条数.

- 响应时间，指令在创建完成之后不会被立即处理，到被调度执行的时间称为响应时间.

- $\text{CPI}$，一条指令所需要的时钟周期数.

- $\text{MIPS}$，百万$\text{IPS}$.

## 数据的表示和运算

#### 数据的编码

- $\text{BODH}$，分别表示二进制，八进制，十进制，和十六进制.

- $\text{15}$用二进制表示$\text{111}$，对应的十六进制就是$\text{F}$.

- 真值和机器数，真值就是真实值，机器数是存储在存储器上的格式.

#### 原码反码补码

- 假设总共$\text{8}$位，则最高位是符号位，$\text{0}$表示正数，$\text{1}$表示负数，其余是数值位.

- 正数的原反补相同.

- 大端存储就是正常顺序，从左到右，边界对齐必须以单个数据的大小的倍数作为起始地址.

- 负数，原码正常写，$-15$则在$\text{8}$位的空间中，机器数为`1000 1111`.

    - 反码，原码的数值位全取反得到`1111 0000`.

    - 补码，反码末尾$+1$（原码的数值位全取反，末尾再加1），得到`1111 0001`.

    - 原码和补码之间的关系，针对负数，

        - 原码`1000 1111`

        - 补码`1111 0001`

        - 从右往左第一个$\text{1}$开始，左边的数值位都是反过来的，右边都是相同的.

        - 例如-8的原码是`1000 1000`，补码是`1111 1000`.

- 移码是补码的符号位取反，或者是真值基础上加上$2^n$（偏移量，与IEEE754中的不同），$\text{n}$代表数值位的位数，可以看成无符号数.

- 对于小数来说，从最高位的右边省略了一个`.`.

    - 例如定点小数`0 1`，真实值是$\frac{1}{2}$

- 表示范围

    - 例如$\text{8}$位的定点整数.

        - 原码的表示范围是`[-127,127]`，$\text{0}$的表示方式有两种`0000 0000`，`1000 0000`，正数编码$\text{127}$种，负数编码$\text{127}$种，一共$\text{256}$.

        - 反码的表示范围是是`[-127,127]`.

        - 补码的表示范围是`[-128,127]`，$\text{0}$的表示方式只有一种`0000 0000`，`1000 0000`在补码当中表示最小值`-128`，在任意的补码中，如果符号位取`1`，数值位全`0`则表示最小值.

    - 定点小数

        - 原码的表示范围`(-1,1)`.

        - 反码的表示范围`(-1,1)`.

        - 补码的表示范围`[-1,1)`，$-1$在$\text{2}$位的定点小数中表示形式`1 0`.

- 加法器中的标志

    - 溢出标志位$\text{OF}=C_n\bigoplus C_{n-1}$，两者相同的时候输出$\text{0}$，否则输出$\text{1}$.

    - 符号位$\text{SF}=\text{F}_{n-1}$.

    - 零标志位$\text{ZF}=1$当且仅当$\text{F}=0$.

    - 进位/借位标志$\text{CF}=C_{out} \bigoplus C_{in}$.


#### 运算方法

- 移位

    - 逻辑移位，视为无符号数，不管左移还是右移都是补$\text{0}$，

    - 算数移位，符号位不参与移位，正数移位都补$\text{0}$，正数的原反补是相同的，

        - 负数，原码仍然是补$\text{0}$，反码补$\text{1}$（反码的数值位和原码相反），补码由于从右往左第一个$\text{1}$开始，左边全反，右边全相同，左移低位出现空挡，补$\text{0}$；右移是高位出现空挡补$\text{1}$.

- 加减运算

    - 直接从十进制开始运算，判断结果是否能表示出来，不能则溢出，能则再转成补码，就是最后的结果机器数.

    - 补码判断溢出

        - 从符号位判断，正数$+$正数得到负数则溢出，负数$+$负数得到正数则溢出.

        - 从最高数值位和符号位的进位判断，符号位和符号位是能进行计算的，数值位的进位不会影响符号位，如果两者都有进位或者都没进位则没有溢出，否则溢出，异或：两者相同的时候输出$\text{0}$，否则输出$\text{1}$.

        - 双符号位，最高的符号位表示真实符号位，此时数值位和符号位同时参与运算，判断结果的符号位是否相等，不等则表示溢出，负数`10`表示负溢出，`01`正数表示正溢出.

#### 浮点数的表示和运算

- $\text{IEEE754}$格式中$\text{float}$类型分别长度为`1 8 23`，符号，阶码和尾数.

    - 符号位$\text{0}$表示浮点数是正数，$\text{1}$表示负数.

    - 阶码$\text{8}$位，是移码表示的，偏移量是`127`.

        - 把阶码想象成无符号数，则表示范围是`0~255`，由于偏移量是`127`，规定移码为`0`或者为`255`的时候分别表示无穷大和无穷小，去除之后剩下`1~254`；所以真实的表示范围是`-126~127`.

    - 尾数隐含了`1.`，例如尾数部分是`1000....`，则表示真正的二进制尾数是`1.1000...`.

        - 尾数的最小值是`000000...`，即$\text{23}$个`0`，表示尾数`1`.

        - 最大值是`11111....`，即$\text{23}$个`1`，表示尾数$2-2^{-23}$.

        - 浮点数的最大值是$2-2^{-23}*2^{127}$.

- 浮点数尾数的规格化

    - 尾数为规格化的尾数$\cfrac{1}{2}\le|M|<1$，原码小数的最高数值位为$\text{1}$，则规格化，否则不是规格化的；补码如果是规格化的尾数，则需要符号位和数值位相异（必要条件）.

- 浮点数的加减法运算，跟$\text{IEEE754}$无关

    - 对阶
        - 小阶向大阶对齐.

    - 尾数加减
        - 采用双符号位进行运算.

    - 规格化
        - 通过左规右规将位数变为规格化尾数.

    - 舍入
        - 通过舍入办法进行舍入尾数.

    - 溢出判断
        - 通过双符号位进行溢出判断.

## 存储系统

#### 概述

- 按照存取方式分为$\text{ROM}$和$\text{RAM}$.

    - $\text{RAM}$随机存储器，断电信息会丢失，可以修改数据的.

        - $\text{SRAM}$，使用触发器，静态随机存储器，组成$\text{cache}$.

        - $\text{DRAM}$，使用电容，动态随机存储器，组成内存.

    - $\text{ROM}$只读存储器，断电信息不丢失，不可以修改数据.

    - 串行访问存储器，磁带，光盘，顺序读取.

- 存储容量$=$地址个数$*$存储字长

- 存取周期$\text{T}$，进行完成读写操作需要的全部时间.

- 主存带宽，数据传输率.

- 层次结构

    - $\text{cache}$主存层，数据交互是由硬件自动完成的，不需要$\text{OS}$参与，对程序员透明.

    - 主存$-$辅存层，数据交互是由$\text{OS}$和硬件共同完成的，外存的存储方式由操作系统决定.

- $\text{BIOS}$主板出厂的时候写入，$\text{MBR}$是创建操作系统的时候写入的，是计算机开机以后访问硬盘时所必须要读取的第一个扇区.

#### 主存工作原理

- $\text{SRAM}$使用触发器保存数据，$\text{cache}$原料.

- $\text{DRAM}$使用电容保存数据，主存原料.

    - 一般认为电容在$2ms$之后电荷会流失.

    - 刷新方式，刷新就是一次读取和写入的过程，认为是一个存取周期，一次刷新一行.

        - 集中刷新，在$2ms$的最后一段时间对所有行进行刷新，会导致主存长时间不可用，死区.

        - 分散刷新，读取一次刷新一次，总时间一半用来刷新，一半用来存取，低效率.

        - 异步刷新，$2ms/$总行数，得到每隔多少时间刷新下一行，对于每一行正好经过$2ms$进行一次刷新.

- $\text{DRAM}$才用双译码地址编码方式，采用引脚复用技术，可以让地址线根数少一半.

- $\text{MDR}$的位数与数据线相同，$\text{MAR}$的位数与地址线相同.

- 多体并行存储器

    - 高位交叉编址，存储体号是在高位的，连续取$\text{n}$个字（存储字）所需要的时间是$t=nT$，利于地址扩充.

    - 低位交叉编址，存储体号是在低位的，连续取$\text{n}$个字所需要的时间是$t=T+(n-1)\tau$，理想情况下$T=m\tau$存储体利用率最高，$\text{m}$是存储体的个数；$T<m\tau$，存储体利用率不足，$T>m\tau$不能形成流水线.

#### 外部存储器

- 记录密度，位密度是单位长度下记录二进制代码的位数，内圈的位密度较高.

- 磁盘的地址结构`磁道号，盘面号，扇区号`，盘面号写在磁道号后面是因为读取连续地址的数据可以不移动磁头.

- $\text{RAID0}$将两个磁盘并行传输数据，文件散列存放在两个磁盘中，可以将数据传输率增加一倍，安全性较差，一个磁盘的数据受损，另外一个不可用；$\text{RAID1}$将一个磁盘上的数据进行备份到另外一个磁盘，安全性较高.

- $\text{SCAN}$调度，来回扫描，$\text{C-SCAN}$单向扫描，$\text{LOOK}$当前移动方向没有请求则直接反方向扫描，$\text{C-LOOK}$前移动方向没有请求则返回起点继续按当前方向扫描.

#### Cache

- 局部性原理，时间局部性：一个数据在被访问之后的不就会被再次访问，空间局部性：一个数据被访问，则周围的数据在将来也会被访问.

```java
int getSum(int a[]){
	int sum = 0;
	for(int i = 0; i < a.length; i ++){
		sum += a[i];//时间局部性和空间局部性
	}
	return sum;
}
```

- $\text{cache}$和主存的映射

    - 直接映射方式$\text{cache}$块号$ = $主存块号$\ mod \text{ cache}$总行数.

        - 问题：可能存在其他$\text{cache}$没有使用的情况，部分$\text{cache}$行一直被替换，利用率比较低，实现简单.
        - 主存地址结构`主存标记，cache块号，块内地址`，块内地址的位数等于$\logN$，$\text{N}$是一个块的大小；$\text{cache}$块号的位数等于$\log(\text{cache}块数)$，适合大容量$\text{cache}$.
    - 全相联映射，允许主存块放入$\text{cache}$中的任意一行，提高了$\text{cache}$的利用率，但是会导致标记项的位数增加，不适合大容量$\text{cache}$，按照内容寻址的存储器是相联存储器.

        - 主存结构`主存标记，块内地址`.
    - 组相联映射，先将$\text{cache}$进行分组，组内使用全相联映射，组间使用直接映射.

        - 组号$=$ 主存块号 $\text{mod}$组数，组内可以随意存放；当每一组只有一行的时候变为直接相联映射，当所有行为一组的时候变为全相联映射.

        - 主存结构`主存标记，组号，块内地址`.
    - 替换算法

        - 随机算法，随机替换$\text{cache}$行.

        - 先进先出，类似于队列.

        - $\text{LRU}$，最近最少使用算法，命中率较高，链表，集合.
- 在修改$\text{cache}$之后写回主存的时机

    - 写回法，在$\text{cache}$中存在一个脏位，表示数据是否修改，当这行被替换的时候，判断脏位，修改了则写会主存，没有修改则直接替换.

    - 全写法，同时修改$\text{cache}$和主存，比较影响运行效率的.

#### 虚拟存储器

- 基于局部性原理.

- 虚拟存储器就是解决内存紧张问题的，将外存中一部分区域当做内存来使用，属于进程但是暂时不用的数据会放入外存的交换区中，等需要使用的时候再进行调入，对应操作系统中级调度.

- 虚拟存储器采用全相联映射，采用写回法.

- 内存大小取决于$\text{MAR}$的位数.

## 指令系统

#### 指令系统

- 指令的基本格式，操作码和地址码，操作码（区分指令的不同）用来表示指令是做什么的，地址码表示了操作数的位置.

- 二地址指令中，目的操作数（第一个地址）用来保存结果.

- 在扩展操作码中指令格式

#### 指令的寻址方式

- 数据寻址

    - 隐含寻址，一个操作数隐含在$\text{ACC}$中.

    - 立即寻址，操作数就是地址码.

    - 直接寻址，通过地址码字段找到对应的主存单元取出数据，$\text{EA=A}$，寻址范围受限于地址码字段.

    - 间接寻址，两次直接寻址，通过地址码字段找到对应的主存单元，取出操作数的主存地址，再通过地址找到主存位置取出数据，$\text{EA=(A)}$，可以通过第一次找到EA之后，寻址范围就变成了主存.

    - 寄存器寻址，通过地址码字段找到对应的寄存器拿出数据，$\text{EA=R}$.

    - 寄存器间接寻址，第一次查找寄存器取出主存地址，第二次根据主存地址找到操作数，$\text{EA=(R)}$.

    - 偏移寻址

        - 相对寻址，寄存器里的值加上一个偏移量得到真实地址，$\text{(PC)+A \rightarrow PC}$.

        - 基址寻址，$\text{EA=(BR)+A}$，$\text{BR}$里的值不变，$\text{A}$可变，利于编制浮动程序和多道程序设计.

        - 变址寻址，$\text{EA=(IX)+A}$，$\text{IX}$里的值会变，$\text{A}$不变，利于处理数组问题($\text{A}$就是每个数组元素的空间大小).

#### CISC和RISC

- $\text{CISC}$复杂指令集，$\text{RISC}$是精简指令集。

- $\text{CISC}$和多，不固定，复杂联系在一起，$\text{RISC}$中的寄存器较多.

- $20\%$的简单指令被重复使用，约占程序的百分之$80\%$，$80\%$的复杂指令很少被用到，约占整个程序的$20\%$.

## 中央处理器

#### CPU功能和基本结构

- 对用户不透明的寄存器：通用寄存器组，程序寄存器$\text{PC}$，程序状态字寄存器$\text{PSW}$，累加寄存器，移位寄存器.

#### 指令的执行过程

- 指令周期包含取指周期，间址周期，执行周期，中断周期.

    - 取指周期用来取指令的.

    - 间址周期取操作数.

    - 执行周期指令操作.

    - 中断周期响应中断去执行其他的指令.

- 指令的数据流，$\text{A+B->A}$，$\text{A}$通过地址码直接寻址获得，$\text{B}$隐含寻址.

```java
取指
(PC)->MAR;
1->R;
M(MAR)->MDR;(PC)+1->PC;
MDR->IR;
间址，假设采用直接寻址
Ad(IR)->MAR;
M(MAR)->MDR;
执行周期
(MDR)+(ACC)->Y;
1->W;
Y->M(MAR);
中断，保存断点到0号地址
(PC)->MDR;
(MDR)->M(0);
1->EINT;
形成中断服务程序的入口地址->PC
```

- 单周期处理器，所有的指令都在一个时钟周期内完成，$\text{CPI=1}$.

#### 数据功能的基本功能和结构

- 组合逻辑元件的输出仅仅取决于当前时刻的输入，没有记忆功能.

- 时序逻辑电路的输出取决于当前时刻的输入和历史时刻的输入，有记忆功能.

#### 控制器的功能和工作原理

- 硬布线控制，通过组合逻辑电路和触发器构成，实现微操作的发生，设计电路复杂，不利于修改，$\text{RISC}$.

- 微程序控制器，$\text{1}$指令$=1$微程序，$\text{1}$微程序$=n$微指令，$\text{1}$微指令$=n$微操作，$\text{CISC}$.

    - 指令存储在主存中，微指令存储在控制存储器中.

    - 指令以$\text{PC}$中的值来确定指令的地址，微指令中通过上一条微指令的下地址字段决定执行的地址.

    - 微程序的起始地址由操作码字段给出.

    - 微指令的编码方式，微指令包含操作控制字段和地址控制字段.

        - 直接编码方式，每一位的地址控制字段表示一种操作，简单直观，但是指令的编码很少，造成控制存储器容量变大.
        - 字段直接编码方式，有多个段，每个段产生一种信号，采用二进制编码的方式，全$\text{0}$表示什么都不做，例如现有$\text{8}$种微指令需要进行编码，则需要$\text{4}$位的二进制进行编码，$(\log(1+8))$，$\text{1}$表示不做操作的编码个数.
        - 在一个段内的指令，应该是相斥的微指令，相容的微指令应该放在不同的段内.
    - 水平型微指令微程序短，并行能力强，执行速度快，缺点指令长.

    - 垂直型微指令微指令短，简单，规整，便于编写微程序，但是微程序长，执行速度慢.

#### 异常和中断机制

- 中断响应过程，中断隐指令

    - 关中断.

    - 保存断点和程序状态，断点是$\text{PC}$里面的内容，$\text{PSW}$程序状态，这两者都是对程序员可见的.

    - 形成中断服务程序入口地址.

#### 指令流水线

- 冒险和处理

    - 结构冒险，在同一个时刻有多个指令访问同一个资源

        - 让冲突指令等待.
        - 采用不同类的部件，例如取指和访存用的不是一个存储器.

    - 数据冒险

        - 延时相关指令.
        - 数据旁路.

    - 控制冒险

        - 分支预测.
        - $\text{nop}$指令和硬件阻塞法.
        - 遇到$\text{jump}$指令可能会发生控制冒险.

- 流水线的性能指标

    - 加速比$S=\frac{T_0}{T_k}$，不用流水线的时间除以用流水线的任务执行时间， 当任务数趋向无穷的时候加速比就等于流水段的个数.

- 高级流水线

    - 超标量流水线，同一个时刻并发出多条指令，需要配置多个部件.

    - 超长指令字，指令的取指阶段，间址阶段和中断阶段都是做同样的事情，传入的地址不同，将多条指令的执行阶段合并到一起，需要多处理器的支持.

    - 超流水线技术，将阶梯缩短，流水线的功能段分的更多.

## 总线

#### 总线概述

- 总线的控制方式

    - 同步控制方式，采取统一的时钟信号进行控制.

    - 异步控制方式，不采取统一的时钟信号进行控制.

- 分类

    - 串行总线：只有一条双向或者单向传输的数据线，$\text{USB}$.

    - 并行总线：有多条双向或者单向传输的数据线，$\text{PCI}$，$\text{PCI-E}$.

#### 总线事务

- 异步定时方式

    - 不互锁，发送方和接收方之间不存在确认 ，相互之间没有制约，发送方定时将数据关闭.

    - 半互锁，接收方接收数据之后返回确认，发送方定时将数据关闭.

    - 全互锁，接收方接收数据之后返回确认，发送方接收到确认之后返回确认，并关闭连接.

## IO

#### 基本概念

- $\text{IO}$控制方式，程序查询方式，程序中断方式，$\text{DMA}$控制方式.

- 显存的计算，帧率$*$分辨率$*$灰度级.

#### IO接口

- 并行接口，一个字节或者一个字的所有位同时传输.

- 串行接口，一位一位的传输.

- 独立编址，对$\text{IO}$接口进行独立的编址.

- 统一编址，将主存中的一部分作为$\text{IO}$的地址.

#### IO控制方式

- 程序查询方式

    - 当遇到数据不存在时，调用$\text{IO}$将数据传送到数据缓冲寄存器，$\text{CPU}$轮训数据是否查询好.

    - 效率低，$\text{CPU}$被阻塞，数据传输效率低.

    - 独占查询，$\text{CPU}$一直轮训.

    - 定时查询，没过一段时间进行一次查询.

- 程序中断方式

    - 当遇到数据不存在时，调用$\text{IO}$将数据传送到数据缓冲寄存器，$\text{CPU}$做其他的事情，等到数据传送完成，$\text{IO}$发送中断指令给$\text{CPU}$，$\text{CPU}$响应之后再来继续工作.

    - 效率低，$\text{CPU}$被解放，数据传输效率低.

    - 多重中断屏蔽字，当前中断源的屏蔽字，某位为$\text{1}$则表示能屏蔽该位的中断源，另外还需要屏蔽自己.

- $\text{DMA}$方式

    - 由$\text{CPU}$发送一批数据的传送指令，当这一批数据传送完成之后才会产生一次中断，需要$\text{DMA}$总线的支持.

    - $\text{DMA}$传送方式，当$\text{CPU}$和$\text{IO}$同时访问主存时

        - 停止$\text{CPU}$访问，$\text{CPU}$停止访问主存，当$\text{IO}$设备访问完成之后$\text{CPU}$再继续访问.
        - 周期挪用，$\text{CPU}$在使用的存取周期中，偶尔给出一个存取周期给$\text{IO}$使用，$\text{CPU}$的使用时间仍然是较长的.
        - 交替访问，将存取周期分成两个时间片，一个给$\text{CPU}$访问，一个给主存访问.

- $\text{DMA}$方式和中断方式的区别

    - 中断方式需要中断现行程序，而$\text{DMA}$方式不需要.

    - 中断方式只在程序的执行周期结束之后才会响应，$\text{DMA}$方式能在任意的机器周期后响应.

    - $\text{DMA}$控制方式中，传送数据过程中不需要$\text{CPU}$干预，而中断方式中需要干预（传送一批的数据）.
