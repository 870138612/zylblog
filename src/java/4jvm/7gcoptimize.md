---
title: GC 调优
icon: page
category:
  - Java
tag:
  - GC 调优
  - 八股
  - JVM
---

### 确定目标

需要低延时使用：

- CMS
- G1
- ZGC

需要吞吐量使用：

- Parallel GC

<!-- more -->

### 最快的 GC 是不发生 GC

- 查看 Full GC 前后的内存占用，考虑以下几个问题：

  - 数据是不是太多
    - resultSet = statement.executeQuery("select *from 大表 limit n")；
    - 查询应该避免使用*查询过多的数据。
  - 数据表示是否太臃肿
    - 数据库查询需要什么字段就返回对应字段，不应该查询所有返回再筛选。
    - Java 对象最小是 16 字节，如果使用包装类（例如Integer对象头就已经占用16字节），则占用的内存比基本数据类型大很多，所以能使用基本数据类型的情况下不要使用包装类型。

  - 是否存在内存泄露
    - 例如使用一个`static Map map`不断的放入对象，就会导致内存泄漏。`ThreadLocal`中就存在内存泄漏。
    - 不建议使用 Java 中的数据结构作为缓存实现。

## 新生代GC调优

- 新生代的特点：

  - 所有的 new 操作的内存分配非常廉价；
    - TLAB 线程本地分配缓存，new 对象手下会在 TLAB 中分配，由于是线程私有的，所以同时也解决了并发问题；

  - 死亡对象的回收代价是零；
  - 大部分对象用过即死；
  - Minor GC 的时间远低于 Full GC。

  总空间不变的情况下，新生代越大，老年代越小，引发的 Full GC 的概率就更大，推荐新生代大小占整个堆的百分之 25 到百分之 50。新生代的空间越大也会导致每次 Minor GC 的时间变长。

### 幸存区

- 幸存区大到能保留【当前活跃对象+需要晋升的对象】。
- 调节晋升阈值，让长时间存活的对象尽快晋升。

```java
-XX:MaxTenuringThreshold=threshold
-XX:PrintTenuringDistribution
```

### 老年代调优

以 CMS 为例：

- CMS 的老年代内存越大越好；
- 观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3。

```java
-XX:CMSInitiatingOccupancyFraction=percent
```

## 案例

### 案例1

Full GC 和 Minor GC 频繁。

- 尝试增大新生代，Minor GC 次数就会减少，增加晋升阈值，让新生代的对象晋升时间更长，进一步让老年代 Full GC 不再频繁。

### 案例2

请求高峰期发生 Full GC，单次暂停时间特别长（CMS）。

- 业务需求低延时所以选择了 CMS。
- 查看 CMS 四个阶段中哪个阶段花的时间太长。
  - 重新标记阶段会花费很长的时间，重新标记会扫描所有新生代对象，而在请求高峰期会产生很多新生代对象。
- 可以在重新标记前进行一次垃圾回收，存活对象少了，重新标记花的时间就少了。

```
-XX:+CMSScavengeBeforeRemark
```

参数表示在重新标记之前先对新生代进行垃圾清理。

### 案例3

老年代充裕的情况下，发生 Full GC（1.7）。

1.7 采用永久代，之后变成元空间使用操作系统的空间。

则这种情况属于永久代内存不足导致 Full GC。







