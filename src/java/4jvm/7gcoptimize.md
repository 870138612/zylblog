---
title: GC调优
icon: page
category:
  - Java
tag:
  - GC调优
  - 八股
---

### 确定目标

需要低延时使用：

- CMS
- G1
- ZGC

需要吞吐量使用：

- ParallelGC

<!-- more -->

### 最快的GC是不发生GC

- 查看FullGC前后的内存占用，考虑以下几个问题：

  - 数据是不是太多
    - resultSet = statement.executeQuery("select *from 大表 limit n")；
    - 查询应该避免使用*查询过多的数据。
  - 数据表示是否太臃肿
    - 数据库查询需要什么字段就返回对应字段，不应该查询所有返回再筛选。
    - Java对象最小是16字节，如果使用包装类（例如Integer对象头就已经占用16字节），则占用的内存比基本数据类型大很多，所以能使用基本数据类型的情况下不要使用包装类型。

  - 是否存在内存泄露
    - 例如使用一个`static Map map`不断的放入对象，就会导致内存泄漏。`ThreadLocal`中就存在内存泄漏。
    - 不建议使用Java中的数据结构作为缓存实现。

## 新生代GC调优

- 新生代的特点：

  - 所有的new操作的内存分配非常廉价；
    - TLAB 线程本地分配缓存，new对象手下会在TLAB中分配，由于是线程私有的，所以同时也解决了并发问题；

  - 死亡对象的回收代价是零;`标记复制算法`
  - 大部分对象用过即死；
  - Minor GC的时间远低于Full GC。

  总空间不变的情况下，新生代越大，老年代越小，引发的Full GC的概率就更大，推荐新生代大小占整个堆的百分之25到百分之50。新生代的空间越大也会导致每次MinorGC的时间变长。

### 幸存区

- 幸存区大到能保留【当前活跃对象+需要晋升的对象】。
- 调节晋升阈值，让长时间存活的对象尽快晋升

```java
-XX:MaxTenuringThreshold=threshold
-XX:PrintTenuringDistribution
```

### 老年代调优

以CMS为例：

- CMS的老年代内存越大越好；
- 观察发生Full GC时老年代内存占用，将老年代内存预设调大1/4~1/3

```java
-XX:CMSInitiatingOccupancyFraction=percent
```

## 案例

### 案例1

FullGC和MinorGC频繁。

- 尝试增大新生代，MinorGC次数就会减少，增加晋升阈值，让新生代的对象晋升时间更长，进一步让老年代FullGC不再频繁。

### 案例2

请求高峰期发生FullGC，单次暂停时间特别长（CMS）。

- 业务需求低延时所以选择了CMS。
- 查看CMS四个阶段中哪个阶段花的时间太长。
  - 重新标记阶段会花费很长的时间，重新标记会扫描所有新生代对象，而在请求高峰期会产生很多新生代对象。
- 可以在重新标记前进行一次垃圾回收，存活对象少了，重新标记花的时间就少了。

```
-XX:+CMSScavengeBeforeRemark
```

参数表示在重新标记之前先对新生代进行垃圾清理。

### 案例3

老年代充裕的情况下，发生FullGC（1.7）。

1.7采用永久代，之后变成元空间使用操作系统的空间。

则这种情况属于永久代内存不足导致FullGC。







