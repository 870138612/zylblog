---
title: JVM垃圾回收
icon: page
category:
  - Java
tags:
  - JVM垃圾回收
  - 八股
---

![130](/markdown/130.jpg)

<!-- more -->

## 内存分配和回收原则

### 对象优先在Eden中分配

大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

### 大对象直接进入老年代

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

### 长期存活的对象将进入老年代

虚拟机给每个对象一个对象年龄（Age）计数器。

大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 **1**)。

对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。

对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

::: info 额外的

Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 `-XX:TargetSurvivorRatio=percent` 来设置），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。

:::

### GC区域

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

**部分收集 (Partial GC)**：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

**整堆收集 (Full GC)**：收集整个 Java 堆和方法区。

### 空间分配担保

在发生 Minor GC 之前，虚拟机必须先检查老年代**最大可用的连续空间是否大于新生代所有对象总空间**，如果这个条件成立，那这一次 Minor GC 可以确保是安全的，如果不成立，则虚拟机会先查看 `-XX:HandlePromotionFailure` 参数的设置值是否允许担保失败(Handle Promotion Failure)；如果允许，那会继续检查**老年代最大可用的连续空间**是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 `-XX: HandlePromotionFailure` 设置不允许冒险，那这时就要改为进行一次 Full GC。

> 可能存在所有的新生代对象都在这次GC之后晋升至老年代，老年代如果没有足够的内存则无法担保分配

## 死亡对象的判断方法

### 引用计数法

给对象添加一个计数器：

- 有地方引用的时候就将计数器+1；
- 引用失效，将计数器-1；
- 计数器为0的对象就是不会再被使用的对象。

简单高效，但是对象之间存在循环引用，导致他们的计数值都不为0，无法通知GC回收器回收它们。

### 可达性分析

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

#### 可以作为**GC Roots**的对象

- 虚拟机栈中的对象；
- 本地方法栈中的对象；
- 方法区中静态属性引用的变量；
- 方法区中常量引用的对象；
- 所有被同步锁持有的对象。

#### 对象可以被回收，就代表一定会被回收吗？

即使被标记为不可达的对象，也并不会立即被回收，而是处于”缓刑“阶段，经过真正的宣告对象死亡，至少要经过两次标记过程；

可达性分析中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行`finalize`方法。

> 对象没有覆盖`finalize`方法，或者`finalize`方法已经被虚拟机调用过，虚拟机把这两种情况视为没有必要执行。

被判断需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象的引用链上的任何一个对象建立关联，否则就会被回收。

### 引用类型总结

- 强引用：必不可少的，垃圾回收器绝对不会回收的对象。

- 软引用：可有可无的，内存足够不会回收，如果内存不太够则可能会回收。
- 弱引用：可有可无的，与软引用的区别在于：具有弱引用的对象具有更短的声明周期，垃圾回收器一旦发现，不管内存空间是否紧张都会回收这个对象。
- 虚引用：形同虚设，虚引用不会决定对象的声明周期，如果一个对象仅持有虚引用，则和没有任何引用一样，任何时候都有可能被回收。

**虚引用主要用来跟踪对象被垃圾回收的活动**。

**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

### 如何判断一个常量是废弃常量？

**JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区**, 此时 hotspot 虚拟机对方法区的实现为永久代。

**JDK1.7 字符串常量池被从方法区拿到了堆中**, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。

JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候**字符串常量池还在堆**, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)。

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

### 如何判断一个类是无用的类？

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。

类需要同时满足下面 3 个条件才能算是 **“无用的类”**：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

## 垃圾收集算法

### 标记-清除算法

标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

1. **效率问题**：标记和清除两个过程效率都不高。
2. **空间问题**：标记清除后会产生大量不连续的内存碎片。

### 复制算法

为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

对应到新生代就是`survivor`中的`from`区和`to`区。

**1.可用内存变小**：可用内存缩小为原来的一半，一半作为`from`区，一半作为`to`。

**2.不适合老年代**：如果存活对象数量比较大，复制性能会变得很差。

### 分代收集算法/HotSpot为什么要分代

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点选择合适的垃圾收集算法。

在新生代中，每次收集都有大量对象死去，所以可以采用“标记-复制算法”，只需要付出少量对象的复制成本就能完成垃圾收集，而老年代中对象存活的久，并且没有额外的空间对它进行分配担保，所以选择“标记-清除”或“标记-整理”算法进行垃圾收集。

## 垃圾回收器

### Serial 收集器

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。只会使用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。简单高效。

![image-20230520203719818](/markdown/image-20230520203719818.png)

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

### ParNew 收集器

ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。

![image-20230520203818307](/markdown/image-20230520203818307.png)

**新生代采用标记-复制算法，老年代采用标记-整理算法**。

除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。

并发：一个时间段内同时执行，操作系统基本特征。

并行：一个时刻同时执行。

### Parallel Scavenge 收集器

采用标记-复制算法的多线程收集器，**重点关注吞吐量（高效利用CPU）**，CMS垃圾收集器关注的是**停顿时间**。

![image-20230520203801684](/markdown/image-20230520203801684.png)

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

JDK1.8的默认收集器。

### Serial Old收集器

**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

![image-20230520203855193](/markdown/image-20230520203855193.png)

### Parallel Old 收集器

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在**注重吞吐量**以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

![image-20230520204013889](/markdown/image-20230520204013889.png)

### CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取**最短回收停顿时间**为目标的收集器。它非常符合在注重用户体验的应用上使用。

![image-20230520204024801](/markdown/image-20230520204024801.png)

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

CMS 收集器是一种“**标记-清除**”算法实现的，运行步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；

- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短

- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

优点：

**并发收集、低停顿**。

缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**（在并发标记阶段用户新产生的垃圾，在重新标记阶段不会标记浮动的新垃圾）
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

### G1 收集器

G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. **以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征**.

G1也是遵循分代收集理论设计的，它不再坚持以固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域，每一个**Region**都可以根据需要扮演Eden空间、Survivor空间或者老年代空间。收集器根据不同的角色采用不同的策略处理这些Region。Region中还有一类特殊的Humongous区域，专门用来存储大对象。这些Humongous被当作老年代处理。有以下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清除”算法不同，**G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。（一个Region复制到另外一个Region）**
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。

**G1 收集器的运作大致分为以下几个步骤：**

- **初始标记**：标记一下GC Roots能直接关联到的对象，再修改TAMS指针。借用Minor GC的时候同步完成。
- **并发标记**：遍历对象图，找出需要回收的对象，与用户线程并发执行。处理原始快照在并发时变动的对象。
- **最终标记**：处理并发阶段结束后仍遗留下来的少量SATB记录。
- **筛选回收**：更新Region的统计数据，对各个Region的回收价值和成本进行排序，然后根据用户的期望停顿时间制定回收计划，最后把需要回收的Region里的存活对象复制到新region中，再清空旧region。需要STW，多条收集线程并发执行。

![image-20230520204132639](/markdown/image-20230520204132639.png)

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

**G1存在着很多问题：**

1. 还是跨代引用的问题，这么多Region，在判断对象是否可达的时候，就需要每个Region都维护一个Remember Set，内存占用是非常高的。
2. 浮动垃圾。为每个Region设置两个TAMS指针，新对象都分配在这个两个指针之间，默认认为这些新对象不是垃圾。如果回收速度赶不上分配速度，也会导致冻结用户线程，进行FullGC。

## CMS和G1的异同

首先CMS是老年代的收集器，一般配合ParNew使用，但是这个组合在G1出现后已经被废弃了。G1 面向整堆进行收集。

CMS采用标记清除算法，因此会产生内存碎片，导致Concurrent mode failure进而Full GC。

**G1宏观上采用标记清除，但是微观上是在各个region之间标记复制，所以降低了内存碎片的产生数量。**

再就是二者的回收过程不同，CMS大致可以分为初始标记、并发标记、重新标记和并发清理；G1 大致可以分为初始标记、并发标记、重新标记和清除。这二者在针对并发标记过程中用户线程对可达性分析的影响的处理方式不同，**一个是增量更新（CMS），一个是原始快照（G1）。**

CMS和G1都是响应时间优先的收集器，但是CMS是追求最小的停顿时间为目标，而G1通过衰减均值来建立可预测的停顿模型，也就是分析每个Region的回收收益，根据均值、标准差、置信度等指标来决定到底要收集哪些region，并且收集这些region所需的停顿时间要大概率不超过期望的停顿时间。

## 到底多大的对象会被直接扔到老年代

用-XX: PretunureSizeThreshold指定对象大小的阈值，超过这个数就直接放入老年代，减少内存复制开销。但是这个参数只支持Serial和ParNew。像G1的话，只要对象大小超过Region的一半，那就会直接放到Humongous里，这个Humongous也被认为是老年代。

## CMS和G1的STW的区别

首先，根节点枚举都是需要STW的，CMS和G1在根节点枚举上的区别就在于处理跨代引用上，跨代引用一般是使用记忆集解决，G1的记忆集和CMS的不一样，因为G1的分区是按Region分的，因此G1的记忆集是一个哈希表，Key是别的Region的起始地址，value是一个集合，里面存储的是卡表的索引号。这个哈希表表示我指向谁，谁又指向我的，是一种双向卡表。而CMS的卡表比较简单，只标识着某个内存区域是否为脏。

然后CMS在可达性分析的时候有两个步骤需要STW，一个是初始标记，一个是重新标记；G1 有三个步骤需要STW，一个是初始标记，一个是最终标记，还有一个是筛选回收。初始标记很好理解，就是将GC roots直接引用的对象标记一遍，速度很快；关键点在于这二者都存在一个并发标记的步骤，此时与用户线程并发执行，难免用户线程会修改对象图的引用关系。这两个收集器的处理策略是不同的，CMS采用的是增量更新，G1 则采用的是原始快照。

增量更新就是将那些新加入引用的位置记录，在重新标记阶段进行处理。原始快照就是将那些被删除的引用记录保存下来，也就是保存个快照，在并发标记的最后以及最终标记中进行处理。
