---
title: 并发编程一
icon: page
category:
  - Java
tag:
  - 并发编程
  - 八股
---

## 进程和线程

### 进程

进程是程序的一次执行过程，启动 main 函数就相当于启动了一个 JVM 进程，而 main 函数所在的线程称为主线程。

### 线程

引入线程之后，调度的最小单位从进程变成了线程，一个进程能在运行的时候产生多个线程，每一个线程共享进程的**堆**和**方法区**（线程共有），每一个线程有自己的程序计数器，虚拟机栈，本地方法栈，所以线程之间的切换开销远远小于进程，线程又称为轻量级进程。
<!-- more -->
## 从 JVM 角度说进程和线程之间的关系

一个进程能有很多个线程，多个线程共享本进程的堆和方法区（1.8 之后的元空间），每一个线程拥有自己的虚拟机栈，本地方法栈，程序计数器。

![image-20230517134427874](/markdown/image-20230616180622721.png)

☀️详见 [**五分钟记住JVM内存结构**](https://www.bilibili.com/video/BV1Q64y1h7PT/?spm_id_from=333.337.search-card.all.click&vd_source=90bb400ad92a9344bb4c2ca0d7921be7)

###  程序计数器为什么是线程私有？

程序计数器存放的是下一条将要执行指令的地址。

在多线程下，程序计数器用来记录当前线程执行的位置，当线程切换回来的时候能够知道上次运行到哪里了。

所以程序计数器的作用就是线程切换之后能恢复到正确的位置。

### 虚拟机栈和本地方法栈为什么是私有的？

虚拟机栈用于存放栈帧，而每一个栈帧就对应着一个 Java 方法，用于存放局部变量表，操作数栈，常量池等信息。从方法调用到执行完成的过程，就对应着栈帧的入栈和出栈。

本地方法栈用于存放 `Native` 方法，这种方法一般是 C 或者 C++ 实现的。本地方法栈和虚拟机栈发挥的作用类似。

### 堆和方法区

堆和方法区都是线程共享的资源，堆是进程内存中最大的一块区域，用于存放新创建的对象，方法区用来存放已经被加载的类信息、常量、静态变量、即时编译器编译之后的代码。

## 线程的生命周期和状态

- **NEW**：初始状态，线程已经创建但是没有调用 `start()`;
- **RUNNABLE**：运行状态，线程调用了 `start()` 等待运行；
- **BLOCKED**：阻塞状态，需要等待锁释放；
- **WAITING**：等待状态，需要等待其他线程作出动作（通知或中断）；
- **TIME_WAITING**：超时等待状态，可以在等待一段时间之后自行返回，而不是像 WAITING 一样一直等待。
- **TERMINATED**：终止状态，表示线程运行完毕。

![image-20230517140544893](/markdown/image-20230517140544893.png)


## 什么是死锁？如何避免

### 死锁

两个或者以上的线程因为竞争资源导致阻塞，若无外力作用都无法向前推进。

死锁的四个必要条件：

- 互斥
- 不剥夺
- 请求并保持
- 环路等待

### 如何预防死锁？

预防死锁就是破坏四个必要条件中的任意一个。

1. **破坏不剥夺条件**：占用部分资源的线程在进一步申请资源失败时，主动放出已经保持的资源。
2. **破坏请求并保持**：一次性分配所需要的所有资源。
3. **破坏环路等待**：资源有序分配。

### 如何避免死锁？

银行家算法，防止当前系统进入不安全状态。

## sleep() 方法和 wait() 方法对比

两个方法都能暂停线程的执行。

区别：

- `sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁；
- `wait()` 通常用于线程之间的通信，`sleep()` 用于线程的暂停执行；
- `wait()` 方法被调用之后，线程不会自动苏醒，需要别的线程调用同一个对象的 `notify()` 或者 `notifyAll()` 方法。`sleep()` 方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `sleep` 方法是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法

### 为什么 wait() 方法不定义在 Thread 中？

`wait()` 是让获得对象锁的线程等待，会释放对象锁，每一个 `Object` 都有对象锁，要释放当前线程占有的对象锁并让其进入 WAITING 状态，当然是使用对象的操作而不是线程的操作。

因为 `sleep()` 方法是让当前线程暂停执行，不涉及对象，所以定义在 `Thread` 类中。

### 直接调用 run() 和 start() 的区别

`new` 一个 `Thread`，并调用 `start()` 方法会创建一个新的线程并让其进入就绪状态。`start()` 的方法会执行线程的准备工作，然后自动调用 `run()` 方法，这样才能实现多线程。

如果直接调用 `run()` 方法，则是通过调用线程来运行的，会把 `run()` 方法当成普通方法执行。

**调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**
