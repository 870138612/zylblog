---
title: I/O
icon: io
category:
  - 计算机基础
tags:
  - IO
  - 八股
---
### 何为IO？

I/O（**I**nput/**O**utpu） 即**输入／输出** 。

从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。

当应用程序发起 I/O 调用后，会经历两个步骤：

1. 内核等待 I/O 设备准备好数据
2. 内核将数据从内核空间拷贝到用户空间。

<!-- more -->

### 有哪些常见的 IO 模型?

UNIX 系统下， IO 模型一共有 5 种：**同步阻塞 I/O**、**同步非阻塞 I/O**、**I/O 多路复用**、**信号驱动 I/O** 和**异步 I/O**。

## Java 中 3 种常见 IO 模型

### BIO (Blocking I/O)

**BIO 属于同步阻塞 IO 模型** 。

同步阻塞IO模型中，应用程序发起read调用后，会一直阻塞，知道内核把数据拷贝到用户空间。

在客户端连接数量不高的情况下是没有问题的，但是当并发数量增大的时候，传统的BIO模型是无能为力的，会导致多线程阻塞，响应不了其他请求。

### NIO (Non-blocking/New I/O)

Java中的NIO于Java 1.4中引入，对应`Java.nio`包，提供了`Channel`,`Selector`,`Buffer`等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。支持面向缓冲，基于通道的I/O操作方法。对于高负载、高并发的应用，应使用NIO。

**Java中的NIO可以看做是I/O多路复用模型。**

>  同步非阻塞IO模型中，应用程序会一直发起read调用，等待数据从内核空间拷贝到用户空间的这段时间，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。（**程序查询法**）相比于同步阻塞IO模型，同步非阻塞IO模型确实有很大的改进，通过轮训操作避免了一直阻塞。

但是这种IO模型仍然存在问题：应用程序不断进行I/O系统调用论文数据是否已经准备好的过程是很消耗CPU资源的。

IO多路复用模型中，线程首先发起select调用，查询内核数据是否准备就绪，等内核把数据准备好了，用户再发起read调用。read调用的过程（数据从内核空间->用户空间）还是阻塞的。**（程序中断法）**

**IO多路复用模型，通过减少无效的系统调用，减少了对CPU资源的消耗。**

Java中的NIO有一个非常重要的**选择器（Selector）**概念，称为**多路复用器**。通过它只需要一个线程便可以管理多个客户端连接，当客户端数据到了之后才会为其服务。![03600](https://blog-1312634242.cos.ap-shanghai.myqcloud.com/markdown/03600.jpg)

### AIO (Asynchronous I/O)

AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。
