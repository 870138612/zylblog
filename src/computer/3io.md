---
title: I/O
icon: io
category:
  - 计算机基础
tag:
  - IO
  - 八股
---

### 何为IO？

I/O（**I**nput/**O**utpu）即**输入／输出** 。

从应用程序的视角来看的话，应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。

当应用程序发起 I/O 调用后，会经历两个步骤：

1. 内核等待 I/O 设备准备好数据
2. 内核将数据从内核空间拷贝到用户空间。

<!-- more -->

### 有哪些常见的 IO 模型?

UNIX 系统下， IO 模型一共有 5 种：**同步阻塞 I/O**、**同步非阻塞 I/O**、**I/O 多路复用**、**信号驱动 I/O**和**异步 I/O**。

### 同步阻塞 IO，BIO（Blocking I/O）

同步阻塞 IO 模型中，应用程序发起 `read` 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。

在客户端连接数量不高的情况下是没有问题的，但是当并发数量增大的时候，传统的 BIO 模型是无能为力的，会导致多线程阻塞，响应不了其他请求。

### 同步非阻塞 IO，NIO（Non-blocking/New I/O）

同步非阻塞 IO 在应用程序进行 `read` 调用之后会立即返回，并在后续的过程中轮询判断数据是否准备好。

Java 中的 NIO 于 Java 1.4 中引入，对应 `Java.nio` 包，提供了 `Channel`,`Selector`,`Buffer` 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。支持面向缓冲，基于通道的I/O 操作方法。对于高负载、高并发的应用，应使用 NIO。

> 在同步非阻塞 IO 模型中，应用程序会一直发起 `read` 调用，等待数据从内核空间拷贝到用户空间的这段时间，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。
> 相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有很大的改进，通过轮训操作避免了一直阻塞。但是这种 IO 模型仍然存在问题：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是很消耗 CPU 资源的。

### IO 多路复用，IO Multiplexing

IO 多路复用是建立在内核提供的多路分离函数 `select` 基础上的，可以避免同步非阻塞 IO 中的轮询等待问题。

IO 多路复用模型中，线程首先发起 `select` 调用，查询内核数据是否准备就绪，等内核把数据准备好则会发出通知用户，线程再发起 `read` 调用。`read` 调用的过程（数据从内核空间 -> 用户空间）还是阻塞的。

![IO多路复用](/markdown/image-ioduolu.png)

#### 多路复用包括
**select**
- **过程**
  - 将当前进程的所有文件描述符一次性拷贝到内核态。
  - 内核态无差别线性扫描文件是否有数据到达，将所有文件描述符 fd 拷贝到用户态，并返回已经就绪的文件描述符 fd 数量。
  - 用户态判断哪些 fd 就绪并执行事件处理。
- **缺点**
  - 文件描述符为 `bitmap` 结构，长度为 1024 限制。
  - fdset 不能做到重用，每次循环需要重新创建。
  - 频繁切换用户态和核心态，性能开销大。
  - 线性扫描，性能差，事件复杂度为 O(n)。

**poll**
- **过程**
  - 将当前进程的所有文件描述符一次性拷贝到内核态。
  - 在内核态中无差别遍历每个 fd，判断是否有数据到达。
  - 将所有 fd 状态从内核态拷贝到用户态，并返回已经就绪的 fd 个数。
  - 用户态判断哪些 fd 就绪并执行事件处理。
- **缺点**
  - poll 采用了 pollfd 结构数组解决了 select 下的文件描述符个数限制。但是仍然存在频繁的内核态和用户态拷贝。
  - 线性扫描，性能差，事件复杂度为 O(n)。

**epoll**
- 在 `epoll_ctl()` 函数中，为每个文件描述符都指定了回调函数，基于回调函数把就绪事件放入到就绪队列中，因此把时间复杂度从 O(n) 降到了 O(1)。
- 只需要在 `epoll_ctl()` 时传递一次文件描述符，`epoll_wait()` 不需要再次传递文件描述符。
- epoll 基于红黑树 + 双向链表存储事件，没有最大连接数限制。
- epoll 没有使用零拷贝技术。

### 信号驱动 IO，Signal-Driven I/O

为一个目标文件描述符指定宿主进程，当文件描述符上有事件发生时，SIGIO 的信号处理函数将被触发，然后便可对目标文件描述符执行 I/O 操作。

![SIGIO](/markdown/image-sigio.png)

### 异步 IO，AIO (Asynchronous I/O)

AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2，它是**异步 IO 模型**。

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞，当后台处理完成读写，操作系统会通知相应的线程进行后续的操作，读写操作由内核管理。

![AIO](/markdown/image-aio.png)
