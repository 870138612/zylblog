---
title: 数据库基础
icon: page

category:
  - 数据库
tags:
  - MySQL
  - 八股
---

## 数据库的三大范式

### 1NF

**属性（对应于表中的字段）不能再被分割**，也就是这个字段只能是一个值，不能再分为多个其他的字段了，**1NF是所有关系型数据库的最基本要求**，也就是说关系型数据库中创建的表一定满足第一范式。

<!-- more -->

### 2NF

2NF在1NF的基础上，**消除了非主属性对于码的部分函数依赖**。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，**非主属性都依赖于主键**。

![image-20230525141922244](/markdown/image-20230525141922244.png)

一些概念：

- 函数依赖：若在一张表中，在属性X（或属性组）的值确定的情况下，必定能确定属性Y的值，那么可以说Y函数依赖于X，写作X->Y。
- 部分函数依赖：如果X->Y，并且存在X的一个真子集X0，是的X0->Y，则Y对X部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）**当然学号属性取值是唯一的**，在 R 关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号），因为确定了学号或者是身份证就能确定姓名。
- 完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）**假设不同的班级学号有相同的**，班级内学号不能相同，在 R 关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；
- 传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖于 X。传递函数依赖会导致数据冗余和异常。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性**系主任**对于**学号**的传递函数依赖。

### 3NF

3NF在2NF的基础上，**消除了非主属性对于码的传递函数依赖**。符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。

## drop、delete 与 truncate 区别？

- `drop`(丢弃数据): `drop table 表名` ，直接将表都删除掉，在删除表的时候使用。
- `truncate` (清空数据) : `truncate table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
- `delete`（删除数据） : `delete from 表名 where 列名=值`，删除某一行的数据，如果不加 `where` 子句和`truncate table 表名`作用类似。

## DML 语句和 DDL 语句区别

- DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。

- DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。


