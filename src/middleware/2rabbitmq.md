---
title: RabbitMQ
icon: mq
star: true
category:
  - 中间件云原生
tags:
  - 消息队列
  - RabbitMQ
  - Kafka
  - 八股
---


消息队列是一种用于在应用程序之间传递消息的通信方式，消息队列允许应用程序异步的发送和接收消息，并且不需要直接连接到对方。

可以把消息队列看作是一个存放消息的容器，需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。

## 消息队列有什么用？

### 通过异步处理提高系统性能（减少响应所需时间）

项目中订单取消之后的解锁库存操作可以通过消息队列实现，订单取消之后发送一个库存释放任务到消息队列中，由库存模块释放监听器完成库存解锁和释放，订单模块不需要等待库存释放完成才返回。

### 削峰/限流

秒杀场景中，开始秒杀时创建秒杀订单具有很大的峰值，通过消息队列减少同时创建订单的任务数，创建订单任务先放入消息队列中，再由数据库创建订单。

### 降低系统耦合性

订单模块负责订单取消，库存模块负责库存解锁释放，两者通过消息队列实现通信，降低耦合度。如果有新的消费者上线，只需要将消费者关联到这个消息队列中，原有系统不会改变。

### 实现分布式事务

分布式事务的解决办法之一就是MQ事务。

☀️详见[分布式事务](https://ylzhong.top/middleware/4distributedtransaction.html)

## 使用消息队列会带来哪些问题？

- **系统可用性降低**：需要额外考虑消息队列服务出错的处理办法。
- **系统复杂度提高**：加入消息队列之后，需要考虑消息重复消费，消息丢失，保证消息传递顺序等问题。
- **一致性问题**：如果消息没有被正确的消费，就会带来一致性问题。

## AMQP是什么？

AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 **高级消息队列协议**（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS（JAVA Message Service，java 消息服务）。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。AMQP 天然具有跨平台、跨语言特性。

## RPC和消息队列的区别

RPC和消息队列都是分布式系统中重要的组件之一。

- **从用途来看**：RPC主要解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。消息队列主要用来降低系统耦合性、实现任务异步、有效地进行流量削峰。
- **从通信方式来看**：RPC 是双向直接网络通讯，消息队列是单向引入中间载体的网络通讯。

- **从架构上来看**：消息队列需要把消息存储起来，RPC 则没有这个要求，因为前面也说了 RPC 是双向直接网络通讯。
- **从请求处理的时效性来看**：通过 RPC 发出的调用一般会立即被处理，存放在消息队列中的消息并不一定会立即被处理。

## 常见的消息队列

### Kafka

> 项目中使用的消息队列是RabbitMQ，Kafka仅仅做介绍。

![image-20230616154303334](/markdown/image-20230616154303334.png)

Kafka 是 LinkedIn 开源的一个分布式流式处理平台，已经成为 Apache 顶级项目，早期被用来用于处理海量的日志，后面才慢慢发展成了一款功能全面的高性能消息队列。

具有三个关键功能：

- **消息队列**：发布和订阅消息流，功能类似消息队列。
- **容错的持久方式存储记录消息流**：Kafka会把消息持久化到磁盘，有效避免了消息丢失的风险。
- **流式处理平台**：在消息发布的时候进行处理，Kafka提供了一个完整的流式处理类库。

### RabbitMQ

![image-20230616154739983](/markdown/image-20230616154739983.png)

RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。

- **可靠性：** RabbitMQ 使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。
- **灵活的路由：** 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。
- **扩展性：** 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。
- **高可用性：** 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。
- **支持多种协议：** RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。
- **多语言客户端：** RabbitMQ 几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。
- **易用的管理界面：** RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。
- **插件机制：** RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI 机制。

### RabbitMQ和Kafka区别

- RabbitMQ 在吞吐量方面虽然稍逊于 Kafka，但是由于它基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 Erlang 开发，所以国内很少有公司有实力做 Erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这几种消息队列中，RabbitMQ 或许是你的首选。

- Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 Kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。Kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。

# RabbitMQ

## 介绍下RabbitMQ

RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。

RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。

## RabbitMQ特点

- **可靠性**：RabbitMQ使用一些机制保证可靠性，例如持久化、传输确认以及发布确认。
- **灵活的路由**：在消息进入队列之前，通过交换机来路由消息。
- **扩展性**：多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。
- **高可用性** : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。
- **多种协议**: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。
- **跨语言**：RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。
- **管理界面** : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。
- **插件机制** : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。

## RabbitMQ组成

RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。

![image-20230616162759698](/markdown/image-20230616162759698.png)

### Producer（生产者）和Consumer（消费者）

- **Producer(生产者)** :生产消息的一方;
- **Consumer(消费者)** :消费消息的一方。

消息一般由 2 部分组成：**消息头**和 **消息体**。消息体也可以称为 payLoad，消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。

### Exchange（交换机）

在RabbitMQ中，消息并不是直接投递到**Queue（消息队列）**中，中间还必须经过**Exchange（交换机）**，交换机会根据路由键和路由方式将消息发送给对应的**Queue（消息队列）**中。

**Exchange（交换器）**用来接收生产者发送的消息并将这些消息路由给服务器中的队列，如果路由不到则会返回给**Producer（生产者）**或者直接丢失。

**RabbitMQ的Exchange（交换机）有4种类型，不同的类型对应着不同的路由策略：direct（默认），fanout，topic和headers。**

生产者将消息发给交换机的时候需要指定一个**RoutingKey（路由键）**，用来指定这个消息的路由规则，而这个**RoutingKey**需要与交换机类型和绑定键**（BindingKey）**联合使用才能生效。

RabbitMQ 中通过 **Binding(绑定)** 将 **Exchange(交换器)** 与 **Queue(消息队列)** 关联起来，在绑定的时候一般会指定一个 **BindingKey(绑定建)** ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。

![image-20230616163557422](/markdown/image-20230616163557422.png)

**Bindkey**就像路由表中的一个表项，指明了响应的**RoutingKey**应该投递到哪个队列。

### Queue（消息队列）

Queue（消息队列）用来保存消息直到发送给消费者。是消息的容器也是终点，一个消息可以投入一个或者多个队列中。

**RabbitMQ** 中消息只能存储在 **队列** 中，这一点和 **Kafka** 相反。Kafka 将消息存储在 **topic（主题）** 这个逻辑层面，而相对应的队列逻辑只是 topic 实际存储文件中的位移标识。

> 事件被组织并持久地存储在Topic中，Topic类似于文件系统中的文件夹，事件就是该文件夹中的文件。Kafka中的Topic始终是多生产者和多订阅者：一个Topic可以有零个、一个或多个生产者向其写入事件，也可以有零个、一个或多个消费者订阅这些事件。Topic中的事件可以根据需要随时读取，与传统的消息中间件不同，事件在使用后不会被删除，相反，可以通过配置来定义Kafka中每个Topic应该保留事件的时间，超过该事件后旧事件将被丢弃。Kafka的性能在数据大小方面实际上是恒定的，因此长时间存储数据是非常好的。

多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样可以避免重复消费。

### Broker（消息中间件的服务节点）

对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者 RabbitMQ 服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。

下图展示了生产者将消息存入 RabbitMQ Broker，以及消费者从 Broker 中消费数据的整个流程。

>  由于RabbitMQ是以`byte[]`为单位进行传输的，因此消息需要序列化和反序列化。

![image-20230616165505506](/markdown/image-20230616165505506.png)

### Exchange Types（交换机类型）

#### 1、fanout（广播）

fanout 类型的 Exchange 路由规则非常简单，它会把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。

#### 2、direct（精确匹配）

direct 类型的 Exchange 路由规则也很简单，它会把消息路由到**那些** Bindingkey 与 RoutingKey 完全匹配的 Queue 中。

> 可能匹配的队列有多个。

#### 3、topic

topic 类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：

- RoutingKey 为一个点号`.`分隔的字符串（被点号`.`分隔开的每一段独立的字符串称为一个单词），如 `com.rabbitmq.client`、`java.util.concurrent`、`com.hidden.client`;

- BindingKey 和 RoutingKey 一样也是点号`.`分隔的字符串；

- BindingKey 中可以存在两种特殊字符串`*`和`#`，用于做模糊匹配，其中`*`用于匹配一个单词，`#`用于匹配零个或者多个单词。

例如BindKey为`#.com`，则所有以`com`结尾的路由键消息都会匹配，`*.*.com`，则路由键必须有三个单词，且最后一个单词是`com`才会匹配，例如`yl.zhong.com`。

![image-20230616171738195](/markdown/image-20230616171738195.png)

#### 4、headers(不推荐)

headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。

## 说说 Broker 服务节点、Queue 队列、Exchange 交换器？

**Broker**：可以看做 RabbitMQ 的服务节点。一般情况下一个 Broker 可以看做一个 RabbitMQ 服务器。

**Queue** :RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。

**Exchange** : 生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。
