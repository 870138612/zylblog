const ut="ENTRIES",W="KEYS",$="VALUES",p="";class O{constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=z(this._path);if(z(s)===p)return{done:!1,value:this.result()};const n=t.get(z(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=z(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>z(t)).filter(t=>t!==p).join("")}value(){return z(this._path).node.get(p)}result(){switch(this._type){case $:return this.value();case W:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const z=e=>e[e.length-1],it=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===p){const a=o[h-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let l=0;l<c.length;++l,++a){const m=c[l],f=i*a,g=f-i;let d=o[f];const F=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let _=F;_<y;++_){const I=m!==t[_],x=o[g+_]+ +I,A=o[g+_+1]+1,k=o[f+_]+1,T=o[f+_+1]=Math.min(x,A,k);T<d&&(d=T)}if(d>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{constructor(t=new Map,s=""){this._size=void 0,this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=v(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=S(n);for(const i of o.keys())if(i!==p&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,rt(this._tree,t)}entries(){return new O(this,ut)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return it(this._tree,t,s)}get(t){const s=M(this._tree,t);return s!==void 0?s.get(p):void 0}has(t){const s=M(this._tree,t);return s!==void 0&&s.has(p)}keys(){return new O(this,W)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,B(this._tree,t).set(p,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=B(this._tree,t);return n.set(p,s(n.get(p))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=B(this._tree,t);let o=n.get(p);return o===void 0&&n.set(p,o=s()),o}values(){return new O(this,$)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const v=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==p&&t.startsWith(n))return s.push([e,n]),v(e.get(n),t.slice(n.length),s);return s.push([e,t]),v(void 0,"",s)},M=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==p&&t.startsWith(s))return M(e.get(s),t.slice(s.length))},B=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==p&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},rt=(e,t)=>{const[s,n]=v(e,t);if(s!==void 0){if(s.delete(p),s.size===0)q(n);else if(s.size===1){const[o,u]=s.entries().next().value;P(n,o,u)}}},q=e=>{if(e.length===0)return;const[t,s]=S(e);if(t.delete(s),t.size===0)q(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==p&&P(e.slice(0,-1),n,o)}},P=(e,t,s)=>{if(e.length===0)return;const[n,o]=S(e);n.set(o+t,s),n.delete(o)},S=e=>e[e.length-1],ct=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,j="or",N="and",lt="and_not",ht=(e,t)=>{e.includes(t)||e.push(t)},G=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},J=({score:e},{score:t})=>t-e,at=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},U=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[j]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),G(n.terms,u)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);G(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[lt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},ft=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},gt=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},Ft={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(ct),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},H={combineWith:j,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:Ft},pt={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K};class At{constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...H,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const Ct=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},X=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},zt=(e,t,s,n)=>{if(!e._index.has(n)){X(e,s,t,n);return}const o=e._index.fetch(n,at),u=o.get(t);u==null||u.get(s)==null?X(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},Y=(e,t=j)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},L=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const a=u[c],l=e._fieldIds[c],m=o.get(l);if(m==null)continue;let f=m.size;const g=e._avgFieldLength[l];for(const d of m.keys()){if(!e._documentIds.has(d)){zt(e,l,d,s),f-=1;continue}const F=i?i(e._documentIds.get(d),s,e._storedFields.get(d)):1;if(!F)continue;const y=m.get(d),_=e._fieldLength.get(d)[l],I=ft(y,f,e._documentCount,_,g,r),x=n*a*F*I,A=h.get(d);if(A){A.score+=x,ht(A.terms,t);const k=U(A.match,s);k?k.push(c):A.match[s]=[c]}else h.set(d,{score:x,terms:[t],match:{[s]:[c]}})}}return h},Et=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((d,F)=>({...d,[F]:U(n.boost,F)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:a}={...H.weights,...i},l=e._index.get(t.term),m=L(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,F=d<1?Math.min(r,Math.round(t.term.length*d)):d;F&&(g=e._index.fuzzyGet(t.term,F))}if(f)for(const[d,F]of f){const y=d.length-t.term.length;if(!y)continue;g==null||g.delete(d);const _=a*d.length/(d.length+.3*y);L(e,t.term,d,_,F,o,u,h,m)}if(g)for(const d of g.keys()){const[F,y]=g.get(d);if(!y)continue;const _=c*d.length/(d.length+y);L(e,t.term,d,_,F,o,u,h,m)}return m},Q=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},l=t.queries.map(m=>Q(e,m,a));return Y(l,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(a=>h(a)).filter(a=>!!a).map(gt(i)).map(a=>Et(e,a,i));return Y(c,i.combineWith)},Z=(e,t,s={})=>{const n=Q(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(J),o},wt=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Z(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(J),o},xt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new At(a);l._documentCount=t,l._nextId=s,l._documentIds=b(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=b(u),l._avgFieldLength=i,l._storedFields=b(r),l._dirtCount=h||0,l._index=new C;for(const[m,f]of l._documentIds)l._idToShortId.set(f,m);for(const[m,f]of e){const g=new Map;for(const d of Object.keys(f)){let F=f[d];c===1&&(F=F.ds),g.set(parseInt(d,10),b(F))}l._index.set(m,g)}return l},tt=Object.entries,kt=Object.fromEntries,E=100,w=20,V=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let l="";i===0?l=c.length>w?`… ${c.slice(-w)}`:c:a?l=c.length+i>E?`${c.slice(0,E-i)}… `:c:l=c.length>w?`${c.slice(0,w)} … ${c.slice(-w)}`:c,l&&o.push(l),i+=l.length,a||(o.push(["mark",t]),i+=t.length,i>=E&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>E)break;h=s.indexOf(n,u)}return i<E&&r(e.slice(u),!0),o},et=/[\u4e00-\u9fa5]/g,st=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(et)||[],n=t.replace(et,"").toLowerCase();return n?[n,...s]:[...s]},...e}),nt=(e,t,s={})=>{const n={};return Z(t,e,st({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[a,l]=u.split(/[#@]/),{contents:m}=n[a]??={title:"",contents:[]};if(h)m.push([{type:"customField",key:a,index:l,display:i.map(f=>o.c.map(g=>V(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>V(o.h,g)).filter(g=>g!==null);if(f.length&&m.push([{type:c?"heading":"title",key:a,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const d=i.map(F=>V(g,F)).filter(F=>F!==null);d.length&&m.push([{type:"text",key:a,...c&&{anchor:l},display:d},r])}}}),tt(n).sort(([,o],[,u])=>u.contents.reduce((i,[,r])=>i+r,0)-o.contents.reduce((i,[,r])=>i+r,0)).map(([o,{title:u,contents:i}])=>{if(!u){const r=Ct(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},ot=(e,t,s={})=>wt(t,e,st(s)).map(({suggestion:n})=>n),D=kt(tt(JSON.parse("{\"/\":{\"documentCount\":521,\"nextId\":521,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-287418c4\",\"2\":\"v-287418c4#操作系统的功能\",\"3\":\"v-287418c4#什么是用户态和内核态\",\"4\":\"v-287418c4#进程和线程\",\"5\":\"v-287418c4#什么是进程和线程\",\"6\":\"v-287418c4#有了进程为什么还需要线程\",\"7\":\"v-287418c4#线程间的同步的方式有哪些\",\"8\":\"v-287418c4#pcb-是什么-包含哪些信息\",\"9\":\"v-287418c4#进程间的通信方式有哪些\",\"10\":\"v-287418c4#什么是僵尸进程和孤儿进程\",\"11\":\"v-287418c4#内存管理\",\"12\":\"v-287418c4#什么是内存碎片\",\"13\":\"v-287418c4#分段分页\",\"14\":\"v-287418c4#文件系统\",\"15\":\"v-287418c4#硬链接和软链接有什么区别\",\"16\":\"v-287418c4#常见的磁盘调度算法有哪些\",\"17\":\"v-0f6e5a7b\",\"18\":\"v-0f6e5a7b#何为io\",\"19\":\"v-0f6e5a7b#有哪些常见的-io-模型\",\"20\":\"v-0f6e5a7b#java-中-3-种常见-io-模型\",\"21\":\"v-0f6e5a7b#bio-blocking-i-o\",\"22\":\"v-0f6e5a7b#nio-non-blocking-new-i-o\",\"23\":\"v-0f6e5a7b#aio-asynchronous-i-o\",\"24\":\"v-0f6e5a7b#比较\",\"25\":\"v-a94a8cca\",\"26\":\"v-7d72c4ac\",\"27\":\"v-14b0a7d7\",\"28\":\"v-14b0a7d7#导航\",\"29\":\"v-2e25198a\",\"30\":\"v-14c69af4\",\"31\":\"v-4d194044\",\"32\":\"v-7ce4aeb6\",\"33\":\"v-7ce4aeb6#_2023-4平潭-世间浪漫海占一半\",\"34\":\"v-e2acc714\",\"35\":\"v-7acb0465\",\"36\":\"v-7acb0465#常见的网络协议\",\"37\":\"v-7acb0465#应用层\",\"38\":\"v-7acb0465#传输层\",\"39\":\"v-7acb0465#网络层\",\"40\":\"v-7acb0465#get和post的区别\",\"41\":\"v-7acb0465#put和post的区别\",\"42\":\"v-7acb0465#http\",\"43\":\"v-7acb0465#从输入-url-到页面展示到底发生了什么\",\"44\":\"v-7acb0465#http状态码\",\"45\":\"v-7acb0465#https与http的区别\",\"46\":\"v-7acb0465#http-1-0-和-http-1-1-区别\",\"47\":\"v-7acb0465#uri-和-url-的区别\",\"48\":\"v-7acb0465#dns\",\"49\":\"v-7acb0465#dns-的作用是什么\",\"50\":\"v-7acb0465#dns-服务器有哪些\",\"51\":\"v-0f0f7366\",\"52\":\"v-0f0f7366#tcp-与-udp\",\"53\":\"v-0f0f7366#tcp-与-udp-的区别\",\"54\":\"v-0f0f7366#什么时候选择-tcp-什么时候选-udp\",\"55\":\"v-0f0f7366#http-基于-tcp-还是-udp\",\"56\":\"v-0f0f7366#使用-tcp-的协议有哪些-使用-udp-的协议有哪些\",\"57\":\"v-0f0f7366#tcp-三次握手和四次挥手-传输层\",\"58\":\"v-0f0f7366#建立连接-tcp三次握手\",\"59\":\"v-0f0f7366#为什么要三次握手\",\"60\":\"v-0f0f7366#断开连接-tcp-四次挥手\",\"61\":\"v-0f0f7366#为什么不能把服务器发送的-ack-和-fin-合并起来-变成三次挥手\",\"62\":\"v-0f0f7366#为什么第四次挥手客户端需要等待-2-msl-报文段最长寿命-时间后才进入-closed-状态\",\"63\":\"v-0f0f7366#tcp-传输可靠性保障-传输层\",\"64\":\"v-0f0f7366#tcp-如何保证传输的可靠性\",\"65\":\"v-0f0f7366#tcp-如何实现流量控制\",\"66\":\"v-0f0f7366#tcp-的拥塞控制是怎么实现的\",\"67\":\"v-0f0f7366#arq协议\",\"68\":\"v-0f0f7366#停止等待协议\",\"69\":\"v-0f0f7366#后退n帧协议-gbn\",\"70\":\"v-0f0f7366#选择重传协议-sr\",\"71\":\"v-b9583b32\",\"72\":\"v-b9583b32#ip-网络层\",\"73\":\"v-b9583b32#ip协议的作用是什么\",\"74\":\"v-b9583b32#什么是ip地址-ip寻址如何工作\",\"75\":\"v-b9583b32#ipv4-和-ipv6-有什么区别\",\"76\":\"v-b9583b32#nat作用是什么\",\"77\":\"v-b9583b32#arp\",\"78\":\"v-b9583b32#什么是-mac-地址\",\"79\":\"v-b9583b32#arp-协议解决了什么问题\",\"80\":\"v-18d61928\",\"81\":\"v-6f176f1e\",\"82\":\"v-6f176f1e#数据库的三大范式\",\"83\":\"v-6f176f1e#_1nf\",\"84\":\"v-6f176f1e#_2nf\",\"85\":\"v-6f176f1e#_3nf\",\"86\":\"v-6f176f1e#drop、delete-与-truncate-区别\",\"87\":\"v-6f176f1e#dml-语句和-ddl-语句区别\",\"88\":\"v-5d9788e5\",\"89\":\"v-5d9788e5#什么是关系型数据库\",\"90\":\"v-5d9788e5#mysql有什么优点\",\"91\":\"v-5d9788e5#mysql基础架构\",\"92\":\"v-5d9788e5#mysql存储引擎\",\"93\":\"v-5d9788e5#myisam-和-innodb-有什么区别\",\"94\":\"v-5d9788e5#mysql查询缓存\",\"95\":\"v-5d9788e5#mysql-事务\",\"96\":\"v-5d9788e5#acid特性\",\"97\":\"v-5d9788e5#并发事务带来了哪些问题\",\"98\":\"v-5d9788e5#并发事务的控制方式有哪些\",\"99\":\"v-5d9788e5#mysql的隔离级别是基于锁实现的吗\",\"100\":\"v-5d9788e5#mysql的默认隔离级别是什么\",\"101\":\"v-5d9788e5#mysql-锁\",\"102\":\"v-5d9788e5#表级锁和行级锁了解吗-有什么区别\",\"103\":\"v-5d9788e5#innodb-有哪几类行锁\",\"104\":\"v-5d9788e5#共享锁和排他锁区别\",\"105\":\"v-5d9788e5#意向锁有什么作用\",\"106\":\"v-5d9788e5#快照读和当前读的区别\",\"107\":\"v-5d9788e5#mysql如何存储ip地址\",\"108\":\"v-5d9788e5#执行计划\",\"109\":\"v-5d9788e5#读写分离和分库分表\",\"110\":\"v-5d9788e5#读写分离\",\"111\":\"v-5d9788e5#读写分离会带来什么问题\",\"112\":\"v-5d9788e5#如何实现读写分离\",\"113\":\"v-5d9788e5#主从复制的原理是什么\",\"114\":\"v-5d9788e5#分库分表\",\"115\":\"v-5d9788e5#什么是分库\",\"116\":\"v-5d9788e5#什么是分表\",\"117\":\"v-5d9788e5#什么情况下需要分库分表\",\"118\":\"v-5d9788e5#常见的分片算法有哪些\",\"119\":\"v-5d9788e5#分库分表会带来什么问题呢\",\"120\":\"v-86a8eecc\",\"121\":\"v-86a8eecc#索引\",\"122\":\"v-86a8eecc#索引底层数据结构\",\"123\":\"v-86a8eecc#hash表\",\"124\":\"v-86a8eecc#二叉查找树-bst\",\"125\":\"v-86a8eecc#avl树\",\"126\":\"v-86a8eecc#红黑树\",\"127\":\"v-86a8eecc#b-树-b-树\",\"128\":\"v-86a8eecc#主键索引-primary-key\",\"129\":\"v-86a8eecc#二级索引\",\"130\":\"v-86a8eecc#聚簇索引与非聚簇索引\",\"131\":\"v-86a8eecc#聚簇索引-聚集索引\",\"132\":\"v-86a8eecc#非聚簇索引-非聚集索引\",\"133\":\"v-86a8eecc#覆盖索引和联合索引\",\"134\":\"v-86a8eecc#覆盖索引\",\"135\":\"v-86a8eecc#联合索引\",\"136\":\"v-86a8eecc#最左匹配原则\",\"137\":\"v-86a8eecc#索引下推\",\"138\":\"v-86a8eecc#使用索引的建议\",\"139\":\"v-86a8eecc#选择合适的字段创建索引\",\"140\":\"v-86a8eecc#被频繁更新的字段应该慎重建立索引\",\"141\":\"v-86a8eecc#限制每张表上的索引数量\",\"142\":\"v-86a8eecc#尽可能的考虑建立联合索引而不是单列索引\",\"143\":\"v-86a8eecc#避免索引失效\",\"144\":\"v-aba67072\",\"145\":\"v-aba67072#redo-log-重做日志\",\"146\":\"v-aba67072#刷盘时机\",\"147\":\"v-aba67072#日志文件组\",\"148\":\"v-aba67072#redo-log-小结\",\"149\":\"v-aba67072#binlog-归档日志\",\"150\":\"v-aba67072#记录格式\",\"151\":\"v-aba67072#写入时机\",\"152\":\"v-aba67072#两阶段提交\",\"153\":\"v-aba67072#undo-log-回滚日志\",\"154\":\"v-aba67072#总结\",\"155\":\"v-3754f902\",\"156\":\"v-3754f902#事务隔离级别\",\"157\":\"v-3754f902#一致性非锁定读和锁定读\",\"158\":\"v-3754f902#一致性非锁定读\",\"159\":\"v-3754f902#锁定读\",\"160\":\"v-3754f902#innodb-对-mvcc-的实现\",\"161\":\"v-3754f902#隐藏字段\",\"162\":\"v-3754f902#readview\",\"163\":\"v-3754f902#undo-log\",\"164\":\"v-3754f902#rc-和-rr-隔离级别下-mvcc-的差异\",\"165\":\"v-3754f902#mvcc下解决不可重复读问题\",\"166\":\"v-3754f902#mvcc-next-key-lock防止幻读\",\"167\":\"v-c91da0ba\",\"168\":\"v-32a15a63\",\"169\":\"v-32a15a63#基础\",\"170\":\"v-32a15a63#什么是-redis\",\"171\":\"v-32a15a63#redis-为什么这么快\",\"172\":\"v-32a15a63#说一下-redis-和-memcached-的区别和共同点\",\"173\":\"v-32a15a63#为什么要用-redis-为什么要用缓存\",\"174\":\"v-32a15a63#常见的缓存读写策略\",\"175\":\"v-32a15a63#cache-aside-pattern-旁路缓存模式\",\"176\":\"v-32a15a63#read-write-through-pattern-读写穿透\",\"177\":\"v-32a15a63#write-behind-pattern-异步缓存写入\",\"178\":\"v-32a15a63#redis-应用\",\"179\":\"v-32a15a63#redis-除了做缓存-还能做什么\",\"180\":\"v-32a15a63#redis-数据结构\",\"181\":\"v-32a15a63#redis-常用的数据结构有哪些\",\"182\":\"v-32a15a63#string-的应用场景有哪些\",\"183\":\"v-32a15a63#string-还是-hash-存储对象数据更好呢\",\"184\":\"v-32a15a63#string-的底层实现是什么\",\"185\":\"v-32a15a63#购物车信息用-string-还是-hash-存储更好呢\",\"186\":\"v-32a15a63#使用-redis-实现一个排行榜怎么做\",\"187\":\"v-32a15a63#set-的应用场景是什么\",\"188\":\"v-32a15a63#使用-set-实现抽奖系统怎么做\",\"189\":\"v-32a15a63#使用-bitmap-统计活跃用户怎么做\",\"190\":\"v-32a15a63#使用-hyperloglog-统计页面-uv-怎么做\",\"191\":\"v-32a15a63#redis持久化\",\"192\":\"v-32a15a63#redis线程模型\",\"193\":\"v-32a15a63#redis单线程了解吗\",\"194\":\"v-32a15a63#单线程如何监听大量的客户端连接\",\"195\":\"v-32a15a63#redis-6-0之前为什么不使用多线程\",\"196\":\"v-32a15a63#redis-6-0之后为何引入了多线程\",\"197\":\"v-32a15a63#redis后台线程了解吗\",\"198\":\"v-32a15a63#redis内存管理\",\"199\":\"v-32a15a63#redis给缓存数据设置过期时间有啥用\",\"200\":\"v-32a15a63#过期数据的删除策略\",\"201\":\"v-32a15a63#redis内存淘汰机制\",\"202\":\"v-41f5be07\",\"203\":\"v-41f5be07#基于-redis-实现分布式锁\",\"204\":\"v-41f5be07#如何基于-redis-实现一个最简易的分布式锁如何基于-redis-实现一个最简易的分布式锁\",\"205\":\"v-41f5be07#如何防止释放锁逻辑失效导致的锁无法释放\",\"206\":\"v-41f5be07#如何实现锁的优雅续期\",\"207\":\"v-41f5be07#如何实现可重入锁\",\"208\":\"v-41f5be07#redis-如何解决集群情况下分布式锁的可靠性\",\"209\":\"v-41f5be07#基于-zookeeper-实现分布式锁\",\"210\":\"v-41f5be07#为什么要用临时顺序节点\",\"211\":\"v-41f5be07#为什么要设置对前一个节点的监听\",\"212\":\"v-4644acc8\",\"213\":\"v-4644acc8#string-字符串\",\"214\":\"v-4644acc8#常用命令\",\"215\":\"v-4644acc8#应用场景\",\"216\":\"v-4644acc8#list-列表\",\"217\":\"v-4644acc8#常用命令-1\",\"218\":\"v-4644acc8#应用场景-1\",\"219\":\"v-4644acc8#hash-哈希\",\"220\":\"v-4644acc8#常用命令-2\",\"221\":\"v-4644acc8#应用场景-2\",\"222\":\"v-4644acc8#set-集合\",\"223\":\"v-4644acc8#常用命令-3\",\"224\":\"v-4644acc8#应用场景-3\",\"225\":\"v-4644acc8#sorted-set-有序集合\",\"226\":\"v-4644acc8#常用命令-4\",\"227\":\"v-4644acc8#应用场景-4\",\"228\":\"v-4644acc8#bitmap\",\"229\":\"v-4644acc8#常用命令-5\",\"230\":\"v-4644acc8#应用场景-5\",\"231\":\"v-4644acc8#hyperloglog\",\"232\":\"v-4644acc8#常用命令-6\",\"233\":\"v-4644acc8#应用场景-6\",\"234\":\"v-4644acc8#geospatial-index\",\"235\":\"v-4644acc8#常用命令-7\",\"236\":\"v-4644acc8#应用场景-7\",\"237\":\"v-7251bf68\",\"238\":\"v-7251bf68#rdb持久化\",\"239\":\"v-7251bf68#rdb创建快照的时候会阻塞主线程吗\",\"240\":\"v-7251bf68#aof持久化\",\"241\":\"v-7251bf68#aof工作基本流程\",\"242\":\"v-7251bf68#aof持久化方式有哪些\",\"243\":\"v-7251bf68#aof为什么是在执行完命令之后记录日志\",\"244\":\"v-7251bf68#aof重写了解吗\",\"245\":\"v-7251bf68#aof-校验机制了解吗\",\"246\":\"v-7251bf68#如何选择-rdb-和-aof\",\"247\":\"v-50823daa\",\"248\":\"v-32f3b57d\",\"249\":\"v-32f3b57d#集合\",\"250\":\"v-32f3b57d#说说-list-set-queue-map-四者的区别\",\"251\":\"v-32f3b57d#集合框架底层数据结构\",\"252\":\"v-32f3b57d#list\",\"253\":\"v-32f3b57d#说说arraylist\",\"254\":\"v-32f3b57d#arrylist和vector区别\",\"255\":\"v-32f3b57d#arraylist-与-linkedlist-区别\",\"256\":\"v-32f3b57d#set\",\"257\":\"v-32f3b57d#比较-hashset、linkedhashset-和-treeset-三者的异同\",\"258\":\"v-32f3b57d#queue\",\"259\":\"v-32f3b57d#arraydeque-与-linkedlist-的区别\",\"260\":\"v-32f3b57d#priorityqueue\",\"261\":\"v-32f3b57d#blockingqueue\",\"262\":\"v-1485935c\",\"263\":\"v-1485935c#map\",\"264\":\"v-1485935c#hashmap-和-hashtable-的区别\",\"265\":\"v-1485935c#hashmap-和-treemap-区别\",\"266\":\"v-1485935c#hashmap-的底层实现\",\"267\":\"v-1485935c#jdk1-8-之前\",\"268\":\"v-1485935c#jdk1-8-之后\",\"269\":\"v-1485935c#hashmap-的长度为什么是-2-的幂次方\",\"270\":\"v-1485935c#hashmap-多线程操作导致死链问题\",\"271\":\"v-1485935c#concurrenthashmap-和-hashtable-的区别\",\"272\":\"v-1485935c#jdk-1-7-和-jdk-1-8-的-concurrenthashmap-实现有什么不同\",\"273\":\"v-31c43ed3\",\"274\":\"v-e26068d4\",\"275\":\"v-e26068d4#jvm-jre-jdk\",\"276\":\"v-e26068d4#什么是字节码-采用字节码的好处\",\"277\":\"v-e26068d4#java-和-c-的区别\",\"278\":\"v-e26068d4#基本数据类型\",\"279\":\"v-e26068d4#基本类型和包装类型\",\"280\":\"v-e26068d4#包装类的缓存机制\",\"281\":\"v-e26068d4#自动拆装箱\",\"282\":\"v-e26068d4#浮点数运算的时候会有精度丢失的风险\",\"283\":\"v-e26068d4#如何解决浮点数运算的时候精度丢失问题\",\"284\":\"v-e26068d4#超过long-64位补码的范围数字应该如何表示\",\"285\":\"v-e26068d4#变量\",\"286\":\"v-e26068d4#静态变量\",\"287\":\"v-e26068d4#方法\",\"288\":\"v-e26068d4#静态方法为什么不能调用非静态成员\",\"289\":\"v-e26068d4#重载和重写\",\"290\":\"v-f9cd8696\",\"291\":\"v-f9cd8696#面向对象\",\"292\":\"v-f9cd8696#面向对象和面向过程的区别\",\"293\":\"v-f9cd8696#对象的相等和引用的相等\",\"294\":\"v-f9cd8696#如果没有声明构造方法-程序能正确执行吗\",\"295\":\"v-f9cd8696#面向对象的三个特征\",\"296\":\"v-f9cd8696#接口和抽象类的共同点\",\"297\":\"v-f9cd8696#浅拷贝-深拷贝-引用拷贝\",\"298\":\"v-f9cd8696#object\",\"299\":\"v-f9cd8696#和equals区别\",\"300\":\"v-f9cd8696#hashcode-作用\",\"301\":\"v-f9cd8696#为什么重写-equals-时必须重写-hashcode-方法\",\"302\":\"v-f9cd8696#string\",\"303\":\"v-f9cd8696#string、stringbuffer、stringbuilder-的区别\",\"304\":\"v-f9cd8696#string为何不可变\",\"305\":\"v-f9cd8696#字符串拼接用-还是-stringbuilder\",\"306\":\"v-f9cd8696#string-s1-new-string-abc-这句话创建了几个字符串对象\",\"307\":\"v-f9cd8696#string-intern-方法有什么作用\",\"308\":\"v-f9cd8696#编译器对字符串拼接的优化\",\"309\":\"v-f9cd8696#java值传递\",\"310\":\"v-f9cd8696#形参和实参\",\"311\":\"v-f9cd8696#值传递-引用传递\",\"312\":\"v-f9cd8696#java只有值传递\",\"313\":\"v-f9cd8696#java序列化\",\"314\":\"v-f9cd8696#serialversionuid-有什么作用\",\"315\":\"v-49079e4a\",\"316\":\"v-49079e4a#反射的应用场景\",\"317\":\"v-49079e4a#反射的优缺点\",\"318\":\"v-49079e4a#反射获取class对象\",\"319\":\"v-49079e4a#获取方法并执行\",\"320\":\"v-63b48971\",\"321\":\"v-63b48971#静态代理\",\"322\":\"v-63b48971#动态代理\",\"323\":\"v-63b48971#jdk动态代理\",\"324\":\"v-63b48971#cglib动态代理\",\"325\":\"v-63b48971#jdk动态代理和cglib动态代理的区别\",\"326\":\"v-63b48971#静态代理和动态代理的区别\",\"327\":\"v-a94b071a\",\"328\":\"v-a94b071a#单例模式实现方式\",\"329\":\"v-a94b071a#饿汉式-静态常量\",\"330\":\"v-a94b071a#饿汉式-静态代码块\",\"331\":\"v-a94b071a#懒汉式-线程安全-同步方法\",\"332\":\"v-a94b071a#双重检查-重要\",\"333\":\"v-a94b071a#静态内部类-重要\",\"334\":\"v-a94b071a#枚举\",\"335\":\"v-2cfca4b0\",\"336\":\"v-53d0b748\",\"337\":\"v-53d0b748#进程和线程\",\"338\":\"v-53d0b748#进程\",\"339\":\"v-53d0b748#线程\",\"340\":\"v-53d0b748#从-jvm-角度说进程和线程之间的关系\",\"341\":\"v-53d0b748#程序计数器为什么是线程私有\",\"342\":\"v-53d0b748#虚拟机栈和本地方法栈为什么是私有的\",\"343\":\"v-53d0b748#堆和方法区\",\"344\":\"v-53d0b748#线程的生命周期和状态\",\"345\":\"v-53d0b748#什么是死锁-如何避免\",\"346\":\"v-53d0b748#死锁\",\"347\":\"v-53d0b748#如何预防死锁\",\"348\":\"v-53d0b748#如何避免死锁\",\"349\":\"v-53d0b748#sleep-方法和-wait-方法对比\",\"350\":\"v-53d0b748#为什么wait-方法不定义在thread中\",\"351\":\"v-53d0b748#直接调用run-和start-的区别\",\"352\":\"v-6a5c135d\",\"353\":\"v-6a5c135d#java内存模型\",\"354\":\"v-6a5c135d#指令重排序\",\"355\":\"v-6a5c135d#什么是java内存模型-为什么需要java内存模型\",\"356\":\"v-6a5c135d#什么是主内存-什么是本地内存\",\"357\":\"v-6a5c135d#java内存结构和java内存模型的区别\",\"358\":\"v-6a5c135d#happens-before\",\"359\":\"v-6a5c135d#happens-before-常见规则\",\"360\":\"v-6a5c135d#并发编程的三个特性\",\"361\":\"v-6a5c135d#volatile关键字\",\"362\":\"v-6a5c135d#volatile如何禁止指令重排序\",\"363\":\"v-6a5c135d#乐观锁和悲观锁\",\"364\":\"v-6a5c135d#什么是乐观锁\",\"365\":\"v-6a5c135d#什么是悲观锁\",\"366\":\"v-6a5c135d#cas-算法\",\"367\":\"v-6a5c135d#aba问题\",\"368\":\"v-6a5c135d#cas问题\",\"369\":\"v-6a5c135d#synchronized\",\"370\":\"v-6a5c135d#synchronized-是什么-有什么用\",\"371\":\"v-6a5c135d#sychronized修饰方法\",\"372\":\"v-6a5c135d#synchronized底层原理\",\"373\":\"v-6a5c135d#synchronized-和-volatile-有什么区别\",\"374\":\"v-6a5c135d#reentrantlock\",\"375\":\"v-6a5c135d#reentrantlock-是什么\",\"376\":\"v-6a5c135d#公平锁和非公平锁有什么区别\",\"377\":\"v-6a5c135d#synchronized-和-reentrantlock-有什么区别\",\"378\":\"v-6a5c135d#可中断锁和不可中断锁有什么区别\",\"379\":\"v-02befb44\",\"380\":\"v-02befb44#threadlocal\",\"381\":\"v-02befb44#threadlocal-有什么用\",\"382\":\"v-02befb44#threadlocal原理\",\"383\":\"v-02befb44#threadlocal内存泄露\",\"384\":\"v-02befb44#线程池\",\"385\":\"v-02befb44#什么是线程池\",\"386\":\"v-02befb44#为什么要用线程池\",\"387\":\"v-02befb44#如何创建线程池\",\"388\":\"v-02befb44#线程池的主要参数\",\"389\":\"v-02befb44#线程池的饱和策略有哪些\",\"390\":\"v-02befb44#线程池中常用的阻塞队列有哪些\",\"391\":\"v-02befb44#线程池处理任务的流程了解吗\",\"392\":\"v-02befb44#如何设定线程池的大小\",\"393\":\"v-02befb44#future\",\"394\":\"v-02befb44#future类有什么用\",\"395\":\"v-02befb44#callable-和-future-有什么关系\",\"396\":\"v-02befb44#completablefuture-类有什么用\",\"397\":\"v-d0bf4a88\",\"398\":\"v-d0bf4a88#自旋锁与自适应自旋\",\"399\":\"v-d0bf4a88#锁消除\",\"400\":\"v-d0bf4a88#锁粗化\",\"401\":\"v-d0bf4a88#轻量级锁\",\"402\":\"v-d0bf4a88#偏向锁\",\"403\":\"v-70192d16\",\"404\":\"v-70192d16#aqs原理\",\"405\":\"v-70192d16#aqs核心思想\",\"406\":\"v-70192d16#aqs资源共享方式\",\"407\":\"v-70192d16#semaphore-信号量\",\"408\":\"v-70192d16#countdownlatch-倒计时器\",\"409\":\"v-70192d16#cyclicbarrier-循环栅栏\",\"410\":\"v-169e4648\",\"411\":\"v-169e4648#copyonwritearraylist\",\"412\":\"v-169e4648#copyonwritearraylist-原理\",\"413\":\"v-169e4648#concurrentlinkedqueue\",\"414\":\"v-169e4648#blockingqueue\",\"415\":\"v-169e4648#arrayblockingqueue\",\"416\":\"v-169e4648#linkedblockingqueue\",\"417\":\"v-169e4648#priorityblockingqueue\",\"418\":\"v-169e4648#concurrentskiplistmap\",\"419\":\"v-64a8bef6\",\"420\":\"v-616d4a15\",\"421\":\"v-616d4a15#运行时数据区域\",\"422\":\"v-616d4a15#线程私有的\",\"423\":\"v-616d4a15#程序计数器\",\"424\":\"v-616d4a15#虚拟机栈\",\"425\":\"v-616d4a15#本地方法栈\",\"426\":\"v-616d4a15#线程共有的\",\"427\":\"v-616d4a15#堆\",\"428\":\"v-616d4a15#方法区\",\"429\":\"v-616d4a15#运行时常量池-方法区内部\",\"430\":\"v-616d4a15#字符串常量池\",\"431\":\"v-616d4a15#jvm中对象的创建\",\"432\":\"v-616d4a15#_1-类加载检查\",\"433\":\"v-616d4a15#_2-分配内存\",\"434\":\"v-616d4a15#_3-初始化零值\",\"435\":\"v-616d4a15#_4-设置对象头\",\"436\":\"v-616d4a15#_5-执行-init-方法\",\"437\":\"v-616d4a15#对象的内存布局\",\"438\":\"v-616d4a15#对象的访问定位\",\"439\":\"v-616d4a15#直接指针\",\"440\":\"v-616d4a15#句柄\",\"441\":\"v-654da30e\",\"442\":\"v-654da30e#内存分配和回收原则\",\"443\":\"v-654da30e#对象优先在eden中分配\",\"444\":\"v-654da30e#大对象直接进入老年代\",\"445\":\"v-654da30e#长期存活的对象将进入老年代\",\"446\":\"v-654da30e#gc区域\",\"447\":\"v-654da30e#空间分配担保\",\"448\":\"v-654da30e#死亡对象的判断方法\",\"449\":\"v-654da30e#引用计数法\",\"450\":\"v-654da30e#可达性分析\",\"451\":\"v-654da30e#可以作为gc-roots的对象\",\"452\":\"v-654da30e#对象可以被回收-就代表一定会被回收吗\",\"453\":\"v-654da30e#引用类型总结\",\"454\":\"v-654da30e#如何判断一个常量是废弃常量\",\"455\":\"v-654da30e#如何判断一个类是无用的类\",\"456\":\"v-654da30e#垃圾收集算法\",\"457\":\"v-654da30e#标记-清除算法\",\"458\":\"v-654da30e#复制算法\",\"459\":\"v-654da30e#分代收集算法-hotspot为什么要分代\",\"460\":\"v-654da30e#垃圾回收器\",\"461\":\"v-654da30e#serial-收集器\",\"462\":\"v-654da30e#parnew-收集器\",\"463\":\"v-654da30e#parallel-scavenge-收集器\",\"464\":\"v-654da30e#serial-old收集器\",\"465\":\"v-654da30e#parallel-old-收集器\",\"466\":\"v-654da30e#cms收集器\",\"467\":\"v-654da30e#g1-收集器\",\"468\":\"v-654da30e#cms和g1的异同\",\"469\":\"v-654da30e#到底多大的对象会被直接扔到老年代\",\"470\":\"v-654da30e#cms和g1的stw的区别\",\"471\":\"v-f43459d6\",\"472\":\"v-f43459d6#字节码\",\"473\":\"v-f43459d6#class文件结构总结\",\"474\":\"v-f43459d6#魔数-magic-number\",\"475\":\"v-f43459d6#class-文件版本号-minor-major-version\",\"476\":\"v-f43459d6#常量池-constant-pool\",\"477\":\"v-f43459d6#访问标志-access-flags\",\"478\":\"v-f43459d6#当前类-this-class-、父类-super-class-、接口-interfaces-索引集合\",\"479\":\"v-f43459d6#字段表集合-fields\",\"480\":\"v-f43459d6#方法表集合-methods\",\"481\":\"v-f43459d6#属性表集合-attributes\",\"482\":\"v-5d9b8262\",\"483\":\"v-5d9b8262#类的生命周期\",\"484\":\"v-5d9b8262#类加载过程\",\"485\":\"v-5d9b8262#加载\",\"486\":\"v-5d9b8262#验证\",\"487\":\"v-5d9b8262#准备\",\"488\":\"v-5d9b8262#解析\",\"489\":\"v-5d9b8262#初始化\",\"490\":\"v-5d9b8262#类卸载\",\"491\":\"v-494f04b5\",\"492\":\"v-494f04b5#类加载器\",\"493\":\"v-494f04b5#类加载器的加载规则\",\"494\":\"v-494f04b5#类加载器总结\",\"495\":\"v-494f04b5#自定义类加载器\",\"496\":\"v-494f04b5#双亲委派\",\"497\":\"v-494f04b5#双亲委派模型的执行流程\",\"498\":\"v-494f04b5#双亲委派的好处\",\"499\":\"v-494f04b5#打破双亲委派模型方法\",\"500\":\"v-6cd0e214\",\"501\":\"v-6cd0e214#堆内存相关\",\"502\":\"v-6cd0e214#指定堆内存-xms和-xmx\",\"503\":\"v-6cd0e214#指定新生代内存-young-generation\",\"504\":\"v-6cd0e214#指定永久代-元空间大小\",\"505\":\"v-6cd0e214#垃圾收集器相关\",\"506\":\"v-6cd0e214#垃圾回收器\",\"507\":\"v-6cd0e214#gc-日志记录\",\"508\":\"v-6cd0e214#处理-oom\",\"509\":\"v-6cd0e214#其他\",\"510\":\"v-3c93d317\",\"511\":\"v-3c93d317#确定目标\",\"512\":\"v-3c93d317#最快的gc是不发生gc\",\"513\":\"v-3c93d317#新生代gc调优\",\"514\":\"v-3c93d317#幸存区\",\"515\":\"v-3c93d317#老年代调优\",\"516\":\"v-3c93d317#案例\",\"517\":\"v-3c93d317#案例1\",\"518\":\"v-3c93d317#案例2\",\"519\":\"v-3c93d317#案例3\",\"520\":\"v-64b6db6e\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,14],\"1\":[1],\"2\":[1,33],\"3\":[2,33],\"4\":[1],\"5\":[2,16],\"6\":[2,10],\"7\":[2,39],\"8\":[4,49],\"9\":[2,73],\"10\":[2,33],\"11\":[1],\"12\":[2,35],\"13\":[1,1],\"14\":[1],\"15\":[2,38],\"16\":[2,75],\"17\":[2],\"18\":[2,25],\"19\":[4,14],\"20\":[6],\"21\":[5,14],\"22\":[7,48],\"23\":[5,17],\"24\":[1],\"25\":[1],\"26\":[1],\"27\":[1],\"28\":[1],\"29\":[1],\"30\":[1],\"31\":[1],\"32\":[1],\"33\":[3,9],\"34\":[1],\"35\":[1],\"36\":[1],\"37\":[1,89],\"38\":[1,19],\"39\":[1,102],\"40\":[1,108],\"41\":[1,37],\"42\":[1],\"43\":[4,11],\"44\":[1,40],\"45\":[1,44],\"46\":[5,68],\"47\":[4,17],\"48\":[1],\"49\":[3,17],\"50\":[3,41],\"51\":[1],\"52\":[3],\"53\":[4,66],\"54\":[5,15],\"55\":[6,36],\"56\":[5,88],\"57\":[4],\"58\":[2,26],\"59\":[2,16],\"60\":[3,44],\"61\":[7,9],\"62\":[8,20],\"63\":[4],\"64\":[3,42],\"65\":[3,5],\"66\":[3,32],\"67\":[1,6],\"68\":[1,13],\"69\":[3,20],\"70\":[3,9],\"71\":[1],\"72\":[3],\"73\":[2,9],\"74\":[3,12],\"75\":[5,57],\"76\":[2,22],\"77\":[1],\"78\":[4,44],\"79\":[3,39],\"80\":[1],\"81\":[1],\"82\":[1],\"83\":[1,8],\"84\":[1,68],\"85\":[1,21],\"86\":[6,25],\"87\":[4,29],\"88\":[1],\"89\":[2,6],\"90\":[2,12],\"91\":[1,58],\"92\":[1,7],\"93\":[5,45],\"94\":[1,21],\"95\":[2,15],\"96\":[1,28],\"97\":[2,16],\"98\":[2,5],\"99\":[2,10],\"100\":[2,7],\"101\":[2],\"102\":[3,40],\"103\":[3,35],\"104\":[1,29],\"105\":[2,33],\"106\":[1,39],\"107\":[2,19],\"108\":[1,162],\"109\":[1],\"110\":[1,7],\"111\":[2,4],\"112\":[2,8],\"113\":[2,23],\"114\":[1],\"115\":[1,12],\"116\":[1,12],\"117\":[2,6],\"118\":[2,14],\"119\":[2,11],\"120\":[1],\"121\":[1,15],\"122\":[1],\"123\":[1,8],\"124\":[3,16],\"125\":[1,13],\"126\":[1,40],\"127\":[3,51],\"128\":[4,20],\"129\":[1,22],\"130\":[1],\"131\":[3,25],\"132\":[3,24],\"133\":[1],\"134\":[1,9],\"135\":[1,6],\"136\":[1,64],\"137\":[1,8],\"138\":[1],\"139\":[1,7],\"140\":[1,6],\"141\":[1,6],\"142\":[1,10],\"143\":[1,42],\"144\":[1],\"145\":[3,27],\"146\":[1,45],\"147\":[1,46],\"148\":[3,26],\"149\":[2,21],\"150\":[1,32],\"151\":[1,56],\"152\":[1,67],\"153\":[3,43],\"154\":[1,18],\"155\":[1],\"156\":[1,66],\"157\":[1],\"158\":[1,48],\"159\":[1,66],\"160\":[4,25],\"161\":[1,33],\"162\":[1,38],\"163\":[2,12],\"164\":[6,25],\"165\":[1,22],\"166\":[3,59],\"167\":[1],\"168\":[1],\"169\":[1],\"170\":[3,33],\"171\":[3,13],\"172\":[6,65],\"173\":[4,45],\"174\":[1],\"175\":[5,69],\"176\":[6,49],\"177\":[5,40],\"178\":[2],\"179\":[4,71],\"180\":[2,2],\"181\":[3,21],\"182\":[3,30],\"183\":[5,18],\"184\":[3,77],\"185\":[6,13],\"186\":[4,18],\"187\":[3,34],\"188\":[4,17],\"189\":[4,39],\"190\":[6,27],\"191\":[1,2],\"192\":[1,11],\"193\":[2,15],\"194\":[2,18],\"195\":[4,12],\"196\":[4,9],\"197\":[2,23],\"198\":[1],\"199\":[2,40],\"200\":[1,9],\"201\":[1,41],\"202\":[1,14],\"203\":[3],\"204\":[6,69],\"205\":[2,37],\"206\":[2,111],\"207\":[2,31],\"208\":[3,40],\"209\":[3,48],\"210\":[2,63],\"211\":[2,9],\"212\":[1,35],\"213\":[3,33],\"214\":[1,38],\"215\":[1,28],\"216\":[3,11],\"217\":[1,32],\"218\":[1,23],\"219\":[3,24],\"220\":[1,40],\"221\":[1,16],\"222\":[3,19],\"223\":[1,35],\"224\":[1,41],\"225\":[4,19],\"226\":[1,48],\"227\":[1,17],\"228\":[1,18],\"229\":[1,32],\"230\":[1,16],\"231\":[1,38],\"232\":[1,23],\"233\":[1,17],\"234\":[2,14],\"235\":[1,50],\"236\":[1,8],\"237\":[1],\"238\":[1,16],\"239\":[2,22],\"240\":[1,16],\"241\":[2,28],\"242\":[2,15],\"243\":[2,12],\"244\":[2,48],\"245\":[3,29],\"246\":[5,122],\"247\":[1],\"248\":[1],\"249\":[1,7],\"250\":[7,20],\"251\":[1,52],\"252\":[1],\"253\":[1,27],\"254\":[2,8],\"255\":[5,14],\"256\":[1],\"257\":[6,19],\"258\":[1,36],\"259\":[4,27],\"260\":[1,50],\"261\":[1,14],\"262\":[1],\"263\":[1],\"264\":[4,26],\"265\":[4,15],\"266\":[2],\"267\":[3,33],\"268\":[3,9],\"269\":[5,18],\"270\":[2,14],\"271\":[4,47],\"272\":[9,29],\"273\":[1],\"274\":[1,4],\"275\":[3,11],\"276\":[3,16],\"277\":[4,9],\"278\":[1,14],\"279\":[1,19],\"280\":[1,17],\"281\":[1,13],\"282\":[2,2],\"283\":[2,3],\"284\":[3,4],\"285\":[1,26],\"286\":[1,9],\"287\":[1],\"288\":[2,8],\"289\":[1,42],\"290\":[1],\"291\":[1],\"292\":[1,7],\"293\":[1,18],\"294\":[3,7],\"295\":[1,37],\"296\":[1,21],\"297\":[3,12],\"298\":[1],\"299\":[1,12],\"300\":[2,10],\"301\":[6,10],\"302\":[1],\"303\":[5,18],\"304\":[2,19],\"305\":[5,12],\"306\":[7,16],\"307\":[4,31],\"308\":[1,33],\"309\":[1],\"310\":[1,13],\"311\":[2,8],\"312\":[1,29],\"313\":[1,8],\"314\":[3,15],\"315\":[1,3],\"316\":[1,41],\"317\":[1,7],\"318\":[1,25],\"319\":[1,11],\"320\":[1,6],\"321\":[1,11],\"322\":[1,10],\"323\":[1,43],\"324\":[1,47],\"325\":[1,7],\"326\":[1,11],\"327\":[1,4],\"328\":[1,15],\"329\":[3,16],\"330\":[3,16],\"331\":[4,18],\"332\":[3,22],\"333\":[3,19],\"334\":[1,7],\"335\":[1],\"336\":[1],\"337\":[1],\"338\":[1,4],\"339\":[1,11],\"340\":[3,8],\"341\":[2,6],\"342\":[2,11],\"343\":[1,8],\"344\":[1,22],\"345\":[2],\"346\":[1,7],\"347\":[2,9],\"348\":[2,3],\"349\":[4,22],\"350\":[3,11],\"351\":[3,18],\"352\":[1],\"353\":[1],\"354\":[1,11],\"355\":[3,6],\"356\":[3,9],\"357\":[1,8],\"358\":[2,20],\"359\":[3,26],\"360\":[1,16],\"361\":[1,15],\"362\":[2,56],\"363\":[1],\"364\":[2,23],\"365\":[2,15],\"366\":[2,26],\"367\":[1,7],\"368\":[1,19],\"369\":[1],\"370\":[4,14],\"371\":[1,13],\"372\":[1,39],\"373\":[5,15],\"374\":[1],\"375\":[3,29],\"376\":[2,12],\"377\":[5,32],\"378\":[2,12],\"379\":[1],\"380\":[1],\"381\":[3,12],\"382\":[1,47],\"383\":[1,34],\"384\":[1],\"385\":[2,6],\"386\":[2,7],\"387\":[2,59],\"388\":[1,44],\"389\":[2,23],\"390\":[2,49],\"391\":[2,16],\"392\":[2,14],\"393\":[1],\"394\":[2,16],\"395\":[5,29],\"396\":[3,45],\"397\":[1,10],\"398\":[1,16],\"399\":[1,10],\"400\":[1,10],\"401\":[1,22],\"402\":[1,17],\"403\":[1,20],\"404\":[1],\"405\":[1,43],\"406\":[1,12],\"407\":[3,92],\"408\":[3,64],\"409\":[3,24],\"410\":[1,32],\"411\":[1,7],\"412\":[2,16],\"413\":[1,21],\"414\":[1,14],\"415\":[1,16],\"416\":[1,21],\"417\":[1,30],\"418\":[1,14],\"419\":[1],\"420\":[1],\"421\":[1],\"422\":[2],\"423\":[1,12],\"424\":[1,26],\"425\":[1,11],\"426\":[2],\"427\":[1,14],\"428\":[1,17],\"429\":[3,20],\"430\":[1,38],\"431\":[1],\"432\":[2,6],\"433\":[2,30],\"434\":[2,8],\"435\":[2,14],\"436\":[4,8],\"437\":[1,22],\"438\":[1,3],\"439\":[1,4],\"440\":[1,8],\"441\":[1],\"442\":[1],\"443\":[1,10],\"444\":[1,6],\"445\":[1,56],\"446\":[1,28],\"447\":[1,29],\"448\":[1],\"449\":[1,11],\"450\":[1,11],\"451\":[4,6],\"452\":[3,16],\"453\":[1,42],\"454\":[2,29],\"455\":[2,28],\"456\":[1],\"457\":[2,15],\"458\":[1,22],\"459\":[2,21],\"460\":[1],\"461\":[2,16],\"462\":[2,26],\"463\":[3,12],\"464\":[2,15],\"465\":[3,15],\"466\":[1,55],\"467\":[2,121],\"468\":[1,33],\"469\":[1,11],\"470\":[1,38],\"471\":[1],\"472\":[1,20],\"473\":[1],\"474\":[4,13],\"475\":[6,24],\"476\":[4,44],\"477\":[4,20],\"478\":[8,38],\"479\":[3,13],\"480\":[3,18],\"481\":[3,24],\"482\":[1],\"483\":[1,30],\"484\":[1],\"485\":[1,9],\"486\":[1,46],\"487\":[1,38],\"488\":[1,28],\"489\":[1,38],\"490\":[1,17],\"491\":[1],\"492\":[1,13],\"493\":[1,17],\"494\":[1,69],\"495\":[1,42],\"496\":[1,40],\"497\":[1,87],\"498\":[1,14],\"499\":[1,19],\"500\":[1],\"501\":[1],\"502\":[4,9],\"503\":[4,22],\"504\":[2,48],\"505\":[1],\"506\":[1,16],\"507\":[2,53],\"508\":[2,61],\"509\":[1,84],\"510\":[1],\"511\":[1,6],\"512\":[1,30],\"513\":[1,21],\"514\":[1,8],\"515\":[1,10],\"516\":[1],\"517\":[1,7],\"518\":[1,15],\"519\":[1,8],\"520\":[1]},\"averageFieldLength\":[1.9904030710172766,26.560080063602307],\"storedFields\":{\"0\":{\"h\":\"关于我\",\"t\":[\"杭州某电计算机专业研二学生，java菜鸟，摸鱼王者，摄影爱好者。\",\"网站用于记录学习笔记、日常、秋招信息、面经。\",\"笔记来自JavaGuide和黑马程序员网课。\",\"希望能对学Java的大家提供一点帮助，不学Java也感谢能逛逛本站。\",\"终将美好，我们的春夏秋冬。\"]},\"1\":{\"h\":\"操作系统\"},\"2\":{\"h\":\"操作系统的功能\",\"t\":[\"进程和线程的管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等。\",\"存储管理：内存的分配和管理、外存（磁盘等）的分配和管理等。\",\"文件管理：文件的读、写、创建及删除等。\",\"设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。\",\"网络管理：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。\",\"安全管理：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。\"]},\"3\":{\"h\":\"什么是用户态和内核态？\",\"t\":[\"用户态：又称为目态，用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些特权指令的时候就会发生系统调用，让用户态变成内核态。\",\"内核态：又称为管态，内核态运行的进程集合可以访问计算机的任何资源，拥有非常高的权限，当操作系统接收到进程的系统调用请求时，就会从用户态切换为内核态，执行响应的系统调用，并将结果返回给进程，最后再从内核态切换为用户态。\",\"用户态切换到内核态的三种方式：\",\"系统调用：用户态进程主动要求切换到内核态的一种方式；\",\"中断：当外围设备完成用户请求操作之后，会向CPU发出响应的中断信号，CPU响应的时候切换到核心态。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。\",\"异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。\"]},\"4\":{\"h\":\"进程和线程\"},\"5\":{\"h\":\"什么是进程和线程？\",\"t\":[\"进程：值得是计算机中正在运行的程序实例，是操作系统中拥有资源的基本单位。\",\"线程：引入线程之后，CPU调度的最小单位变成线程，线程又称为轻量级进程。\",\"对于Java来说，一个进程能拥有很多个线程，多个线程共享进程的堆和方法区（JDK1.8之后的元空间），但是每个线程都有自己的程序计数器，虚拟机栈和本地方法栈（线程私有）。\"]},\"6\":{\"h\":\"有了进程为什么还需要线程?\",\"t\":[\"进程切换的成本大于线程切换。\",\"线程更加轻量，一个进程能创建多个线程。\",\"多个线程能并发处理不同的任务，有效利用CPU资源。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞就会挂起直到结果返回。\",\"同一个进程的线程共享内存和文件，因此线程之间的相互通信无需调用内核。\"]},\"7\":{\"h\":\"线程间的同步的方式有哪些？\",\"t\":[\"互斥锁(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。\",\"读写锁（Read-Write Lock）：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。\",\"信号量(Semaphore)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。\",\"屏障（Barrier）：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 CyclicBarrier 是这种机制。\",\"事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。\"]},\"8\":{\"h\":\"PCB 是什么？包含哪些信息？\",\"t\":[\"PCB（Process Control Block） 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。你可以将 PCB 视为进程的大脑。\",\"当操作系统创建一个新进程时，会为该进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块。当进程执行时，PCB 中的信息会不断变化，操作系统会根据这些信息来管理和调度进程。\",\"PCB 主要包含下面几部分的内容：\",\"进程的描述信息，包括进程的名称、标识符等等；\",\"进程的调度信息，包括进程阻塞原因、进程状态（就绪、运行、阻塞等）、进程优先级（标识进程的重要程度）等等；\",\"进程对资源的需求情况，包括 CPU 时间、内存空间、I/O 设备等等。\",\"进程打开的文件信息，包括文件描述符、文件类型、打开模式等等。\",\"处理机的状态信息（由处理机的各种寄存器中的内容组成的），包括通用寄存器、指令计数器、程序状态字 PSW、用户栈指针。\"]},\"9\":{\"h\":\"进程间的通信方式有哪些？\",\"t\":[\"管道/匿名管道(Pipes)：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。\",\"有名管道(Named Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循 先进先出(First In First Out) 。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。\",\"信号(Signal)：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\",\"消息队列(Message Queuing)：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。\",\"信号量(Semaphores)：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。\",\"共享内存(Shared memory)：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\",\"套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\"]},\"10\":{\"h\":\"什么是僵尸进程和孤儿进程？\",\"t\":[\"僵尸进程：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。\",\"孤儿进程：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。\"]},\"11\":{\"h\":\"内存管理\"},\"12\":{\"h\":\"什么是内存碎片？\",\"t\":[\"内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（2^7） 大小的内存，那 63 字节的内存就成为了内部内存碎片。（固定分区分配）\",\"外部内存碎片(External Memory Fragmentation，简称为外部碎片)：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并为分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。没有分配的内存多出的碎片。（动态分区分配）\"]},\"13\":{\"h\":\"分段分页\",\"t\":[\"...\"]},\"14\":{\"h\":\"文件系统\"},\"15\":{\"h\":\"硬链接和软链接有什么区别？\",\"t\":[\"1、硬链接（Hard Link）\",\"是对原文件起了一个别名。\",\"（1）文件有相同的 inode 及 data block；\",\"（2）只能对已存在的文件进行创建；\",\"（3）不能交叉文件系统进行硬链接的创建；\",\"（4）不能对目录进行创建，只可对文件创建；\",\"（5）删除一个硬链接文件并不影响其他有相同inode 号的文件。\",\"2、软链接（Symbolic Link 或 Symlink）\",\"又被叫为符号链接（symbolic Link），它包含了到原文件的路径信息。\",\"文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。（快捷方式）\",\"本质区别\",\"硬链接：本质是同一个文件\",\"软链接：本质不是同一个文件\"]},\"16\":{\"h\":\"常见的磁盘调度算法有哪些？\",\"t\":[\"先来先服务算法（First-Come First-Served，FCFS）：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。\",\"最短寻道时间优先算法（Shortest Seek Time First，SSTF）：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF 算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。\",\"扫描算法（SCAN）：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。\",\"循环扫描算法（Circular Scan，C-SCAN）：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。\",\"边扫描边观察算法（LOOK）：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。\",\"均衡循环扫描算法（C-LOOK）：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。\"]},\"17\":{\"h\":\"I/O\"},\"18\":{\"h\":\"何为IO？\",\"t\":[\"I/O（Input/Outpu） 即输入／输出 。\",\"从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。\",\"当应用程序发起 I/O 调用后，会经历两个步骤：\",\"内核等待 I/O 设备准备好数据\",\"内核将数据从内核空间拷贝到用户空间。\"]},\"19\":{\"h\":\"有哪些常见的 IO 模型?\",\"t\":[\"UNIX 系统下， IO 模型一共有 5 种：同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。\"]},\"20\":{\"h\":\"Java 中 3 种常见 IO 模型\"},\"21\":{\"h\":\"BIO (Blocking I/O)\",\"t\":[\"BIO 属于同步阻塞 IO 模型 。\",\"同步阻塞IO模型中，应用程序发起read调用后，会一直阻塞，知道内核把数据拷贝到用户空间。\",\"在客户端连接数量不高的情况下是没有问题的，但是当并发数量增大的时候，传统的BIO模型是无能为力的，会导致多线程阻塞，响应不了其他请求。\"]},\"22\":{\"h\":\"NIO (Non-blocking/New I/O)\",\"t\":[\"Java中的NIO于Java 1.4中引入，对应Java.nio包，提供了Channel,Selector,Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。支持面向缓冲，基于通道的I/O操作方法。对于高负载、高并发的应用，应使用NIO。\",\"Java中的NIO可以看做是I/O多路复用模型。\",\"在同步非阻塞IO模型中，应用程序会一直发起read调用，等待数据从内核空间拷贝到用户空间的这段时间，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。相比于同步阻塞IO模型，同步非阻塞IO模型确实有很大的改进，通过轮训操作避免了一直阻塞。但是这种IO模型仍然存在问题：应用程序不断进行I/O系统调用论文数据是否已经准备好的过程是很消耗CPU资源的。\",\"IO多路复用模型中，线程首先发起select调用，查询内核数据是否准备就绪，等内核把数据准备好了，用户再发起read调用。read调用的过程（数据从内核空间->用户空间）还是阻塞的。\",\"IO多路复用模型，通过减少无效的系统调用，减少了对CPU资源的消耗。\",\"Java中的NIO有一个非常重要的选择器（Selector）概念，称为多路复用器。通过它只需要一个线程便可以管理多个客户端连接，当客户端数据到了之后才会为其服务。\"]},\"23\":{\"h\":\"AIO (Asynchronous I/O)\",\"t\":[\"AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2，它是异步 IO 模型。\",\"异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\"]},\"24\":{\"h\":\"比较\"},\"25\":{\"h\":\"计算机基础\"},\"26\":{\"h\":\"框架\"},\"27\":{\"h\":\"欢迎\"},\"28\":{\"h\":\"导航\"},\"29\":{\"h\":\"数据库\"},\"30\":{\"h\":\"Java\"},\"31\":{\"h\":\"中间件\"},\"32\":{\"h\":\"平潭四月\"},\"33\":{\"h\":\"2023.4平潭-世间浪漫海占一半\",\"t\":[\" 今年四月又来看海了\",\"⭐猴研岛，68海里景区\",\" ⭐去北线的路上\",\"⭐环岛路旁\",\"⭐长江澳风车田\",\"⭐北部湾生态长廊\",\"⭐龙凤头浪花\"]},\"34\":{\"h\":\"拍拍\"},\"35\":{\"h\":\"计算机网络一\"},\"36\":{\"h\":\"常见的网络协议\"},\"37\":{\"h\":\"应用层\",\"t\":[\"HTTP（Hypertext Transfer Protocol，超文本传输协议）：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。\",\"SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。\",\"POP3/IMAP（邮件接收协议）：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。\",\"FTP（File Transfer Protocol，文件传输协议） : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。\",\"Telnet（远程登陆协议）：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。\",\"SSH（Secure Shell Protocol，安全的网络传输协议）：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务\",\"RTP（Real-time Transport Protocol，实时传输协议）：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。\",\"DNS（Domain Name System，域名管理系统）: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。\"]},\"38\":{\"h\":\"传输层\",\"t\":[\"TCP（Transmission Control Protocol，传输控制协议 ）：提供 面向连接 的，可靠 的数据传输服务。\",\"UDP（User Datagram Protocol，用户数据协议）：提供 无连接 的，尽最大努力 的数据传输服务（不保证数据传输的可靠性），简单高效。\"]},\"39\":{\"h\":\"网络层\",\"t\":[\"IP（Internet Protocol，网际协议）：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。\",\"ARP（Address Resolution Protocol，地址解析协议）：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。\",\"ICMP（Internet Control Message Protocol，互联网控制报文协议）：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。\",\"NAT（Network Address Translation，网络地址转换协议）：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。\",\"OSPF（Open Shortest Path First，开放式最短路径优先） ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。\",\"RIP(Routing Information Protocol，路由信息协议）：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。\",\"BGP（Border Gateway Protocol，边界网关协议）：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。\"]},\"40\":{\"h\":\"Get和POST的区别\",\"t\":[\"GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。\",\"不带参数时，这俩请求的报文只有在HTTP请求行的 method字段不一样，其他都一样。带参数时，我们通常约定GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中。当然也可以不遵循这种约定，只要在服务端做好支持就好了。\",\"GET 用于获取信息，是无副作用的，是幂等的，且可缓存\",\"POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存\",\"GET 方法参数写法是固定的吗？\",\"在约定中，我们的参数是写在 ? 后面，用 & 分割。我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行。\",\"POST 方法比 GET 方法安全？\",\"按照网上大部分文章的解释，POST 比 GET 安全，因为数据在地址栏上不可见。然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。要想安全传输，就只有加密，也就是 HTTPS。\",\"GET 方法的长度限制是怎么回事？\",\"首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。\",\"POST 方法会产生两个 TCP 数据包？\",\"有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。\"]},\"41\":{\"h\":\"PUT和POST的区别\",\"t\":[\"PUT请求\",\"PUT请求是HTTP协议中的一种请求方法，通常用于更新或者是替换服务器上的资源。使用PUT请求时，客户端需要将整个资源的新版本发送到服务器，如果服务器有这个资源，则用客户端提交的新版本替换原有的资源，如果资源不存在则会创建一个新的资源。\",\"可以更新整个资源。\",\"客户端需要发送完整的资源内容。\",\"如果服务器上不存在该资源，则会创建一个新的资源。\",\"PUT 请求具有幂等性，即执行多次 PUT 请求的结果应该相同。\",\"POST请求\",\"POST 请求是 HTTP 协议中的一种请求方法，通常用于创建新的资源或提交数据到服务器进行处理。使用 POST 请求时，客户端将数据提交到服务器，服务器根据数据进行处理，并返回响应。通常情况下，POST 请求会在服务器上创建新的资源，并返回该资源的 URI。\",\"可以创建新的资源或提交数据到服务器进行处理。\",\"客户端可以只发送部分资源内容。\",\"如果请求成功，服务器会返回一个表示新资源的 URI。\",\"POST 请求不具有幂等性。\"]},\"42\":{\"h\":\"HTTP\"},\"43\":{\"h\":\"从输入 URL 到页面展示到底发生了什么？\",\"t\":[\"DNS 解析\",\"TCP 连接\",\"发送 HTTP 请求\",\"服务器处理请求并返回 HTTP 报文\",\"浏览器解析渲染页面\",\"连接结束\"]},\"44\":{\"h\":\"HTTP状态码\",\"t\":[\"1开头的表示临时响应，比如100表示客户端可以继续发送剩余请求。\",\"2开头的表示客户端的请求成功被接收、理解、接受了。200表示请求成功，会根据请求中使用的方法返回响应的实体。\",\"3开头的表示重定向。就是说用户代理需要采取进一步措施才能满足要求。首部Location字段标示重定向的URL。301表示永久性的重定向，302表示临时性的重定向，304表示客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件(if-Match, if-Range)。当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。\",\"4开头的表示客户端错误。400 Bad Request代表客户端的请求服务器理解不了，401未授权、403服务器拒绝执行该请求，授权了也没用、404Not Found请求路径不存在。\",\"5开头的表示服务端错误。500服务端内部出现错误 ;502 Bad Gateway 504 Gateway timeout有可能是服务器断网了。\"]},\"45\":{\"h\":\"HTTPS与HTTP的区别\",\"t\":[\"端口号：HTTP 默认是 80，HTTPS 默认是 443。\",\"URL 前缀：HTTP 的 URL 前缀是 http://，HTTPS 的 URL 前缀是 https://。\",\"安全性和资源消耗：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。**所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。**所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。\",\"SEO（搜索引擎优化）：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。\"]},\"46\":{\"h\":\"HTTP/1.0 和 HTTP/1.1 区别\",\"t\":[\"连接方式 : HTTP/1.0 为短连接，HTTP/1.1 支持长连接。\",\"状态响应码 : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，100 (Continue)——在请求大资源前的预热请求，206 (Partial Content)——范围请求的标识码，409 (Conflict)——请求与当前资源的规定冲突，410 (Gone)——资源已被永久转移，而且没有任何已知的转发地址。\",\"缓存机制 : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。\",\"带宽：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\",\"Host 头（Host Header）处理 :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。\"]},\"47\":{\"h\":\"URI 和 URL 的区别\",\"t\":[\"URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。\",\"URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。\"]},\"48\":{\"h\":\"DNS\"},\"49\":{\"h\":\"DNS 的作用是什么？\",\"t\":[\"DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是域名和 IP 地址的映射问题。\",\"如果访问的网址在hosts文件中有对应的映射表目，则直接进行解析，否则需要使用DNS系统，DNS是应用层协议，基于UDP协议之上，端口为53。\"]},\"50\":{\"h\":\"DNS 服务器有哪些？\",\"t\":[\"根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。\",\"顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如com、org、net和edu等。国家也有自己的顶级域，如uk、fr和ca。TLD 服务器提供了权威 DNS 服务器的 IP 地址。\",\"权限 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。\",\"本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构。\",\"解析方式分为迭代查询和递归查询。\"]},\"51\":{\"h\":\"计算机网络二\"},\"52\":{\"h\":\"TCP 与 UDP\"},\"53\":{\"h\":\"TCP 与 UDP 的区别\",\"t\":[\"是否面向连接：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。\",\"是否是可靠传输：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。\",\"是否有状态：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。\",\"传输效率：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。\",\"传输形式：TCP 是面向字节流的，UDP 是面向报文的。\",\"首部开销：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。\",\"是否提供广播或多播服务：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；\"]},\"54\":{\"h\":\"什么时候选择 TCP，什么时候选 UDP?\",\"t\":[\"UDP 一般用于即时通信，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。\",\"TCP 用于对传输准确性要求特别高的场景，比如文件传输、发送和接收邮件、远程登录等等。\"]},\"55\":{\"h\":\"HTTP 基于 TCP 还是 UDP？\",\"t\":[\"HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 。此变化解决了 HTTP/2 中存在的队头阻塞问题。由于 HTTP/2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。另外，HTTP/2.0 需要经过经典的 TCP 三次握手过程（一般是 3 个 RTT）。由于 QUIC 协议的特性，HTTP/3.0 可以避免 TCP 三次握手的延迟，允许在第一次连接时发送数据（0 个 RTT ，零往返时间）。\"]},\"56\":{\"h\":\"使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?\",\"t\":[\"运行于 TCP 协议之上的协议：\",\"HTTP 协议：超文本传输协议（HTTP，HyperText Transfer Protocol)是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。\",\"HTTPS 协议：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议\",\"FTP 协议：文件传输协议 FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。\",\"SMTP 协议：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。\",\"POP3/IMAP 协议：两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。\",\"Telnet 协议：用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。\",\"SSH 协议 : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。\",\"运行于 UDP 协议之上的协议：\",\"**DHCP **：动态主机配置协议，动态配置 IP 地址。\",\"DNS：域名系统（DNS，Domain Name System）。\"]},\"57\":{\"h\":\"TCP 三次握手和四次挥手（传输层）\"},\"58\":{\"h\":\"建立连接-TCP三次握手\",\"t\":[\"一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 SYN_SEND 状态，等待服务器的确认；\",\"二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 SYN_RECV 状态\",\"三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务器端都进入ESTABLISHED 状态，完成 TCP 三次握手。\"]},\"59\":{\"h\":\"为什么要三次握手？\",\"t\":[\"三次握手的目的是建立可靠的通信信道。\",\"第一次握手：Client什么都不能确认，Server确认了对方发送正常，自己接收正常。\",\"第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：对方发送正常，自己接收正常。\",\"第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送、接收正常。\",\"三次握手就能确认双方收发功能都正常，缺一不可。\"]},\"60\":{\"h\":\"断开连接-TCP 四次挥手\",\"t\":[\"第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 FIN-WAIT-1 状态。\",\"第二次挥手：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后，此时服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。\",\"第三次挥手：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包->客户端请求关闭连接，然后，服务端进入 LAST-ACK 状态。\",\"第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包->服务端并且进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。\",\"只要四次挥手没有结束，客户端和服务端就可以继续传输数据\"]},\"61\":{\"h\":\"为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？\",\"t\":[\"因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。\"]},\"62\":{\"h\":\"为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？\",\"t\":[\"第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。\"]},\"63\":{\"h\":\"TCP 传输可靠性保障（传输层）\"},\"64\":{\"h\":\"TCP 如何保证传输的可靠性？\",\"t\":[\"基于数据块传输：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。\",\"对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。\",\"校验和 : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。\",\"超时重传 : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失open in new window并进行重传。\",\"流量控制 : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。\",\"拥塞控制 : 当网络拥塞时，减少数据的发送。\"]},\"65\":{\"h\":\"TCP 如何实现流量控制？\",\"t\":[\"TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。\"]},\"66\":{\"h\":\"TCP 的拥塞控制是怎么实现的？\",\"t\":[\"通过拥塞控制算法实现。\",\"慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。\",\"拥塞避免： 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.\",\"快重传与快恢复： 快重传：**如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。**快恢复：在网络发生拥塞之后，不会将拥塞窗口设置为1，而是直接设置为ssthresh阈值的一半。\"]},\"67\":{\"h\":\"ARQ协议\",\"t\":[\"ARQ称为自动重传请求（Automatic Repeat-reQuest，ARQ）；\"]},\"68\":{\"h\":\"停止等待协议\",\"t\":[\"发送窗口=接收窗口=1；\",\"停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。\"]},\"69\":{\"h\":\"后退N帧协议（GBN）\",\"t\":[\"发送窗口>1 ,接收窗口=1；\",\"连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\",\"发送方能将发送窗口内的所有序号发送，接收窗口每收到一个序号就会发送一个确认帧，并将接收窗口向前移动。如果发送方超时没有收到确认帧，则将此确认帧还有之后已经发送的序号全部重发。\",\"如果收到了序号n的确认，则认为前面需要的数据在接收端都受到了，这种确认叫做累计确认机制。\"]},\"70\":{\"h\":\"选择重传协议（SR）\",\"t\":[\"发送窗口>1 ,接收窗口>1；\",\"选择重传协议不再具有累计确认机制，凡是接收窗口中的序号都接收并返回确认帧，如果发生超时，就重传超时的帧，而不是GBN中的当前帧和后续的所有帧。\",\"相关信息\",\"本章的所有知识都属于计算机统考408计算机学科专业基础中的知识点\"]},\"71\":{\"h\":\"计算机网络三\"},\"72\":{\"h\":\"IP（网络层）\"},\"73\":{\"h\":\"IP协议的作用是什么？\",\"t\":[\"IP（网际协议）是TCP/IP协议中最重要的协议之一，属于网络层的协议，主作用是定义数据包的格式，对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。\"]},\"74\":{\"h\":\"什么是IP地址？IP寻址如何工作？\",\"t\":[\"每个连入互联网的设备或域都被分配一个IP地址，作为唯一标识符。\",\"当网络设备发送IP数据包时，数据包包含了源IP地址和目的IP地址。源IP地址用于标识数据包的发送来源，目的IP地址用来表示数据包的接收方设备地址。\",\"网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。\"]},\"75\":{\"h\":\"IPv4 和 IPv6 有什么区别？\",\"t\":[\"为了解决 IP 地址耗尽的问题，IPV6采用128位的地址，除了更大的地址空间之外，IPv6 的优势还包括：\",\"无状态地址自动配置（Stateless Address Autoconfiguration，简称 SLAAC）：主机可以直接通过根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP（Dynamic Host Configuration Protocol）服务器，简化了网络配置和管理。\",\"NAT（Network Address Translation，网络地址转换） 成为可选项：IPv6 地址资源充足，可以给全球每个设备一个独立的地址。\",\"对标头结构进行了改进：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。\",\"可选的扩展头：允许在 IPv6 标头中添加不同的扩展头（Extension Headers），用于实现不同类型的功能和选项。\",\"ICMPv6（Internet Control Message Protocol for IPv6）：IPv6 中的 ICMPv6 相较于 IPv4 中的 ICMP 有了一些改进，如邻居发现、路径 MTU 发现等功能的改进，从而提升了网络的可靠性和性能。\"]},\"76\":{\"h\":\"NAT作用是什么？\",\"t\":[\"NAT（Network Address Translation，网络地址转换） 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。\",\"NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。\"]},\"77\":{\"h\":\"ARP\"},\"78\":{\"h\":\"什么是 MAC 地址？\",\"t\":[\"MAC 地址的全称是 媒体访问控制地址（Media Access Control Address）。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。\",\"可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。\",\"MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。\",\"MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。\"]},\"79\":{\"h\":\"ARP 协议解决了什么问题？\",\"t\":[\"ARP 协议，全称 地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议用来IP地址转MAC地址。\",\"在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 <IP, MAC, TTL> 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。\"]},\"80\":{\"h\":\"计算机网络\"},\"81\":{\"h\":\"数据库基础\"},\"82\":{\"h\":\"数据库的三大范式\"},\"83\":{\"h\":\"1NF\",\"t\":[\"属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了，1NF是所有关系型数据库的最基本要求，也就是说关系型数据库中创建的表一定满足第一范式。\"]},\"84\":{\"h\":\"2NF\",\"t\":[\"2NF在1NF的基础上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。\",\"一些概念：\",\"函数依赖：若在一张表中，在属性X（或属性组）的值确定的情况下，必定能确定属性Y的值，那么可以说Y函数依赖于X，写作X->Y。\",\"部分函数依赖：如果X->Y，并且存在X的一个真子集X0，是的X0->Y，则Y对X部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号），因为确定了学号或者是身份证就能确定姓名。\",\"完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；\",\"传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖于 X。传递函数依赖会导致数据冗余和异常。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。\"]},\"85\":{\"h\":\"3NF\",\"t\":[\"3NF在2NF的基础上，消除了非主属性对于码的传递函数依赖。符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。\"]},\"86\":{\"h\":\"drop、delete 与 truncate 区别？\",\"t\":[\"drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。\",\"truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。\",\"delete（删除数据） : delete from 表名 where 列名=值，删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。\"]},\"87\":{\"h\":\"DML 语句和 DDL 语句区别\",\"t\":[\"DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。\",\"DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。\"]},\"88\":{\"h\":\"MySQL基础\"},\"89\":{\"h\":\"什么是关系型数据库？\",\"t\":[\"一种建立在关系模型基础上的数据库，关系模型表明了数据库中所存储的数据之间的联系（一对一，一对多，多对多）。\"]},\"90\":{\"h\":\"MySQL有什么优点？\",\"t\":[\"成熟稳定，功能完善。\",\"开源免费。\",\"文档丰富。\",\"兼容性好。\",\"社区活跃，生态完善。\",\"事务支持优秀。\",\"支持分库分表、读写分离、高可用。\"]},\"91\":{\"h\":\"MySQL基础架构\",\"t\":[\"MySQL主要由下面几个部分构成：\",\"连接器：身份认证和权限相关。\",\"查询缓存：执行查询语句的时候，会先查询缓存（MySQL 8.0版本后移除）。\",\"分析器：没有命中缓存的话，SQL语句会经过分析器，分析SQL语句操作，检查语法是否正确。\",\"优化器：按照MySQL认为最优的方案去执行。\",\"执行器：执行语句，然后从存储引擎返回数据。\",\"插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持InnoDB，MyISAM，Memory等多种存储引擎。\",\"MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。\",\"引擎层是插件式的，目前主要包括，MyISAM，InnoDB，Memory 等。\",\"查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎\",\"更新语句执行流程如下：分析器--->权限校验--->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态)\"]},\"92\":{\"h\":\"MySQL存储引擎\",\"t\":[\"MySQL 5.5.5之前，MyISAM是MySQL的默认存储引擎。之后，InnoDB是MySQL的默认存储引擎。\"]},\"93\":{\"h\":\"MyISAM 和 InnoDB 有什么区别？\",\"t\":[\"是否支持行级锁\",\"MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。MyISAM一锁就是整张表，并发度不及InnoDB。\",\"是否支持事务\",\"MyISAM不提供事务。\",\"InnoDB提供事务支持，实现了SQL标准定义的四个隔离级别，具有提交和回滚事务的能力，并且InnoDB默认使用REPEAETABLE-READ（可重复读）隔离级别是可以解决幻读问题的（基于MVCC和Next-Key Lock）。\",\"是否支持外键\",\"MyISAM不支持，而InnoDB支持。外键对于维护数据的一致性非常有帮助，但是在日常开发中不建议使用外键，请通过关系表实现。\",\"是否支持数据库异常崩溃后的安全恢复\",\"MyISAM不支持，而InnoDB支持。\",\"使用InnoDB的数据库在异常崩溃之后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，这个恢复过程依赖于redo log。\",\"是否支持MVCC\",\"MyISAM不支持，InnoDB支持。\",\"索引实现不同\",\"MyISAM引擎InnoDB引擎都是使用B+Tree作为索引结构，但是两者实现方式不同。\",\"InnoDB引擎中，其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree阻止的一个索引结构，树的叶节点data域保存了完整的数据记录。\",\"性能\",\"InnoDB的性能比MyISAM性能更好，InnoDB读写支持并发，MyISAM不支持并发。\"]},\"94\":{\"h\":\"MySQL查询缓存\",\"t\":[\"执行查询语句的时候，会先查询缓存，不过在8.0版本之后缓存被移除。\",\"查询不命中的情况：\",\"任何两个查询在任何字符上的不同都会导致缓存不命中。\",\"如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。\",\"缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的没一张表，如果这些表发生变化，那么和这张表的所有缓存数据都失效。\",\"缓存虽然能提升数据库的查询能力，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。\"]},\"95\":{\"h\":\"MySQL 事务\",\"t\":[\"事务是逻辑上的一组操作，要么都执行，要么都不执行。\",\"MySQL中开启事务：\",\"# 开启一个事务 START TRANSACTION; # 多条 SQL 语句 SQL1,SQL2... ## 提交事务 COMMIT; \"]},\"96\":{\"h\":\"ACID特性\",\"t\":[\"关系型数据库都有ACID特性。\",\"原子性Atomicity：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么都完成，要么都不完成。\",\"一致性Consistency：执行事物的前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的。\",\"隔离性Isolation：并发访问数据库时，一个用户的事物不被其他事务所干扰，各并发事务之间的数据库是独立的。\",\"持久性Durability：一个事务被提交之后。它对数据库中的数据改变是持久的，即使数据库发生故障也不应该对其有任何影响。\",\"ACID\",\"只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是AID是手段，C是目的。\"]},\"97\":{\"h\":\"并发事务带来了哪些问题?\",\"t\":[\"脏读：读到了没有提交的数据。\",\"READ-UNCOMMITTED\",\"不可重复读：在一个事务内开启多次读，读取条件相同的情况下得到的结果却是不一样的。\",\"READ-UNCOMMITTED、READ-COMMITTED\",\"幻读：读取到了一个原本没有的数据（新插入的数据）。\",\"READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ（通过MVCC和Next-Key Lock可解决幻读）\"]},\"98\":{\"h\":\"并发事务的控制方式有哪些？\",\"t\":[\"MySQL中并发事务的控制方式有两种：锁和MVCC。锁可以看做是悲观控制的模式，多版本并发控制是乐观控制的模式。\"]},\"99\":{\"h\":\"MySQL的隔离级别是基于锁实现的吗？\",\"t\":[\"MySQL的隔离级别基于锁和MVCC机制共同实现的。\",\"SERIALIZABLE隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。\"]},\"100\":{\"h\":\"MySQL的默认隔离级别是什么？\",\"t\":[\"MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。\"]},\"101\":{\"h\":\"MySQL 锁\"},\"102\":{\"h\":\"表级锁和行级锁了解吗？有什么区别？\",\"t\":[\"MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。\",\"行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。\",\"表级锁和行级锁对比：\",\"表级锁：MySQL中锁定粒度最大的锁，对当前操作的整张表加锁，实现简单，资源消耗快，不会出现死锁。并发度低，与存储引擎无关，MyISAM和InnoDB都支持表级锁。\",\"行级锁：MySQL中锁定粒度最小的一种锁，是针对索引字段加锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突。加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，InnoDB支持MyISAM不支持。\"]},\"103\":{\"h\":\"InnoDB 有哪几类行锁？\",\"t\":[\"InnoDB支持三种行锁定方式：\",\"记录锁（Record Lock）：也被称为记录锁，属于单个行记录上的锁。\",\"间隙锁（Gap Lock）：锁定一个范围，不包括记录本身。\",\"临键锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。\",\"相关信息\",\"在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。\"]},\"104\":{\"h\":\"共享锁和排他锁区别\",\"t\":[\"两者都是行级锁。\",\"共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。读写互斥，写写互斥，其他不互斥。\",\"排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。\",\"由于 MVCC 的存在，对于一般的 SELECT 语句，InnoDB 不会加任何锁。\"]},\"105\":{\"h\":\"意向锁有什么作用？\",\"t\":[\"如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差，所以需要意向锁来快速判断是否可以对某个表使用表锁。\",\"意向锁是表级锁，共有两种：\",\"意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。\",\"意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。\",\"注意\",\"意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InnoDB会先获取该行数据所在数据表对应的意向锁。\",\"意向锁之间是相互兼容的。\",\"除了意向共享锁（IS）和共享锁兼容（S），其余的意向锁和共享或者排他锁都互斥。\"]},\"106\":{\"h\":\"快照读和当前读的区别\",\"t\":[\"快照读（一致性非锁定读）就是单纯的 SELECT 语句，不对数据加锁的读。\",\"SELECT ... WHERE ... \",\"快照即记录的历史版本，每行记录可能存在多个历史版本。\",\"快照读的情况下，如果读取的记录正在执行UPDATE/DELETE操作，读取操作不会因此去等待记录上X锁的释放，而是会去读取行的一个快照。\",\"只有在事务隔离级别RC和RR下，InnoDB才会使用快照读。\",\"在RC级别下，对于快照数据，快照读总是读取被锁定行的最新一份快照数据。\",\"在RR级别下，对于快照数据，快照读总是读取本事务开始时的行数据版本。\",\"当前读（一致性锁定读）就是给行记录加S锁（共享锁）或者X锁（排它锁）。\",\"# 对读的记录加一个X锁 SELECT...FOR UPDATE # 对读的记录加一个S锁 SELECT...LOCK IN SHARE MODE # 对修改的记录加一个X锁 INSERT... UPDATE... DELETE... \"]},\"107\":{\"h\":\"MySQL如何存储IP地址？\",\"t\":[\"可以将IP地址转换成整形数据存储，性能更好，占用空间更小。\",\"MySQL提供了两个方法来处理ip地址：\",\"INET_ATON()：把ip转化为无符号整数。\",\"INET_NTOA()：把整型的 ip 转为地址。\",\"插入数据前，先用 INET_ATON() 把 ip 地址转为整型，显示数据时，使用 INET_NTOA() 把整型的 ip 地址转为地址显示即可。\"]},\"108\":{\"h\":\"执行计划\",\"t\":[\"可以使用 EXPLAIN 命令来分析 SQL 的 执行计划 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。\",\"EXPLAIN 并不会真的去执行相关的语句，而是通过 查询优化器 对语句进行分析，找出最优的查询方案，并显示对应的信息。\",\"分析EXPLAIN结果\",\"id：SELECT标识符，是查询中SELECT的序号，用来标识整个查询中SELECT语句的顺序。id如果相同，从上往下一次执行。\",\"select_type：查询的类型，主要用于区分普通查询、联合查询、子查询等复杂查询。\",\"SIMPLE：简单查询，不包含 UNION 或者子查询。\",\"PRIMARY：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。\",\"SUBQUERY：子查询中的第一个 SELECT。\",\"UNION：在 UNION 语句中，UNION 之后出现的 SELECT。\",\"DERIVED：在 FROM 中出现的子查询将被标记为 DERIVED。\",\"UNION RESULT：UNION 查询的结果\",\"table：表名。\",\"type（重要）：查询执行的类型，所有值的顺序从最优到最差排序为system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL。\",\"system：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。\",\"const：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。\",\"eq_ref：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。\",\"ref：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。\",\"index_merge：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。\",\"range：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。\",\"index：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。\",\"ALL：全表扫描。\",\"key（重要）：key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。\",\"key_len：key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。\",\"rows：rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。\",\"Extra（重要）：这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：\",\"Using filesort：在排序时使用了外部的索引排序，没有用到表内索引进行排序。\",\"Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。\",\"Using index：表明查询使用了覆盖索引，不用回表，查询效率非常高。\",\"Using index condition：表示查询优化器选择使用了索引条件下推这个特性。\",\"Using where：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。\",\"Using join buffer (Block Nested Loop)：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。\"]},\"109\":{\"h\":\"读写分离和分库分表\"},\"110\":{\"h\":\"读写分离\",\"t\":[\"读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点（主节点写，从节点读）上，这样能小幅度提升写性能，大幅度提升读性能。\"]},\"111\":{\"h\":\"读写分离会带来什么问题？\",\"t\":[\"读写分离对提升数据库的并发非常有效，但是主库和从库的数据存在延时（主从同步延迟 ）。\"]},\"112\":{\"h\":\"如何实现读写分离？\",\"t\":[\"部署多台数据库，选择其中一台作为主数据库，其他的一台或者多台作为从数据库。\",\"保证主数据库和从数据库之间的数据是实时同步的，这个过程称为主从复制。\",\"系统将写请求交给主数据库处理，读请求交给从数据库处理。\"]},\"113\":{\"h\":\"主从复制的原理是什么？\",\"t\":[\"主库将数据库中数据的变化写入到 binlog；\",\"从库连接主库；\",\"从库会创建一个 I/O 线程向主库请求更新的 binlog；\",\"主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收；\",\"从库的 I/O 线程将接收的 binlog 写入到 relay log 中；\",\"从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。\"]},\"114\":{\"h\":\"分库分表\"},\"115\":{\"h\":\"什么是分库\",\"t\":[\"分库就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。\",\"垂直分库就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。\",\"水平分库是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的数据库上，实现了水平扩展，解决了单表的存储和性能瓶颈的问题。例如将10万条数据分成两个5万条数据。\"]},\"116\":{\"h\":\"什么是分表\",\"t\":[\"分表：就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。\",\"垂直分表：是对数据表列的拆分，把一张列比较多的表拆分成多张表。\",\"水平分表：是对数据表行的拆分，吧一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。\"]},\"117\":{\"h\":\"什么情况下需要分库分表？\",\"t\":[\"单表的数据达到千万级别以上，数据库读写速度比较缓慢。\",\"数据库的数据占用的空间越来越大，备份时间越来越长。\",\"应用的并发量太大。\"]},\"118\":{\"h\":\"常见的分片算法有哪些？\",\"t\":[\"分片算法主要解决了数据被水平分片之后，数据应该放在哪个表的问题。\",\"哈希分片：求指定key的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常使用范围查询的场景。\",\"范围分片：按照特性的范围区间来分配数据。\",\"地理位置分片：很多NewSQL数据库都支持地理位置分片算法。\",\"融合算法：灵活组合多种分片算法。\"]},\"119\":{\"h\":\"分库分表会带来什么问题呢？\",\"t\":[\"join操作：同一个数据库中的表分布在不同的数据库中，导致无法使用join操作。\",\"事务问题：同一个数据库中的表分布在不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事物就无法满足要求。\",\"分布式id：分库之后，数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成唯一主键。\"]},\"120\":{\"h\":\"MySQL索引\"},\"121\":{\"h\":\"索引\",\"t\":[\"索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\",\"优点：\",\"使用索引可以大大加快数据的检索速度，这也是创建索引的主要原因。\",\"通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\",\"缺点：\",\"创建索引和维护索引需要耗费许多时间，当堆表中的数据进行增删改的时候，如果数据有索引，那么索引也需要改动，降低SQL执行效率。\",\"索引需要占用一定的物理空间。\"]},\"122\":{\"h\":\"索引底层数据结构\"},\"123\":{\"h\":\"Hash表\",\"t\":[\"哈希表示键值对的集合，通过键可以快速取出对应的值，因此哈希表可以快速检索数据。\",\"但是哈希算法有Hash冲突问题，不同的key最后会得到相同的index。\",\"因为Hash索引不支持顺序和范围查询，所以MySQL没有使用其作为索引的数据结构。\"]},\"124\":{\"h\":\"二叉查找树（BST）\",\"t\":[\"二叉查找树是一种基于二叉树的数据结构，具有以下特点：\",\"左子树的所有节点值均小于根节点。\",\"右子树所有节点的值均大于根节点的值。\",\"左右子树也符合上述规则。\",\"当二叉查找树是平衡的时候，任何节点的左右子树高度差的绝对值不超过1即为平衡，查询的时间复杂度是O(log2(N))。当二叉查找树不平衡时，最坏情况下退化为线性链表，查找的时间复杂度是O(N)。\",\"因为不会自动平衡，不适合作为MySQL底层索引的数据结构。\"]},\"125\":{\"h\":\"AVL树\",\"t\":[\"AVL树是自平衡的二叉查找树。保证任何节点的左右子树高度差的绝对值不超过1，因此被称为平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。\",\"AVL树需要频繁的进行旋转来保持平衡，因此会有较大的计算开销。并且使用AVL树，每个树节点仅存储一个数据，每次磁盘IO只能读取一个节点的数据。\"]},\"126\":{\"h\":\"红黑树\",\"t\":[\"红黑树是一种自平衡的二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终平衡，具有以下特点：\",\"每个节点不是红色就是黑色。\",\"根节点总是黑色。\",\"每个叶子节点都是黑色的空节点。\",\"如果节点是红色的，则它的子节点必须是黑色（反之不一定）。\",\"从根节点到叶节点或空子节点的每一条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。\",\"和 AVL 树不同的是，红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。也正因如此，红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。\"]},\"127\":{\"h\":\"B 树& B+树\",\"t\":[\"B树也称为B-树，全称多路平衡查找树，B+树是B树的变体，B树和B+树中的B是Balanced的意思。\",\"有何不同？\",\"B树的所有节点既存放键（key）也存放数据（data），而B+树只有叶子节点存放key和data，其他节点只存放key，起到索引作用。\",\"B树的叶子节点都是独立的，B+树的叶子节点有一条引用链指向与他相邻的叶子节点。\",\"B树的检索过程相当于对范围内的每个结点的关键字做二分查找，可能还没有到达叶子节点，索引就结束了。而B+树任何查找都是根节点到叶子节点的过程，只有叶子节点存储data。\",\"在B树中进行范围查询时，首先要找到查找的下限，然后对B树进行中序遍历，直到找到查找的上限；而B+树的范围查询，只需要拍对链表进行遍历即可。\",\"实现方式\",\"MyISAM引擎和InnoDB引擎都是使用B+树作为索引结构，但是两者实现方式有所不同：\",\"MyISAM引擎中，B+树叶节点的data域存放的是数据记录的地址，搜索的时候如果找道对应的节点，则会将节点的data值拿出，再通过data值作为地址读取相应的数据，这被称为非聚簇索引（非聚集索引）。\",\"InnoDB中，数据文件本身就是索引文件，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是索引，这被称为聚簇索引（聚集索引），而其余的索引都成为辅助索引，辅助索引的data域存储响应记录主键的值而不是地址。根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。\"]},\"128\":{\"h\":\"主键索引（Primary Key）\",\"t\":[\"数据表的主键列使用的就是主键索引。\",\"一张表只能有一个主键，并且不能为null，不能重复。\",\"在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。\"]},\"129\":{\"h\":\"二级索引\",\"t\":[\"二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键，也就是通过辅助索引能定位主键的位置。\",\"唯一索引：唯一索引是一种约束。唯一索引的属性页不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。建立唯一索引的目的大部分都是为了属性列的数据唯一性，而不是为了查询效率。\",\"普通索引：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。\",\"前缀索引：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小。\",\"全文索引：全文索引主要为了检索大文本数据中的关键字信息，是目前搜索引擎数据库使用的一种技术。\"]},\"130\":{\"h\":\"聚簇索引与非聚簇索引\"},\"131\":{\"h\":\"聚簇索引（聚集索引）\",\"t\":[\"聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB中的主键索引就属于聚簇索引。\",\"优点：\",\"查询速度非常快：库粗索引的查询速度很快，因为B+树本身就是一棵多叉平衡树，叶子节点也都是有序的，定位到索引的节点，相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的IO操作。\",\"对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度很快。\",\"缺点：\",\"依赖于有序的数据：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序。\",\"更新代价大：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改的代价很大。\"]},\"132\":{\"h\":\"非聚簇索引（非聚集索引）\",\"t\":[\"非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型，二级索引（辅助索引）就属于非聚簇索引。MySQL的MyISAM引擎不管是主键还是非主键，使用的都是非聚簇索引。（B+树的叶子节点不是数据本身，而是数据对应的地址）\",\"非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点存放的是主键，根据主键再回表查询数据。\",\"优点：\",\"更新代价比聚簇索引小。非聚簇索引的叶子节点不是存放数据，更新代价比聚簇索引小。\",\"缺点：\",\"依赖于有序的数据：跟聚簇索引一样，非聚簇索引也依赖于有序的数据。\",\"可能会二次查询（回表）：由于非聚簇索引的叶子节点存放的是主键，还需要根据主键去聚簇索引中去查找对应行的数据。\"]},\"133\":{\"h\":\"覆盖索引和联合索引\"},\"134\":{\"h\":\"覆盖索引\",\"t\":[\"如果一个索引包含所有需要查询字段的值，则称为覆盖索引。在InnoDB引擎中，如果不是主键索引，叶子节点存储的是主键+列值，最终需要会表查询。而覆盖搜因就是要查询出的列和索引是对应的，不会回表。\"]},\"135\":{\"h\":\"联合索引\",\"t\":[\"使用表中的多个字段创建索引，就是联合索引，也叫作组合索引或复合索引。\",\"使用表中的多个字段创建搜因，就是联合索引，也叫作组合索引或者复合索引。\"]},\"136\":{\"h\":\"最左匹配原则\",\"t\":[\"使用联合索引时存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。\",\"在使用联合索引进行查询的时候，如果不遵循最左匹配原则，联合索引会失效。\",\"例如如果创建了一个（a，b，c）联合索引，以下几种查询条件就能利用联合索引：\",\"where a=1; where a=1 and b=2 and c=3; where a=1 and b=2; \",\"因为有查询优化器，所以a字段在where中的顺序并不重要，但是如果查询条件是以下几种，就不符合最左匹配原则，联合索引就会失效：\",\"where b=2; where c=2; where b=2 and c=3; \",\"联合索引的最左匹配原则会一直向右匹配知道遇到范围查询就会停止匹配。也就是范围查询的字段可以用到联合索引，但是范围查询字段的后面的字段无法使用到联合索引。\",\"例子一\",\"select *from t_table where a>1 and b=2,联合索引（a，b）哪一个字段用到了联合索引？ \",\"由于联合索引是先按照a字段的值排序的，所以符合a>1条件的二级索引记录是肯定相邻的，于是在进行索引扫描的时候，可以定位到符合a>1条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合a>1条件位置。索引a字段可以在联合索引的B+树中进行索引查询。\",\"但是在符合a>1条件的二级索引记录的范围里，b字段的值是无序的。\",\"因此不能通过b=2来进一步减少需要扫描的记录数量\",\"所以在执行查询的时候，对应的扫描区间是[2,+ ∞)，形成这个扫描区间的条件是a>1，与b=2无关。\",\"例子二\",\" select * from t_table where a >= 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引？ \",\"跟例子1很像，不过条件变成了a>=1；\",\"符合a>=1条件的二级索引记录的范围里，b字段的值是无序的，但是在a=1的二级索引记录的范围里，b字段是有序的（因为对于联合索引，先是按照a字段的值排序，然后在a字段相同的情况下，再按照b字段值进行排序）。所以对于这个查询ab都用到了联合索引进行查询。\"]},\"137\":{\"h\":\"索引下推\",\"t\":[\"索引下推是MySQL 5.6版本中提供的索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段做判断，过滤掉不符合条件的记录，减少回表次数。\"]},\"138\":{\"h\":\"使用索引的建议\"},\"139\":{\"h\":\"选择合适的字段创建索引\",\"t\":[\"以下字段适合创建索引：\",\"不为NULL的字段；\",\"被频繁查询的字段；\",\"被作为条件查询的字段；\",\"频繁需要排序的字段；\",\"被经常频繁用于连接的字段。\"]},\"140\":{\"h\":\"被频繁更新的字段应该慎重建立索引\",\"t\":[\"虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。\"]},\"141\":{\"h\":\"限制每张表上的索引数量\",\"t\":[\"索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。\"]},\"142\":{\"h\":\"尽可能的考虑建立联合索引而不是单列索引\",\"t\":[\"因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。\"]},\"143\":{\"h\":\"避免索引失效\",\"t\":[\"索引失效是慢查询的主要原因之一，常见的导致索引失效的情况：\",\"创建了组合索引，但查询条件未遵守最左匹配原则；\",\"在索引列上进行计算、函数、类型转换等操作；\",\"以 % 开头的 LIKE 查询比如 like '%abc'；\",\"查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到；\",\"发生隐式转换\",\"隐式转换\",\"当操作符左右两边的数据类型不一致时，会发生隐式转换。\",\"当 where 查询操作符左边为数值类型时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。\",\"当 where 查询操作符左边为字符类型时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。\",\"字符串转换为数值类型时，非数字开头的字符串会转化为0，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。\",\"我们在写 SQL 时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描。\"]},\"144\":{\"h\":\"MySQL日志\"},\"145\":{\"h\":\"redo log 重做日志\",\"t\":[\"redo log是重做日志，是InnoDB引擎独有的，让MySQL拥有了崩溃恢复的能力。\",\"MySQL中以页为单位，查询记录的时候会从硬盘中将一页的数据加载，放入Buffer Pool中。\",\"后续的查找都是从Buffer Pool中查找。\",\"更新表数据的时候，发现Buffer Pool里存在要更新的数据，就直接在Buffer Pool中更新。\",\"然后会把在“某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，刷盘到redo log文件里。\",\"理想情况下，事务一提交就会进行刷盘操作，实际上刷盘的实际是根据策略来进行的。\"]},\"146\":{\"h\":\"刷盘时机\",\"t\":[\"InnoDB 存储引擎为 redo log 的刷盘策略提供了 innodb_flush_log_at_trx_commit 参数，它支持三种策略：\",\"0：设置为 0 的时候，表示每次事务提交时不进行刷盘操作\",\"1：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）\",\"2：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache\",\"innodb_flush_log_at_trx_commit 参数默认为 1 ，也就是说当事务提交时会调用 fsync 对 redo log 进行刷盘。\",\"另外，InnoDB 存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。\",\"也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。\",\"数据修改->redo log buffer->redo.file\"]},\"147\":{\"h\":\"日志文件组\",\"t\":[\"硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的redo日志文件大小都是一样的。\",\"比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。\",\"它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。\",\"在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint\",\"write pos 是当前记录的位置，一边写一边后移\",\"checkpoint 是当前要擦除的位置，也是往后推移\",\"每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。\",\"每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。\",\"write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。\",\"如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。(循环链表)\"]},\"148\":{\"h\":\"redo log 小结\",\"t\":[\"redo log刷盘和从Buffer Pool刷盘的区别。\",\"数据页的大小是16KB，刷盘比较耗时，可能就修改了几Byte数据，没有必要将整个页面刷盘。\",\"而且数据页刷盘是随机写，因为一个数据也对应的位置可能在磁盘文件的随机位置，性能很差。\",\"如果是写redo log，一行记录就占用很少的空间，而且是顺序写，刷盘速度很快。\",\"所以用redo log形式记录修改内容，性能会远远超过刷数据页面的方式，这也让数据库的并发能力增强。\",\"每次变更都需要先修改Buffer Pool，然后master线程（同步、阻塞）以一定频率刷入磁盘。\"]},\"149\":{\"h\":\"binlog 归档日志\",\"t\":[\"redo log是物理日志，记录内容是“在某个数据页上做了什么修改”，属于InnoDB存储引擎。\",\"而binlog是逻辑日志，记录内容是语句的原始逻辑，属于MySQL Server层。\",\"不管用什么存储引擎，只要发生了表数据更新，都会产生binlog日志。\",\"数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据的一致性。\",\"binlog会记录所有涉及更新数据的逻辑操作，并且是顺序写。\"]},\"150\":{\"h\":\"记录格式\",\"t\":[\"binlog 日志有三种格式，可以通过binlog_format参数指定。\",\"statement\",\"row\",\"mixed\",\"指定statement，记录的内容是SQL语句原文，比如执行一条update T set update_time=now() where id=1，记录的内容如下。\",\"同步数据时，会执行记录的SQL语句，但是有个问题，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。\",\"为了解决这种问题，需要指定为row，记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。\",\"MySQL会判断这条SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式。\"]},\"151\":{\"h\":\"写入时机\",\"t\":[\"binlog的写入时机也非常简单，事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。\",\"因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。\",\"可以通过binlog_cache_size参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。\",\"binlog日志刷盘流程如下。\",\"write是把日志写入page cache，不是数据持久化到磁盘，所以速度比较快。\",\"fsync超时将数据持久化到磁盘的操作。\",\"write和fsync的时机，可以由参数sync_binlog控制，默认是0。\",\"为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。\",\"虽然性能得到提升，但是机器宕机，page cache里面的 binlog 会丢失。\",\"为了安全起见，可以设置为1，表示每次提交事务都会执行fsync，就如同 redo log 日志刷盘流程 一样。\",\"最后还有一种折中方式，可以设置为N(N>1)，表示每次提交事务都write，但累积N个事务后才fsync。\",\"在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。\",\"同样的，如果机器宕机，会丢失最近N个事务的binlog日志。\"]},\"152\":{\"h\":\"两阶段提交\",\"t\":[\"redo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力。\",\"binlog（归档日志）保证了MySQL集群架构的数据一致性。\",\"虽然它们都属于持久化的保证，但是侧重点不同。\",\"在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。\",\"以update语句为例，假设id=2的记录，字段c值是0，把字段c值更新成1，SQL语句为update T set c=1 where id=2。\",\"假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？\",\"由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。因此，之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是0，而原库因为redo log日志恢复，这一行c值是1，最终数据不一致。\",\"从数据库和备份数据库通过binlog同步数据。\",\"为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用两阶段提交方案。\",\"原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是两阶段提交。\",\"使用两阶段提交后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。\",\"再看一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？\",\"并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。\"]},\"153\":{\"h\":\"undo log 回滚日志\",\"t\":[\"在 MySQL 中，恢复机制是通过 回滚日志（undo log） 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 回滚日志 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。\",\"MVCC 的实现依赖于：隐藏字段、Read View、undo log。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改。\",\"☀️详见事务隔离级别和MVCC。\"]},\"154\":{\"h\":\"总结\",\"t\":[\"MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。\",\"MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。\"]},\"155\":{\"h\":\"事务隔离级别和MVCC\"},\"156\":{\"h\":\"事务隔离级别\",\"t\":[\"SQL定义了四个隔离级别：\",\"READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。\",\"READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\",\"REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\",\"SERIALIZABLE(可串行化)：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\",\"隔离级别\",\"脏读\",\"不可重复读\",\"幻读\",\"READ-UNCOMMITTED\",\"√\",\"√\",\"√\",\"READ-COMMITTED\",\"×\",\"√\",\"√\",\"REPEATABLE-READ\",\"×\",\"×\",\"√\",\"SERIALIZABLE\",\"×\",\"×\",\"×\",\"MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。\",\"标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的，但是InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：\",\"快照读：由 MVCC 机制来保证不出现幻读。\",\"当前读：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁\"]},\"157\":{\"h\":\"一致性非锁定读和锁定读\"},\"158\":{\"h\":\"一致性非锁定读\",\"t\":[\"对于一致性非锁定读的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见。\",\"在 InnoDB 存储引擎中，多版本并发控制就是对非锁定读的实现。如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，叫它快照读 (snapshot read)\",\"在 Repeatable Read 和 Read Committed 两个隔离级别下，如果是执行普通的 select 语句（不包括 select ... lock in share mode ,select ... for update）则会使用 一致性非锁定读（MVCC）。并且在 Repeatable Read 下 MVCC 实现了可重复读和防止部分幻读。\"]},\"159\":{\"h\":\"锁定读\",\"t\":[\"如果执行的是下列语句，就是锁定读\",\"select ... lock in share mode\",\"select ... for update\",\"insert、update、delete 操作\",\"在锁定读下，读取的是数据的最新版本，这种读也被称为 当前读（current read）。锁定读会对读取到的记录加锁：\",\"select ... lock in share mode：对记录加 S 锁，其它事务也可以加S（共享锁）锁，如果加 x 锁则会被阻塞。\",\"select ... for update、insert、update、delete：对记录加 X（排它锁） 锁，且其它事务不能加任何锁。\",\"在一致性非锁定读下，即使读取的记录已被其它事务加上 X 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 Repeatable Read 下 MVCC 防止了部分幻读，这边的 “部分” 是指在一致性非锁定读 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， InnoDB 在实现Repeatable Read 时，如果执行的是当前读，则会对读取的记录使用 Next-key Lock ，来防止其它事务在间隙间插入数据。\"]},\"160\":{\"h\":\"InnoDB 对 MVCC 的实现\",\"t\":[\"MVCC 的实现依赖于：隐藏字段、Read View、undo log。\",\"在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改\"]},\"161\":{\"h\":\"隐藏字段\",\"t\":[\"在内部，InnoDB 存储引擎为每行数据添加了三个隐藏字段：\",\"DB_TRX_ID（6字节）：表示最后一次插入或更新该行的事务 id。此外，delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除；\",\"DB_ROLL_PTR（7字节） 回滚指针，指向该行的 undo log 。如果该行未被更新，则为空；\",\"DB_ROW_ID（6字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引。\"]},\"162\":{\"h\":\"ReadView\",\"t\":[\"主要有以下字段：\",\"m_low_limit_id：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见\",\"m_up_limit_id：活跃事务列表 m_ids 中最小的事务 ID，如果 m_ids 为空，则 m_up_limit_id 为 m_low_limit_id。小于这个 ID 的数据版本均可见\",\"m_ids：Read View 创建时其他未提交的活跃事务 ID 列表。创建 Read View时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。m_ids 不包括当前事务自己和已提交的事务（正在内存中）\",\"m_creator_trx_id：创建该 Read View 的事务 ID。\"]},\"163\":{\"h\":\"undo log\",\"t\":[\"undo log 主要有两个作用：\",\"当事务回滚时用于将数据恢复到修改前的样子；\",\"另一个作用是 MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 undo log 读取之前的版本数据，以此实现非锁定读。\"]},\"164\":{\"h\":\"RC 和 RR 隔离级别下 MVCC 的差异\",\"t\":[\"在事务隔离级别 RC 和 RR （InnoDB 存储引擎的默认事务隔离级别）下，InnoDB 存储引擎使用 MVCC（非锁定一致性读），但它们生成 Read View 的时机却不同。\",\"在 RC 隔离级别下的 每次select 查询前都生成一个Read View (m_ids 列表)；\",\"在 RR 隔离级别下只在事务开始后 第一次select 数据前生成一个Read View（m_ids 列表）。\"]},\"165\":{\"h\":\"MVCC下解决不可重复读问题\",\"t\":[\"虽然 RC 和 RR 都通过 MVCC 来读取快照数据，但由于 生成 Read View 时机不同，从而在 RR 级别下实现可重复读。\",\"在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读。\",\"在RR隔离级别下，事务在第一次查询开始的时候会生成一个Read View 后续复用这个Read View。\"]},\"166\":{\"h\":\"MVCC+Next-key Lock防止幻读\",\"t\":[\"InnoDB存储引擎在RR隔离级别下通过MVCC和Next-key Lock来解决幻读问题。\",\"1、执行普通 select，此时会以 MVCC 快照读的方式读取数据\",\"在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 Read View ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。\",\"2、执行 select...for update/lock in share mode、insert、update、delete 等当前读\",\"在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。\",\"☀️详见MySQL锁\",\"临键锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。\"]},\"167\":{\"h\":\"MySQL\"},\"168\":{\"h\":\"Redis基础一\"},\"169\":{\"h\":\"基础\"},\"170\":{\"h\":\"什么是 Redis？\",\"t\":[\"Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。\",\"为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。\"]},\"171\":{\"h\":\"Redis 为什么这么快？\",\"t\":[\"Redis 基于内存，内存的访问速度是磁盘的上千倍；\",\"Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；\",\"Redis 内置了多种优化过后的数据结构实现，性能非常高。\"]},\"172\":{\"h\":\"说一下 Redis 和 Memcached 的区别和共同点？\",\"t\":[\"共同点：\",\"都是基于内存的数据库，一般都用来当做缓存使用。\",\"都有过期策略。\",\"两者的性能都非常高。\",\"区别：\",\"支持的数据类型：Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。\",\"持久化：Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。\",\"容灾恢复：Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。\",\"内存不足操作：Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。\",\"集群支持：Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。\",\"线程数：Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。（Redis 6.0 针对网络数据的读写引入了多线程）\",\"高级功能：Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。\",\"过期数据删除：Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。\"]},\"173\":{\"h\":\"为什么要用 Redis/为什么要用缓存？\",\"t\":[\"1、高性能\",\"假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。\",\"这样有什么好处呢？ 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。\",\"2、高并发\",\"一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。\",\"QPS（Query Per Second）：服务器每秒可以执行的查询次数；\",\"由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。\"]},\"174\":{\"h\":\"常见的缓存读写策略\"},\"175\":{\"h\":\"Cache Aside Pattern（旁路缓存模式）\",\"t\":[\"Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。\",\"服务端同时维护db和cache，并且是以db的结果为准。\",\"写（缓存失效）：\",\"先更新db\",\"然后直接删除cache\",\"读：\",\"从cache中读取数据，读到直接返回；\",\"cache中没有取到数据，就从db中读取数据返回；\",\"再把数据放到cache中。\",\"相关信息\",\"在写数据的过程中，可以先删除 cache ，后更新 db 么？\",\"不行，因为会造成数据库和缓存的数据不一致问题。\",\"请求 1 先把 cache 中的 A 数据删除 -> 请求 2 从 db 中读取数据->请求 1 再把 db 中的 A 数据更新\",\"在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？\",\"理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。\",\"请求 1 从 db 读数据 A-> 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -> 请求 1 将数据 A 写入 cache（发生在请求2更新数据之前则会出现数据不一致）\",\"优缺点：\",\"缺点1：首次请求的数据一定不在cache中。\",\"解决办法：将热点数据提前放入cache中。\",\"缺点2：写操作频繁的话会导致cache中数据频繁被删除，影响命中率。\",\"解决办法：\",\"数据库和缓存数据强一致性场景：更新db的时候同时更新cache，不过需要添加一个锁来保证更新cache的时候不存在线程安全问题。\",\"可以短暂地允许数据库和缓存数据不一致的场景：更新db的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样就能保证即使数据不一致影响也比较小。\"]},\"176\":{\"h\":\"Read/Write Through Pattern（读写穿透）\",\"t\":[\"Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。\",\"写（Write Through）：\",\"先查 cache，cache 中不存在，直接更新 db。\",\"cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（同步更新 cache 和 db）\",\"读(Read Through)：\",\"从 cache 中读取数据，读取到就直接返回 。\",\"读取不到的话，先从 db 加载，写入到 cache 后返回响应。\",\"Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。\",\"和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。\"]},\"177\":{\"h\":\"Write Behind Pattern（异步缓存写入）\",\"t\":[\"Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。\",\"但是，两个又有很大的不同：Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。\",\"很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。\",\"这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。\",\"Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。\"]},\"178\":{\"h\":\"Redis 应用\"},\"179\":{\"h\":\"Redis 除了做缓存，还能做什么？\",\"t\":[\"分布式锁：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。（秒杀下更新数据库时使用分布式锁）\",\"☀️详见：分布式锁\",\"限流：一般是通过 Redis + Lua 脚本的方式来实现限流。（秒杀下一人一单占位使用Lua脚本）\",\"消息队列：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。（快速创建秒杀单之后写回数据库使用消息队列）\",\"Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现，List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。\",\"Redis 2.0 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有广播机制的问题。Redis 5.0 新增加的一个数据结构 Stream 来做消息队列。\",\"Stream 支持：\",\"发布 / 订阅模式\",\"按照消费者组进行消费\",\"消息持久化（ RDB 和 AOF）\",\"复杂业务场景：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。\"]},\"180\":{\"h\":\"Redis 数据结构\",\"t\":[\"☀️详见：Redis数据结构\"]},\"181\":{\"h\":\"Redis 常用的数据结构有哪些？\",\"t\":[\"5 种基础数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。\",\"3 种特殊数据结构：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。\"]},\"182\":{\"h\":\"String 的应用场景有哪些？\",\"t\":[\"String 是 Redis 中最简单同时也是最常用的一个数据结构。String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。\",\"String 的常见应用场景如下：\",\"常规数据（比如 session、token、序列化后的对象、图片的路径）的缓存；\",\"计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；\",\"分布式锁(利用 SETNX key value 命令可以实现一个最简易的分布式锁)。\"]},\"183\":{\"h\":\"String 还是 Hash 存储对象数据更好呢？\",\"t\":[\"String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。\",\"String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。\"]},\"184\":{\"h\":\"String 的底层实现是什么？\",\"t\":[\"Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 \\\\0 结尾的字符数组），而是自己编写了 SDS（Simple Dynamic String，简单动态字符串） 来作为底层实现。\",\"Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。\",\"SDS 相比于 C 语言中的字符串有如下提升：\",\"可以避免缓冲区溢出：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。\",\"获取字符串长度的复杂度较低：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。\",\"减少内存分配次数：为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。\",\"二进制安全：C 语言中的字符串以空字符 \\\\0 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。\"]},\"185\":{\"h\":\"购物车信息用 String 还是 Hash 存储更好呢?\",\"t\":[\"由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：\",\"用户 id 为 key；\",\"商品 id 为 field，商品数量为 value。\"]},\"186\":{\"h\":\"使用 Redis 实现一个排行榜怎么做？\",\"t\":[\"Redis 中有一个叫做 sorted set 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、游戏中的段位排行榜、话题热度排行榜等等。\",\"相关的一些 Redis 命令: ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。\"]},\"187\":{\"h\":\"Set 的应用场景是什么？\",\"t\":[\"Redis 中 Set 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。\",\"Set 的常见应用场景如下：\",\"存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等等。\",\"需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。\",\"需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。\"]},\"188\":{\"h\":\"使用 Set 实现抽奖系统怎么做？\",\"t\":[\"如果想要使用 Set 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：\",\"SADD key member1 member2 ...：向指定集合添加一个或多个元素。\",\"SPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\",\"SRANDMEMBER key count : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。\"]},\"189\":{\"h\":\"使用 Bitmap 统计活跃用户怎么做？\",\"t\":[\"Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。\",\"如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。\",\"初始化数据：\",\"> SETBIT 20210308 1 1 (integer) 0 > SETBIT 20210308 2 1 (integer) 0 > SETBIT 20210309 1 1 (integer) 0 \",\"统计 20210308~20210309 总活跃用户数:\",\"> BITOP and desk1 20210308 20210309 (integer) 1 > BITCOUNT desk1 (integer) 1 \",\"统计 20210308~20210309 在线活跃用户数:\",\"> BITOP or desk2 20210308 20210309 (integer) 1 > BITCOUNT desk2 (integer) 2 \"]},\"190\":{\"h\":\"使用 HyperLogLog 统计页面 UV 怎么做？\",\"t\":[\"使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：\",\"PFADD key element1 element2 ...：添加一个或多个元素到 HyperLogLog 中。\",\"PFCOUNT key1 key2：获取一个或者多个 HyperLogLog 的唯一计数。\",\"1、将访问指定页面的每个用户 ID 添加到 HyperLogLog 中。\",\"PFADD PAGE_1:UV USER1 USER2 ...... USERn \",\"2、统计指定页面的 UV。\",\"PFCOUNT PAGE_1:UV \"]},\"191\":{\"h\":\"Redis持久化\",\"t\":[\"☀️详见：Redis持久化\"]},\"192\":{\"h\":\"Redis线程模型\",\"t\":[\"Redis读写单线程\",\"对于读写来说，Redis一直是单线程模型。不过在Redis 4.0版本之后引入了多线程来执行一些大键值对的异步删除操作，Redis 6.0之后引入了多线程来处理网络请求（提高网络IO读写性能）。\"]},\"193\":{\"h\":\"Redis单线程了解吗？\",\"t\":[\"Redis基于Reactor模式设计开发了一套高效的事件处理模型（Netty的线程模型也是基于Reactor模式），这套时间处理模型对应的是Redis中的文件事件处理器，由于文件事件处理器是单线程方式运行的，所以一般说Redis是单线程模型。\",\"Redis IO多路复用\",\"文件事件处理器使用IO多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。\",\"虽然文件事件处理器以单线程方式运行，但通过IO多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对阶，这保持列Redis内部单线程设计的简单性。\"]},\"194\":{\"h\":\"单线程如何监听大量的客户端连接？\",\"t\":[\"Redis通过IO多路复用程序来监听来自客户端的大量连接（或者说是监听多个socket），它将感兴趣的事件及类型注册到内核中并监听每个事件是否发生。\",\"IO多路复用技术的使用让Redis不需要额外创建多余的线程来监听客户端的大量连接，降低了资源消耗，（和NIO中的Selector组件很像）。\",\"文件事件处理器包含四个部分：\",\"多个socket（客户端连接）；\",\"IO多路复用程序（支持多个客户端连接的关键）；\",\"文件事件派发器（将socket关联到相应的事件处理器）；\",\"事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。\"]},\"195\":{\"h\":\"Redis 6.0之前为什么不使用多线程？\",\"t\":[\"在Redis 4.0之后的版本中就已经加入了对多线程的支持。不过多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来异步处理。\",\"单线程变成容易并且易于维护；\",\"Redis的性能瓶颈不再CPU，主要在于内存和网络；\",\"多线程就会存在死锁、线程上下文切换等问题，可能会影响性能。\"]},\"196\":{\"h\":\"Redis 6.0之后为何引入了多线程？\",\"t\":[\"Redis 6.0引入多线程主要是为了提高网络IO读写性能，这是Redis中的一个性能瓶颈。\",\"虽然引入了多线程，但是Redis 的多线程只是在网络数据的读写上使用，执行命令仍然是单线程顺序执行。\"]},\"197\":{\"h\":\"Redis后台线程了解吗？\",\"t\":[\"虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：\",\"通过 bio_close_file 后台线程来释放 AOF / RDB 等过程中产生的临时文件资源。\",\"通过 bio_aof_fsync 后台线程调用 fsync 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。\",\"通过 bio_lazy_free后台线程释放大对象（已删除）占用的内存空间.\"]},\"198\":{\"h\":\"Redis内存管理\"},\"199\":{\"h\":\"Redis给缓存数据设置过期时间有啥用？\",\"t\":[\"因为内存有限，不设置过期时间，会导致OOM。\",\"Redis 自带了给缓存数据设置过期时间的功能，比如：\",\"127.0.0.1:6379> expire key 60 # 数据在 60s 后过期 (integer) 1 127.0.0.1:6379> setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire) OK 127.0.0.1:6379> ttl key # 查看数据还有多久过期 (integer) 56 \",\"Redis中除了字符串类型有自己独有设置过期时间的命令setex外，其他方法都需要依靠expire命令来设置过期时间。persist命令可以溢出一个键的过期时间。\",\"Redis是如何判断数据是否过期的？\",\"Redis通过过期字典（可以看做是hash表）来保存数据过期的时间，过期字典的键指向Redis数据库中的某个key，过期字典的值是一个long long 类型的整数，这个整数保存了key所指向的数据库键的过期时间。\"]},\"200\":{\"h\":\"过期数据的删除策略\",\"t\":[\"常用的过期数据的删除策略就两个：\",\"惰性删除：只会在取出key的时候才对数据进行过期检查，这样对CPU友好，但是可能会造成过多的key没有被删除。\",\"定期删除：每隔一段时间抽取一批key执行删除过期key操作。并且Redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。\"]},\"201\":{\"h\":\"Redis内存淘汰机制\",\"t\":[\"Redis 提供 6 种数据淘汰策略：\",\"volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。\",\"volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。\",\"volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。\",\"allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。\",\"allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。\",\"no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！\",\"4.0 版本后增加以下两种：\",\"volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。\",\"allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。\"]},\"202\":{\"h\":\"分布式锁\",\"t\":[\"一个最基本的分布式锁需要满足：\",\"互斥：任意一个时刻，锁只能被一个线程持有；\",\"高可用：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。\",\"可重入：一个节点获取了锁之后，还可以再次获取锁。\"]},\"203\":{\"h\":\"基于 Redis 实现分布式锁\"},\"204\":{\"h\":\"如何基于-redis-实现一个最简易的分布式锁如何基于 Redis 实现一个最简易的分布式锁？\",\"t\":[\"在 Redis 中， SETNX 命令是可以帮助我们实现互斥。SETNX 即 SET if Not eXists (对应 Java 中的 setIfAbsent 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， SETNX 啥也不做。\",\"> SETNX lockKey uniqueValue (integer) 1 > SETNX lockKey uniqueValue (integer) 0 \",\"释放锁的话，直接通过 DEL 命令删除对应的 key 即可。\",\"> DEL lockKey (integer) 1 \",\"为了防止误删到其他的锁，建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。\",\"选用 Lua 脚本是为了保证解锁操作的原子性。\",\"// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放 if redis.call(\\\"get\\\",KEYS[1]) == ARGV[1] then return redis.call(\\\"del\\\",KEYS[1]) else return 0 end \",\"+这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。例如引用程序释放锁的逻辑挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。\"]},\"205\":{\"h\":\"如何防止释放锁逻辑失效导致的锁无法释放？\",\"t\":[\"为了避免锁无法被释放，可以给锁添加一个过期时间。\",\"127.0.0.1:6379> SET lockKey uniqueValue EX 3 NX OK \",\"lockKey：加锁的锁名；\",\"uniqueValue：能够唯一标示锁的随机字符串；\",\"NX：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；\",\"EX：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。\",\"一定要保证设置指定key的值和过期时间是一个原子操作，否则依然可能会出现锁无法被释放的问题。\",\"如果操作共享资源的时间大于过期时间，则会导致锁提前释放，分布锁直接失效。设置时间过长，解锁逻辑挂了又会影响性能。\"]},\"206\":{\"h\":\"如何实现锁的优雅续期？\",\"t\":[\"Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。\",\"Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 Watch Dog（ 看门狗），如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。\",\"看门狗名字的由来于 getLockWatchdogTimeout() 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒。\",\"//默认 30秒，支持修改 private long lockWatchdogTimeout = 30 * 1000; public Config setLockWatchdogTimeout(long lockWatchdogTimeout) { this.lockWatchdogTimeout = lockWatchdogTimeout; return this; } public long getLockWatchdogTimeout() { return lockWatchdogTimeout; } \",\"默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。\",\"Watch Dog 通过调用 renewExpirationAsync() 方法实现锁的异步续期\",\"protected CompletionStage<Boolean> renewExpirationAsync(long threadId) { return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, // 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认） \\\"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \\\" + \\\"redis.call('pexpire', KEYS[1], ARGV[1]); \\\" + \\\"return 1; \\\" + \\\"end; \\\" + \\\"return 0;\\\", Collections.singletonList(getRawName()), internalLockLeaseTime, getLockName(threadId)); } \",\"以 Redisson 的分布式可重入锁 RLock 为例来说明如何使用 Redisson 实现分布式锁：\",\"// 1.获取指定的分布式锁对象 RLock lock = redisson.getLock(\\\"lock\\\"); // 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制 lock.lock(); // 3.执行业务 ... // 4.释放锁 lock.unlock(); \",\"只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。\",\"// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制 lock.lock(10, TimeUnit.SECONDS); \"]},\"207\":{\"h\":\"如何实现可重入锁？\",\"t\":[\"所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 synchronized 和 ReentrantLock 都属于可重入锁。\",\"不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。\",\"我们不需要自己手动实现，推荐使用我们上面提到的 Redisson ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。\"]},\"208\":{\"h\":\"Redis 如何解决集群情况下分布式锁的可靠性？\",\"t\":[\"为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。\",\"Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。\",\"针对这个问题，Redis 之父 antirez 设计了Redlock 算法来解决。\",\"Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，就认为客户端成功地获得分布式锁，否则加锁失败。即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。\",\"Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。\"]},\"209\":{\"h\":\"基于 ZooKeeper 实现分布式锁\",\"t\":[\"Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。\",\"ZooKeeper 分布式锁是基于 临时顺序节点 和 Watcher（事件监听器） 实现的。\",\"类似AQS的实现方式。\",\"获取锁：\",\"首先我们要有一个持久节点/locks，客户端获取锁就是在locks下创建临时顺序节点。\",\"假设客户端 1 创建了/locks/lock1节点，创建成功之后，会判断 lock1是否是 /locks 下最小的子节点。\",\"如果 lock1是最小的子节点，则获取锁成功。否则，获取锁失败。\",\"如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如/locks/lock0上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。\",\"释放锁：\",\"成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。\",\"成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。\",\"前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。\"]},\"210\":{\"h\":\"为什么要用临时顺序节点？\",\"t\":[\"每个数据节点在 ZooKeeper 中被称为 znode，它是 ZooKeeper 中数据的最小单元。\",\"通常是将 znode 分为 4 大类：\",\"持久（PERSISTENT）节点：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。\",\"临时（EPHEMERAL）节点：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点只能做叶子节点 ，不能创建子节点。\",\"持久顺序（PERSISTENT_SEQUENTIAL）节点：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001、/node1/app0000000002 。\",\"临时顺序（EPHEMERAL_SEQUENTIAL）节点：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。\",\"可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。\",\"使用 Redis 实现分布式锁的时候，通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。\",\"假设不使用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。\",\"ZooKeeper通过临时节点解决释放锁逻辑失效问题，通过顺序节点解决顺序唤醒后续节点（避免竞争锁）。\"]},\"211\":{\"h\":\"为什么要设置对前一个节点的监听？\",\"t\":[\"当一个节点对应的客户端释放锁之后（也就是前一个节点被删除，监听的是删除事件），通知获取锁失败的客户端（唤醒等待线程，Java中的wait/notify），让它去获取锁。\"]},\"212\":{\"h\":\"Redis数据结构\",\"t\":[\"Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。\",\"这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。\",\"Redis 基本数据结构的底层数据结构实现如下：\",\"String\",\"List\",\"Hash\",\"Set\",\"Zset\",\"SDS\",\"LinkedList/ZipList/QuickList\",\"Hash Table、ZipList\",\"ZipList、Intset\",\"ZipList、SkipList\"]},\"213\":{\"h\":\"String（字符串）\",\"t\":[\"String 是 Redis 中最简单同时也是最常用的一个数据结构。\",\"String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。\",\"Redis自己构建了一种 简单动态字符串（Simple Dynamic String，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。\"]},\"214\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"SET key value\",\"设置指定 key 的值\",\"SETNX key value\",\"只有在 key 不存在时设置 key 的值\",\"GET key\",\"获取指定 key 的值\",\"MSET key1 value1 key2 value2 …\",\"设置一个或多个指定 key 的值\",\"MGET key1 key2 ...\",\"获取一个或多个指定 key 的值\",\"STRLEN key\",\"返回 key 所储存的字符串值的长度\",\"INCR key\",\"将 key 中储存的数字值增一\",\"DECR key\",\"将 key 中储存的数字值减一\",\"EXISTS key\",\"判断指定 key 是否存在\",\"DEL key（通用）\",\"删除指定的 key\",\"EXPIRE key seconds（通用）\",\"给指定 key 设置过期时间\"]},\"215\":{\"h\":\"应用场景\",\"t\":[\"需要存储常规数据的场景\",\"举例：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。\",\"相关命令：SET、GET。\",\"需要计数的场景\",\"举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。\",\"相关命令：SET、GET、 INCR、DECR 。\",\"分布式锁\",\"利用 SETNX key value 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。\"]},\"216\":{\"h\":\"List（列表）\",\"t\":[\"Redis 中的 List 其实就是链表数据结构的实现，Redis 的 List 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。\"]},\"217\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"RPUSH key value1 value2 ...\",\"在指定列表的尾部（右边）添加一个或多个元素\",\"LPUSH key value1 value2 ...\",\"在指定列表的头部（左边）添加一个或多个元素\",\"LSET key index value\",\"将指定列表索引 index 位置的值设置为 value\",\"LPOP key\",\"移除并获取指定列表的第一个元素(最左边)\",\"RPOP key\",\"移除并获取指定列表的最后一个元素(最右边)\",\"LLEN key\",\"获取列表元素数量\",\"LRANGE key start end\",\"获取列表 start 和 end 之间 的元素\"]},\"218\":{\"h\":\"应用场景\",\"t\":[\"信息流展示\",\"举例：最新文章、最新动态。\",\"相关命令：LPUSH、LRANGE。\",\"消息队列\",\"Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。\",\"相对来说，Redis 5.0 新增加的一个数据结构 Stream 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。\"]},\"219\":{\"h\":\"Hash（哈希）\",\"t\":[\"Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象。\",\"Hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。\"]},\"220\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"HSET key field value\",\"设置指定哈希表中指定字段的值\",\"HSETNX key field value\",\"只有指定字段不存在时设置指定字段的值\",\"HMSET key field1 value1 field2 value2 ...\",\"同时将一个或多个 field-value (域-值)对设置到指定哈希表中\",\"HGET key field\",\"获取指定哈希表中指定字段的值\",\"HMGET key field1 field2 ...\",\"获取指定哈希表中一个或者多个指定字段的值\",\"HGETALL key\",\"获取指定哈希表中所有的键值对\",\"HEXISTS key field\",\"查看指定哈希表中指定的字段是否存在\",\"HDEL key field1 field2 ...\",\"删除一个或多个哈希表字段\",\"HLEN key\",\"获取指定哈希表中字段的数量\",\"HINCRBY key field increment\",\"对指定哈希中的指定字段做运算操作（正数为加，负数为减）\",\"Hash数据结构添加需要三个参数，分别是hash的key、键、值，而String类型是两个参数。\"]},\"221\":{\"h\":\"应用场景\",\"t\":[\"对象数据存储场景\",\"举例：用户信息、商品信息、文章信息、购物车信息。\",\"相关命令：HSET （设置单个字段的值）、HMSET（设置多个字段的值）、HGET（获取单个字段的值）、HMGET（获取多个字段的值）。\"]},\"222\":{\"h\":\"Set（集合）\",\"t\":[\"Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。基于 Set 能轻易实现交集、并集、差集的操作，比如可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。\"]},\"223\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"SADD key member1 member2 ...\",\"向指定集合添加一个或多个元素\",\"SMEMBERS key\",\"获取指定集合中的所有元素\",\"SCARD key\",\"获取指定集合的元素数量\",\"SISMEMBER key member\",\"判断指定元素是否在指定集合中\",\"SINTER key1 key2 ...\",\"获取给定所有集合的交集\",\"SINTERSTORE destination key1 key2 ...\",\"将给定所有集合的交集存储在 destination 中\",\"SUNION key1 key2 ...\",\"获取给定所有集合的并集\",\"SUNIONSTORE destination key1 key2 ...\",\"将给定所有集合的并集存储在 destination 中\",\"SDIFF key1 key2 ...\",\"获取给定所有集合的差集\",\"SDIFFSTORE destination key1 key2 ...\",\"将给定所有集合的差集存储在 destination 中\",\"SPOP key count\",\"随机移除并获取指定集合中一个或多个元素\",\"SRANDMEMBER key count\",\"随机获取指定集合中指定数量的元素\"]},\"224\":{\"h\":\"应用场景\",\"t\":[\"需要存放的数据不能重复的场景\",\"举例：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等场景。\",\"相关命令：SCARD（获取集合数量） 。\",\"需要获取多个数据源交集、并集和差集的场景\",\"举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。\",\"相关命令：SINTER（交集）、SINTERSTORE （交集）、SUNION （并集）、SUNIONSTORE（并集）、SDIFF（差集）、SDIFFSTORE （差集）。\",\"需要随机获取数据源中的元素的场景\",\"举例：抽奖系统、随机点名等场景。\",\"相关命令：SPOP（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、SRANDMEMBER（随机获取集合中的元素，适合允许重复中奖的场景）。\"]},\"225\":{\"h\":\"Sorted Set（有序集合）\",\"t\":[\"Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。\"]},\"226\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"ZADD key score1 member1 score2 member2 ...\",\"向指定有序集合添加一个或多个元素\",\"ZCARD KEY\",\"获取指定有序集合的元素数量\",\"ZSCORE key member\",\"获取指定有序集合中指定元素的 score 值\",\"ZINTERSTORE destination numkeys key1 key2 ...\",\"将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量\",\"ZUNIONSTORE destination numkeys key1 key2 ...\",\"求并集，其它和 ZINTERSTORE 类似\",\"ZDIFFSTORE destination numkeys key1 key2 ...\",\"求差集，其它和 ZINTERSTORE 类似\",\"ZRANGE key start end\",\"获取指定有序集合 start 和 end 之间的元素（score 从低到高）\",\"ZREVRANGE key start end\",\"获取指定有序集合 start 和 end 之间的元素（score 从高到底）\",\"ZREVRANK key member\",\"获取指定有序集合中指定元素的排名(score 从大到小排序)\"]},\"227\":{\"h\":\"应用场景\",\"t\":[\"需要随机获取数据源中的元素根据某个权重进行排序的场景\",\"举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、游戏中的段位排行榜、话题热度排行榜等等。\",\"相关命令：ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。\",\"需要存储的数据有优先级或者重要程度的场景 比如优先级任务队列。\",\"举例：优先级任务队列。\",\"相关命令：ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。\"]},\"228\":{\"h\":\"Bitmap\",\"t\":[\"Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。\"]},\"229\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"SETBIT key offset value\",\"设置指定 offset 位置的值\",\"GETBIT key offset\",\"获取指定 offset 位置的值\",\"BITCOUNT key start end\",\"获取 start 和 end 之前值为 1 的元素个数\",\"BITOP operation destkey key1 key2 ...\",\"对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT\"]},\"230\":{\"h\":\"应用场景\",\"t\":[\"需要保存状态信息（0/1 即可表示）的场景\",\"举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。\",\"相关命令：SETBIT、GETBIT、BITCOUNT、BITOP。\"]},\"231\":{\"h\":\"HyperLogLog\",\"t\":[\"HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。\",\"Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近2^64个不同元素。并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：\",\"稀疏矩阵：计数较少的时候，占用空间很小。\",\"稠密矩阵：计数达到某个阈值的时候，占用 12k 的空间。\",\"基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 0.81% ）。\"]},\"232\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"PFADD key element1 element2 ...\",\"添加一个或多个元素到 HyperLogLog 中\",\"PFCOUNT key1 key2\",\"获取一个或者多个 HyperLogLog 的唯一计数。\",\"PFMERGE destkey sourcekey1 sourcekey2 ...\",\"将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。\"]},\"233\":{\"h\":\"应用场景\",\"t\":[\"数量量巨大（百万、千万级别以上）的计数场景\",\"举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、\",\"相关命令：PFADD、PFCOUNT 。\"]},\"234\":{\"h\":\"Geospatial index\",\"t\":[\"Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。\",\"通过 GEO 可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。\"]},\"235\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"GEOADD key longitude1 latitude1 member1 ...\",\"添加一个或多个元素对应的经纬度信息到 GEO 中\",\"GEOPOS key member1 member2 ...\",\"返回给定元素的经纬度信息\",\"GEODIST key member1 member2 M/KM/FT/MI\",\"返回两个给定元素之间的距离\",\"GEORADIUS key longitude latitude radius distance\",\"获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数\",\"GEORADIUSBYMEMBER key member radius distance\",\"类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素\",\"GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。\"]},\"236\":{\"h\":\"应用场景\",\"t\":[\"需要管理使用地理空间数据的场景\",\"举例：查找附近商铺。\",\"相关命令: GEOADD、GEORADIUS、GEORADIUSBYMEMBER 。\"]},\"237\":{\"h\":\"Redis持久化\"},\"238\":{\"h\":\"RDB持久化\",\"t\":[\"Redis Database Backup file 把内存中的所有数据都记录到磁盘中，当Redis实例故障之后，从磁盘中读取快照文件。\",\"快照持久化是Redis默认采用的持久化方式。\",\"Redis停机时会自动执行一次RDB。\",\"缺点 \",\"执行间隔很长，可能存在数据丢失的风险。\",\"fork子进程，压缩，写出RDB文件都比较耗时。\"]},\"239\":{\"h\":\"RDB创建快照的时候会阻塞主线程吗？\",\"t\":[\"Redis提供了两个命令来生成RDB快照文件：\",\"save：由主进程执行save，其他命令都会被阻塞；\",\"bgsave：fork出一个子进程，子进程执行，不会阻塞Redis主进程，默认选项。 \",\"子进程是fork主进程得到的，此时会阻塞主进程；\",\"子进程共享主进程的物理内存区域，加快fork速度；\",\"fork采用copy on write技术； \",\"主进程进行读的时候，访问共享内存；\",\"主进程执行写的时候，则会拷贝一份数据，执行写操作。\"]},\"240\":{\"h\":\"AOF持久化\",\"t\":[\"Append Only File 追加文件，redis处理的每一个命令都会记录在AOF文件中，可以看做是命令日志文件。\",\"与快照持久化相比，AOF持久化的实时性更好。默认情况下Redis没有开启AOF方式的持久化，通过appendonly参数开启。\",\"开启AOF持久化后没执行一条会更改Redis中的数据的命令，Redis就会将命令写入到AOF缓冲区中，最后再根据持久化方式的配置来决定何时将系统内核缓存区的数据同步到磁盘中。\",\"只有同步到磁盘中才算持久化保存，否则还是会存在数据丢失的风险。\"]},\"241\":{\"h\":\"AOF工作基本流程？\",\"t\":[\"AOF持久化功能的实现可以简单分为5步：\",\"命令追加（append）：所有的写命令会追加到AOF缓冲区中。\",\"文件写入（write）：将AOF缓冲区的数据写入到AOF文件中，这一步需要调用write函数，write将数据写入到了系统内核缓冲区之后直接返回。此时并没有同步到磁盘。\",\"文件同步（fsync）：AOF缓冲区根据对应的持久化方式向磁盘做同步操作，这一步需要调用fsync函数，fsync针对单个文件操作，对其进行强制磁盘同步，fsync将阻塞直到写入磁盘完成之后返回，保证数据的持久化。\",\"文件重写（rewrite）：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩目的。\",\"重启加载（load）：当Redis重启时，可以加载AOF文件进行数据恢复。\"]},\"242\":{\"h\":\"AOF持久化方式有哪些？\",\"t\":[\"appendonly开启，保存文件的频率有三种：\",\"appendfsync always ：主线程调用 write 执行写操作后，后台线程调用fsync保存aof文件到磁盘，严重影响性能。\",\"appendfsync everysec ：主线程调用 write 执行写操作后，后台线程每秒调用fsync保存aof文件。\",\"appendfsync no： 主线程调用 write 执行写操作后将数据写入AOF缓冲区，由操作系统决定什么时候写回磁盘。\"]},\"243\":{\"h\":\"AOF为什么是在执行完命令之后记录日志？\",\"t\":[\"关系型数据库通常都是执行命令之前记录日志，而Redis AOF持久化机制是在执行完命令之后再记录日志。\",\"为什么？\",\"避免额外的检查开销，AOF记录日志不会对命令进行语法检查；\",\"在命令执行完之后再记录，不会阻塞当前的命令执行。\",\"同时也带来了风险：\",\"如果刚执行完命令Redis宕机了就会导致对应的修改记录丢失；\",\"可能会阻塞后续其他命令的执行。\"]},\"244\":{\"h\":\"AOF重写了解吗？\",\"t\":[\"当AOF变得太大时，Redis能在后台自动重写AOF产生一个新的AOF文件，新的AOF文件和原有AOF文件所保存的数据库状态一直，但是体积更小。\",\"由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。\",\"AOF 文件重写期间，Redis 还会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。\",\"使用BGREWRITEAOF可以手动让AOF文件执行重写功能。\",\"也可以通过以下配置，让程序自动决定触发时机：\",\"auto-aof-rewrite-percentage 100：这次的文件大小比上次增长超过100%则重写，默认值100，设置为0表示禁用自动重写。\",\"auto-aof-rewrite-min-size 64mb：文件体积大于多少时执行重写，默认值64MB。\"]},\"245\":{\"h\":\"AOF 校验机制了解吗？\",\"t\":[\"AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。通过使用一种叫做 **校验和（checksum）**的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。\",\"因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。\"]},\"246\":{\"h\":\"如何选择 RDB 和 AOF？\",\"t\":[\"RDB 比 AOF 优秀的地方：\",\"RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。\",\"使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。\",\"AOF 比 RDB 优秀的地方：\",\"RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。\",\"RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。\",\"AOF 以一种易于理解和解析的格式包含所有操作的日志。可以轻松地导出 AOF 文件进行分析，也可以直接操作 AOF 文件来解决一些问题。比如，如果执行FLUSHALL命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。\",\"综上：\",\"Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。\",\"不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。\",\"如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。\",\"RDB\",\"AOF\",\"持久化方式\",\"定时对整个内存创建快照\",\"记录每一次执行的命令\",\"数据完整性\",\"不完整，两次备份之间的操作会丢失\",\"相对完整，取决于刷盘策略\",\"文件大小\",\"会有压缩，文件体积小\",\"记录命令，文件体积很大\",\"宕机恢复速度\",\"很快\",\"慢\",\"数据恢复优先级\",\"低，因为数据完整性不如AOF\",\"高，数据完整性更高\",\"系统占用资源\",\"高，大量CPU和内存消耗（创建快照时）\",\"低，主要是磁盘IO资源，但是AOF重写时会占用大量CPU和内存资源\",\"使用场景\",\"可以容忍数据部分不完整，追求更快的启动速度的场景\",\"对数据完整性安全性要求较高的场景\"]},\"247\":{\"h\":\"Redis\"},\"248\":{\"h\":\"Java集合一\"},\"249\":{\"h\":\"集合\",\"t\":[\"Java集合由两大接口派生而来，分别是用来存放单一元素的Collection和用来存放键值对的Map接口。对于Collection接口有三个子接口，分别是List、Set、Queue。\"]},\"250\":{\"h\":\"说说 List, Set, Queue, Map 四者的区别？\",\"t\":[\"List（顺序存储）存储的元素是有序的，可以重复；\",\"Set（独一无二）存储的元素无序，不可重复；\",\"Queue（排队）按特定的排队规则确定元素先后顺序，元素是有序的，可重复的；\",\"Map（用key搜索）使用键值对存储，key是无序的，不可重复的，value是无序的，可重复的。\"]},\"251\":{\"h\":\"集合框架底层数据结构\",\"t\":[\"List\",\"ArrayList：Object[]数组；\",\"Vector：Object[]数组；\",\"LinkedList：双向链表（JDK1.6之前为循环链表，JDK1.7取消）。\",\"Set\",\"HashSet（无序，唯一）：基于HashMap实现，底层使用HashMap保存数据；\",\"LinkedHashMap：LinkedHashSet是HashSet子类，内部都是通过LinkedHashMap实现；\",\"TreeSet（有序，唯一）：红黑树（自平衡的排序二叉树）。\",\"Queue\",\"PriorityQueue: Object[] 数组来实现二叉堆；\",\"ArrayQueue: Object[] 数组 + 双指针。\",\"Map\",\"HashMap：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在。JDK1.8 以后由数组+链表/红黑树组成，当链表长度大于阈值（默认为8），数组长度大于等于64的时候会进行树化，转化为红黑树加快查找。\",\"LinkedHashMap：LinkedHashMap 继承自 HashMap，底层是数组+链表/红黑树。LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。\",\"Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在\"]},\"252\":{\"h\":\"List\"},\"253\":{\"h\":\"说说ArrayList\",\"t\":[\"ArrayList存储元素的特点是顺序，可重复；\",\"ArrayList会根据实际存储的元素动态扩容或者缩容；\",\"ArrayList只能存储对象，不能存储基本类型，需要使用包装类；\",\"ArrayList支持插入、删除、遍历等操作；\",\"ArrayList能插入null；\",\"超过容量之后触发扩容；\",\"扩容后大小为int newCapacity = oldCapacity + (oldCapacity >> 1);;\",\"JDK1.8以无参数构造方法创建ArrayList时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。\"]},\"254\":{\"h\":\"ArryList和Vector区别？\",\"t\":[\"ArrayList是List的主要实现类，底层用Object[]存储，适用于频繁查找的场景，线程不安全；\",\"Vector是List的古老实现类，底层用Object[]存储，线程安全。\"]},\"255\":{\"h\":\"ArrayList 与 LinkedList 区别?\",\"t\":[\"首先两者都不是线程安全的实现；\",\"ArrayList底层使用Object[]存储元素，LinkedList底层使用双向链表存储数据（JDK1.6之前为循环链表，1.7取消循环）；\",\"ArrayList实现了RandomAccess接口，可以随机访问，LinkedList不支持随机访问；\",\"由于LinkedList内部包含前驱和后继，占用内存比ArrayList大。\"]},\"256\":{\"h\":\"Set\"},\"257\":{\"h\":\"比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\",\"t\":[\"HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。\",\"HashSet底层是哈希表，LinkedHashSet底层是链表和哈希表，元素的插入满足队列特性，TreeSet底层是红黑树，元素是有序的。\",\"根据应用场景不同，对元素顺序无要求则用HashSet，有要求使用TreeSet，需要满足FIFO使用LinkedHashSet。\"]},\"258\":{\"h\":\"Queue\",\"t\":[\"队列满足FIFO性质，Queue因为容量问题导致操作失败后的处理方式不同分为两类方法；\",\"Queue\",\"抛出异常\",\"返回特殊值\",\"插入队尾\",\"add(E e)\",\"offer(E e)\",\"删除队首\",\"remove()\",\"poll()\",\"查询队首元素\",\"element()\",\"peek()\",\"Deque是双端队列，在队列两端都能插入和删除元素，同样根据返回值不同分为两类方法\",\"Deque\",\"抛出异常\",\"返回特殊值\",\"插入队尾\",\"addFirst(E e)\",\"offerFirst(E e)\",\"插入队首\",\"addLast(E e)\",\"offerLast(E e)\",\"删除队首\",\"removeFirst()\",\"pollFirst()\",\"删除队尾\",\"removeLast()\",\"pollLast()\",\"查询队首元素\",\"getFirst()\",\"peekFirst()\",\"查询队尾元素\",\"getLast()\",\"peekLast()\"]},\"259\":{\"h\":\"ArrayDeque 与 LinkedList 的区别\",\"t\":[\"ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现；\",\"ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持；\",\"ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在；\",\"ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。\"]},\"260\":{\"h\":\"PriorityQueue\",\"t\":[\"PriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。\",\"PriorityQueue使用变长数组存储元素，使用二叉堆实现结构；\",\"PriorityQueue使用堆实现了在O(logn)的时间复杂度内插入和删除元素；\",\"PriorityQueue是线程不安全的，不支持存储null和non-comparable对象；\",\"PriorityQueue默认是小顶堆。\",\"堆排序的伪代码（重要）。\",\"//调整函数 建立大顶堆 void Sift(int R[], int low, int high){ int i = low; int j =2*i; int temp = R[i]; while(j<=high){ if(j < high && R[j] < R[i+1]) ++j;//j指向左右孩子中大的那个 if(temp < R[j]){ R[i] = R[j]; i = j; j = 2*i; }else{ break; } } R[i] = temp; } //堆排序 void headSort(int R[], int n){ int i; int temp; for (int j = n / 2; j >= 1; j--) { Sift(R,i,n); } for (i = n; i >= 2; --i){ temp = R[1]; R[1] = R[i]; R[i] = temp; Sift(R, 1, i-1); } } \"]},\"261\":{\"h\":\"BlockingQueue\",\"t\":[\"BlockingQueue （阻塞队列）是一个接口，继承自 Queue。BlockingQueue阻塞的原因是其支持当队列没有元素时一直阻塞，直到有有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。\",\"BlockingQueue 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。\"]},\"262\":{\"h\":\"Java集合二\"},\"263\":{\"h\":\"Map\"},\"264\":{\"h\":\"HashMap 和 Hashtable 的区别\",\"t\":[\"线程是否安全：HashMap是非线程安全的，Hashtable是线程安全的，内部方法使用synchronized修饰。\",\"效率：因为锁的问题，HashMap的效率要稍微好点。\",\"是否能存储Null Key和Value：HashMap能存储null的key和value，但是作为null的key只能有一个，Hashtable不能有nullkey和value。\",\"扩容：Hashtable默认初始大小是11，扩容之后变为2n+1。HashMap默认大小是16，当元素个数超过负载因子*表长时扩容，每次扩容变为原来的两倍。\",\"底层：JDK1.8之后HashMap底层使用数组+链表/红黑树，特定条件链表转化为红黑树，Hashtable则没有转化为红黑树的机制。\"]},\"265\":{\"h\":\"HashMap 和 TreeMap 区别\",\"t\":[\"TreeMap 和HashMap 都继承自AbstractMap ，TreeMap还实现了NavigableMap接口和SortedMap 接口。实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序。\"]},\"266\":{\"h\":\"HashMap 的底层实现\"},\"267\":{\"h\":\"JDK1.8 之前\",\"t\":[\"JDK1.8之前HashMap底层是数组和链表集合一起，通过key的hashcode经过扰动函数之后获得hash值，通过(n-1)&hash计算元素存放的位置。\",\"找到存放位置之后判断当前位置元素和要存入的元素hash值和key是否相同，相同则直接覆盖，否则通过链表法解决冲突。\",\"JDK1.8中的扰动函数源码：\",\"static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^：按位异或 // >>>:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } \"]},\"268\":{\"h\":\"JDK1.8 之后\",\"t\":[\"JDK1.8之后HashMap使用数组+链表/红黑树作为底层，当单个链表的长度大于8（默认8），数组长度大于等于64的时候就会触发树化，将链表转化为红黑树，以此减少查找时间。\"]},\"269\":{\"h\":\"HashMap 的长度为什么是 2 的幂次方?\",\"t\":[\"Hash值的取值为32位补码的取值范围，一般情况很难出现碰撞。但是范围过大不可能直接放入内存中进行计算，因此需要先通过取模运算（数据结构散列表中除留余数法），通过位运算实现取模。\",\"假设数组长度n为16；Hash值为0111 0000 1001 0000 000 1001 1110 1101 \",\"Hash\",\"0111 0000 1001 0000 0000 1001 1110 1101\",\"n-1\",\"0000 0000 0000 0000 0000 0000 0000 1111\",\"Hash&(n-1)\",\"0000 0000 0000 0000 0000 0000 0000 1101\"]},\"270\":{\"h\":\"HashMap 多线程操作导致死链问题\",\"t\":[\"JDK1.7 及之前版本的 HashMap 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。\",\"JDK1.8之后通过尾插法解决上述问题。但是在多线程下还是会出现数据覆盖问题，推荐使用线程安全的CucurrentHashMap。\"]},\"271\":{\"h\":\"ConcurrentHashMap 和 Hashtable 的区别\",\"t\":[\"ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\",\"底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 分段的Segment、HashEntry数组+链表 实现，JDK1.8 时采用**Node+链表/红黑二叉树**。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。\",\"实现线程安全的方式（重要）： \",\"JDK1.7的时候，ConcurrentHashMap 底层采用 分段的Segment、HashEntry数组+链表 实现，每一把锁锁住一个Segment，Segment的个数固定默认16，也就是并发度固定为16。\",\"到了 JDK1.8 的时候，ConcurrentHashMap 已经摒弃了 Segment 的概念，改用**Node数组+链表/红黑树**，采用 Node + CAS + synchronized 来保证并发安全。\",\"Hashtable使用同一个锁进行并发控制，效率低下。\"]},\"272\":{\"h\":\"JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？\",\"t\":[\"线程安全实现方式：\",\"线程安全实现方式：JDK 1.7 采用 Segment 分段锁来保证安全， Segment 是继承自 ReentrantLock。JDK1.8 放弃了 Segment 分段锁的设计，采用 Node + CAS + synchronized 保证线程安全，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点。\",\"Hash解决碰撞办法：JDK1.7采用拉链法，JDK1.8采用拉链法+红黑树。\",\"并发度：JDK1.7中最大的并发度是Segment的个数，默认是16。JDK1.8最大并发度是Node的个数，并发度更大。\"]},\"273\":{\"h\":\"集合\"},\"274\":{\"h\":\"Java基础一\",\"t\":[\"一切就从这里开始吧\",\"笔记来源网络，仅做个人学习。\"]},\"275\":{\"h\":\"JVM JRE JDK\",\"t\":[\"JVM是java虚拟机，针对不同系统有不同的实现，常用的为HotSpot VM。\",\"JDK是功能齐全的SDK，包含JRE和一些其他的工具，例如javac，java等。\",\"JRE是Java运行时环境，仅包含Java应用程序运行时的必要环境。\"]},\"276\":{\"h\":\"什么是字节码？采用字节码的好处？\",\"t\":[\"JVM能理解的代码就是字节码，字节码解决了传统解释语言运行效率低的问题，还具有很好的可移植性，一次编译，任何地方运行。\",\".java文件经过javac编译之后变成.class文件，.class通过解释器和JIT（运行时编译器）编译成机器可以理解的代码，JIT完成一次编译之后，就会将对应的机器码保存下来，之后复用，其中编译的是热点代码。所以Java也是编译与解释共存的语言。\"]},\"277\":{\"h\":\"Java 和 C++ 的区别\",\"t\":[\"Java和C++都是面向对象的语言，都支持封装继承多态。\",\"Java不支持通过指针来直接访问内存，程序内存更加安全。\",\"Java的类是单继承的，C++支持多继承。\",\"Java有自动的垃圾回收机制，不需要手动释放内存。\"]},\"278\":{\"h\":\"基本数据类型\",\"t\":[\"Java有8种基本数据类型：\",\"6种数字类型 \",\"4种整数类型：byte、short、int、long\",\"2种浮点数类型：float、double\",\"1种字符类型：char\",\"1种布尔类型：boolean\"]},\"279\":{\"h\":\"基本类型和包装类型\",\"t\":[\"包装类型能用于泛型，而基本类型不可以。\",\"基本数据类型的局部变量存放在Java虚拟机栈中的局部变量表中（线程私有），基本数据类型的成员变量没有被static修饰的话放在堆中。而包装类型属于对象类型。\",\"包装类型占用的空间比基本类型要大。\",\"成员包装类型不赋值就是null，而基本类型有默认值并且不是null。\",\"基本数据类型使用==进行比较，而包装类型通过equals()进行比较。\",\"在HotSpot虚拟机中引入JIT优化之后，会对对象进行逃逸分析，如果对象的作用范围没有超过当前方法，则可能通过标量替换来实现栈（线程私有）上分配，避免堆上分配对象。\"]},\"280\":{\"h\":\"包装类的缓存机制\",\"t\":[\"Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，8位补码的表示范围。\",\"Character创建了 [0，127] 范围的缓存数据，7位无符号数的表示范围，Boolean直接返回True或者是False。\"]},\"281\":{\"h\":\"自动拆装箱\",\"t\":[\"装箱就是使用包装类的valueOf方法，拆箱就是使用xxValue方法。\",\"Integer i=10等价于Integer i = Integer.valueOf(10)\",\"int n = i 等价于int n = i.intValue()\"]},\"282\":{\"h\":\"浮点数运算的时候会有精度丢失的风险？\",\"t\":[\"计算机组成原理第二章浮点加减法。\"]},\"283\":{\"h\":\"如何解决浮点数运算的时候精度丢失问题？\",\"t\":[\"使用BigDecimal类进行浮点数运算，不会造成精度丢失问题。\"]},\"284\":{\"h\":\"超过long 64位补码的范围数字应该如何表示？\",\"t\":[\"通过BigInteger存储，BigInteger内部使用int[]存储任意大小的整型数据。\"]},\"285\":{\"h\":\"变量\",\"t\":[\"public class Example{ //成员变量 private String name; private int age; public void method(){ int num1 = 0;//栈中分配的局部变量，没有逃逸出本方法 System.out.println(num1); } // 带参数的方法中的局部变量 public void method2(int num2) { int sum = num2 + 10; // 栈中分配的局部变量 System.out.println(sum); } } \"]},\"286\":{\"h\":\"静态变量\",\"t\":[\"静态变量就是被static修饰的变量，被static修饰的变量为类所共享的，无论创建了多少个类实例，这个变量都是共享的，只会分配一次内存，静态变量通过类名.进行访问。\",\"通常情况下被final修饰的static变量会成为常量。\"]},\"287\":{\"h\":\"方法\"},\"288\":{\"h\":\"静态方法为什么不能调用非静态成员？\",\"t\":[\"静态方法属于类，在类加载的时候就会分配内存，通过类名直接访问，非静态方法属于实例对象，需要通过类的实例对象去调用。\",\"在类的非静态成员不存在的时候静态方法就已经存在，此时调用内存中不存在的非静态成员不合法。\"]},\"289\":{\"h\":\"重载和重写\",\"t\":[\"重载就是对同一个方法根据输入的不同作出不同的方法处理。\",\"重写一般在子类继承父类，输入的数据一样，但是方法内的代码不同。\",\"重载\",\"public class Example { public void method(String a) { System.out.println(\\\"输入了一个参数\\\"); } public void method(String a, String b) { System.out.println(\\\"输入了两个参数\\\"); } } \",\"重写\",\"重写发生在运行时，是子类对父类方法的实现过程重新编写\",\"方法名，参数列表必须相同，子类方法返回值类型比父类方法返回值类型更小或者是相等，子类抛出的异常应该小于或者等于父类，访问修饰符范围大于等于父类\",\"如果父类方法访问修饰符是private/final/static则子类不能重写方法，被static修饰的方法能被再次声明。\",\"构造方法无法被重写\",\"方法的重写要遵循“两同两小一大”\",\"“两同”即方法名相同、形参列表相同；\",\"“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；\",\"“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。\"]},\"290\":{\"h\":\"Java基础二\"},\"291\":{\"h\":\"面向对象\"},\"292\":{\"h\":\"面向对象和面向过程的区别\",\"t\":[\"面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。\",\"面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。\",\"一个注重过程，一个注重内部属性。\"]},\"293\":{\"h\":\"对象的相等和引用的相等\",\"t\":[\"对象的相等是是比较内存中存放的对象是否相等。\",\"引用相等是指向的内存地址是否相等。\",\"String str1 = \\\"a\\\"; String str2 = new String(\\\"a\\\"); String str3 = \\\"a\\\"; System.out.println(str1 == str2);//false System.out.println(str1 == str3);//true System.out.println(str1.equals(str2));//true System.out.println(str1.equals(str3));//true \",\"System.out.println(str1 == str2);//false\",\"☀️详见String。\"]},\"294\":{\"h\":\"如果没有声明构造方法，程序能正确执行吗？\",\"t\":[\"如果类没有声明构造方法则会默认生成一个不带参数的构造方法。\",\"如果自己添加了构造方法无论是否有参数都不会再自动生成无参构造方法。\",\"构造方法不能被重写@Override，但是能重载（有参构造和无参构造）。\"]},\"295\":{\"h\":\"面向对象的三个特征\",\"t\":[\"封装\",\"封装是将一个对象的状态信息隐藏在内部，不允许外部直接访问这些属性，但是会提供方法来操作属性。\",\"继承\",\"不同类型的对象可能会具有相似特点，例如游戏中的每一个英雄都有血量，移速等基础属性，但是每一个英雄的技能各有不同，则可以通过继承复用减少开发难度。\",\"子类拥有父类的所有属性和方法（包括私有属性和私有方法）。\",\"子类能对父类进行扩展。\",\"多态\",\"表示一个对象具有多种状态，上述代码中创建对象：\",\"Hero hero = new Hero1(); hero.skill();//打印技能1，编译是否能通过看左边，执行结果看右边。 \",\"对象类型和引用类型之间具有继承/实现关系；\",\"引用类型变量发出的方法调用到底是哪个类中的方法，在程序运行的时候才能确定；\",\"多态不能调用只在子类中存在，但是父类中不存在的方法，也就是hero能调用的方法是看父类Hero的，执行的结果看子类Hero1；\",\"如果子类重写了父类方法，则执行的是子类中的方法，如果没有重写则执行的是父类中的方法。\"]},\"296\":{\"h\":\"接口和抽象类的共同点\",\"t\":[\"共同点\",\"都不能被实例化；\",\"都可以包含抽象方法；\",\"都可以有默认的实现方法（Java8可以用default关键字在接口中定义默认方法）。\",\"不同点\",\"接口强调行为的约束，实现某个接口就相当于有某个责任，必须实现对应的方法，继承则是强调复用，子类继承父类并不一定要重写父类方法；\",\"一个类只能extends一个类，但是能implements多个接口；\",\"接口中的成员变量只能是public static final类型，不能被修改而且必须有初始值，抽象类中的成员变量默认default，可以在子类中被重新定义，重新赋值。\"]},\"297\":{\"h\":\"浅拷贝，深拷贝，引用拷贝\",\"t\":[\"浅拷贝\",\"在堆上创建一个新对象N，N对象中的内部对象是引用类型的话，会直接复制原本类O的内部对象引用地址；\",\"也就是新对象N内部对象和原来的对象O的内部对象是同一个。\",\"深拷贝\",\"不仅仅拷贝对象，将原本对象内部的所有属性都单独复制一份；\",\"新对象的内部引用对象不再是原来对象的内部引用对象。\",\"引用拷贝\",\"两个不同对象的引用指向同一个对象。\"]},\"298\":{\"h\":\"Object\"},\"299\":{\"h\":\"==和equals区别\",\"t\":[\"对于基本类型来说==是比较值；\",\"对于引用类型来说==是比较地址。\",\"equals存在两种情况：\",\"类没有重写equals方法：则通过equals比较两个对象的时候等价于==；\",\"重写了equals方法：则是比较两个对象内部的属性是否相等。\",\"创建String类型的对象，虚拟机会在字符串常量池中查找有没有相同值的对象，如果有则直接返回这个对象的引用，如果没有就创建一个String对象。\"]},\"300\":{\"h\":\"hashCode()作用\",\"t\":[\"hashCode()方法用来获哈希码，作用是确定在哈希表中的位置。\",\"hashCode()定义在Object类中，所以所有的对象都有这个方法。hashCode()是本地方法，也就是通过C或者是C++实现的。\",\"HashMap通过计算Hash值使得查找元素的时间复杂度为1，数据结构散列表。\"]},\"301\":{\"h\":\"为什么重写 equals() 时必须重写 hashCode() 方法？\",\"t\":[\"Java中如果两个对象相同则HashCode，必须相等；\",\"如果HashCode相同，则对象不一定相等；\",\"如果两个对象的HashCode不同则对象一定不同。\",\"重写equals()代表这个方法是用来比较两个对象是否相等，如果不重写HashCode()方法可能会导致判断是相等的两个对象但是HashCode不等。\"]},\"302\":{\"h\":\"String\"},\"303\":{\"h\":\"String、StringBuffer、StringBuilder 的区别？\",\"t\":[\"String是不可变的，可以看成常量，线程安全。对内部方法加了同步锁，是线程安全的。StringBuilder没有添加同步锁，所以是线程不安全的。\",\"每次对String类型进行修改的时候，都会新生成一个String类型，然后将引用指向新的String对象。StringBuffer和StringBuilder是对对象本身进行操作，不会生成新的对象，相同情况下使用StringBuilder会带来一点性能提升，但是线程不安全。\",\"少量数据使用String，单线程下大量数据使用StringBuilder，多线程下使用StringBuffer。\"]},\"304\":{\"h\":\"String为何不可变？\",\"t\":[\"JDK8中的源码：\",\"public final class String implements java.io.Serializable, Comparable<String>, CharSequence { private final char value[]; //... } \",\"保存字符串的数组是final修饰的，并且内部没有暴露能修改这个数组的方法；\",\"String类本身也被final修饰导致不能被继承，从而避免子类破坏String的不变性。\"]},\"305\":{\"h\":\"字符串拼接用“+” 还是 StringBuilder?\",\"t\":[\"+和+=是Java中唯二为String重载过的运算符。\",\"String对象使用+进行拼接，实际就是通过StringBuilder调用append()方法，拼完之后调用toString()方法返回String对象。\",\"相关信息\",\"如果在循环内使用+进行拼接多个字符串，编译器不会复用StringBuilder，而是每次循环都创建一个StringBuilder。\",\"直接使用StringBuilder进行拼接就能解决这个问题。\"]},\"306\":{\"h\":\"String s1 = new String(\\\"abc\\\");这句话创建了几个字符串对象？\",\"t\":[\"会创建1个或者2个字符串对象。\",\"String str = new String(\\\"abc\\\");\",\"String str = new String(\\\"abc\\\"); \",\"如果字符串常量池中不存在\\\"abc\\\"的引用，则会在堆中创建2个字符串对象\\\"abc\\\"。一个是在字符串常量池中创建的\\\"abc\\\"，另外是new在堆中创建的对象。\",\"如果字符串常量池中存在\\\"abc\\\"的引用，则会在堆中创建1个字符串对象\\\"abc\\\"。也就是new在堆中创建的对象。\",\"示意图：\"]},\"307\":{\"h\":\"String#intern 方法有什么作用?\",\"t\":[\"String.intern()是一个本地方法，作用是将指定的字符串对象保存到字符串常量池中。\",\"如果字符串常量池中保存了对应的字符串对象的引用，则返回引用。\",\"如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。\",\"// 在堆中创建字符串对象”Java“ // 将字符串对象”Java“的引用保存在字符串常量池中 String s1 = \\\"Java\\\"; // 直接返回字符串常量池中字符串对象”Java“对应的引用 String s2 = s1.intern(); // 会在堆中在单独创建一个字符串对象 String s3 = new String(\\\"Java\\\"); // 直接返回字符串常量池中字符串对象”Java“对应的引用 String s4 = s3.intern(); // s1 和 s2 指向的是堆中的同一个对象 System.out.println(s1 == s2); // true // s3 和 s4 指向的是堆中不同的对象 System.out.println(s3 == s4); // false // s1 和 s4 指向的是堆中的同一个对象 System.out.println(s1 == s4); //true \"]},\"308\":{\"h\":\"编译器对字符串拼接的优化\",\"t\":[\"String str1 = \\\"a\\\"; String str2 = \\\"b\\\"; String str3 = \\\"a\\\" + \\\"b\\\";//常量池中创建的对象 String str4 = str1 + str2;//堆中创建的对象 \",\"对于String str3 = \\\"a\\\" + \\\"b\\\"等价于String str3 = \\\"ab\\\"；对于在编译期间就能确定的字符串，编译器会在编译期间直接放入字符串常量池中。\",\"String str4 = str1 + str2;则不会在编译期间确定结果，不会产生优化。\",\"final String str1 = \\\"str\\\"; final String str2 = \\\"ing\\\"; // 下面两个表达式其实是等价的 String c = \\\"str\\\" + \\\"ing\\\";// 常量池中的对象 String d = str1 + str2; // 常量池中的对象 System.out.println(c == d);// true \",\"使用final修饰则看成常量，在编译期间就会优化放入字符串常量池中。\"]},\"309\":{\"h\":\"Java值传递\"},\"310\":{\"h\":\"形参和实参\",\"t\":[\"String s = \\\"abc\\\"; //s 为实参 method(s); //str 为形参 void method(String str){ System.out.println(str); } \"]},\"311\":{\"h\":\"值传递&引用传递\",\"t\":[\"值传递：方法接收的是实参的拷贝，会创建副本；\",\"引用传递：方法接收的直接是实参所引用对象在堆中的地址，不会创建副本，对形参的修改将会影响到实参。\"]},\"312\":{\"h\":\"Java只有值传递\",\"t\":[\"public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); change(arr); System.out.println(arr[0]);//输出为 0 } public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0; } \",\"array为引用类型，但是不称为引用传递，案例中仍然是值传递，值是实参的地址。\",\"引用传递值得是：对形参本身修改会导致实参变化。\"]},\"313\":{\"h\":\"Java序列化\",\"t\":[\"序列化：将数据结构或对象转换成二进制字节流的过程\",\"反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程\",\"序列化协议属于TCP/IP中的应用层。\",\"Java中通过实现Serializable接口实现序列化功能。\"]},\"314\":{\"h\":\"serialVersionUID 有什么作用？\",\"t\":[\"serialVersionUID的作用是版本控制，反序列化的时候会检查serialVersionUID是否和当前类的serialVersionUID相同，如果不同则会抛出InvalidClassException异常。如果不指定serialVersionUID，编译器会自动生成。\",\"private static final long serialVersionUID = 1905122041950251207L; \",\"serialVersionUID用来给JVM识别的，并不会被序列化。\"]},\"315\":{\"h\":\"Java反射\",\"t\":[\"反射可以获取任意一个类的所有属性和方法，还能调用这些方法和属性。\"]},\"316\":{\"h\":\"反射的应用场景\",\"t\":[\"Spring/SpringBoot/Mybatis等框架中都大量使用了反射机制。\",\"框架中也使用了动态代理，动态代理就是依赖反射。\",\"JDK动态代理：\",\"public class DebugInvocationHandler implements InvocationHandler { /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException { System.out.println(\\\"before method \\\" + method.getName()); Object result = method.invoke(target, args); System.out.println(\\\"after method \\\" + method.getName()); return result; } } \",\"其中的Method就是反射类。\",\"SpringBoot中使用@Component就能声明一个Bean，原理就是基于反射获取到对应类上的注解，再做处理。\"]},\"317\":{\"h\":\"反射的优缺点\",\"t\":[\"优点：让代码更加灵活，为各种框架提供开箱即用的便利。\",\"缺点：拥有分析操作类的能力，增加了安全隐患。\"]},\"318\":{\"h\":\"反射获取Class对象\",\"t\":[\"知道具体类的情况下：\",\"Class clazz = Target.class; \",\"通过Class.forName()传入类的全路径名：\",\"Class clazz = Class.forName(\\\"com.zyl.Target\\\"); \",\"通过实例对象的getClass()获取：\",\"Target t = new Target(); Class clazz = t.getClass(); \",\"通过类加载器xxxClassLoader.loadClasss()传入类路径获取：\",\"ClassLoader.getSystemClassLoader().loadClass(\\\"com.zyl.Target\\\"); \",\"通过类加载器获取Class对象不会进行初始化，意味着静态代码块和静态对象不会得到执行。\"]},\"319\":{\"h\":\"获取方法并执行\",\"t\":[\"Method privateMethod = targetClass.getDeclaredMethod(\\\"privateMethod\\\"); //为了调用private方法取消安全检查 privateMethod.setAccessible(true); privateMethod.invoke(targetObject); \"]},\"320\":{\"h\":\"代理模式\",\"t\":[\"使用代理对象来代替真实对象的访问，这样能在不改变目标对象的前提下，提供额外的功能，扩展目标对象。\",\"代理模式有静态代理和动态代理两种实现方式。\"]},\"321\":{\"h\":\"静态代理\",\"t\":[\"静态代理中，对方法的增强是手动完成的，非常不灵活，从JVM层面来说，静态代理在编译的时候就将接口、实现类、代理类变成一个个class文件。编译从.java变成.class。\"]},\"322\":{\"h\":\"动态代理\",\"t\":[\"相对于静态代理，动态代理更加灵活，不需要对每一个目标对象创建一个代理类，也不需要强制实现接口。\",\"动态代理属于运行时动态生成类字节码，并加载到JVM中。\",\"动态代理主要有两种：JDK动态代理、CGLIB动态代理。\"]},\"323\":{\"h\":\"JDK动态代理\",\"t\":[\"Java中动态代理中InvocationHandler接口和Proxy类是核心。\",\"Proxy类中使用较多的方法是newProxyInstance()，用来生成一个代理对象。\",\"public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException { ...... } \",\"newProxyInstance()方法有三个参数：\",\"loader：类加载器，用来加载代理对象；\",\"interfaces：被代理类实现的接口；\",\"h：实现了InvocationHandler接口的对象。\",\"要实现动态代理，还要实现InvocationHandler接口，使用动态代理类调用方法的时候，方法就会被转发到实现InvocationHandler接口类的invoke方法来调用。\",\"public interface InvocationHandler { /** * 当你使用代理对象调用方法的时候实际会调用到这个方法 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; } \",\"invoke()方法有三个参数：\",\"proxy：动态生成的代理类；\",\"method：与代理类对象调用的方法相对应；\",\"args：当前method方法的参数。\",\"流程：通过proxy类的newInstance()创建代理对象调用方法，会实际调用实现InvocationHandler接口类的invoke()方法。\",\"实现：\"]},\"324\":{\"h\":\"CGLIB动态代理\",\"t\":[\"JDK代理需要实现接口的类才能作为目标对象，为了解决这个问题，可以使用CGLIB动态代理。\",\"CGLIB动态代理中MethodIntercepter接口和Enhancer类是核心。\",\"需要自定义接口MethodIntercepter并重写intercept方法，用于拦截增强被代理类的方法。\",\"public interface MethodInterceptor extends Callback{ // 拦截被代理类中的方法 public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy) throws Throwable; } \",\"obj：被代理的对象（需要增强的对象）；\",\"method：被拦截的方法；\",\"args：方法参数；\",\"proxy：用于调用原始方法。\",\"通过Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是MethodInterceptor中的intercept方法。\",\"实现：\",\"添加依赖\",\"<dependency> <groupId>cglib</groupId> <artifactId>cglib</artifactId> <version>3.3.0</version> </dependency> \"]},\"325\":{\"h\":\"JDK动态代理和CGLIB动态代理的区别\",\"t\":[\"1.JDK动态代理需要目标类实现接口或直接代理接口，CGLIB则不需要，CGLIB是通过生成一个被代理类的子类来拦截代理类的方法调用，因此不能代理声明final类型的类和方法。\",\"JDK动态代理的效率要更好。\"]},\"326\":{\"h\":\"静态代理和动态代理的区别\",\"t\":[\"动态代理更加灵活，不需要实现接口可以直接代理实现类，并且不用为每一个目标类都创建一个代理类，静态代理中接口新增方法，则目标类和代理类都要修改。\",\"静态代理在编译时就将接口、实现类、代理类这些都变成一个个class文件，而动态代理是在运行时产生class文件，并加载到JVM中。\"]},\"327\":{\"h\":\"单例模式\",\"t\":[\"保证在整个系统中，对某一个类只会存在一个对象实例，并且类只提供一个取得对象实例的方法。\"]},\"328\":{\"h\":\"单例模式实现方式\",\"t\":[\"饿汉式 \",\"静态常量\",\"静态代码块\",\"懒汉式 \",\"线程不安全法(不推荐)\",\"线程安全法，同步方法(不推荐)\",\"线程安全，同步代码块\",\"其他 \",\"双重检查（重要）\",\"静态内部类（重要）\",\"枚举\"]},\"329\":{\"h\":\"饿汉式（静态常量）\",\"t\":[\"public class Singleton{ //构造器私有化 private Singleton(){} //本类内部创建对象实例 private final static Singleton singleton = new Singleton(); //对外暴露一个静态的公共方法，返回实例对象 public static Singleton getInstance(){ return singleton; } } \"]},\"330\":{\"h\":\"饿汉式（静态代码块）\",\"t\":[\"public class Singleton{ private Singleton(){} private static Singleton singleton; //在静态代码块中创建单例对象 static { singleton = new Singleton(); } public static Singleton getInstance(){ return singleton; } } \",\"饿汉式在类装载的时候就完成实例化，避免了线程同步问题。如果一直没有使用这个实例，则会浪费内存。\"]},\"331\":{\"h\":\"懒汉式(线程安全， 同步方法)\",\"t\":[\"public class Singleton{ private Singleton(){} private static Singleton singleton; //提供一个静态的共有方法，当使用该方法时，才去创建singleton public static synchronized Singleton getInstance(){ if(singleton == null){ singleton = new Singleton(); } return singleton; } } \",\"效率较低\"]},\"332\":{\"h\":\"双重检查（重要）\",\"t\":[\" class Singleton{ private Singleton(){} //注意使用volatile修饰singleton，实现可见性，有序性 private static volatile Singleton singleton; public static Singleton getInstance(){ if(singleton == null){ synchronized (Singleton.class){ if(singleton == null){ singleton = new Singleton(); } } } return singleton; } } \",\"线程安全；延迟加载；效率较高\"]},\"333\":{\"h\":\"静态内部类（重要）\",\"t\":[\"public class Singleton{ private Singleton(){} private static class SingletonInstance{ private static final Singleton SINGLETON = new Singleton(); } public static Singleton getInstance(){ return SingletonInstance.SINGLETON; } } \",\"由于静态内部类在Singleton被装载的时候，并不会实例化静态内部类SingletonInstance，只有在被用到的时候才会实例化，线程安全，延时加载，效率高。\"]},\"334\":{\"h\":\"枚举\",\"t\":[\"enum Singleton{ SINGLETON; } \",\"不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，枚举仍然算饿汉式。\"]},\"335\":{\"h\":\"Java基础\"},\"336\":{\"h\":\"并发编程一\"},\"337\":{\"h\":\"进程和线程\"},\"338\":{\"h\":\"进程\",\"t\":[\"进程是程序的一次执行过程，启动main函数就相当于启动了一个JVM进程，而main函数所在的线程称为主线程。\"]},\"339\":{\"h\":\"线程\",\"t\":[\"引入线程之后，调度的最小单位从进程变成了线程，一个进程能在运行的时候产生多个线程，每一个线程共享进程的堆和方法区（线程共有），每一个线程有自己的程序计数器，虚拟机栈，本地方法栈，所以线程之间的切换开销远远小于进程，线程又称为轻量级进程。\"]},\"340\":{\"h\":\"从 JVM 角度说进程和线程之间的关系\",\"t\":[\"一个进程能有很多个线程，多个线程共享本进程的堆和方法区（1.8之后的元空间），每一个线程拥有自己的虚拟机栈，本地方法栈，程序计数器。\",\"五分钟记住JVM内存结构\"]},\"341\":{\"h\":\"程序计数器为什么是线程私有？\",\"t\":[\"程序计数器存放的是下一条将要执行指令的地址。\",\"在多线程下，程序计数器用来记录当前线程执行的位置，当线程切换回来的时候能够知道上次运行到哪里了。\",\"所以程序计数器的作用就是线程切换之后能恢复到正确的位置。\"]},\"342\":{\"h\":\"虚拟机栈和本地方法栈为什么是私有的?\",\"t\":[\"虚拟机栈用于存放栈帧，而每一个栈帧就对应着一个Java方法，用于存放局部变量表，操作数栈，常量池等信息。从方法调用到执行完成的过程，就对应着栈帧的入栈和出栈。\",\"本地方法栈用于存放Native方法，这种方法一般是C或者C++实现的。本地方法栈和虚拟机栈发挥的作用类似。\"]},\"343\":{\"h\":\"堆和方法区\",\"t\":[\"堆和方法区都是线程共享的资源，堆是进程内存中最大的一块区域，用于存放新创建的对象，方法区用来存放已经被加载的类信息、常量、静态变量、即时编译器编译之后的代码。\"]},\"344\":{\"h\":\"线程的生命周期和状态\",\"t\":[\"NEW：初始状态，线程已经创建但是没有调用start();\",\"RUNNABLE：运行状态，线程调用了start()等待运行；\",\"BLOCKED：阻塞状态，需要等待锁释放；\",\"WAITING：等待状态，需要等待其他线程作出动作（通知或中断）；\",\"TIME_WAITING：超时等待状态，可以在等待一段时间之后自行返回，而不是像WAITING一样一直等待。\",\"TERMINATED：终止状态，表示线程运行完毕。\"]},\"345\":{\"h\":\"什么是死锁？如何避免\"},\"346\":{\"h\":\"死锁\",\"t\":[\"两个或者以上的线程因为竞争资源导致阻塞，若无外力作用都无法向前推进。\",\"死锁的四个必要条件：\",\"互斥\",\"不剥夺\",\"请求并保持\",\"环路等待\"]},\"347\":{\"h\":\"如何预防死锁？\",\"t\":[\"预防死锁就是破坏四个必要条件中的任意一个。\",\"破坏不剥夺条件：占用部分资源的线程在进一步申请资源失败时，主动放出已经保持的资源。\",\"破坏请求并保持：一次性分配所需要的所有资源。\",\"破坏环路等待：资源有序分配。\"]},\"348\":{\"h\":\"如何避免死锁？\",\"t\":[\"银行家算法，防止当前系统进入不安全状态。\"]},\"349\":{\"h\":\"sleep() 方法和 wait() 方法对比\",\"t\":[\"两个方法都能暂停线程的执行。\",\"区别：\",\"sleep()方法没有释放锁，而wait()方法释放了锁；\",\"wait()通常用于线程之间的通信，sleep()用于线程的暂停执行；\",\"wait()方法被调用之后，线程不会自动苏醒，需要别的线程调用同一个对象的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。\",\"sleep方法是Thread类的静态本地方法，wait()则是Object类的本地方法\"]},\"350\":{\"h\":\"为什么wait()方法不定义在Thread中？\",\"t\":[\"wait()是让获得对象锁的线程等待，会释放对象锁，每一个Object都有对象锁，要释放当前线程占有的对象锁并让其进入WAITING状态，当然是使用对象的操作而不是线程的操作。\",\"因为sleep()方法是让当前线程暂停执行，不涉及对象，所以定义在Thread类中。\"]},\"351\":{\"h\":\"直接调用run()和start()的区别\",\"t\":[\"new一个Thread，并调用start()方法会创建一个新的线程并让其进入就绪状态。start()的方法会执行线程的准备工作，然后自动调用run()方法，这样才能实现多线程。\",\"如果直接调用run()方法，则是通过调用线程来运行的，会把run()方法当成普通方法执行。\",\"调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。\"]},\"352\":{\"h\":\"并发编程二\"},\"353\":{\"h\":\"Java内存模型\"},\"354\":{\"h\":\"指令重排序\",\"t\":[\"编译器优化重排：编译器在不改变单线程程序语义的前提下，重新安排语句执行顺序。\",\"指令并行重排：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\",\"指令重排序可以保证串行语义的一致，但是没义务保证多线程之间语义的一致，在多线程下，指令重排可能会导致问题。\"]},\"355\":{\"h\":\"什么是Java内存模型？为什么需要Java内存模型？\",\"t\":[\"JMM是Java定义的并发编程相关的一组规范，除了抽象了线程和内存之间的关系之外，还规定了Java源代码到CPU可执行指令这个转化过程要遵循哪些和并发相关的原则和规范，主要目的是为了简化编程，增强代码的可移植性。\"]},\"356\":{\"h\":\"什么是主内存？什么是本地内存？\",\"t\":[\"主内存：所有线程创建的对象实例都放在主内存中；\",\"本地内存：每个线程都有私有的本地内存来存储共享变量的副本，并且每一个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是JMM抽象出的概念，存储了主内存中的变量副本。\"]},\"357\":{\"h\":\"Java内存结构和Java内存模型的区别\",\"t\":[\"Java内存结构和运行时区域有关，定义了JVM在运行时如何分区存储数据，例如堆主要用来存放对象实例。\",\"JMM和Java的并发编程有关，抽象了线程和内存之间的关系，规定了Java源代码到CPU可执行指令这个转化过程要遵循哪些并发相关的原则和规范，目的主要是简化多线程编程，增强程序的可移植性\"]},\"358\":{\"h\":\"happens-before\",\"t\":[\"前一个操作的结果应该对后一个操作是可见的，无论这两个操作是不是在同一个线程里。\",\"int userNum = getUserNum(); // 1 int teacherNum = getTeacherNum(); // 2 int totalNum = userNum + teacherNum; // 3 \",\"在线程并发执行的时候，可能1 2 操作的结果还没有存入变量中，3操作已经开始执行，这时得到的结果就不是正确结果。（指令流水线数据相关）\"]},\"359\":{\"h\":\"happens-before 常见规则\",\"t\":[\"程序顺序规则：一个线程内，书写在前的操作happens-before于书写在后面的操作；\",\"解锁规则：解锁happens-before加锁；\",\"volatile变量规则：对于一个volatile变量的写操作happens-before后面对这个变量的读操作，也就是对这个变量的修改对其后的所有操作都可见；\",\"传递规则：如果A happens-before B，B happens-before C，则A happens-before C；\",\"线程启动规则：Thread对象的start()方法happens-before这个线程的每一个操作。\",\"如果两个操作不满足上述条件的任意一个，则这两个操作就没有顺序保障，JVM可以对这两个操作进行重排序。\"]},\"360\":{\"h\":\"并发编程的三个特性\",\"t\":[\"原子性：\",\"一次操作或者多次操作，要么所有的操作都能全部执行不会收到任何外界因素干扰而中断，要么都不执行。\",\"synchronized和各种Lock来实现原子性。\",\"可见性：\",\"当一个线程对共享变量进行修改，那么另外的线程都是能立即看到的。\",\"synchronized、volatile、各种Lock实现可见性。\",\"有序性：\",\"由于指令重排序问题，代码的执行顺序未必就是编写代码的顺序。\",\"使用volatile关键字可以禁止指令进行重排序优化。\"]},\"361\":{\"h\":\"volatile关键字\",\"t\":[\"在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\",\"volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\"]},\"362\":{\"h\":\"volatile如何禁止指令重排序？\",\"t\":[\"如果将变量通过volatile修饰，则对这个变量读写的时候会添加上特定的读写屏障保证可见性。\",\"在CPU的物理世界里，内存屏障通常有三种：\",\"lfence: 读屏障（load fence)，即立刻让CPU Cache失效，从内存中读取数据，并装载入Cache中。\",\"sfence: 写屏障（write fence）, 即立刻进行flush，把缓存中的数据刷入内存中。\",\"mfence: 全屏障 (memory fence)，即读写屏障，保证读写都串行化，确保数据都写入内存并清除缓存。\",\"双检查单例模式：\",\"public class Singleton{ private Singleton{}//构造方法私有 private volatile Singleton singleton;//volatile修饰的singleton 保证可见性 public static Singleton getInstance(){ if(singleton==null){ synchronized(Singleton.class){//对类对象加锁 if(singleton==null){ singleton=new Singleton(); } } } return singleton; } } \",\"volatile是“轻量级”synchronized，保证了共享变量的“可见性”（JMM确保所有线程看到这个变量的值是一致的），当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，并且锁住缓存行，因此当其他CPU需要读取这个变量时，要等锁释放，并发现自己缓存行是无效的，那么它就会从内存重新读取。\"]},\"363\":{\"h\":\"乐观锁和悲观锁\"},\"364\":{\"h\":\"什么是乐观锁？\",\"t\":[\"乐观锁总是假设最好的情况，即认为将要修改的数据并没有被其他线程修改，修改失败采用重复尝试的办法。\",\"验证数据是否被其他线程修改可通过版本号机制或者CAS算法。\",\"在 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式 CAS 实现的。AtomicInteger类主要利用CAS(compare and swap)+volatile和native方法来保证原子操作，从而避免synchronized的高开销，执行效率大为提升。\"]},\"365\":{\"h\":\"什么是悲观锁？\",\"t\":[\"悲观锁总是假设最坏的情况，认为共享资源总是会被其他线程修改了，所以在访问资源的时候采取加锁的方案，防止其他线程修改，像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。\",\"高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。\"]},\"366\":{\"h\":\"CAS 算法\",\"t\":[\"CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。\",\"CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。\",\"CAS 涉及到三个操作数：\",\"V：要更新的变量值(Var)\",\"E：预期值(Expected)\",\"N：拟写入的新值(New)\"]},\"367\":{\"h\":\"ABA问题\",\"t\":[\"如果有一个线程将变量值A改为B，之后又有一个线程将B改为A，则第三个线程采用CAS进行修改的时候发现预期值A正确，则认为变量没有被修改，其实已经修改了两次。\",\"解决ABA问题就是添加版本号或者是时间戳。\"]},\"368\":{\"h\":\"CAS问题\",\"t\":[\"CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。\",\"CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行 CAS 操作。\"]},\"369\":{\"h\":\"synchronized\"},\"370\":{\"h\":\"synchronized 是什么？有什么用？\",\"t\":[\"synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\",\"早期版本中synchronized 属于重量级锁，Java 6 之后对synchronized 做了优化。\",\"☀️详见synchronized锁优化。\"]},\"371\":{\"h\":\"sychronized修饰方法\",\"t\":[\"synchronized 关键字的使用方式主要有下面 3 种：\",\"synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁；\",\"synchronized 关键字加到实例方法上是给对象实例上锁；\"]},\"372\":{\"h\":\"synchronized底层原理\",\"t\":[\"修饰同步代码块\",\"synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\",\"在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。\",\"对象锁的的拥有者线程才可以执行 monitorexit 指令来释放锁。在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。\",\"修饰方法\",\"synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\",\"synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\",\"两者本质都是对对象监视器monitor的获取。\"]},\"373\":{\"h\":\"synchronized 和 volatile 有什么区别？\",\"t\":[\"volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。\",\"volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\",\"volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。\"]},\"374\":{\"h\":\"ReentrantLock\"},\"375\":{\"h\":\"ReentrantLock 是什么？\",\"t\":[\"ReentrantLock 实现了 Lock 接口，是一个可重入且独占式的锁，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。\",\"ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。\",\"☀️详见AQS抽象队列同步器。\"]},\"376\":{\"h\":\"公平锁和非公平锁有什么区别？\",\"t\":[\"公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。\",\"非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。\"]},\"377\":{\"h\":\"synchronized 和 ReentrantLock 有什么区别？\",\"t\":[\"两者都是可重入锁，也就是线程可以再次获取自己的内部锁。\",\"synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API。\",\"ReentrantLock 比synchronized 增加了一些高级功能： \",\"等待可中断：ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。\",\"可实现公平锁: ReentrantLock可以指定是公平锁还是非公平锁，而synchronized只能是非公平锁。\",\"可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock也可以实现，但是需要借助于Condition接口与newCondition()方法。\"]},\"378\":{\"h\":\"可中断锁和不可中断锁有什么区别？\",\"t\":[\"可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。\",\"不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁。\"]},\"379\":{\"h\":\"并发编程三\"},\"380\":{\"h\":\"ThreadLocal\"},\"381\":{\"h\":\"ThreadLocal 有什么用？\",\"t\":[\"ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。\",\"如果创建了一个ThreadLocal变量，那么访问这个变量的每一个线程都有这个变量的副本。可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。\"]},\"382\":{\"h\":\"ThreadLocal原理\",\"t\":[\"Thread类源码：\",\"public class Thread implements Runnable { //与此线程有关的ThreadLocal值。由ThreadLocal类维护 ThreadLocal.ThreadLocalMap threadLocals = null; //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护 ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; //...... } \",\"变量是放在了当前线程的ThreadLocalMap中，并不是存在ThreadLocal中,ThreadLocal可以理解为ThreadLocalMap的封装。\",\"ThreadLocal类的set()方法：\",\"public void set(T value) { //获取当前请求的线程 Thread t = Thread.currentThread(); //取出 Thread 类内部的 threadLocals 变量(哈希表结构) ThreadLocalMap map = getMap(t); if (map != null) // 将需要存储的值放入到这个哈希表中 map.set(this, value); else createMap(t, value); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } \",\"每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap存储以ThreadLocal为key，Object对象为value的键值对（JDK1.8）。\",\"ThreadLocalMap是ThreadLocal的静态内部类。\"]},\"383\":{\"h\":\"ThreadLocal内存泄露\",\"t\":[\"ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。\",\"这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。\"]},\"384\":{\"h\":\"线程池\"},\"385\":{\"h\":\"什么是线程池?\",\"t\":[\"线程池是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。\"]},\"386\":{\"h\":\"为什么要用线程池？\",\"t\":[\"池化技术是为了减少每次获取资源的消耗，提高资源利用率。\",\"使用线程池的好处：\",\"降低资源消耗；\",\"提高响应速度；\",\"提高线程的可管理性。\"]},\"387\":{\"h\":\"如何创建线程池？\",\"t\":[\"通过ThreadPoolExecutor构造函数来创建；\",\"通过 Executor 框架的工具类 Executors 来创建。\",\"不同类型的ThreadPoolExecutor:\",\"FixedThreadPool：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。核心线程数为n，最大线程数为n。\",\"SingleThreadExecutor： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。核心线程数为1，最大线程数为1。\",\"CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。核心线程数为0，最大线程数为Integer.MAX_VALUE。\",\"ScheduledThreadPool：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。核心线程数为n，最大线程数为Integer.MAX_VALUE。\",\"ThreadPoolExecutor\",\"corePoolSize\",\"maximumPoolSize\",\"任务队列\",\"可创建的最大线程数\",\"FixedThreadPool\",\"n\",\"n\",\"LinkedBlockingQueue无界队列\",\"n\",\"SingleThreadExecutor\",\"1\",\"1\",\"LinkedBlockingQueue无界队列\",\"1\",\"CachedThreadPool\",\"0\",\"Integer.MAX_VALUE\",\"SynchronousQueue同步队列\",\"Integer.MAX_VALUE\",\"ScheduledThreadPool\",\"n\",\"Integer.MAX_VALUE\",\"DelayedWorkQueue延迟阻塞队列\",\"n\",\"注意\",\"最大线程数是线程池参数，与可创建的最大线程数不是一个意思。\"]},\"388\":{\"h\":\"线程池的主要参数\",\"t\":[\"int corePoolSize,//线程池的核心线程数量 int maximumPoolSize,//线程池的最大线程数 long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间 TimeUnit unit,//时间单位 BlockingQueue<Runnable> workQueue,//任务队列 ThreadFactory threadFactory,//线程工厂 RejectedExecutionHandler handler//拒绝策略 \",\"ThreadPoolExecutor 3 个最重要的参数：\",\"corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。\",\"maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\",\"workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\",\"ThreadPoolExecutor其他常见参数 :\",\"keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；\",\"unit : keepAliveTime 参数的时间单位。\",\"threadFactory :executor 创建新线程的时候会用到。\",\"handler :饱和策略。\"]},\"389\":{\"h\":\"线程池的饱和策略有哪些？\",\"t\":[\"如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，新来的任务将会被：\",\"ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。\",\"ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。\",\"ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。\",\"ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。\"]},\"390\":{\"h\":\"线程池中常用的阻塞队列有哪些？\",\"t\":[\"新任务到来的时候，如果核心线程已经满了，就会放入到阻塞队列中。\",\"常见的阻塞队列：\",\"容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）：FixedThreadPool 和 SingleThreadExector 。由于队列永远不会被放满，因此**FixedThreadPool最多只能创建核心线程数的线程**。\",\"SynchronousQueue（同步队列）：CachedThreadPool 。SynchronousQueue 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，CachedThreadPool 的最大线程数是 Integer.MAX_VALUE ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。\",\"DelayedWorkQueue（延迟阻塞队列）：ScheduledThreadPool 和 SingleThreadScheduledExecutor 。DelayedWorkQueue 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。DelayedWorkQueue 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 Integer.MAX_VALUE，所以最多只能创建核心线程数的线程。\"]},\"391\":{\"h\":\"线程池处理任务的流程了解吗？\",\"t\":[\"如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。\",\"如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。\",\"如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。\",\"如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用RejectedExecutionHandler.rejectedExecution()方法。\"]},\"392\":{\"h\":\"如何设定线程池的大小？\",\"t\":[\"CPU 密集型任务(N+1)：N表示CPU核心数，比N多1是为了处理线程偶然发生的缺页中断，或者是其他原因导致任务暂停带来的影响。\",\"I/O 密集型任务(2N)：系统大部分时间用来IO交互，而在处理IO的时候不会占用CPU资源，这时可将CPU资源交给其他任务，因此创建N+N个核心线程。\"]},\"393\":{\"h\":\"Future\"},\"394\":{\"h\":\"Future类有什么用？\",\"t\":[\"Future 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。\",\"简单理解：有一个任务，提交给了 Future 来处理。任务执行期间自己可以去做任何想做的事情。并且，在这期间还可以取消任务以及获取任务的执行状态。一段时间之后，可以从 Future 那里直接取出任务执行结果。\"]},\"395\":{\"h\":\"Callable 和 Future 有什么关系？\",\"t\":[\"FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit() 方法返回的其实就是 Future 的实现类 FutureTask。\",\"FutureTask 有两个构造函数，可传入 Callable 或者 Runnable 对象。实际上，传入 Runnable 对象也会在方法内部转换为Callable 对象。\",\"FutureTask相当于对Callable 进行了封装，管理着任务执行的情况，存储了 Callable 的 call 方法的任务执行结果。\"]},\"396\":{\"h\":\"CompletableFuture 类有什么用？\",\"t\":[\"Future 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。\",\"Java 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。\",\"CompletableFuture<SkuInfoEntity> future1 = CompletableFuture.supplyAsync(() -> { //sku基本信息的获取 pms_sku_info SkuInfoEntity info = this.getById(skuId); skuItemVo.setInfo(info); return info; }, executor); CompletableFuture<SkuInfoEntity> future2 = future1.thenAcceptAsync(() -> { //业务代码2，需要future1完成之后才能执行 }, executor); CompletableFuture<SkuInfoEntity> future3 = CompletableFuture.supplyAsync(() -> { //业务代码 }, executor); CompletableFuture<SkuInfoEntity> future4 = CompletableFuture.supplyAsync(() -> { //业务代码 }, executor); //多个任务等待异步完成 CompletableFuture.allOf(future1,future2,future3,future4).get(); \"]},\"397\":{\"h\":\"synchronized锁优化\",\"t\":[\"锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\"]},\"398\":{\"h\":\"自旋锁与自适应自旋\",\"t\":[\"当获取锁失败的时候线程不会立马阻塞，而是采用忙循环（自旋）去再次尝试获取锁。重试的次数默认是10次。\",\"JDK1.6之后引入自适应锁，自旋锁重试次数是固定的，不够灵活，如果在同一个锁对象上，最近通过自旋获得过这个锁，则认为此次的自旋也有较大概率获得锁，会自旋更多次。另外如果对于某个锁自旋很少成功获得，则以后在获取锁失败之后很可能会省略自旋的过程。\"]},\"399\":{\"h\":\"锁消除\",\"t\":[\"虚拟机即时编译的时候，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持。\",\"在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程所访问到，就可以把它们当做栈上数据，认为是线程私有的，同步锁就没有必要加上了。\"]},\"400\":{\"h\":\"锁粗化\",\"t\":[\"在编写代码的时候，推荐将加锁的范围尽可能的变小以获得更好的性能。\",\"大部分情况下，上面的原则都是正确的，例如在一个循环内对同一个对象进行加锁解锁，频繁的同步操作会导致不必要的性能损耗，则虚拟机会把加锁的范围扩展（粗化）以减少加锁和解锁的次数。\"]},\"401\":{\"h\":\"轻量级锁\",\"t\":[\"轻量级锁是JDK 1.6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”锁。\",\"它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。\",\"整个加解锁过程其实就是一个新旧数据比对的过程（通过CAS），根据数据的变化来确定同步代码块是否多个线程抢占共享变量，如果在某段时间内没有多个线程访问这块同步代码那就可以不需要去指向操作系统互斥量（这个对象的内存相比较2bit的锁标志位是要大很多的，同时还能减少传统的重量级锁使用操作系统互斥量产生的性能消耗），如果是出现了多个线程进行抢占共享变量，就会使用操作系统互斥量达到互斥同步。也可以理解成如果同步代码块没有多个出现并发问题的话，就应该尽可能的减少实现同步互斥所带来的一系列损耗。\"]},\"402\":{\"h\":\"偏向锁\",\"t\":[\"偏向锁也是JDK 1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。\",\"偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。\"]},\"403\":{\"h\":\"AQS抽象队列同步器\",\"t\":[\"AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面。\",\"AQS 就是一个抽象类，主要用来构建锁和同步器。\",\"比如 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。\"]},\"404\":{\"h\":\"AQS原理\"},\"405\":{\"h\":\"AQS核心思想\",\"t\":[\"AQS的核心思想是如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源的状态设置为锁定状态。如果资源被占用，则需要一套线程阻塞等待以及被唤醒分配的机制，这个机制AQS是基于CLH锁实现的。\",\"CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。\",\"CLH锁的结构如下：\",\"AQS的核心原理图如下：\",\"AQS 使用 int 成员变量 state 表示同步状态，通过内置的 线程等待队列 来完成获取资源线程的排队工作。\",\"state 变量由 volatile 修饰，用于展示当前临界资源的获锁情况。\"]},\"406\":{\"h\":\"AQS资源共享方式\",\"t\":[\"AQS 定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。\"]},\"407\":{\"h\":\"Semaphore（信号量）\",\"t\":[\"synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，而Semaphore(信号量)可以用来控制同时访问特定资源的线程数量。\",\"Semaphore 的使用简单，假设有 N(N>5) 个线程来获取 Semaphore 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。\",\"final Semaphore semaphore = new Semaphore(5); // 获取1个许可，相当于P操作 semaphore.acquire(); // 释放1个许可，相当于V操作 semaphore.release(); \",\"Semaphore 有两种模式：\",\"公平模式： 调用 acquire() 方法的顺序就是获取许可证的顺序，遵循 FIFO；\",\"非公平模式： 抢占式的，默认模式。\",\"原理：\",\"Semaphore 是共享锁的一种实现，它默认构造 AQS 的 state 值为 permits，你可以将 permits 的值理解为许可证的数量，只有拿到许可证的线程才能执行。\",\"P操作：调用semaphore.acquire() ，线程尝试获取许可证，如果 state >= 0 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 state 的值 state=state-1。如果 state<0 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。\",\"V操作：调用semaphore.release() ，线程尝试释放许可证，并使用 CAS 操作去修改 state 的值 state=state+1。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 state 的值 state=state-1 ，如果 state>=0 则获取令牌成功，否则重新进入阻塞队列，挂起线程。\",\"除了 acquire() 方法之外，另一个比较常用的与之对应的方法是 tryAcquire() 方法，该方法如果获取不到许可就立即返回 false。\"]},\"408\":{\"h\":\"CountDownLatch （倒计时器）\",\"t\":[\"CountDownLatch 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。\",\"CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。\",\"CountDownLatch 是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用 countDown() 方法时,其实使用了tryReleaseShared方法以 CAS 的操作来减少 state,直至 state 为 0 。当调用 await() 方法的时候，如果 state 不为 0，那就证明任务还没有执行完毕，await() 方法就会一直阻塞，也就是说 await() 方法之后的语句不会被执行。然后，CountDownLatch 会自旋 CAS 判断 state == 0，如果 state == 0 的话，就会释放所有等待的线程，await() 方法之后的语句得到执行。\",\" \",\"两种典型用法：\",\"等待n个线程完成任务之后，主线程继续工作。\",\"子线程1： //业务代码 countDownLatch.countDown();//将state值-1 子线程2： //业务代码 countDownLatch.countDown();//将state值-1 ---- 主线程：countDownLatch.await();//等到state值为0的时候才不会被阻塞，等待两个线程执行完成 \",\"等待n个线程准备，在执行任务前先countDownLatch.awit()，然后主线程调用countDown()计数值变0，n个线程同时被唤醒。\",\"子线程1：countDownLatch.await();//等待state值变为0 //业务代码 子线程2：countDownLatch.await(); //业务代码 ---- 主线程：countDownLatch.countDown();//将state值变为0，类似信号枪响 \"]},\"409\":{\"h\":\"CyclicBarrier(循环栅栏)\",\"t\":[\"CyclicBarrier 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1，并将自身阻塞。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，此时才会将栅栏放开，让所有线程继续执行下去。\",\"使用await()方法告诉CyclicBarrier 已经到达了屏障，然后当前线程被阻塞。当count值为0则会将被阻塞的线程唤醒。\"]},\"410\":{\"h\":\"JUC常见并发容器\",\"t\":[\"JDK 提供的这些容器大部分在 java.util.concurrent 包中。\",\"ConcurrentHashMap : 线程安全的 HashMap\",\"CopyOnWriteArrayList : 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector。\",\"ConcurrentLinkedQueue : 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。\",\"BlockingQueue : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。\",\"ConcurrentSkipListMap : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。\"]},\"411\":{\"h\":\"CopyOnWriteArrayList\",\"t\":[\"为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。\"]},\"412\":{\"h\":\"CopyOnWriteArrayList 原理\",\"t\":[\"CopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作。\"]},\"413\":{\"h\":\"ConcurrentLinkedQueue\",\"t\":[\"Java 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，使用链表作为其数据结构。在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。\",\"ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全。\",\"ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。\"]},\"414\":{\"h\":\"BlockingQueue\",\"t\":[\"BlockingQueue （阻塞队列）是一个接口，继承自 Queue。BlockingQueue阻塞的原因是其支持当队列没有元素时一直阻塞，直到有有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。\",\"BlockingQueue 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。\"]},\"415\":{\"h\":\"ArrayBlockingQueue\",\"t\":[\"ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁 ReentrantLock ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。默认是不公平实现的。.\"]},\"416\":{\"h\":\"LinkedBlockingQueue\",\"t\":[\"LinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。\"]},\"417\":{\"h\":\"PriorityBlockingQueue\",\"t\":[\"PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。\",\"简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。\"]},\"418\":{\"h\":\"ConcurrentSkipListMap\",\"t\":[\"跳表的本质是同时维护了多个链表，并且链表是分层的，最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。\",\"跳表内的所有链表的元素都是排序的。\",\"查找时，可以从顶级链表开始找。一旦发现被查找的元素处于两个元素值的区间，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。\",\"查找18原本要遍历18次，现在只需要7次。\"]},\"419\":{\"h\":\"并发编程\"},\"420\":{\"h\":\"JVM内存结构\"},\"421\":{\"h\":\"运行时数据区域\"},\"422\":{\"h\":\"线程私有的：\"},\"423\":{\"h\":\"程序计数器\",\"t\":[\"一块很小的内存区域，保存了将要执行指令的地址。为了线程切换之后能恢复到正确的执行位置，每一个线程都需要一个程序计数器，各线程之间计数器互不影响，称为“线程私有”的内存。\",\"程序计数器是唯一一个不会出现OOM的内存区域，随着线程的创建而创建，线程的消亡而消亡。\"]},\"424\":{\"h\":\"虚拟机栈\",\"t\":[\"虚拟机栈也是线程私有的，方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。\",\"栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。\",\"局部变量表：主要存放了编译期可知的各种数据类型、对象引用。\",\"操作数栈：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。\",\"动态链接 ：主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其 。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 动态链接 。\"]},\"425\":{\"h\":\"本地方法栈\",\"t\":[\"和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。\"]},\"426\":{\"h\":\"线程共有的：\"},\"427\":{\"h\":\"堆\",\"t\":[\"Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**堆的内存结构在垃圾回收章节提及。\",\"注意\",\"在JDK1.7开启了逃逸分析，如果一个对象引用不会逃出本方法的作用范围，则认为没有逃逸，直接进行栈上分配。\"]},\"428\":{\"h\":\"方法区\",\"t\":[\"方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。从内存分布图中可以看出永久代是 JDK 1.8 之前的方法区实现（运行时数据区），JDK 1.8 及以后方法区的实现变成了元空间（本地内存）。\",\"转到本地内存的原因：元空间使用本地内存，可能会受到本机内存的限制，但是出现溢出的概率比原来的永久代小很多。 \"]},\"429\":{\"h\":\"运行时常量池（方法区内部）\",\"t\":[\"Class文件中除了有类的版本号、字段、方法、接口等描述信息，还有用于存放各种字面量和符号引用的常量池表。\",\"字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。\",\"常量池表会在类加载后存放到方法区的运行时常量池中。既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。\"]},\"430\":{\"h\":\"字符串常量池\",\"t\":[\"JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。\",\"因为方法区的GC效率很低，堆的GC效率很高，Java程序中通常有大量的字符串等待回收，放入堆中能加快回收频率。\",\"字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\",\"HotSpot 虚拟机中字符串常量池的实现是 stringTable.cpp ，StringTable 可以简单理解为一个固定大小的HashTable ，容量为 StringTableSize（可以通过 -XX:StringTableSize 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。\"]},\"431\":{\"h\":\"JVM中对象的创建\"},\"432\":{\"h\":\"1：类加载检查\",\"t\":[\"虚拟机遇到new指令时，先会检查指令的参数能否在常量池中找到这个参数对应类的符号引用，并检查这个符号引用代表的类是否已经加载，解析和初始化。如果没有需要先执行响应的类加载过程。\"]},\"433\":{\"h\":\"2：分配内存\",\"t\":[\"类加载完成之后开始分配内存，所需要的内存大小在类加载完成之后就能确定。内存的分配方式有“指针碰撞”和“空闲列表”两种。\",\"指针碰撞\",\"适合内存规整的情况。\",\"将用过的内存整理到一边，没用过的放在另外一边，通过移动中间的指针，和另外一边的边界划定一个对象内存大小的区域。\",\"使用指针碰撞分配方式的GC收集器：Serial，ParNew。\",\"空闲列表\",\"适合内存不规整的情况。\",\"虚拟机维护一个列表，用来表示哪部分的内存是空闲的，在分配的时候找到一块能满足分配大小的空闲内存进行分配。\",\"使用空闲列表的GC收集器：CMS。\",\"保证内存分配时的线程安全\",\"CAS+重试：虚拟机采用CAS和失败重试的方式保证更新操作的原子性。\",\"：每一个线程都有一个TLAB（线程本地分配缓冲区），在线程中对象分配内存的时候先会在TLAB中分配，当对象大于TLAB剩余空内存或者TLAB内存耗尽的时候，才会使用CAS+重试的分配方式。\"]},\"434\":{\"h\":\"3：初始化零值\",\"t\":[\"内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\"]},\"435\":{\"h\":\"4：设置对象头\",\"t\":[\"初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\"]},\"436\":{\"h\":\"5：执行 init 方法\",\"t\":[\"执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\"]},\"437\":{\"h\":\"对象的内存布局\",\"t\":[\"在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。\",\"对象头包含两部分信息：一部分用于存储对象自身的运行时数据（哈希码，GC分代年龄，锁状态标志），另外一部分是类型指针，即对象指向他的类数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\",\"实例数据部分是对象真正存储的有效信息，对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。（内存对齐存放）\"]},\"438\":{\"h\":\"对象的访问定位\",\"t\":[\"对象的访问定位就是如何找到创建的对象信息，包括实例和类数据。\"]},\"439\":{\"h\":\"直接指针\",\"t\":[\"如果使用直接指针访问，reference 中存储的直接就是对象的地址。\"]},\"440\":{\"h\":\"句柄\",\"t\":[\"如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。\"]},\"441\":{\"h\":\"JVM垃圾回收\"},\"442\":{\"h\":\"内存分配和回收原则\"},\"443\":{\"h\":\"对象优先在Eden中分配\",\"t\":[\"大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。\"]},\"444\":{\"h\":\"大对象直接进入老年代\",\"t\":[\"大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。\",\"大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。\"]},\"445\":{\"h\":\"长期存活的对象将进入老年代\",\"t\":[\"虚拟机给每个对象一个对象年龄（Age）计数器。\",\"大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。\",\"对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。\",\"对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。\",\"额外的\",\"Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 -XX:TargetSurvivorRatio=percent 来设置），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。\"]},\"446\":{\"h\":\"GC区域\",\"t\":[\"针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：\",\"部分收集 (Partial GC)：\",\"新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；\",\"老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；\",\"混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。\",\"整堆收集 (Full GC)：收集整个 Java 堆和方法区。\"]},\"447\":{\"h\":\"空间分配担保\",\"t\":[\"在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的，如果不成立，则虚拟机会先查看 -XX:HandlePromotionFailure 参数的设置值是否允许担保失败(Handle Promotion Failure)；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 -XX: HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次 Full GC。\",\"可能存在所有的新生代对象都在这次GC之后晋升至老年代，老年代如果没有足够的内存则无法担保分配\"]},\"448\":{\"h\":\"死亡对象的判断方法\"},\"449\":{\"h\":\"引用计数法\",\"t\":[\"给对象添加一个计数器：\",\"有地方引用的时候就将计数器+1；\",\"引用失效，将计数器-1；\",\"计数器为0的对象就是不会再被使用的对象。\",\"简单高效，但是对象之间存在循环引用，导致他们的计数值都不为0，无法通知GC回收器回收它们。\"]},\"450\":{\"h\":\"可达性分析\",\"t\":[\"这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。\"]},\"451\":{\"h\":\"可以作为 GC Roots 的对象\",\"t\":[\"虚拟机栈中的对象；\",\"本地方法栈中的对象；\",\"方法区中静态属性引用的变量；\",\"方法区中常量引用的对象；\",\"所有被同步锁持有的对象。\"]},\"452\":{\"h\":\"对象可以被回收，就代表一定会被回收吗？\",\"t\":[\"即使被标记为不可达的对象，也并不会立即被回收，而是处于”缓刑“阶段，经过真正的宣告对象死亡，至少要经过两次标记过程；\",\"可达性分析中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法。\",\"对象没有覆盖finalize方法，或者finalize方法已经被虚拟机调用过，虚拟机把这两种情况视为没有必要执行。\",\"被判断需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象的引用链上的任何一个对象建立关联，否则就会被回收。\"]},\"453\":{\"h\":\"引用类型总结\",\"t\":[\"强引用：必不可少的，垃圾回收器绝对不会回收的对象。\",\"软引用：可有可无的，内存足够不会回收，如果内存不太够则可能会回收。\",\"弱引用：可有可无的，与软引用的区别在于：具有弱引用的对象具有更短的声明周期，垃圾回收器一旦发现，不管内存空间是否紧张都会回收这个对象。\",\"虚引用：形同虚设，虚引用不会决定对象的声明周期，如果一个对象仅持有虚引用，则和没有任何引用一样，任何时候都有可能被回收。\",\"虚引用主要用来跟踪对象被垃圾回收的活动。\",\"虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\",\"程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\",\"特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。\"]},\"454\":{\"h\":\"如何判断一个常量是废弃常量？\",\"t\":[\"JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。\",\"JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。\",\"JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)。\",\"假如在字符串常量池中存在字符串 \\\"abc\\\"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 \\\"abc\\\" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，\\\"abc\\\" 就会被系统清理出常量池了。\"]},\"455\":{\"h\":\"如何判断一个类是无用的类？\",\"t\":[\"判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。\",\"类需要同时满足下面 3 个条件才能算是 “无用的类”：\",\"该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\",\"加载该类的 ClassLoader 已经被回收。\",\"该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\",\"虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。\"]},\"456\":{\"h\":\"垃圾收集算法\"},\"457\":{\"h\":\"标记-清除算法\",\"t\":[\"标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。\",\"效率问题：标记和清除两个过程效率都不高。\",\"空间问题：标记清除后会产生大量不连续的内存碎片。\"]},\"458\":{\"h\":\"复制算法\",\"t\":[\"为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\",\"对应到新生代就是survivor中的from区和to区。\",\"1.可用内存变小：可用内存缩小为原来的一半，一半作为from区，一半作为to。\",\"2.不适合老年代：如果存活对象数量比较大，复制性能会变得很差。\"]},\"459\":{\"h\":\"分代收集算法/HotSpot为什么要分代\",\"t\":[\"当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点选择合适的垃圾收集算法。\",\"在新生代中，每次收集都有大量对象死去，所以可以采用“标记-复制算法”，只需要付出少量对象的复制成本就能完成垃圾收集，而老年代中对象存活的久，并且没有额外的空间对它进行分配担保，所以选择“标记-清除”或“标记-整理”算法进行垃圾收集。\"]},\"460\":{\"h\":\"垃圾回收器\"},\"461\":{\"h\":\"Serial 收集器\",\"t\":[\"Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。只会使用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ \\\"Stop The World\\\" ），直到它收集结束。简单高效。\",\"新生代采用标记-复制算法，老年代采用标记-整理算法。\"]},\"462\":{\"h\":\"ParNew 收集器\",\"t\":[\"ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。\",\"新生代采用标记-复制算法，老年代采用标记-整理算法。\",\"除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。\",\"并发：一个时间段内同时执行，操作系统基本特征。\",\"并行：一个时刻同时执行。\"]},\"463\":{\"h\":\"Parallel Scavenge 收集器\",\"t\":[\"采用标记-复制算法的多线程收集器，重点关注吞吐量（高效利用CPU），CMS垃圾收集器关注的是停顿时间。\",\"新生代采用标记-复制算法，老年代采用标记-整理算法。\",\"JDK1.8的默认收集器。\"]},\"464\":{\"h\":\"Serial Old收集器\",\"t\":[\"Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。\"]},\"465\":{\"h\":\"Parallel Old 收集器\",\"t\":[\"Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。\"]},\"466\":{\"h\":\"CMS收集器\",\"t\":[\"CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。\",\"CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\",\"CMS 收集器是一种“标记-清除”算法实现的，运行步骤：\",\"初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；\",\"并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\",\"重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\",\"并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\",\"优点：\",\"并发收集、低停顿。\",\"缺点：\",\"对 CPU 资源敏感；\",\"无法处理浮动垃圾；（在并发标记阶段用户新产生的垃圾，在重新标记阶段不会标记浮动的新垃圾）\",\"它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\"]},\"467\":{\"h\":\"G1 收集器\",\"t\":[\"G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.\",\"G1也是遵循分代收集理论设计的，它不再坚持以固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域，每一个Region都可以根据需要扮演Eden空间、Survivor空间或者老年代空间。收集器根据不同的角色采用不同的策略处理这些Region。Region中还有一类特殊的Humongous区域，专门用来存储大对象。这些Humongous被当作老年代处理。有以下特点：\",\"并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。\",\"分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。\",\"空间整合：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。（一个Region复制到另外一个Region）\",\"可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。\",\"G1 收集器的运作大致分为以下几个步骤：\",\"初始标记：标记一下GC Roots能直接关联到的对象，再修改TAMS指针。借用Minor GC的时候同步完成。\",\"并发标记：遍历对象图，找出需要回收的对象，与用户线程并发执行。处理原始快照在并发时变动的对象。\",\"最终标记：处理并发阶段结束后仍遗留下来的少量SATB记录。\",\"筛选回收：更新Region的统计数据，对各个Region的回收价值和成本进行排序，然后根据用户的期望停顿时间制定回收计划，最后把需要回收的Region里的存活对象复制到新region中，再清空旧region。需要STW，多条收集线程并发执行。\",\"G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\",\"G1存在着很多问题：\",\"还是跨代引用的问题，这么多Region，在判断对象是否可达的时候，就需要每个Region都维护一个Remember Set，内存占用是非常高的。\",\"浮动垃圾。为每个Region设置两个TAMS指针，新对象都分配在这个两个指针之间，默认认为这些新对象不是垃圾。如果回收速度赶不上分配速度，也会导致冻结用户线程，进行FullGC。\"]},\"468\":{\"h\":\"CMS和G1的异同\",\"t\":[\"首先CMS是老年代的收集器，一般配合ParNew使用，但是这个组合在G1出现后已经被废弃了。G1 面向整堆进行收集。\",\"CMS采用标记清除算法，因此会产生内存碎片，导致Concurrent mode failure进而Full GC。\",\"G1宏观上采用标记清除，但是微观上是在各个region之间标记复制，所以降低了内存碎片的产生数量。\",\"再就是二者的回收过程不同，CMS大致可以分为初始标记、并发标记、重新标记和并发清理；G1 大致可以分为初始标记、并发标记、重新标记和清除。这二者在针对并发标记过程中用户线程对可达性分析的影响的处理方式不同，一个是增量更新（CMS），一个是原始快照（G1）。\",\"CMS和G1都是响应时间优先的收集器，但是CMS是追求最小的停顿时间为目标，而G1通过衰减均值来建立可预测的停顿模型，也就是分析每个Region的回收收益，根据均值、标准差、置信度等指标来决定到底要收集哪些region，并且收集这些region所需的停顿时间要大概率不超过期望的停顿时间。\"]},\"469\":{\"h\":\"到底多大的对象会被直接扔到老年代\",\"t\":[\"用-XX: PretunureSizeThreshold指定对象大小的阈值，超过这个数就直接放入老年代，减少内存复制开销。但是这个参数只支持Serial和ParNew。像G1的话，只要对象大小超过Region的一半，那就会直接放到Humongous里，这个Humongous也被认为是老年代。\"]},\"470\":{\"h\":\"CMS和G1的STW的区别\",\"t\":[\"首先，根节点枚举都是需要STW的，CMS和G1在根节点枚举上的区别就在于处理跨代引用上，跨代引用一般是使用记忆集解决，G1的记忆集和CMS的不一样，因为G1的分区是按Region分的，因此G1的记忆集是一个哈希表，Key是别的Region的起始地址，value是一个集合，里面存储的是卡表的索引号。这个哈希表表示我指向谁，谁又指向我的，是一种双向卡表。而CMS的卡表比较简单，只标识着某个内存区域是否为脏。\",\"然后CMS在可达性分析的时候有两个步骤需要STW，一个是初始标记，一个是重新标记；G1 有三个步骤需要STW，一个是初始标记，一个是最终标记，还有一个是筛选回收。初始标记很好理解，就是将GC roots直接引用的对象标记一遍，速度很快；关键点在于这二者都存在一个并发标记的步骤，此时与用户线程并发执行，难免用户线程会修改对象图的引用关系。这两个收集器的处理策略是不同的，CMS采用的是增量更新，G1 则采用的是原始快照。\",\"增量更新就是将那些新加入引用的位置记录，在重新标记阶段进行处理。原始快照就是将那些被删除的引用记录保存下来，也就是保存个快照，在并发标记的最后以及最终标记中进行处理。\"]},\"471\":{\"h\":\"类文件结构\"},\"472\":{\"h\":\"字节码\",\"t\":[\"在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。\"]},\"473\":{\"h\":\"Class文件结构总结\"},\"474\":{\"h\":\"魔数（Magic Number）\",\"t\":[\" u4 magic; //Class 文件的标志 \",\"每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。\"]},\"475\":{\"h\":\"Class 文件版本号（Minor&Major Version）\",\"t\":[\" u2 minor_version;//Class 的小版本号 u2 major_version;//Class 的大版本号 \",\"四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是次版本号（2个字节），第 7 和第 8 位是主版本号（2个字节）。\",\"每当Java发布大版本的时候，主版本号都会加1。\",\"高版本的JVM能运行低版本编译器生成的.class文件，但是低版本的JVM不会向上兼容高版本的.class文件。\"]},\"476\":{\"h\":\"常量池（Constant Pool）\",\"t\":[\" u2 constant_pool_count;//常量池的数量 cp_info constant_pool[constant_pool_count-1];//常量池 \",\"紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”）。\",\"常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：\",\"类和接口的全限定名\",\"字段的名称和描述符\",\"方法的名称和描述符\",\"常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型。\"]},\"477\":{\"h\":\"访问标志(Access Flags)\",\"t\":[\" u2 access_flags;//Class 的访问标记 \",\"在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。\"]},\"478\":{\"h\":\"当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合\",\"t\":[\" u2 this_class;//当前类 u2 super_class;//父类 u2 interfaces_count;//接口 u2 interfaces[interfaces_count];//一个类可以实现多个接口 \",\"Java 类的继承关系由类索引、父类索引和接口索引集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后，\",\"类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。\",\"接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implements (如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。\"]},\"479\":{\"h\":\"字段表集合（Fields）\",\"t\":[\" u2 fields_count;//Class 文件的字段的个数 field_info fields[fields_count];//一个类会可以有个字段 \",\"字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。\"]},\"480\":{\"h\":\"方法表集合（Methods）\",\"t\":[\" u2 methods_count;//Class 文件的方法的数量 method_info methods[methods_count];//一个类可以有个多个方法 \",\"methods_count 表示方法的数量，而 method_info 表示方法表。\",\"Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。\"]},\"481\":{\"h\":\"属性表集合（Attributes）\",\"t\":[\" u2 attributes_count;//此类的属性表中的属性数 attribute_info attributes[attributes_count];//属性表集合 \",\"在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。\"]},\"482\":{\"h\":\"类加载过程\"},\"483\":{\"h\":\"类的生命周期\",\"t\":[\"类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，前三个阶段可以统称为连接（Linking）。\",\"类加载过程：加载->连接->初始化。\",\"其中连接过程分为：验证->准备->解析。\",\"整体流程为：加载->验证->准备->解析->初始化。\"]},\"484\":{\"h\":\"类加载过程\"},\"485\":{\"h\":\"加载\",\"t\":[\"类加载过程的第一步，完成以下三件事情：\",\"通过全类名获取定义此类的二进制字节流。\",\"将字节流所代表的静态存储结构转化为方法区的运行时数据结构。\",\"在内存中生成一个类的.class文件，作为方法区这些数据的入口。\",\"加载这一步通过类加载器完成的。\"]},\"486\":{\"h\":\"验证\",\"t\":[\"验证是连接中的第一步。这一步的作用是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。\",\"验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的，但很有必要，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。\",\"验证阶段主要由四个检验阶段组成：\",\"文件格式验证（Class文件格式检查）\",\"验证字节流是否符合Class文件格式的规范。例如是否以魔数开头，主版本号是否在当前虚拟机的处理范围内，详见类文件结构。主要目的是保证输入的字节流能正确的解析并存储于方法区内，其余的三个验证阶段都是基于方法区的存储结构上进行，不会再直接读取、操作字节流了。\",\"元数据验证（字节码语义检查）\",\"对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》要求。例如这个类是否有父类，这个类是否继承了不允许继承的类。\",\"字节码验证（程序语义检查）\",\"通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的。例如函数的参数类型是否正确，对象的类型转换是否合理。\",\"符号引用验证（类的正确性检查）\",\"验证类的正确性。例如该类要使用的其他类、方法、字段是否存在，是否有正确的访问权限。发生在类加载阶段的解析阶段，具体来说就是JVM将符号引用转化为直接引用的时候。\"]},\"487\":{\"h\":\"准备\",\"t\":[\"准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都在方法区内分配。\",\"这时候进行内存分配的仅包括类变量（即是静态变量，被static修饰的变量，只与类有关，因此称为类变量），不包括实例变量。实例变量会在对象实例化的时候随着对象一块分配在Java堆中。\",\"类变量所使用的内存都应该在方法区中分配，但是在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。\",\"这是设置的初始值“通常情况”下是数据类型的默认值，例如public static int value = 111，那么value变量在准备阶段的的初始值是0而不是111（初始化阶段才会赋值）。特殊情况，变量添加final修饰，则可以看成常量，直接就会在准备阶段赋值。\"]},\"488\":{\"h\":\"解析\",\"t\":[\"解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符进行引用。\",\"符号引用以一组符号来描述所引用的对象，符号可以使任何字面量，只要能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存中的内容。\",\"直接引用是可以直接指向目标的指针、相对偏移量或者是一个能定位到目标的句柄。如果使用了直接引用，则引用目标必定在虚拟机的内存中。\",\"当程序执行方法的时候，系统需要明确知道这个方法所处的位置。Java为每一个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就能调用这个方法了。通过解析操作符号引用就能直接变成为目标方法在类中方法表的位置，从而方法才能被调用。\",\"综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。\"]},\"489\":{\"h\":\"初始化\",\"t\":[\"初始化阶段是执行初始化方法 <clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。\",\"对于初始化，以下几种情况必须对类进行初始化：\",\"当遇到new 、getstatic、putstatic、invokestatic这4条字节码指令。\",\"使用java.lang.reflect包的方法对类进行反射调用时如果类没有初始化，则需要先进行初始化。\",\"初始化一个类，父类还没有初始化，则需要先初始化父类。\",\"虚拟机启动时，用户需要定义一个需要执行的主类，虚拟机会先初始化这个类。\",\"MethodHandle和VarHandle可以看做轻量级的反射调用机制，使用这两个调用就要先使用findStaticVarHandle来初始化要调用的类。\",\"当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。\"]},\"490\":{\"h\":\"类卸载\",\"t\":[\"卸载类，即该类的Class对象被GC。\",\"需要满足三个条件才能卸载：\",\"该类的所有实例对象都被GC，也就是说堆中不存在该类的实例对象。\",\"该类没有在其他任何地方被引用。\",\"该类的类加载器的实例已经被GC。\",\"所以在JVM生命周期内，由JVM自带的类加载器（JDK 自带的 BootstrapClassLoader, ExtClassLoader, AppClassLoader ）加载的类是不会被卸载的，但是自定义的类加载器加载的类是可能被卸载的。\"]},\"491\":{\"h\":\"类加载器\"},\"492\":{\"h\":\"类加载器\",\"t\":[\"类加载器是一个负责加载类的对象，用于实现类加载过程中的第一步。\",\"每一个Java类都有一个引用指向加载它的ClassLoader。\",\"数组类不是通过ClassLoader创建的，是由JVM自动产生的\",\"类加载器的作用就是加载Java类的字节码（.class文件）到JVM中，字节码可以使源程序（.java文件）经过编译而来，也可以是通过工具动态生成或者是从网络上下载而来。\"]},\"493\":{\"h\":\"类加载器的加载规则\",\"t\":[\"JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。\",\"对于已经加载的类会被放在 ClassLoader 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。\"]},\"494\":{\"h\":\"类加载器总结\",\"t\":[\"JVM中内置了三个ClassLoader：\",\"BootstrapClassLoader(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ %JAVA_HOME%/lib目录下的 rt.jar、resources.jar、charsets.jar等 jar 包和类）以及被 -Xbootclasspath参数指定的路径下的所有类。\",\"ExtensionClassLoader(扩展类加载器)：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类以及被 java.ext.dirs 系统变量所指定的路径下的所有类。\",\"AppClassLoader(应用程序类加载器)：面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。\",\"除了 BootstrapClassLoader 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 ClassLoader抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。\",\"每个 ClassLoader 可以通过getParent()获取其父 ClassLoader，如果获取到 ClassLoader 为null的话，那么该类是通过 BootstrapClassLoader 加载的。\",\"ClassLoader 为null就是 BootstrapClassLoader 加载的呢？ 这是因为BootstrapClassLoader 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。\"]},\"495\":{\"h\":\"自定义类加载器\",\"t\":[\"除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader抽象类。\",\"ClassLoader 类有两个关键的方法：\",\"protected Class loadClass(String name, boolean resolve)：加载指定二进制名称的类，实现了双亲委派机制 。name 为类的二进制名称，resove 如果为 true，在加载时调用 resolveClass(Class<?> c) 方法解析该类。\",\"protected Class findClass(String name)：根据类的二进制名称来查找类，默认实现是空方法。\",\"如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。\"]},\"496\":{\"h\":\"双亲委派\",\"t\":[\"ClassLoader 类使用委托模型来搜索类和资源。每个 ClassLoader 实例都有一个相关的父类加载器。需要查找类或资源时，ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。 虚拟机中被称为 \\\"bootstrap class loader\\\"的内置类加载器本身没有父类加载器，但是可以作为 ClassLoader 实例的父类加载器。\",\"ClassLoader 类使用委托模型来搜索类和资源。\",\"双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。\",\"ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。\",\"下图展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型(Parents Delegation Model)”。\",\"info::: warning\",\"双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。\",\":::\",\"另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。\",\"public abstract class ClassLoader { ... // 组合 private final ClassLoader parent; protected ClassLoader(ClassLoader parent) { this(checkCreateClassLoader(), parent); } ... } \"]},\"497\":{\"h\":\"双亲委派模型的执行流程\",\"t\":[\"protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { //首先，检查该类是否已经加载过 Class c = findLoadedClass(name); if (c == null) { //如果 c 为 null，则说明该类没有被加载过 long t0 = System.nanoTime(); try { if (parent != null) { //当父类的加载器不为空，则通过父类的loadClass来加载该类 //重写loadClass方法 就能破坏双亲委派 c = parent.loadClass(name, false); } else { //当父类的加载器为空，则调用启动类加载器来加载该类 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //非空父类的类加载器无法找到相应的类，则抛出异常 } if (c == null) { //当父类加载器无法加载时，则调用findClass方法来加载该类 //用户可通过覆写该方法，来自定义类加载器 long t1 = System.nanoTime(); c = findClass(name); //用于统计类加载器相关的信息 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { //对类进行link操作 resolveClass(c); } return c; } } \",\"每当一个类加载器接收到加载请求的时候，会先将请求转发给父类加载器，在父类加载器没有找到所请求的类情况下，该类才会尝试去加载。\",\"执行流程：\",\"在类加载的时候，先判断这个类是否已经加载过了，加载过了会直接返回，否则才会尝试加载。\",\"类加载器在进行类加载的时候，它首先不会尝试去加载这个类，而是把请求委派给父类加载器去完成。最终的请求都会到顶层的启动类加载器BootstrapClassLoader中。\",\"只有父类加载器反馈不能完成这个加载请求的时候，子加载器才会尝试自己加载。\",\"☀️ JVM检查两个Java类是否相同的依据：检查类的全名是否相同，还要看类的加载器是否相同，只有两者都是一样的才认为是相同的Java类。即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，则这两个类不同。\"]},\"498\":{\"h\":\"双亲委派的好处\",\"t\":[\"双亲委派模式，保证了Java程序的稳定运行，可以避免类的重复加载，也保证了Java的核心API不会被修改。\",\"例如自己写一个java.lang.Object类，在程序运行的时候就会产生两个Object类，一个是JRE里面的，一个是自己写的，使用双亲委派通过启动类加载器BootStrapClassLoader发现这个类已经加载了，则会直接返回，不会加载自己写的Object。\"]},\"499\":{\"h\":\"打破双亲委派模型方法\",\"t\":[\"自定义加载器的话，需要继承 ClassLoader 。如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。\",\"类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成（调用父类的loadClass()方法来加载类）。\"]},\"500\":{\"h\":\"JVM重要参数\"},\"501\":{\"h\":\"堆内存相关\"},\"502\":{\"h\":\"指定堆内存 -Xms 和 -Xmx\",\"t\":[\"-Xms<heap size>[unit] -Xmx<heap size>[unit] \",\"为JVM堆内存分配最大5GB，最小2GB内存：\",\"-Xms2G -Xmx5G \"]},\"503\":{\"h\":\"指定新生代内存（Young Generation）\",\"t\":[\"一共有两种指定新生代内存大小的办法：\",\"1. 通过-XX:NewSize和-XX:MaxNewSize指定\",\"-XX:NewSize=256m -XX:MaxNewSize=1024m \",\"2.通过-Xmn<young size>[unit]指定\",\"为新生代分配256MB内存：\",\"-Xmn256m \",\"还可以通过 -XX:NewRatio=<int> 来设置老年代与新生代内存的比值：\",\"老年代与新生代比值为1:1，说明新生代占整个内存的1/2；\",\"-XX:NewRatio=1 \"]},\"504\":{\"h\":\"指定永久代/元空间大小\",\"t\":[\"从 Java 8 开始，如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。\",\"JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小：\",\"-XX:PermSize=N #方法区 (永久代) 初始大小 -XX:MaxPermSize=N #方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen \",\"JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。\",\"-XX:MetaspaceSize=N #设置 Metaspace 的FGC阈值 -XX:MaxMetaspaceSize=N #设置 Metaspace 的最大大小 \",\"Metaspace 由于使用不断扩容到-XX:MetaspaceSize参数指定的量，就会发生 Full GC，且之后每次 Metaspace 扩容都会发生 Full GC。\"]},\"505\":{\"h\":\"垃圾收集器相关\"},\"506\":{\"h\":\"垃圾回收器\",\"t\":[\"JVM 具有四种类型的 GC 实现：\",\"串行垃圾收集器\",\"并行垃圾收集器\",\"CMS 垃圾收集器\",\"G1 垃圾收集器\",\"可以使用以下参数声明这些实现：\",\"-XX:+UseSerialGC -XX:+UseParallelGC -XX:+UseParNewGC -XX:+UseG1GC \"]},\"507\":{\"h\":\"GC 日志记录\",\"t\":[\"生产环境上，或者其他要测试 GC 问题的环境上，一定会配置上打印 GC 日志的参数，便于分析 GC 相关的问题。\",\"# 必选 # 打印基本 GC 信息 -XX:+PrintGCDetails -XX:+PrintGCDateStamps # 打印对象分布 -XX:+PrintTenuringDistribution # 打印堆数据 -XX:+PrintHeapAtGC # 打印Reference处理信息 # 强引用/弱引用/软引用/虚引用/finalize 相关的方法 -XX:+PrintReferenceGC # 打印STW时间 -XX:+PrintGCApplicationStoppedTime # 可选 # 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 # GC日志输出的文件路径 -Xloggc:/path/to/gc-%t.log # 开启日志文件分割 -XX:+UseGCLogFileRotation # 最多分割几个文件，超过之后从头文件开始写 -XX:NumberOfGCLogFiles=14 # 每个文件上限大小，超过就触发分割 -XX:GCLogFileSize=50M \"]},\"508\":{\"h\":\"处理 OOM\",\"t\":[\"对于大型应用程序来说，面对内存不足错误是非常常见的，这反过来会导致应用程序崩溃。这是一个非常关键的场景，很难通过复制来解决这个问题。\",\"这就是为什么 JVM 提供了一些参数，这些参数将堆内存转储到一个物理文件中，以后可以用来查找泄漏:\",\"-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./java_pid<pid>.hprof -XX:OnOutOfMemoryError=\\\"< cmd args >;< cmd args >\\\" -XX:+UseGCOverheadLimit \",\"HeapDumpOnOutOfMemoryError 指示 JVM 在遇到 OutOfMemoryError 错误时将 heap 转储到物理文件中。\",\"HeapDumpPath 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 <pid> 标记，则当前进程的进程 id 将附加到文件名中，并使用.hprof格式\",\"OnOutOfMemoryError 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 cmd args 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: -XX:OnOutOfMemoryError=\\\"shutdown -r\\\" 。\",\"UseGCOverheadLimit 是一种策略，它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例\"]},\"509\":{\"h\":\"其他\",\"t\":[\"-server : 启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM\",\"-XX:+UseStringDeduplication : Java 8u20 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 char [] 数组来优化堆内存。\",\"-XX:+UseLWPSynchronization: 设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步。\",\"``-XX:LargePageSizeInBytes `: 设置用于 Java 堆的较大页面大小; 它采用 GB/MB/KB 的参数; 页面大小越大，我们可以更好地利用虚拟内存硬件资源; 然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。\",\"-XX:MaxHeapFreeRatio : 设置 GC 后, 堆空闲的最大百分比，以避免收缩。\",\"-XX:SurvivorRatio : eden/survivor 空间的比例, 例如-XX:SurvivorRatio=6 设置每个 survivor 和 eden 之间的比例为 1:6。\",\"-XX:+UseLargePages : 如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。\",\"-XX:+UseStringCache : 启用 String 池中可用的常用分配字符串的缓存。\",\"-XX:+UseCompressedStrings : 对 String 对象使用 byte [] 类型，该类型可以用纯 ASCII 格式表示。\",\"-XX:+OptimizeStringConcat : 它尽可能优化字符串串联操作。\"]},\"510\":{\"h\":\"GC调优\"},\"511\":{\"h\":\"确定目标\",\"t\":[\"需要低延时使用：\",\"CMS\",\"G1\",\"ZGC\",\"需要吞吐量使用：\",\"ParallelGC\"]},\"512\":{\"h\":\"最快的GC是不发生GC\",\"t\":[\"查看FullGC前后的内存占用，考虑以下几个问题：\",\"数据是不是太多\",\"resultSet = statement.executeQuery(\\\"select *from 大表 limit n\\\")；\",\"查询应该避免使用*查询过多的数据。\",\"数据表示是否太臃肿\",\"数据库查询需要什么字段就返回对应字段，不应该查询所有返回再筛选。\",\"Java对象最小是16字节，如果使用包装类（例如Integer对象头就已经占用16字节），则占用的内存比基本数据类型大很多，所以能使用基本数据类型的情况下不要使用包装类型。\",\"是否存在内存泄露\",\"例如使用一个static Map map不断的放入对象，就会导致内存泄漏。ThreadLocal中就存在内存泄漏。\",\"不建议使用Java中的数据结构作为缓存实现。\"]},\"513\":{\"h\":\"新生代GC调优\",\"t\":[\"新生代的特点：\",\"所有的new操作的内存分配非常廉价；\",\"TLAB 线程本地分配缓存，new对象手下会在TLAB中分配，由于是线程私有的，所以同时也解决了并发问题；\",\"死亡对象的回收代价是零;标记复制算法\",\"大部分对象用过即死；\",\"Minor GC的时间远低于Full GC。\",\"总空间不变的情况下，新生代越大，老年代越小，引发的Full GC的概率就更大，推荐新生代大小占整个堆的百分之25到百分之50。新生代的空间越大也会导致每次MinorGC的时间变长。\"]},\"514\":{\"h\":\"幸存区\",\"t\":[\"幸存区大到能保留【当前活跃对象+需要晋升的对象】。\",\"调节晋升阈值，让长时间存活的对象尽快晋升\",\"-XX:MaxTenuringThreshold=threshold -XX:PrintTenuringDistribution \"]},\"515\":{\"h\":\"老年代调优\",\"t\":[\"以CMS为例：\",\"CMS的老年代内存越大越好；\",\"观察发生Full GC时老年代内存占用，将老年代内存预设调大1/4~1/3\",\"-XX:CMSInitiatingOccupancyFraction=percent \"]},\"516\":{\"h\":\"案例\"},\"517\":{\"h\":\"案例1\",\"t\":[\"FullGC和MinorGC频繁。\",\"尝试增大新生代，MinorGC次数就会减少，增加晋升阈值，让新生代的对象晋升时间更长，进一步让老年代FullGC不再频繁。\"]},\"518\":{\"h\":\"案例2\",\"t\":[\"请求高峰期发生FullGC，单次暂停时间特别长（CMS）。\",\"业务需求低延时所以选择了CMS。\",\"查看CMS四个阶段中哪个阶段花的时间太长。 \",\"重新标记阶段会花费很长的时间，重新标记会扫描所有新生代对象，而在请求高峰期会产生很多新生代对象。\",\"可以在重新标记前进行一次垃圾回收，存活对象少了，重新标记花的时间就少了。\",\"-XX:+CMSScavengeBeforeRemark \",\"参数表示在重新标记之前先对新生代进行垃圾清理。\"]},\"519\":{\"h\":\"案例3\",\"t\":[\"老年代充裕的情况下，发生FullGC（1.7）。\",\"1.7采用永久代，之后变成元空间使用操作系统的空间。\",\"则这种情况属于永久代内存不足导致FullGC。\"]},\"520\":{\"h\":\"JVM\"}},\"dirtCount\":0,\"index\":[[\"业务需求低延时所以选择了cms\",{\"1\":{\"518\":1}}],[\"业务代码\",{\"1\":{\"396\":2,\"408\":4}}],[\"业务代码2\",{\"1\":{\"396\":1}}],[\"案例3\",{\"0\":{\"519\":1}}],[\"案例2\",{\"0\":{\"518\":1}}],[\"案例1\",{\"0\":{\"517\":1}}],[\"案例\",{\"0\":{\"516\":1}}],[\"案例中仍然是值传递\",{\"1\":{\"312\":1}}],[\"观察发生full\",{\"1\":{\"515\":1}}],[\"幸存区大到能保留\",{\"1\":{\"514\":1}}],[\"幸存区\",{\"0\":{\"514\":1}}],[\"格式表示\",{\"1\":{\"509\":1}}],[\"格式的问题\",{\"1\":{\"246\":1}}],[\"池中可用的常用分配字符串的缓存\",{\"1\":{\"509\":1}}],[\"池化技术是为了减少每次获取资源的消耗\",{\"1\":{\"386\":1}}],[\"页面大小越大\",{\"1\":{\"509\":1}}],[\"页面单位时间的访问数\",{\"1\":{\"182\":1,\"215\":1}}],[\"`\",{\"1\":{\"509\":1}}],[\"``\",{\"1\":{\"509\":1}}],[\"启用\",{\"1\":{\"509\":2}}],[\"启动类加载器\",{\"1\":{\"494\":1}}],[\"启动的时候\",{\"1\":{\"493\":1}}],[\"启动main函数就相当于启动了一个jvm进程\",{\"1\":{\"338\":1}}],[\"便于分析\",{\"1\":{\"507\":1}}],[\"便处理在任务队列中的任务\",{\"1\":{\"387\":1}}],[\"问题的环境上\",{\"1\":{\"507\":1}}],[\"☀️\",{\"1\":{\"497\":1}}],[\"☀️详见aqs抽象队列同步器\",{\"1\":{\"375\":1}}],[\"☀️详见synchronized锁优化\",{\"1\":{\"370\":1}}],[\"☀️详见string\",{\"1\":{\"293\":1}}],[\"☀️详见\",{\"1\":{\"179\":1,\"180\":1,\"191\":1}}],[\"☀️详见mysql锁\",{\"1\":{\"166\":1}}],[\"☀️详见事务隔离级别和mvcc\",{\"1\":{\"153\":1}}],[\"检查类的全名是否相同\",{\"1\":{\"497\":1}}],[\"检查该类是否已经加载过\",{\"1\":{\"497\":1}}],[\"检查语法是否正确\",{\"1\":{\"91\":1}}],[\"官方推荐的一种方式\",{\"1\":{\"496\":1}}],[\"负责加载当前应用\",{\"1\":{\"494\":1}}],[\"负数为减\",{\"1\":{\"220\":1}}],[\"卸载类\",{\"1\":{\"490\":1}}],[\"符号可以使任何字面量\",{\"1\":{\"488\":1}}],[\"符号引用与虚拟机实现的内存布局无关\",{\"1\":{\"488\":1}}],[\"符号引用以一组符号来描述所引用的对象\",{\"1\":{\"488\":1}}],[\"符号引用验证\",{\"1\":{\"486\":1}}],[\"符合逻辑的\",{\"1\":{\"486\":1}}],[\"符合a>=1条件的二级索引记录的范围里\",{\"1\":{\"136\":1}}],[\"符合3nf要求的数据库设计\",{\"1\":{\"85\":1}}],[\"详见类文件结构\",{\"1\":{\"486\":1}}],[\"准备阶段是正式为类变量分配内存并设置类变量初始值的阶段\",{\"1\":{\"487\":1}}],[\"准备\",{\"0\":{\"487\":1},\"1\":{\"483\":1}}],[\"验证类的正确性\",{\"1\":{\"486\":1}}],[\"验证字节流是否符合class文件格式的规范\",{\"1\":{\"486\":1}}],[\"验证阶段主要由四个检验阶段组成\",{\"1\":{\"486\":1}}],[\"验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的\",{\"1\":{\"486\":1}}],[\"验证是连接中的第一步\",{\"1\":{\"486\":1}}],[\"验证\",{\"0\":{\"486\":1},\"1\":{\"483\":2}}],[\"验证数据是否被其他线程修改可通过版本号机制或者cas算法\",{\"1\":{\"364\":1}}],[\"入自己定义的属性信息\",{\"1\":{\"481\":1}}],[\"描述符索引\",{\"1\":{\"480\":1}}],[\"名称索引\",{\"1\":{\"480\":1}}],[\"父类还没有初始化\",{\"1\":{\"489\":1}}],[\"父类索引用于确定这个类的父类的全限定名\",{\"1\":{\"478\":1}}],[\"父类索引和接口索引集合按照顺序排在访问标志之后\",{\"1\":{\"478\":1}}],[\"父类索引和接口索引集合三项确定\",{\"1\":{\"478\":1}}],[\"父类\",{\"0\":{\"478\":1},\"1\":{\"478\":1}}],[\"父进程需要及时调用\",{\"1\":{\"10\":1}}],[\"紧接着的两个字节代表访问标志\",{\"1\":{\"477\":1}}],[\"紧接着主次版本号之后的是常量池\",{\"1\":{\"476\":1}}],[\"声明为\",{\"1\":{\"476\":1}}],[\"项常量空出来是有特殊考虑的\",{\"1\":{\"476\":1}}],[\"魔数\",{\"0\":{\"474\":1}}],[\"难免用户线程会修改对象图的引用关系\",{\"1\":{\"470\":1}}],[\"谁又指向我的\",{\"1\":{\"470\":1}}],[\"跨代引用一般是使用记忆集解决\",{\"1\":{\"470\":1}}],[\"置信度等指标来决定到底要收集哪些region\",{\"1\":{\"468\":1}}],[\"浮动垃圾\",{\"1\":{\"467\":1}}],[\"浮点数和字符串字面量\",{\"1\":{\"429\":1}}],[\"浮点数运算的时候会有精度丢失的风险\",{\"0\":{\"282\":1}}],[\"浮点数\",{\"1\":{\"182\":1,\"213\":1}}],[\"划分内存空间以及有优先级的区域回收方式\",{\"1\":{\"467\":1}}],[\"筛选回收\",{\"1\":{\"467\":1}}],[\"筛选的条件是此对象是否有必要执行finalize方法\",{\"1\":{\"452\":1}}],[\"借用minor\",{\"1\":{\"467\":1}}],[\"毫秒\",{\"1\":{\"467\":1}}],[\"毫秒的时间片段内\",{\"1\":{\"467\":1}}],[\"毫秒为单位\",{\"1\":{\"205\":1}}],[\"动作\",{\"1\":{\"467\":1}}],[\"动态链接的作用就是为了将符号引用转换为调用方法的直接引用\",{\"1\":{\"424\":1}}],[\"动态链接\",{\"1\":{\"424\":3}}],[\"动态生成的代理类\",{\"1\":{\"323\":1}}],[\"动态代理主要有两种\",{\"1\":{\"322\":1}}],[\"动态代理属于运行时动态生成类字节码\",{\"1\":{\"322\":1}}],[\"动态代理更加灵活\",{\"1\":{\"322\":1,\"326\":1}}],[\"动态代理\",{\"0\":{\"322\":1}}],[\"动态代理就是依赖反射\",{\"1\":{\"316\":1}}],[\"动态点赞等场景\",{\"1\":{\"224\":1}}],[\"动态点赞等等\",{\"1\":{\"187\":1}}],[\"动态配置\",{\"1\":{\"56\":1}}],[\"动态主机配置协议\",{\"1\":{\"56\":1}}],[\"动态分区分配\",{\"1\":{\"12\":1}}],[\"停顿时间\",{\"1\":{\"467\":1}}],[\"停顿时间要求的同时\",{\"1\":{\"467\":1}}],[\"停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认\",{\"1\":{\"68\":1}}],[\"停止等待协议\",{\"0\":{\"68\":1}}],[\"暂停所有的其他线程\",{\"1\":{\"466\":1}}],[\"暂时获取不到锁的线程将被加入到该队列中\",{\"1\":{\"405\":1}}],[\"控制参数\",{\"1\":{\"462\":1}}],[\"历史最悠久的垃圾收集器了\",{\"1\":{\"461\":1}}],[\"串行垃圾收集器\",{\"1\":{\"506\":1}}],[\"串行\",{\"1\":{\"461\":1}}],[\"收集算法\",{\"1\":{\"462\":1}}],[\"收集算法出现了\",{\"1\":{\"458\":1}}],[\"收集器在有限时间内可以尽可能高的收集效率\",{\"1\":{\"467\":1}}],[\"收集器在后台维护了一个优先列表\",{\"1\":{\"467\":1}}],[\"收集器仍然可以通过并发的方式让\",{\"1\":{\"467\":1}}],[\"收集器根据不同的角色采用不同的策略处理这些region\",{\"1\":{\"467\":1}}],[\"收集器是一种\",{\"1\":{\"466\":1}}],[\"收集器是一种以获取最短回收停顿时间为目标的收集器\",{\"1\":{\"466\":1}}],[\"收集器是\",{\"1\":{\"466\":1}}],[\"收集器是最基本\",{\"1\":{\"461\":1}}],[\"收集器和\",{\"1\":{\"465\":1}}],[\"收集器搭配使用\",{\"1\":{\"464\":1}}],[\"收集器的运作大致分为以下几个步骤\",{\"1\":{\"467\":1}}],[\"收集器的后备方案\",{\"1\":{\"464\":1}}],[\"收集器的老年代版本\",{\"1\":{\"464\":1,\"465\":1}}],[\"收集器的多线程版本\",{\"1\":{\"462\":1}}],[\"收集器配合工作\",{\"1\":{\"462\":1}}],[\"收集器外\",{\"1\":{\"462\":1}}],[\"收集器完全一样\",{\"1\":{\"462\":1}}],[\"收集器其实就是\",{\"1\":{\"462\":1}}],[\"收集器\",{\"0\":{\"461\":1,\"462\":1,\"463\":1,\"465\":1,\"467\":1},\"1\":{\"465\":1}}],[\"收集整个\",{\"1\":{\"446\":1}}],[\"清除\",{\"1\":{\"457\":2,\"459\":1,\"466\":2,\"467\":1}}],[\"清除算法的效率和内存碎片问题\",{\"1\":{\"458\":1}}],[\"清除算法\",{\"0\":{\"457\":1}}],[\"清空一些记录\",{\"1\":{\"147\":1}}],[\"清空数据\",{\"1\":{\"86\":1}}],[\"垃圾收集器\",{\"1\":{\"506\":2}}],[\"垃圾收集器相关\",{\"0\":{\"505\":1}}],[\"垃圾收集算法\",{\"0\":{\"456\":1}}],[\"垃圾回收器\",{\"0\":{\"460\":1,\"506\":1}}],[\"垃圾回收器一旦发现\",{\"1\":{\"453\":1}}],[\"垃圾回收器绝对不会回收的对象\",{\"1\":{\"453\":1}}],[\"废弃常量\",{\"1\":{\"455\":1}}],[\"判定一个常量是否是\",{\"1\":{\"455\":1}}],[\"判断\",{\"1\":{\"408\":1}}],[\"判断指定元素是否在指定集合中\",{\"1\":{\"223\":1}}],[\"判断指定\",{\"1\":{\"214\":1}}],[\"判断是否为持锁线程\",{\"1\":{\"206\":1}}],[\"判断数据可见性\",{\"1\":{\"159\":1}}],[\"虚引用必须和引用队列\",{\"1\":{\"453\":1}}],[\"虚引用与软引用和弱引用的一个区别在于\",{\"1\":{\"453\":1}}],[\"虚引用主要用来跟踪对象被垃圾回收的活动\",{\"1\":{\"453\":1}}],[\"虚引用不会决定对象的声明周期\",{\"1\":{\"453\":1}}],[\"虚引用\",{\"1\":{\"453\":1,\"507\":1}}],[\"虚拟的双向队列即不存在队列实例\",{\"1\":{\"405\":1}}],[\"虚拟机会耗尽所有可用的系统内存\",{\"1\":{\"504\":1}}],[\"虚拟机会先初始化这个类\",{\"1\":{\"489\":1}}],[\"虚拟机会在字符串常量池中查找有没有相同值的对象\",{\"1\":{\"299\":1}}],[\"虚拟机启动时\",{\"1\":{\"489\":1}}],[\"虚拟机运行时会忽略掉它不认识的属性\",{\"1\":{\"481\":1}}],[\"虚拟机第一款真正意义上的并发收集器\",{\"1\":{\"466\":1}}],[\"虚拟机可以对满足上述\",{\"1\":{\"455\":1}}],[\"虚拟机对方法区的实现为永久代\",{\"1\":{\"454\":1}}],[\"虚拟机把这两种情况视为没有必要执行\",{\"1\":{\"452\":1}}],[\"虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间\",{\"1\":{\"447\":1}}],[\"虚拟机给每个对象一个对象年龄\",{\"1\":{\"445\":1}}],[\"虚拟机将发起一次\",{\"1\":{\"443\":1}}],[\"虚拟机通过这个指针来确定这个对象是哪个类的实例\",{\"1\":{\"437\":1}}],[\"虚拟机中被称为\",{\"1\":{\"496\":1}}],[\"虚拟机中\",{\"1\":{\"437\":1}}],[\"虚拟机中字符串常量池的实现是\",{\"1\":{\"430\":1}}],[\"虚拟机要对对象进行必要的设置\",{\"1\":{\"435\":1}}],[\"虚拟机需要将分配到的内存空间都初始化为零值\",{\"1\":{\"434\":1}}],[\"虚拟机采用cas和失败重试的方式保证更新操作的原子性\",{\"1\":{\"433\":1}}],[\"虚拟机维护一个列表\",{\"1\":{\"433\":1}}],[\"虚拟机遇到new指令时\",{\"1\":{\"432\":1}}],[\"虚拟机所管理的内存中最大的一块\",{\"1\":{\"427\":1}}],[\"虚拟机即时编译的时候\",{\"1\":{\"399\":1}}],[\"虚拟机栈中的对象\",{\"1\":{\"451\":1}}],[\"虚拟机栈为虚拟机执行\",{\"1\":{\"425\":1}}],[\"虚拟机栈也是线程私有的\",{\"1\":{\"424\":1}}],[\"虚拟机栈用于存放栈帧\",{\"1\":{\"342\":1}}],[\"虚拟机栈\",{\"0\":{\"424\":1},\"1\":{\"339\":1}}],[\"虚拟机栈和本地方法栈为什么是私有的\",{\"0\":{\"342\":1}}],[\"虚拟机栈和本地方法栈\",{\"1\":{\"5\":1}}],[\"弱引用\",{\"1\":{\"453\":1,\"507\":1}}],[\"软引用\",{\"1\":{\"453\":1,\"507\":1}}],[\"软链接\",{\"1\":{\"15\":2}}],[\"强引用\",{\"1\":{\"453\":1,\"507\":1}}],[\"至少要经过两次标记过程\",{\"1\":{\"452\":1}}],[\"阶段之前\",{\"1\":{\"507\":1}}],[\"阶段\",{\"1\":{\"452\":1,\"457\":1}}],[\"给对象添加一个计数器\",{\"1\":{\"449\":1}}],[\"给指定\",{\"1\":{\"214\":1}}],[\"老年代充裕的情况下\",{\"1\":{\"519\":1}}],[\"老年代调优\",{\"0\":{\"515\":1}}],[\"老年代越小\",{\"1\":{\"513\":1}}],[\"老年代与新生代比值为1\",{\"1\":{\"503\":1}}],[\"老年代采用标记\",{\"1\":{\"461\":1,\"462\":1,\"463\":1}}],[\"老年代如果没有足够的内存则无法担保分配\",{\"1\":{\"447\":1}}],[\"老年代收集\",{\"1\":{\"446\":1}}],[\"混合收集\",{\"1\":{\"446\":1}}],[\"混合持久化\",{\"1\":{\"246\":1}}],[\"遍历对象图\",{\"1\":{\"467\":1}}],[\"遍历所有对象时\",{\"1\":{\"445\":1}}],[\"遍历等操作\",{\"1\":{\"253\":1}}],[\"额外的\",{\"1\":{\"445\":1}}],[\"岁\",{\"1\":{\"445\":2}}],[\"年龄就增加\",{\"1\":{\"445\":1}}],[\"出生并经过第一次\",{\"1\":{\"445\":1}}],[\"长度和内容不同\",{\"1\":{\"481\":1}}],[\"长度加限制\",{\"1\":{\"40\":1}}],[\"长期存活的对象将进入老年代\",{\"0\":{\"445\":1}}],[\"区的\",{\"1\":{\"445\":1}}],[\"区后对象的初始年龄变为\",{\"1\":{\"445\":1}}],[\"区\",{\"1\":{\"445\":1}}],[\"区域分配\",{\"1\":{\"445\":1}}],[\"区没有足够空间进行分配时\",{\"1\":{\"443\":1}}],[\"区分配\",{\"1\":{\"443\":1}}],[\"区别是\",{\"1\":{\"425\":1}}],[\"区别\",{\"0\":{\"46\":1,\"86\":1,\"255\":1,\"265\":1},\"1\":{\"172\":1,\"349\":1}}],[\"句柄\",{\"0\":{\"440\":1}}],[\"块区域\",{\"1\":{\"437\":1}}],[\"没用过的放在另外一边\",{\"1\":{\"433\":1}}],[\"没有任何引用链相连的话\",{\"1\":{\"450\":1}}],[\"没有容量\",{\"1\":{\"390\":1}}],[\"没有被外部强引用的情况下\",{\"1\":{\"383\":1}}],[\"没有逃逸出本方法\",{\"1\":{\"285\":1}}],[\"没有办法实时或者秒级持久化数据\",{\"1\":{\"246\":1}}],[\"没有原生的集群模式\",{\"1\":{\"172\":1}}],[\"没有必要将整个页面刷盘\",{\"1\":{\"148\":1}}],[\"没有选择红黑树的主要原因\",{\"1\":{\"126\":1}}],[\"没有用到表内索引进行排序\",{\"1\":{\"108\":1}}],[\"没有命中缓存的话\",{\"1\":{\"91\":1}}],[\"没有收到\",{\"1\":{\"62\":1}}],[\"没有\",{\"1\":{\"46\":1}}],[\"没有区别\",{\"1\":{\"40\":1}}],[\"没有分配的内存多出的碎片\",{\"1\":{\"12\":1}}],[\"空间的比例\",{\"1\":{\"509\":1}}],[\"空间中使用适当的命令\",{\"1\":{\"508\":1}}],[\"空间整合\",{\"1\":{\"467\":1}}],[\"空间问题\",{\"1\":{\"457\":1}}],[\"空间分配担保\",{\"0\":{\"447\":1}}],[\"空间\",{\"1\":{\"445\":1}}],[\"空闲列表\",{\"1\":{\"433\":2}}],[\"空位都以0补齐\",{\"1\":{\"267\":1}}],[\"专门用来存储大对象\",{\"1\":{\"467\":1}}],[\"专门开辟的一块区域\",{\"1\":{\"430\":1}}],[\"专为远程登录会话和其他网络服务提供安全性的协议\",{\"1\":{\"56\":1}}],[\"错误之前在\",{\"1\":{\"508\":1}}],[\"错误时将\",{\"1\":{\"508\":1}}],[\"错误\",{\"1\":{\"429\":1}}],[\"既然运行时常量池是方法区的一部分\",{\"1\":{\"429\":1}}],[\"元空间使用的是本地内存\",{\"1\":{\"504\":1}}],[\"元空间使用本地内存\",{\"1\":{\"428\":1}}],[\"元空间大小\",{\"0\":{\"504\":1}}],[\"元数据验证\",{\"1\":{\"486\":1}}],[\"元素的插入满足队列特性\",{\"1\":{\"257\":1}}],[\"元素是有序的\",{\"1\":{\"250\":1,\"257\":1}}],[\"局部变量表\",{\"1\":{\"424\":2}}],[\"局域网\",{\"1\":{\"39\":1}}],[\"栈由一个个栈帧组成\",{\"1\":{\"424\":1}}],[\"栈中分配的局部变量\",{\"1\":{\"285\":2}}],[\"称为\",{\"1\":{\"423\":1}}],[\"称为多路复用器\",{\"1\":{\"22\":1}}],[\"现在只需要7次\",{\"1\":{\"418\":1}}],[\"损耗大量内存\",{\"1\":{\"416\":1}}],[\"尝试增大新生代\",{\"1\":{\"517\":1}}],[\"尝试从一个空队列中取一个元素也会同样阻塞\",{\"1\":{\"415\":1}}],[\"尝试将元素放入队列将导致操作阻塞\",{\"1\":{\"415\":1}}],[\"跳表内的所有链表的元素都是排序的\",{\"1\":{\"418\":1}}],[\"跳表的本质是同时维护了多个链表\",{\"1\":{\"418\":1}}],[\"跳表的实现\",{\"1\":{\"410\":1}}],[\"跳跃表\",{\"1\":{\"212\":1}}],[\"了\",{\"1\":{\"409\":1}}],[\"倒计时器\",{\"0\":{\"408\":1}}],[\"挂起线程\",{\"1\":{\"407\":1}}],[\"挂起当前线程\",{\"1\":{\"407\":1}}],[\"抢占式的\",{\"1\":{\"407\":1}}],[\"遵循\",{\"1\":{\"407\":1}}],[\"公平模式\",{\"1\":{\"407\":1}}],[\"公平锁和非公平锁有什么区别\",{\"0\":{\"376\":1}}],[\"公平锁和非公平锁等高级功能\",{\"1\":{\"375\":1}}],[\"公平锁\",{\"1\":{\"207\":1,\"376\":1}}],[\"队列锁中\",{\"1\":{\"405\":1}}],[\"队列锁的一个结点\",{\"1\":{\"405\":1}}],[\"队列满足fifo性质\",{\"1\":{\"258\":1}}],[\"翻译过来的意思就是抽象队列同步器\",{\"1\":{\"403\":1}}],[\"翻译成中文是同步的意思\",{\"1\":{\"370\":1}}],[\"偏袒的\",{\"1\":{\"402\":1}}],[\"偏\",{\"1\":{\"402\":3}}],[\"偏向锁的\",{\"1\":{\"402\":1}}],[\"偏向锁也是jdk\",{\"1\":{\"402\":1}}],[\"偏向锁\",{\"0\":{\"402\":1}}],[\"偏向锁状态\",{\"1\":{\"397\":1}}],[\"粗化\",{\"1\":{\"400\":1}}],[\"频繁的同步操作会导致不必要的性能损耗\",{\"1\":{\"400\":1}}],[\"频繁需要排序的字段\",{\"1\":{\"139\":1}}],[\"去再次尝试获取锁\",{\"1\":{\"398\":1}}],[\"组合\",{\"1\":{\"496\":1}}],[\"组成一个完整的链式调用\",{\"1\":{\"396\":1}}],[\"组根服务器\",{\"1\":{\"50\":1}}],[\"管理着任务执行的情况\",{\"1\":{\"395\":1}}],[\"管道只能承载无格式字\",{\"1\":{\"9\":1}}],[\"管道和消息队列的通信数据都是先进先出的原则\",{\"1\":{\"9\":1}}],[\"管道\",{\"1\":{\"9\":1}}],[\"密集型任务\",{\"1\":{\"392\":2}}],[\"容纳的话\",{\"1\":{\"445\":1}}],[\"容量等于\",{\"1\":{\"416\":1}}],[\"容量迅速增\",{\"1\":{\"416\":1}}],[\"容量不能改变\",{\"1\":{\"415\":1}}],[\"容量为\",{\"1\":{\"390\":1,\"430\":1}}],[\"容灾恢复\",{\"1\":{\"172\":1}}],[\"你可以选择这个策略\",{\"1\":{\"389\":1}}],[\"你可以将\",{\"1\":{\"8\":1,\"407\":1}}],[\"抛出\",{\"1\":{\"389\":1}}],[\"抛出异常\",{\"1\":{\"258\":2}}],[\"饱和策略会调用rejectedexecutionhandler\",{\"1\":{\"391\":1}}],[\"饱和策略\",{\"1\":{\"388\":1}}],[\"拒绝策略\",{\"1\":{\"388\":1}}],[\"待线程空闲\",{\"1\":{\"387\":1}}],[\"待有线程空闲时\",{\"1\":{\"387\":1}}],[\"永久代\",{\"1\":{\"504\":2}}],[\"永久代并不会出现这种情况\",{\"1\":{\"504\":1}}],[\"永久性\",{\"1\":{\"78\":1}}],[\"永远无法被\",{\"1\":{\"383\":1}}],[\"盒子中可以存储每个线程的私有数据\",{\"1\":{\"381\":1}}],[\"改为处理其他事情\",{\"1\":{\"377\":1}}],[\"改用\",{\"1\":{\"55\":1,\"271\":1}}],[\"取而代之是元空间\",{\"1\":{\"504\":1}}],[\"取而代之\",{\"1\":{\"454\":1}}],[\"取这个年龄和\",{\"1\":{\"445\":1}}],[\"取出\",{\"1\":{\"382\":1}}],[\"取得代之的是\",{\"1\":{\"372\":1}}],[\"取决于刷盘策略\",{\"1\":{\"246\":1}}],[\"取决\",{\"1\":{\"246\":1}}],[\"修饰\",{\"1\":{\"405\":1}}],[\"修饰的方法并没有\",{\"1\":{\"372\":1}}],[\"修饰方法\",{\"1\":{\"372\":1}}],[\"修饰同步代码块\",{\"1\":{\"372\":1}}],[\"修改失败采用重复尝试的办法\",{\"1\":{\"364\":1}}],[\"修改的代价很大\",{\"1\":{\"131\":1}}],[\"修改的操作语言\",{\"1\":{\"87\":1}}],[\"修改异常\",{\"1\":{\"85\":1}}],[\"做了优化\",{\"1\":{\"370\":1}}],[\"做了更多优化\",{\"1\":{\"219\":1}}],[\"早期版本中synchronized\",{\"1\":{\"370\":1}}],[\"早在\",{\"1\":{\"259\":1}}],[\"经过编译而来\",{\"1\":{\"492\":1}}],[\"经过真正的宣告对象死亡\",{\"1\":{\"452\":1}}],[\"经常会用到自旋操作来进行重试\",{\"1\":{\"368\":1}}],[\"经验表明\",{\"1\":{\"66\":1}}],[\"拟写入的新值\",{\"1\":{\"366\":1}}],[\"预期值\",{\"1\":{\"366\":1}}],[\"预防死锁就是破坏四个必要条件中的任意一个\",{\"1\":{\"347\":1}}],[\"涉及到三个操作数\",{\"1\":{\"366\":1}}],[\"涉及的索引都不会被使用到\",{\"1\":{\"143\":1}}],[\"影响程序的整体性能\",{\"1\":{\"389\":1}}],[\"影响代码的正常运行\",{\"1\":{\"365\":1}}],[\"影响命中率\",{\"1\":{\"175\":1}}],[\"悲观锁还可能会存在死锁问题\",{\"1\":{\"365\":1}}],[\"悲观锁总是假设最坏的情况\",{\"1\":{\"365\":1}}],[\"激烈的锁竞争会造成线程阻塞\",{\"1\":{\"365\":1}}],[\"乐观锁总是假设最好的情况\",{\"1\":{\"364\":1}}],[\"乐观锁和悲观锁\",{\"0\":{\"363\":1}}],[\"轻量级进程\",{\"1\":{\"509\":1}}],[\"轻量级锁是jdk\",{\"1\":{\"401\":1}}],[\"轻量级锁\",{\"0\":{\"401\":1}}],[\"轻量级锁状态\",{\"1\":{\"397\":1}}],[\"轻量级\",{\"1\":{\"362\":1,\"401\":1}}],[\"书写在前的操作happens\",{\"1\":{\"359\":1}}],[\"规定了java源代码到cpu可执行指令这个转化过程要遵循哪些并发相关的原则和规范\",{\"1\":{\"357\":1}}],[\"增量更新就是将那些新加入引用的位置记录\",{\"1\":{\"470\":1}}],[\"增强程序的可移植性\",{\"1\":{\"357\":1}}],[\"增强代码的可移植性\",{\"1\":{\"355\":1}}],[\"增加晋升阈值\",{\"1\":{\"517\":1}}],[\"增加系统的性能开销\",{\"1\":{\"365\":1}}],[\"增加了轮询\",{\"1\":{\"375\":1}}],[\"增加了安全隐患\",{\"1\":{\"317\":1}}],[\"增加了一些高级功能\",{\"1\":{\"377\":1}}],[\"增加了一条双向链表\",{\"1\":{\"251\":1}}],[\"增加了一个权重参数\",{\"1\":{\"225\":1}}],[\"增加\",{\"1\":{\"184\":1}}],[\"银行家算法\",{\"1\":{\"348\":1}}],[\"破坏环路等待\",{\"1\":{\"347\":1}}],[\"破坏请求并保持\",{\"1\":{\"347\":1}}],[\"破坏不剥夺条件\",{\"1\":{\"347\":1}}],[\"环路等待\",{\"1\":{\"346\":1}}],[\"死亡对象的回收代价是零\",{\"1\":{\"513\":1}}],[\"死亡对象的判断方法\",{\"0\":{\"448\":1}}],[\"死锁的四个必要条件\",{\"1\":{\"346\":1}}],[\"死锁\",{\"0\":{\"346\":1}}],[\"死链接可恢复为正常的软链接\",{\"1\":{\"15\":1}}],[\"终止状态\",{\"1\":{\"344\":1}}],[\"终将美好\",{\"1\":{\"0\":1}}],[\"五分钟记住jvm内存结构\",{\"1\":{\"340\":1}}],[\"角度说进程和线程之间的关系\",{\"0\":{\"340\":1}}],[\"延时加载\",{\"1\":{\"333\":1}}],[\"延迟阻塞队列\",{\"1\":{\"390\":1}}],[\"延迟加载\",{\"1\":{\"332\":1}}],[\"延迟等因素来选择最佳路径\",{\"1\":{\"39\":1}}],[\"构造器私有化\",{\"1\":{\"329\":1}}],[\"构造方法私有\",{\"1\":{\"362\":1}}],[\"构造方法不能被重写\",{\"1\":{\"294\":1}}],[\"构造方法无法被重写\",{\"1\":{\"289\":1}}],[\"枚举仍然算饿汉式\",{\"1\":{\"334\":1}}],[\"枚举\",{\"0\":{\"334\":1},\"1\":{\"328\":1}}],[\"懒汉式\",{\"0\":{\"331\":1},\"1\":{\"328\":1}}],[\"饿汉式在类装载的时候就完成实例化\",{\"1\":{\"330\":1}}],[\"饿汉式\",{\"0\":{\"329\":1,\"330\":1},\"1\":{\"328\":1}}],[\"拦截被代理类中的方法\",{\"1\":{\"324\":1}}],[\"流程\",{\"1\":{\"323\":1}}],[\"流量控制是为了控制发送方发送速率\",{\"1\":{\"65\":1}}],[\"流量控制\",{\"1\":{\"64\":1}}],[\"意味着静态代码块和静态对象不会得到执行\",{\"1\":{\"318\":1}}],[\"意向排他锁\",{\"1\":{\"105\":1}}],[\"意向共享锁\",{\"1\":{\"105\":1}}],[\"意向锁之间是相互兼容的\",{\"1\":{\"105\":1}}],[\"意向锁是由数据引擎自己维护的\",{\"1\":{\"105\":1}}],[\"意向锁是表级锁\",{\"1\":{\"105\":1}}],[\"意向锁有什么作用\",{\"0\":{\"105\":1}}],[\"知道具体类的情况下\",{\"1\":{\"318\":1}}],[\"知道内核把数据拷贝到用户空间\",{\"1\":{\"21\":1}}],[\"代表当前这个常量属于哪种常量类型\",{\"1\":{\"476\":1}}],[\"代表\",{\"1\":{\"476\":1}}],[\"代表这个方法是用来比较两个对象是否相等\",{\"1\":{\"301\":1}}],[\"代码中可以不赋初始值就直接使用\",{\"1\":{\"434\":1}}],[\"代码块上都是是给\",{\"1\":{\"371\":1}}],[\"代码的执行顺序未必就是编写代码的顺序\",{\"1\":{\"360\":1}}],[\"代理类这些都变成一个个class文件\",{\"1\":{\"326\":1}}],[\"代理类变成一个个class文件\",{\"1\":{\"321\":1}}],[\"代理类中的真实对象\",{\"1\":{\"316\":1}}],[\"代理模式有静态代理和动态代理两种实现方式\",{\"1\":{\"320\":1}}],[\"代理模式\",{\"0\":{\"320\":1}}],[\"序列化协议属于tcp\",{\"1\":{\"313\":1}}],[\"序列化\",{\"1\":{\"313\":1}}],[\"序列化后的对象\",{\"1\":{\"182\":2,\"213\":1,\"215\":1}}],[\"堆空闲的最大百分比\",{\"1\":{\"509\":1}}],[\"堆空间的大小减小\",{\"1\":{\"509\":1}}],[\"堆内存相关\",{\"0\":{\"501\":1}}],[\"堆分为新生代和老年代\",{\"1\":{\"459\":1}}],[\"堆的较大页面大小\",{\"1\":{\"509\":1}}],[\"堆的gc效率很高\",{\"1\":{\"430\":1}}],[\"堆的内存结构在垃圾回收章节提及\",{\"1\":{\"427\":1}}],[\"堆中不存在该类的任何实例\",{\"1\":{\"455\":1}}],[\"堆中将会划分出一块内存来作为句柄池\",{\"1\":{\"440\":1}}],[\"堆中\",{\"1\":{\"430\":1,\"487\":1}}],[\"堆中创建的对象\",{\"1\":{\"308\":1}}],[\"堆是所有线程共享的一块内存区域\",{\"1\":{\"427\":1}}],[\"堆是进程内存中最大的一块区域\",{\"1\":{\"343\":1}}],[\"堆上的所有数据都不会逃逸出去从而被其他线程所访问到\",{\"1\":{\"399\":1}}],[\"堆\",{\"0\":{\"427\":1},\"1\":{\"390\":1,\"467\":1}}],[\"堆和方法区都是线程共享的资源\",{\"1\":{\"343\":1}}],[\"堆和方法区\",{\"0\":{\"343\":1},\"1\":{\"446\":1}}],[\"堆排序\",{\"1\":{\"260\":1}}],[\"堆排序的伪代码\",{\"1\":{\"260\":1}}],[\"示意图\",{\"1\":{\"306\":1}}],[\"拼完之后调用tostring\",{\"1\":{\"305\":1}}],[\"少量数据使用string\",{\"1\":{\"303\":1}}],[\"少量的丢包就可能导致整个\",{\"1\":{\"55\":1}}],[\"作用是将指定的字符串对象保存到字符串常量池中\",{\"1\":{\"307\":1}}],[\"作用是确定在哈希表中的位置\",{\"1\":{\"300\":1}}],[\"作用\",{\"0\":{\"300\":1}}],[\"作为方法区这些数据的入口\",{\"1\":{\"485\":1}}],[\"作为新的晋升年龄阈值\",{\"1\":{\"445\":1}}],[\"作为\",{\"1\":{\"189\":1}}],[\"作为字符串结束的标识\",{\"1\":{\"184\":1}}],[\"作为唯一标识符\",{\"1\":{\"74\":1}}],[\"深拷贝\",{\"0\":{\"297\":1},\"1\":{\"297\":1}}],[\"浅拷贝\",{\"0\":{\"297\":1},\"1\":{\"297\":1}}],[\"抽象了线程和内存之间的关系\",{\"1\":{\"357\":1}}],[\"抽象类中的成员变量默认default\",{\"1\":{\"296\":1}}],[\"抽奖系统\",{\"1\":{\"187\":1,\"224\":1}}],[\"打印safepoint信息\",{\"1\":{\"507\":1}}],[\"打印stw时间\",{\"1\":{\"507\":1}}],[\"打印reference处理信息\",{\"1\":{\"507\":1}}],[\"打印堆数据\",{\"1\":{\"507\":1}}],[\"打印对象分布\",{\"1\":{\"507\":1}}],[\"打印基本\",{\"1\":{\"507\":1}}],[\"打印技能1\",{\"1\":{\"295\":1}}],[\"打破双亲委派模型方法\",{\"0\":{\"499\":1}}],[\"打开模式等等\",{\"1\":{\"8\":1}}],[\"移速等基础属性\",{\"1\":{\"295\":1}}],[\"移除了永久代用元空间\",{\"1\":{\"454\":1}}],[\"移除并获取指定列表的最后一个元素\",{\"1\":{\"217\":1}}],[\"移除并获取指定列表的第一个元素\",{\"1\":{\"217\":1}}],[\"移除最不经常使用的\",{\"1\":{\"201\":1}}],[\"移除最近最少使用的\",{\"1\":{\"201\":1}}],[\"继承则是强调复用\",{\"1\":{\"296\":1}}],[\"继承\",{\"1\":{\"295\":1,\"375\":1}}],[\"继承自\",{\"1\":{\"251\":1,\"261\":1,\"414\":1}}],[\"封装是将一个对象的状态信息隐藏在内部\",{\"1\":{\"295\":1}}],[\"封装\",{\"1\":{\"295\":1}}],[\"形同虚设\",{\"1\":{\"453\":1}}],[\"形参和实参\",{\"0\":{\"310\":1}}],[\"形参列表相同\",{\"1\":{\"289\":1}}],[\"形成这个扫描区间的条件是a>1\",{\"1\":{\"136\":1}}],[\"静态内部类\",{\"0\":{\"333\":1},\"1\":{\"328\":1}}],[\"静态代码块\",{\"0\":{\"330\":1},\"1\":{\"328\":1}}],[\"静态代理在编译时就将接口\",{\"1\":{\"326\":1}}],[\"静态代理在编译的时候就将接口\",{\"1\":{\"321\":1}}],[\"静态代理和动态代理的区别\",{\"0\":{\"326\":1}}],[\"静态代理中接口新增方法\",{\"1\":{\"326\":1}}],[\"静态代理中\",{\"1\":{\"321\":1}}],[\"静态代理\",{\"0\":{\"321\":1}}],[\"静态常量\",{\"0\":{\"329\":1},\"1\":{\"328\":1}}],[\"静态方法和\",{\"1\":{\"371\":1}}],[\"静态方法属于类\",{\"1\":{\"288\":1}}],[\"静态方法为什么不能调用非静态成员\",{\"0\":{\"288\":1}}],[\"静态变量等移动到堆中\",{\"1\":{\"487\":1}}],[\"静态变量通过类名\",{\"1\":{\"286\":1}}],[\"静态变量就是被static修饰的变量\",{\"1\":{\"286\":1}}],[\"静态变量\",{\"0\":{\"286\":1},\"1\":{\"343\":1}}],[\"拆箱就是使用xxvalue方法\",{\"1\":{\"281\":1}}],[\"装箱就是使用包装类的valueof方法\",{\"1\":{\"281\":1}}],[\"程序代码\",{\"1\":{\"489\":1}}],[\"程序语义检查\",{\"1\":{\"486\":1}}],[\"程序安全都是第一位\",{\"1\":{\"486\":1}}],[\"程序无须重新编译便可在多种不同操作系统的计算机上运行\",{\"1\":{\"472\":1}}],[\"程序运行时比较高效\",{\"1\":{\"472\":1}}],[\"程序继续执行\",{\"1\":{\"467\":1}}],[\"程序如果发现某个虚引用已经被加入到引用队列\",{\"1\":{\"453\":1}}],[\"程序可以通过判断引用队列中是否已经加入了虚引用\",{\"1\":{\"453\":1}}],[\"程序能访问到这些字段的数据类型所对应的零值\",{\"1\":{\"434\":1}}],[\"程序能正确执行吗\",{\"0\":{\"294\":1}}],[\"程序顺序规则\",{\"1\":{\"359\":1}}],[\"程序计数器是唯一一个不会出现oom的内存区域\",{\"1\":{\"423\":1}}],[\"程序计数器用来记录当前线程执行的位置\",{\"1\":{\"341\":1}}],[\"程序计数器存放的是下一条将要执行指令的地址\",{\"1\":{\"341\":1}}],[\"程序计数器为什么是线程私有\",{\"0\":{\"341\":1}}],[\"程序计数器\",{\"0\":{\"423\":1},\"1\":{\"340\":1}}],[\"程序内存更加安全\",{\"1\":{\"277\":1}}],[\"程序状态字\",{\"1\":{\"8\":1}}],[\"编译从\",{\"1\":{\"321\":1}}],[\"编译器在不改变单线程程序语义的前提下\",{\"1\":{\"354\":1}}],[\"编译器优化重排\",{\"1\":{\"354\":1}}],[\"编译器会自动生成\",{\"1\":{\"314\":1}}],[\"编译器会在编译期间直接放入字符串常量池中\",{\"1\":{\"308\":1}}],[\"编译器对字符串拼接的优化\",{\"0\":{\"308\":1}}],[\"编译器不会复用stringbuilder\",{\"1\":{\"305\":1}}],[\"编译是否能通过看左边\",{\"1\":{\"295\":1}}],[\"编译成机器可以理解的代码\",{\"1\":{\"276\":1}}],[\"编码或者解码或者图片的路径\",{\"1\":{\"182\":1,\"213\":1}}],[\"笔记来源网络\",{\"1\":{\"274\":1}}],[\"笔记来自javaguide和黑马程序员网课\",{\"1\":{\"0\":1}}],[\"放入堆中能加快回收频率\",{\"1\":{\"430\":1}}],[\"放入buffer\",{\"1\":{\"145\":1}}],[\"放弃了\",{\"1\":{\"272\":1}}],[\"忽略符号位\",{\"1\":{\"267\":1}}],[\"^\",{\"1\":{\"267\":2}}],[\"效率问题\",{\"1\":{\"457\":1}}],[\"效率高\",{\"1\":{\"333\":1}}],[\"效率较高\",{\"1\":{\"332\":1}}],[\"效率较低\",{\"1\":{\"331\":1}}],[\"效率低下\",{\"1\":{\"271\":1}}],[\"效率\",{\"1\":{\"264\":1}}],[\"<pid>\",{\"1\":{\"508\":1}}],[\"<clinit>\",{\"1\":{\"489\":1}}],[\"<init>\",{\"1\":{\"436\":1}}],[\"<ip\",{\"1\":{\"79\":1}}],[\"<version>3\",{\"1\":{\"324\":1}}],[\"<artifactid>cglib<\",{\"1\":{\"324\":1}}],[\"<groupid>cglib<\",{\"1\":{\"324\":1}}],[\"<dependency>\",{\"1\":{\"324\":1}}],[\"<\",{\"1\":{\"260\":3,\"324\":1,\"508\":2}}],[\"调节晋升阈值\",{\"1\":{\"514\":1}}],[\"调度的最小单位从进程变成了线程\",{\"1\":{\"339\":1}}],[\"调整函数\",{\"1\":{\"260\":1}}],[\"调用父类的loadclass\",{\"1\":{\"499\":1}}],[\"调用semaphore\",{\"1\":{\"407\":2}}],[\"调用执行自己的线程运行任务\",{\"1\":{\"389\":1}}],[\"调用后\",{\"1\":{\"18\":1}}],[\"调用\",{\"1\":{\"18\":1,\"351\":1,\"407\":1}}],[\"适用于频繁查找的场景\",{\"1\":{\"254\":1}}],[\"适合内存不规整的情况\",{\"1\":{\"433\":1}}],[\"适合内存规整的情况\",{\"1\":{\"433\":1}}],[\"适合在对性能要求相对较高\",{\"1\":{\"413\":1}}],[\"适合做数据的备份\",{\"1\":{\"246\":1}}],[\"适合允许重复中奖的场景\",{\"1\":{\"188\":1,\"224\":1}}],[\"适合不允许重复中奖的场景\",{\"1\":{\"188\":1,\"224\":1}}],[\"才开始真正执行类中定义的\",{\"1\":{\"489\":1}}],[\"才被引入completablefuture\",{\"1\":{\"396\":1}}],[\"才被引入的\",{\"1\":{\"259\":1}}],[\"才能进行其他逻辑处理\",{\"1\":{\"378\":1}}],[\"才去创建singleton\",{\"1\":{\"331\":1}}],[\"才真正分配容量\",{\"1\":{\"253\":1}}],[\"才会使用cas+重试的分配方式\",{\"1\":{\"433\":1}}],[\"才会使用到\",{\"1\":{\"206\":1}}],[\"才会设置\",{\"1\":{\"204\":1}}],[\"扩容都会发生\",{\"1\":{\"504\":1}}],[\"扩容之后变为2n+1\",{\"1\":{\"264\":1}}],[\"扩容\",{\"1\":{\"264\":1}}],[\"扩容后大小为int\",{\"1\":{\"253\":1}}],[\"扩展类加载器\",{\"1\":{\"494\":1}}],[\"扩展目标对象\",{\"1\":{\"320\":1}}],[\"扩展\",{\"1\":{\"179\":1}}],[\"底层基于单向链表实现的阻塞队列\",{\"1\":{\"416\":1}}],[\"底层依赖于一条\",{\"1\":{\"366\":1}}],[\"底层采用数组来实现\",{\"1\":{\"415\":1}}],[\"底层采用\",{\"1\":{\"271\":2}}],[\"底层数据结构\",{\"1\":{\"271\":1}}],[\"底层\",{\"1\":{\"264\":1}}],[\"底层用object\",{\"1\":{\"254\":2}}],[\"底层是数组+链表\",{\"1\":{\"251\":1}}],[\"底层使用hashmap保存数据\",{\"1\":{\"251\":1}}],[\"双亲委派模式\",{\"1\":{\"498\":1}}],[\"双亲委派模型的执行流程\",{\"0\":{\"497\":1}}],[\"双亲委派模型并不是一种强制性的约束\",{\"1\":{\"496\":1}}],[\"双亲委派模型\",{\"1\":{\"496\":1}}],[\"双亲委派模型要求除了顶层的启动类加载器外\",{\"1\":{\"496\":1}}],[\"双亲委派的好处\",{\"0\":{\"498\":1}}],[\"双亲委派\",{\"0\":{\"496\":1}}],[\"双检查单例模式\",{\"1\":{\"362\":1}}],[\"双重检查\",{\"0\":{\"332\":1},\"1\":{\"328\":1}}],[\"双指针\",{\"1\":{\"251\":1}}],[\"双向链表\",{\"1\":{\"212\":1,\"216\":1,\"251\":1}}],[\"按先入先出的顺序执行队列中的任务\",{\"1\":{\"387\":1}}],[\"按位异或\",{\"1\":{\"267\":1}}],[\"按特定的排队规则确定元素先后顺序\",{\"1\":{\"250\":1}}],[\"按照年龄从小到大对其所占用的大小进行累积\",{\"1\":{\"445\":1}}],[\"按照消费者组进行消费\",{\"1\":{\"179\":1}}],[\"按照特性的范围区间来分配数据\",{\"1\":{\"118\":1}}],[\"按照mysql认为最优的方案去执行\",{\"1\":{\"91\":1}}],[\"按照网上大部分文章的解释\",{\"1\":{\"40\":1}}],[\"按照请求到达磁盘调度器的顺序进行处理\",{\"1\":{\"16\":1}}],[\"独占\",{\"1\":{\"406\":1}}],[\"独占锁\",{\"1\":{\"104\":1}}],[\"独一无二\",{\"1\":{\"250\":1}}],[\"顺序存储\",{\"1\":{\"250\":1}}],[\"四个字节存储的是\",{\"1\":{\"475\":1}}],[\"四者的区别\",{\"0\":{\"250\":1}}],[\"四次挥手\",{\"0\":{\"60\":1}}],[\"说明新生代占整个内存的1\",{\"1\":{\"503\":1}}],[\"说说arraylist\",{\"0\":{\"253\":1}}],[\"说说\",{\"0\":{\"250\":1}}],[\"说一下\",{\"0\":{\"172\":1}}],[\"低停顿\",{\"1\":{\"466\":1}}],[\"低\",{\"1\":{\"246\":2}}],[\"低很多\",{\"1\":{\"53\":1}}],[\"慢\",{\"1\":{\"246\":1}}],[\"慢开始算法的思路是当主机开始发送数据时\",{\"1\":{\"66\":1}}],[\"慢开始\",{\"1\":{\"66\":1}}],[\"宕机恢复速度\",{\"1\":{\"246\":1}}],[\"综上\",{\"1\":{\"246\":1,\"488\":1}}],[\"版本演进中有多个版本的\",{\"1\":{\"246\":1}}],[\"版本后增加以下两种\",{\"1\":{\"201\":1}}],[\"策略\",{\"1\":{\"246\":1}}],[\"速度很快\",{\"1\":{\"466\":1,\"470\":1}}],[\"速度非常慢\",{\"1\":{\"246\":1}}],[\"速度非常快\",{\"1\":{\"246\":1}}],[\"速度更快\",{\"1\":{\"108\":1,\"246\":1}}],[\"变量添加final修饰\",{\"1\":{\"487\":1}}],[\"变量作为计数器\",{\"1\":{\"409\":1}}],[\"变量由\",{\"1\":{\"405\":1}}],[\"变量是放在了当前线程的threadlocalmap中\",{\"1\":{\"382\":1}}],[\"变量\",{\"0\":{\"285\":1},\"1\":{\"382\":1}}],[\"变得太大时\",{\"1\":{\"246\":1}}],[\"变成三次挥手\",{\"0\":{\"61\":1}}],[\"灾难恢复\",{\"1\":{\"246\":1}}],[\"校验机制十分简单有效\",{\"1\":{\"245\":1}}],[\"校验机制是\",{\"1\":{\"245\":1}}],[\"校验机制了解吗\",{\"0\":{\"245\":1}}],[\"校验和\",{\"1\":{\"64\":1,\"245\":1}}],[\"严重的情况下甚至会直接把\",{\"1\":{\"246\":1}}],[\"严重影响性能\",{\"1\":{\"242\":1}}],[\"严格说来\",{\"1\":{\"50\":1}}],[\"保存的是字符串\",{\"1\":{\"430\":1}}],[\"保存的数据丢失一些也没什么影响的话\",{\"1\":{\"246\":1}}],[\"保存了将要执行指令的地址\",{\"1\":{\"423\":1}}],[\"保存字符串的数组是final修饰的\",{\"1\":{\"304\":1}}],[\"保存着某个时间点的数据集\",{\"1\":{\"246\":1}}],[\"保存文件的频率有三种\",{\"1\":{\"242\":1}}],[\"保证这些信息被当做代码运行后不会危害虚拟机自身的安全\",{\"1\":{\"486\":1}}],[\"保证内存分配时的线程安全\",{\"1\":{\"433\":1}}],[\"保证了java程序的稳定运行\",{\"1\":{\"498\":1}}],[\"保证了\",{\"1\":{\"467\":1}}],[\"保证了共享变量的\",{\"1\":{\"362\":1}}],[\"保证了mysql集群架构的数据一致性\",{\"1\":{\"152\":1}}],[\"保证可见性\",{\"1\":{\"362\":1}}],[\"保证读写都串行化\",{\"1\":{\"362\":1}}],[\"保证在整个系统中\",{\"1\":{\"327\":1}}],[\"保证线程安全\",{\"1\":{\"272\":1}}],[\"保证数据的持久化\",{\"1\":{\"241\":1}}],[\"保证数据的一致性\",{\"1\":{\"149\":1}}],[\"保证数据一致性\",{\"1\":{\"154\":1}}],[\"保证事务的持久性\",{\"1\":{\"154\":1}}],[\"保证任何节点的左右子树高度差的绝对值不超过1\",{\"1\":{\"125\":1}}],[\"保证主数据库和从数据库之间的数据是实时同步的\",{\"1\":{\"112\":1}}],[\"保证接收方来得及接收\",{\"1\":{\"65\":1}}],[\"达到压缩目的\",{\"1\":{\"241\":1}}],[\"追求更快的启动速度的场景\",{\"1\":{\"246\":1}}],[\"追加文件\",{\"1\":{\"240\":1}}],[\"追上\",{\"1\":{\"147\":1}}],[\"压缩\",{\"1\":{\"238\":1}}],[\"压缩列表\",{\"1\":{\"212\":1}}],[\"权重参数\",{\"1\":{\"235\":1}}],[\"权限校验\",{\"1\":{\"91\":1}}],[\"权限\",{\"1\":{\"50\":1}}],[\"热门帖子\",{\"1\":{\"233\":1}}],[\"热门网站每日\",{\"1\":{\"233\":1}}],[\"千万级别以上\",{\"1\":{\"233\":1}}],[\"百万\",{\"1\":{\"233\":1}}],[\"算出对应的唯一计数\",{\"1\":{\"232\":1}}],[\"算法不同\",{\"1\":{\"467\":1}}],[\"算法会导致收集结束时会有大量空间碎片产生\",{\"1\":{\"466\":1}}],[\"算法实现的收集器\",{\"1\":{\"467\":1}}],[\"算法实现的\",{\"1\":{\"466\":1,\"467\":1}}],[\"算法实现起来比较简单\",{\"1\":{\"16\":1}}],[\"算法进行垃圾收集\",{\"1\":{\"459\":1}}],[\"算法进行了改进\",{\"1\":{\"16\":2}}],[\"算法分为\",{\"1\":{\"457\":1}}],[\"算法计算得出的数字\",{\"1\":{\"245\":1}}],[\"算法转换成了一个整数\",{\"1\":{\"235\":1}}],[\"算法的思想是让客户端向\",{\"1\":{\"208\":1}}],[\"算法的变体\",{\"1\":{\"16\":1}}],[\"算法来解决\",{\"1\":{\"208\":1}}],[\"算法对\",{\"1\":{\"16\":2}}],[\"算法中磁头到了磁盘的边界才改变移动方向\",{\"1\":{\"16\":1}}],[\"算法能够保证所有的请求得到服务\",{\"1\":{\"16\":1}}],[\"算法能够最小化磁头的寻道时间\",{\"1\":{\"16\":1}}],[\"算法\",{\"0\":{\"366\":1},\"1\":{\"16\":2,\"465\":1}}],[\"合并到\",{\"1\":{\"232\":1}}],[\"合并起来\",{\"0\":{\"61\":1}}],[\"稠密矩阵\",{\"1\":{\"231\":1}}],[\"稀疏矩阵\",{\"1\":{\"231\":1}}],[\"特殊情况\",{\"1\":{\"487\":1}}],[\"特性之外\",{\"1\":{\"396\":1}}],[\"特定条件链表转化为红黑树\",{\"1\":{\"264\":1}}],[\"特有的\",{\"1\":{\"231\":1}}],[\"特别注意\",{\"1\":{\"453\":1}}],[\"特别适合用于存储对象\",{\"1\":{\"219\":1}}],[\"特别当查询的字段是字符串时\",{\"1\":{\"143\":1}}],[\"活跃用户情况\",{\"1\":{\"230\":1}}],[\"活跃事务列表\",{\"1\":{\"162\":1}}],[\"求差集\",{\"1\":{\"226\":1}}],[\"求并集\",{\"1\":{\"226\":1}}],[\"求指定key的哈希\",{\"1\":{\"118\":1}}],[\"向指定有序集合添加一个或多个元素\",{\"1\":{\"226\":1}}],[\"向指定集合添加一个或多个元素\",{\"1\":{\"188\":1,\"223\":1}}],[\"键\",{\"1\":{\"220\":1}}],[\"键值对\",{\"1\":{\"219\":1}}],[\"键值对数据\",{\"1\":{\"170\":1}}],[\"域\",{\"1\":{\"220\":1}}],[\"域名系统\",{\"1\":{\"56\":1}}],[\"域名管理系统\",{\"1\":{\"37\":1,\"49\":1}}],[\"链表则是主要为了解决哈希冲突而存在的\",{\"1\":{\"271\":1}}],[\"链表则是主要为了解决哈希冲突而存在\",{\"1\":{\"251\":2}}],[\"链表\",{\"1\":{\"219\":1}}],[\"信息\",{\"1\":{\"507\":1}}],[\"信息流展示\",{\"1\":{\"218\":1}}],[\"信号驱动\",{\"1\":{\"19\":1}}],[\"信号是一种比较复杂的通信方式\",{\"1\":{\"9\":1}}],[\"信号\",{\"1\":{\"9\":1}}],[\"信号量的意图在于进程间同步\",{\"1\":{\"9\":1}}],[\"信号量是一个计数器\",{\"1\":{\"9\":1}}],[\"信号量\",{\"0\":{\"407\":1},\"1\":{\"7\":1,\"9\":1,\"407\":1}}],[\"右边\",{\"1\":{\"217\":1}}],[\"右子树所有节点的值均大于根节点的值\",{\"1\":{\"124\":1}}],[\"举例\",{\"1\":{\"215\":2,\"218\":1,\"221\":1,\"224\":3,\"227\":2,\"230\":1,\"233\":1,\"236\":1}}],[\"举个例子\",{\"1\":{\"12\":1}}],[\"返回实例对象\",{\"1\":{\"329\":1}}],[\"返回散列值也就是hashcode\",{\"1\":{\"267\":1}}],[\"返回特殊值\",{\"1\":{\"258\":2}}],[\"返回两个给定元素之间的距离\",{\"1\":{\"235\":1}}],[\"返回给定元素的经纬度信息\",{\"1\":{\"235\":1}}],[\"返回\",{\"1\":{\"214\":1}}],[\"介绍\",{\"1\":{\"214\":1,\"217\":1,\"220\":1,\"223\":1,\"226\":1,\"229\":1,\"232\":1,\"235\":1}}],[\"监听的是删除事件\",{\"1\":{\"211\":1}}],[\"势必会造成所有尝试获取锁的客户端来争夺锁\",{\"1\":{\"210\":1}}],[\"绑定的\",{\"1\":{\"210\":1}}],[\"针对\",{\"1\":{\"446\":1}}],[\"针对不同系统有不同的实现\",{\"1\":{\"275\":1}}],[\"针对这个问题\",{\"1\":{\"208\":1}}],[\"针对网络数据的读写引入了多线程\",{\"1\":{\"172\":1}}],[\"红黑二叉树\",{\"1\":{\"271\":1}}],[\"红黑树作为底层\",{\"1\":{\"268\":1}}],[\"红黑树组成\",{\"1\":{\"251\":1}}],[\"红黑树的插入和删除操作效率大大提高了\",{\"1\":{\"126\":1}}],[\"红黑树的查询效率稍有下降\",{\"1\":{\"126\":1}}],[\"红黑树并不追求严格的平衡\",{\"1\":{\"126\":1}}],[\"红黑树是一种自平衡的二叉查找树\",{\"1\":{\"126\":1}}],[\"红黑树\",{\"0\":{\"126\":1},\"1\":{\"251\":2,\"264\":1,\"271\":1}}],[\"红锁\",{\"1\":{\"207\":1}}],[\"推荐新生代大小占整个堆的百分之25到百分之50\",{\"1\":{\"513\":1}}],[\"推荐将加锁的范围尽可能的变小以获得更好的性能\",{\"1\":{\"400\":1}}],[\"推荐使用线程安全的cucurrenthashmap\",{\"1\":{\"270\":1}}],[\"推荐使用我们上面提到的\",{\"1\":{\"207\":1}}],[\"推进一下\",{\"1\":{\"147\":1}}],[\"手动给锁设置过期时间\",{\"1\":{\"206\":1}}],[\"拿锁且不设置锁超时时间\",{\"1\":{\"206\":1}}],[\"看门狗续期前也会先判断是否需要执行续期操作\",{\"1\":{\"206\":1}}],[\"看门狗就会执行续期操作\",{\"1\":{\"206\":1}}],[\"看门狗名字的由来于\",{\"1\":{\"206\":1}}],[\"看门狗\",{\"1\":{\"206\":1}}],[\"选用\",{\"1\":{\"204\":1}}],[\"选择合适的字段创建索引\",{\"0\":{\"139\":1}}],[\"选择其中一台作为主数据库\",{\"1\":{\"112\":1}}],[\"选择重传协议不再具有累计确认机制\",{\"1\":{\"70\":1}}],[\"选择重传协议\",{\"0\":{\"70\":1}}],[\"选择跳数最少的路径作为最佳路径\",{\"1\":{\"39\":1}}],[\"唯一\",{\"1\":{\"251\":2}}],[\"唯一值\",{\"1\":{\"204\":1}}],[\"唯一索引的属性页不能出现重复的数据\",{\"1\":{\"129\":1}}],[\"唯一索引是一种约束\",{\"1\":{\"129\":1}}],[\"唯一索引\",{\"1\":{\"129\":1}}],[\"释放许可证成功之后\",{\"1\":{\"407\":1}}],[\"释放1个许可\",{\"1\":{\"407\":1}}],[\"释放锁\",{\"1\":{\"206\":1,\"209\":1}}],[\"释放锁时\",{\"1\":{\"204\":1}}],[\"释放锁的话\",{\"1\":{\"204\":1}}],[\"释放子进程占用的资源\",{\"1\":{\"10\":1}}],[\"啥也不做\",{\"1\":{\"204\":1}}],[\"任务执行期间自己可以去做任何想做的事情\",{\"1\":{\"394\":1}}],[\"任务队列已经满了\",{\"1\":{\"391\":1}}],[\"任务队列中存放的任务达到队列容量的时候\",{\"1\":{\"388\":1}}],[\"任务队列未达到队列容量时\",{\"1\":{\"388\":1}}],[\"任务队列\",{\"1\":{\"387\":1,\"388\":1}}],[\"任务会被保存在一个任务队列中\",{\"1\":{\"387\":1}}],[\"任意一个时刻\",{\"1\":{\"202\":1}}],[\"任何时候\",{\"1\":{\"486\":1}}],[\"任何时候都有可能被回收\",{\"1\":{\"453\":1}}],[\"任何人实现的编译器都可以向属性表中写\",{\"1\":{\"481\":1}}],[\"任何地方运行\",{\"1\":{\"276\":1}}],[\"任何节点的左右子树高度差的绝对值不超过1即为平衡\",{\"1\":{\"124\":1}}],[\"任何两个查询在任何字符上的不同都会导致缓存不命中\",{\"1\":{\"94\":1}}],[\"禁止驱逐数据\",{\"1\":{\"201\":1}}],[\"定义两种资源共享方式\",{\"1\":{\"406\":1}}],[\"定义了jvm在运行时如何分区存储数据\",{\"1\":{\"357\":1}}],[\"定义在object类中\",{\"1\":{\"300\":1}}],[\"定时对整个内存创建快照\",{\"1\":{\"246\":1}}],[\"定期删除\",{\"1\":{\"200\":1}}],[\"定位到索引的节点\",{\"1\":{\"131\":1}}],[\"惰性删除\",{\"1\":{\"200\":1}}],[\"占用部分资源的线程在进一步申请资源失败时\",{\"1\":{\"347\":1}}],[\"占用内存比arraylist大\",{\"1\":{\"255\":1}}],[\"占用\",{\"1\":{\"231\":1}}],[\"占用空间很小\",{\"1\":{\"231\":1}}],[\"占用空间非常非常小\",{\"1\":{\"231\":1}}],[\"占用空间更小\",{\"1\":{\"107\":1}}],[\"占用的内存空间\",{\"1\":{\"197\":1}}],[\"已经被加载的类会直接返回\",{\"1\":{\"493\":1}}],[\"已经被回收\",{\"1\":{\"455\":1}}],[\"已经把原本放在永久代的字符串常量池\",{\"1\":{\"487\":1}}],[\"已经到达了屏障\",{\"1\":{\"409\":1}}],[\"已经摒弃了\",{\"1\":{\"271\":1}}],[\"已经存在\",{\"1\":{\"204\":1}}],[\"已经分配给进程使用但未被使用的内存\",{\"1\":{\"12\":1}}],[\"已删除\",{\"1\":{\"197\":1}}],[\"降低停顿时间是\",{\"1\":{\"467\":1}}],[\"降低资源消耗\",{\"1\":{\"386\":1}}],[\"降低了资源消耗\",{\"1\":{\"194\":1}}],[\"降低sql执行效率\",{\"1\":{\"121\":1}}],[\"单次暂停时间特别长\",{\"1\":{\"518\":1}}],[\"单例模式实现方式\",{\"0\":{\"328\":1}}],[\"单例模式\",{\"0\":{\"327\":1}}],[\"单机\",{\"1\":{\"206\":1}}],[\"单线程下大量数据使用stringbuilder\",{\"1\":{\"303\":1}}],[\"单线程变成容易并且易于维护\",{\"1\":{\"195\":1}}],[\"单线程如何监听大量的客户端连接\",{\"0\":{\"194\":1}}],[\"单表的数据达到千万级别以上\",{\"1\":{\"117\":1}}],[\"添加元素满了之后会自动扩容原来容量的\",{\"1\":{\"390\":1}}],[\"添加锁和释放锁的大部分操作实际上都是在\",{\"1\":{\"375\":1}}],[\"添加依赖\",{\"1\":{\"324\":1}}],[\"添加一个或多个元素对应的经纬度信息到\",{\"1\":{\"235\":1}}],[\"添加一个或多个元素\",{\"1\":{\"217\":2}}],[\"添加一个或多个元素到\",{\"1\":{\"190\":1,\"232\":1}}],[\"添加到\",{\"1\":{\"190\":1}}],[\"获取其父\",{\"1\":{\"494\":1}}],[\"获取1个许可\",{\"1\":{\"407\":1}}],[\"获取计算结果的\",{\"1\":{\"396\":1}}],[\"获取当前请求的线程\",{\"1\":{\"382\":1}}],[\"获取后将锁计数器设为\",{\"1\":{\"372\":1}}],[\"获取方法并执行\",{\"0\":{\"319\":1}}],[\"获取\",{\"1\":{\"229\":1,\"318\":1}}],[\"获取集合数量\",{\"1\":{\"224\":1}}],[\"获取给定所有集合的差集\",{\"1\":{\"223\":1}}],[\"获取给定所有集合的并集\",{\"1\":{\"223\":1}}],[\"获取给定所有集合的交集\",{\"1\":{\"223\":1}}],[\"获取多个字段的值\",{\"1\":{\"221\":1}}],[\"获取单个字段的值\",{\"1\":{\"221\":1}}],[\"获取列表\",{\"1\":{\"217\":1}}],[\"获取列表元素数量\",{\"1\":{\"217\":1}}],[\"获取一个或多个指定\",{\"1\":{\"214\":1}}],[\"获取一个或者多个\",{\"1\":{\"190\":1,\"232\":1}}],[\"获取指定位置附近\",{\"1\":{\"235\":1}}],[\"获取指定位置附近的元素等功能\",{\"1\":{\"234\":1}}],[\"获取指定有序集合\",{\"1\":{\"226\":2}}],[\"获取指定有序集合中指定元素的排名\",{\"1\":{\"226\":1}}],[\"获取指定有序集合中指定元素的\",{\"1\":{\"226\":1}}],[\"获取指定有序集合的元素数量\",{\"1\":{\"226\":1}}],[\"获取指定集合的元素数量\",{\"1\":{\"223\":1}}],[\"获取指定集合中的所有元素\",{\"1\":{\"223\":1}}],[\"获取指定哈希表中字段的数量\",{\"1\":{\"220\":1}}],[\"获取指定哈希表中所有的键值对\",{\"1\":{\"220\":1}}],[\"获取指定哈希表中一个或者多个指定字段的值\",{\"1\":{\"220\":1}}],[\"获取指定哈希表中指定字段的值\",{\"1\":{\"220\":1}}],[\"获取指定\",{\"1\":{\"214\":1,\"229\":1}}],[\"获取指定的分布式锁对象\",{\"1\":{\"206\":1}}],[\"获取锁的过程中可以被中断\",{\"1\":{\"378\":1}}],[\"获取锁失败\",{\"1\":{\"209\":1}}],[\"获取锁\",{\"1\":{\"209\":1}}],[\"获取字符串长度的复杂度较低\",{\"1\":{\"184\":1}}],[\"怎么做\",{\"0\":{\"190\":1}}],[\"初始大小\",{\"1\":{\"504\":1}}],[\"初始标记很好理解\",{\"1\":{\"470\":1}}],[\"初始标记\",{\"1\":{\"466\":1,\"467\":1}}],[\"初始化一个类\",{\"1\":{\"489\":1}}],[\"初始化阶段是执行初始化方法\",{\"1\":{\"489\":1}}],[\"初始化阶段才会赋值\",{\"1\":{\"487\":1}}],[\"初始化\",{\"0\":{\"489\":1},\"1\":{\"483\":1}}],[\"初始化零值完成之后\",{\"1\":{\"435\":1}}],[\"初始化零值\",{\"0\":{\"434\":1}}],[\"初始化数据\",{\"1\":{\"189\":1}}],[\"初始状态\",{\"1\":{\"344\":1}}],[\"初始值为\",{\"1\":{\"66\":1}}],[\"精确到天\",{\"1\":{\"189\":1}}],[\"随着更多类的创建\",{\"1\":{\"504\":1}}],[\"随着线程的创建而创建\",{\"1\":{\"423\":1}}],[\"随着aof文件越来越大\",{\"1\":{\"241\":1}}],[\"随机获取集合中的元素\",{\"1\":{\"224\":1}}],[\"随机获取集合中的元素并移除\",{\"1\":{\"224\":1}}],[\"随机获取指定集合中指定数量的元素\",{\"1\":{\"188\":1,\"223\":1}}],[\"随机点名等场景\",{\"1\":{\"224\":1}}],[\"随机点名等等\",{\"1\":{\"187\":1}}],[\"随机移除并获取指定集合中一个或多个元素\",{\"1\":{\"188\":1,\"223\":1}}],[\"随后\",{\"1\":{\"60\":1}}],[\"订阅号推荐\",{\"1\":{\"187\":1,\"224\":1}}],[\"订阅模式\",{\"1\":{\"179\":1}}],[\"音乐推荐\",{\"1\":{\"187\":1,\"224\":1}}],[\"音频\",{\"1\":{\"184\":1}}],[\"差集的操作\",{\"1\":{\"222\":1}}],[\"差集+交集\",{\"1\":{\"187\":1,\"224\":1}}],[\"差集\",{\"1\":{\"187\":2,\"224\":4}}],[\"好友推荐\",{\"1\":{\"187\":1,\"224\":1}}],[\"交集\",{\"1\":{\"187\":3,\"224\":5}}],[\"统计指定页面的\",{\"1\":{\"190\":1}}],[\"统计页面\",{\"0\":{\"190\":1},\"1\":{\"190\":1}}],[\"统计\",{\"1\":{\"187\":1,\"189\":2,\"224\":1,\"233\":1}}],[\"统计活跃用户的话\",{\"1\":{\"189\":1}}],[\"统计活跃用户怎么做\",{\"0\":{\"189\":1}}],[\"统计活跃用户\",{\"1\":{\"179\":1}}],[\"话题热度排行榜等等\",{\"1\":{\"186\":1,\"227\":1}}],[\"游戏中的段位排行榜\",{\"1\":{\"186\":1,\"227\":1}}],[\"朋友圈的微信步数排行榜\",{\"1\":{\"186\":1,\"227\":1}}],[\"商品信息\",{\"1\":{\"221\":1}}],[\"商品数量为\",{\"1\":{\"185\":1}}],[\"商品\",{\"1\":{\"185\":1}}],[\"购物车信息\",{\"1\":{\"221\":1}}],[\"购物车信息建议使用\",{\"1\":{\"185\":1}}],[\"购物车信息用\",{\"0\":{\"185\":1}}],[\"像g1的话\",{\"1\":{\"469\":1}}],[\"像\",{\"1\":{\"207\":1,\"365\":1}}],[\"像一些二进制文件\",{\"1\":{\"184\":1}}],[\"像消息确认机制等功能还需要我们自己实现\",{\"1\":{\"179\":1}}],[\"结尾的字符数组\",{\"1\":{\"184\":1}}],[\"结构的修改\",{\"1\":{\"87\":1}}],[\"节点所走过的路径称为引用链\",{\"1\":{\"450\":1}}],[\"节点加入阻塞队列\",{\"1\":{\"407\":1}}],[\"节点\",{\"1\":{\"210\":4}}],[\"节点的特性之外\",{\"1\":{\"210\":2}}],[\"节点的\",{\"1\":{\"208\":1}}],[\"节点可用\",{\"1\":{\"208\":1}}],[\"节点出现问题\",{\"1\":{\"208\":1}}],[\"节省网络流量\",{\"1\":{\"183\":1}}],[\"节流以及缓冲区大小受限等缺点\",{\"1\":{\"9\":1}}],[\"计算的时候会把最后一行保存校验和的内容给忽略点\",{\"1\":{\"245\":1}}],[\"计算机组成原理第二章浮点加减法\",{\"1\":{\"282\":1}}],[\"计算机网络\",{\"0\":{\"80\":1}}],[\"计算机网络三\",{\"0\":{\"71\":1}}],[\"计算机网络二\",{\"0\":{\"51\":1}}],[\"计算机网络一\",{\"0\":{\"35\":1}}],[\"计算机基础\",{\"0\":{\"25\":1}}],[\"计数器为0的对象就是不会再被使用的对象\",{\"1\":{\"449\":1}}],[\"计数器\",{\"1\":{\"445\":1}}],[\"计数器的值只能在构造方法中初始化一次\",{\"1\":{\"408\":1}}],[\"计数值变0\",{\"1\":{\"408\":1}}],[\"计数达到某个阈值的时候\",{\"1\":{\"231\":1}}],[\"计数较少的时候\",{\"1\":{\"231\":1}}],[\"计数比如用户单位时间的请求数\",{\"1\":{\"182\":1}}],[\"图片地址\",{\"1\":{\"215\":1}}],[\"图片的路径\",{\"1\":{\"182\":1}}],[\"图片的\",{\"1\":{\"182\":1,\"213\":1}}],[\"图片\",{\"1\":{\"182\":1,\"213\":1}}],[\"整体流程为\",{\"1\":{\"483\":1}}],[\"整理算法\",{\"1\":{\"461\":1,\"462\":1,\"463\":1}}],[\"整理\",{\"1\":{\"459\":1,\"465\":1,\"467\":1}}],[\"整堆收集\",{\"1\":{\"446\":1}}],[\"整数集合\",{\"1\":{\"212\":1}}],[\"整数\",{\"1\":{\"182\":1,\"213\":1}}],[\"整个加解锁过程其实就是一个新旧数据比对的过程\",{\"1\":{\"401\":1}}],[\"整个\",{\"1\":{\"147\":1}}],[\"位\",{\"1\":{\"509\":1}}],[\"位是主版本号\",{\"1\":{\"475\":1}}],[\"位是次版本号\",{\"1\":{\"475\":1}}],[\"位置的值\",{\"1\":{\"229\":2}}],[\"位置的值设置为\",{\"1\":{\"217\":1}}],[\"位置就会后移更新\",{\"1\":{\"147\":1}}],[\"位来表示某个元素对应的值或者状态\",{\"1\":{\"189\":1,\"228\":1}}],[\"位存储\",{\"1\":{\"181\":1}}],[\"散列\",{\"1\":{\"181\":1,\"212\":1}}],[\"集合框架底层数据结构\",{\"0\":{\"251\":1}}],[\"集合中包含元素的个数\",{\"1\":{\"231\":1}}],[\"集合中的元素没有先后顺序但都唯一\",{\"1\":{\"187\":1,\"222\":1}}],[\"集合\",{\"0\":{\"222\":1,\"249\":1,\"273\":1},\"1\":{\"181\":1,\"212\":1}}],[\"集群宕机\",{\"1\":{\"210\":1}}],[\"集群主从切换导致的锁丢失问题\",{\"1\":{\"208\":1}}],[\"集群操作的\",{\"1\":{\"208\":1}}],[\"集群中有半数以上的\",{\"1\":{\"208\":1}}],[\"集群中的多个独立的\",{\"1\":{\"208\":1}}],[\"集群数据同步到各个节点时是异步的\",{\"1\":{\"208\":1}}],[\"集群下\",{\"1\":{\"208\":1}}],[\"集群的话会更高\",{\"1\":{\"173\":1}}],[\"集群支持\",{\"1\":{\"172\":1}}],[\"维护排行榜\",{\"1\":{\"179\":1}}],[\"复制性能会变得很差\",{\"1\":{\"458\":1}}],[\"复制\",{\"1\":{\"458\":1,\"467\":1}}],[\"复制算法的多线程收集器\",{\"1\":{\"463\":1}}],[\"复制算法\",{\"0\":{\"458\":1},\"1\":{\"459\":1,\"461\":1,\"462\":1,\"463\":1}}],[\"复杂业务场景\",{\"1\":{\"179\":1}}],[\"复用模型\",{\"1\":{\"172\":1}}],[\"复用的网络模型\",{\"1\":{\"172\":1}}],[\"新加入的默认方法\",{\"1\":{\"489\":1}}],[\"新对象都分配在这个两个指针之间\",{\"1\":{\"467\":1}}],[\"新对象的内部引用对象不再是原来对象的内部引用对象\",{\"1\":{\"297\":1}}],[\"新生代的空间越大也会导致每次minorgc的时间变长\",{\"1\":{\"513\":1}}],[\"新生代的特点\",{\"1\":{\"513\":1}}],[\"新生代越大\",{\"1\":{\"513\":1}}],[\"新生代gc调优\",{\"0\":{\"513\":1}}],[\"新生代采用标记\",{\"1\":{\"461\":1,\"462\":1,\"463\":1}}],[\"新生代收集\",{\"1\":{\"446\":1}}],[\"新建线程将会使当前运行的线程超出最大线程数\",{\"1\":{\"391\":1}}],[\"新来的任务将会被\",{\"1\":{\"389\":1}}],[\"新任务到来的时候\",{\"1\":{\"390\":1}}],[\"新任务就会被存放在队列中\",{\"1\":{\"388\":1}}],[\"新任务来的时候会先判断当前运行的线程数量是否达到核心线程数\",{\"1\":{\"388\":1}}],[\"新的\",{\"1\":{\"246\":1}}],[\"新的aof文件和原有aof文件所保存的数据库状态一直\",{\"1\":{\"244\":1}}],[\"新写入操作会报错\",{\"1\":{\"201\":1}}],[\"新增加的一个数据结构\",{\"1\":{\"179\":1,\"218\":1}}],[\"新插入的数据\",{\"1\":{\"97\":1}}],[\"功能\",{\"1\":{\"179\":1}}],[\"功能完善\",{\"1\":{\"90\":1}}],[\"限流\",{\"1\":{\"179\":1}}],[\"限制每张表上的索引数量\",{\"0\":{\"141\":1}}],[\"限制的大多是浏览器和服务器的原因\",{\"1\":{\"40\":1}}],[\"点赞量\",{\"1\":{\"177\":1}}],[\"机制\",{\"1\":{\"179\":1}}],[\"机制都用到了这种策略\",{\"1\":{\"177\":1}}],[\"机制来保证不出现幻读\",{\"1\":{\"156\":1}}],[\"很难通过复制来解决这个问题\",{\"1\":{\"508\":1}}],[\"很快\",{\"1\":{\"246\":1}}],[\"很明显需要继承\",{\"1\":{\"495\":1}}],[\"很明显\",{\"1\":{\"177\":1}}],[\"很相似\",{\"1\":{\"177\":1}}],[\"很多newsql数据库都支持地理位置分片算法\",{\"1\":{\"118\":1}}],[\"故不用执行删除缓存操作\",{\"1\":{\"175\":1}}],[\"么\",{\"1\":{\"175\":1}}],[\"旁路缓存模式\",{\"0\":{\"175\":1}}],[\"甚至最高能达到\",{\"1\":{\"173\":1}}],[\"核心\",{\"1\":{\"467\":1}}],[\"核心线程外的线程不会立即销毁\",{\"1\":{\"388\":1}}],[\"核心线程数为0\",{\"1\":{\"387\":1}}],[\"核心线程数为1\",{\"1\":{\"387\":1}}],[\"核心线程数为n\",{\"1\":{\"387\":2}}],[\"核\",{\"1\":{\"173\":1}}],[\"qps\",{\"1\":{\"173\":2}}],[\"queue因为容量问题导致操作失败后的处理方式不同分为两类方法\",{\"1\":{\"258\":1}}],[\"queue\",{\"0\":{\"250\":1,\"258\":1},\"1\":{\"249\":1,\"250\":1,\"251\":1,\"258\":1,\"260\":1,\"261\":1,\"413\":1,\"414\":1}}],[\"queuing\",{\"1\":{\"9\":1}}],[\"query\",{\"1\":{\"173\":1}}],[\"quicklist\",{\"1\":{\"212\":2}}],[\"quic\",{\"1\":{\"55\":2}}],[\"毕竟是从硬盘中读取的\",{\"1\":{\"173\":1}}],[\"假如在字符串常量池中存在字符串\",{\"1\":{\"454\":1}}],[\"假如不做任何措施的话\",{\"1\":{\"383\":1}}],[\"假如用户第一次访问数据库中的某些数据的话\",{\"1\":{\"173\":1}}],[\"假设有\",{\"1\":{\"407\":1}}],[\"假设数组长度n为16\",{\"1\":{\"269\":1}}],[\"假设不使用顺序节点的话\",{\"1\":{\"210\":1}}],[\"假设不同的班级学号有相同的\",{\"1\":{\"84\":1}}],[\"假设客户端\",{\"1\":{\"209\":1}}],[\"假设执行过程中写完redo\",{\"1\":{\"152\":1}}],[\"假设id=2的记录\",{\"1\":{\"152\":1}}],[\"过期时间设置\",{\"1\":{\"205\":1}}],[\"过期字典的值是一个long\",{\"1\":{\"199\":1}}],[\"过期字典的键指向redis数据库中的某个key\",{\"1\":{\"199\":1}}],[\"过期数据的删除策略\",{\"0\":{\"200\":1}}],[\"过期数据的删除策略只用了惰性删除\",{\"1\":{\"172\":1}}],[\"过期数据删除\",{\"1\":{\"172\":1}}],[\"过滤掉不符合条件的记录\",{\"1\":{\"137\":1}}],[\"v操作\",{\"1\":{\"407\":1}}],[\"var\",{\"1\":{\"366\":1}}],[\"value是一个集合\",{\"1\":{\"470\":1}}],[\"value是无序的\",{\"1\":{\"250\":1}}],[\"valueof\",{\"1\":{\"281\":1}}],[\"value2\",{\"1\":{\"214\":1,\"217\":2,\"220\":1}}],[\"value1\",{\"1\":{\"214\":1,\"217\":2,\"220\":1}}],[\"value\",{\"1\":{\"182\":1,\"185\":1,\"199\":1,\"204\":2,\"214\":2,\"215\":1,\"217\":2,\"219\":1,\"220\":3,\"229\":1,\"304\":1,\"382\":3,\"383\":3,\"387\":5,\"390\":3,\"416\":1,\"430\":1,\"487\":1}}],[\"verification\",{\"1\":{\"483\":1}}],[\"version\",{\"0\":{\"475\":1},\"1\":{\"475\":2}}],[\"version>\",{\"1\":{\"324\":1}}],[\"vector是list的古老实现类\",{\"1\":{\"254\":1}}],[\"vector\",{\"1\":{\"251\":1,\"410\":1}}],[\"vm\",{\"1\":{\"275\":1,\"446\":1,\"508\":1,\"509\":1}}],[\"void\",{\"1\":{\"260\":2,\"285\":2,\"289\":2,\"310\":1,\"312\":2,\"382\":1}}],[\"volatile性能肯定比synchronized关键字要好\",{\"1\":{\"373\":1}}],[\"volatile是\",{\"1\":{\"362\":1}}],[\"volatile修饰的singleton\",{\"1\":{\"362\":1}}],[\"volatile如何禁止指令重排序\",{\"0\":{\"362\":1}}],[\"volatile关键字主要用于解决变量在多个线程之间的可见性\",{\"1\":{\"373\":1}}],[\"volatile关键字\",{\"0\":{\"361\":1}}],[\"volatile变量规则\",{\"1\":{\"359\":1}}],[\"volatile\",{\"0\":{\"373\":1},\"1\":{\"201\":4,\"332\":1,\"360\":1,\"361\":3,\"362\":1,\"373\":3,\"405\":1}}],[\"v\",{\"1\":{\"172\":2,\"366\":1}}],[\"view时\",{\"1\":{\"162\":1}}],[\"view\",{\"1\":{\"153\":3,\"159\":2,\"160\":3,\"162\":2,\"164\":3,\"165\":4,\"166\":2}}],[\"模式的\",{\"1\":{\"172\":1}}],[\"模式设计开发了一套高效的事件处理模型\",{\"1\":{\"171\":1}}],[\"模型一共有\",{\"1\":{\"19\":1}}],[\"模型\",{\"0\":{\"19\":1,\"20\":1},\"1\":{\"21\":1,\"23\":1}}],[\"脚本是为了保证解锁操作的原子性\",{\"1\":{\"204\":1}}],[\"脚本通过\",{\"1\":{\"204\":1}}],[\"脚本的方式来实现限流\",{\"1\":{\"179\":1}}],[\"脚本\",{\"1\":{\"170\":1,\"172\":1}}],[\"持久顺序\",{\"1\":{\"210\":1}}],[\"持久\",{\"1\":{\"210\":1}}],[\"持久化方式\",{\"1\":{\"246\":1}}],[\"持久化或者开启\",{\"1\":{\"246\":1}}],[\"持久化\",{\"1\":{\"170\":1,\"172\":1}}],[\"持久性durability\",{\"1\":{\"96\":1}}],[\"kb\",{\"1\":{\"509\":1}}],[\"keepalivetime才会被回收销毁\",{\"1\":{\"388\":1}}],[\"keepalivetime\",{\"1\":{\"388\":3}}],[\"key是别的region的起始地址\",{\"1\":{\"470\":1}}],[\"key是无序的\",{\"1\":{\"250\":1}}],[\"key和value\",{\"1\":{\"264\":1}}],[\"keys\",{\"1\":{\"204\":2,\"206\":2}}],[\"key2\",{\"1\":{\"190\":1,\"214\":2,\"223\":6,\"226\":3,\"229\":1,\"232\":1}}],[\"key1\",{\"1\":{\"190\":1,\"214\":2,\"223\":6,\"226\":3,\"229\":1,\"232\":1}}],[\"key\",{\"0\":{\"128\":1,\"166\":1},\"1\":{\"93\":1,\"97\":1,\"103\":3,\"108\":8,\"127\":1,\"156\":2,\"159\":1,\"166\":3,\"182\":1,\"185\":1,\"188\":3,\"189\":2,\"190\":1,\"199\":3,\"201\":2,\"204\":5,\"205\":1,\"214\":21,\"215\":1,\"217\":7,\"220\":10,\"223\":6,\"226\":6,\"228\":1,\"229\":3,\"232\":1,\"235\":5,\"265\":1,\"267\":4,\"383\":4,\"430\":1}}],[\"km\",{\"1\":{\"235\":1}}],[\"kafka\",{\"1\":{\"179\":1}}],[\"k\",{\"1\":{\"172\":2}}],[\"kv\",{\"1\":{\"170\":1}}],[\"许可\",{\"1\":{\"170\":1}}],[\"级别下实现可重复读\",{\"1\":{\"165\":1}}],[\"生产环境上\",{\"1\":{\"507\":1}}],[\"生产环境下的\",{\"1\":{\"208\":1}}],[\"生产者线程会向队列中添加数据\",{\"1\":{\"261\":1,\"414\":1}}],[\"生成\",{\"1\":{\"165\":1,\"246\":1}}],[\"生态完善\",{\"1\":{\"90\":1}}],[\"正常处理命令请求造成影响\",{\"1\":{\"244\":1}}],[\"正数为加\",{\"1\":{\"220\":1}}],[\"正在内存中\",{\"1\":{\"162\":1}}],[\"正因如此\",{\"1\":{\"126\":1}}],[\"小于这个\",{\"1\":{\"162\":1}}],[\"小结\",{\"0\":{\"148\":1}}],[\"情况下\",{\"1\":{\"159\":1}}],[\"叫它快照读\",{\"1\":{\"158\":1}}],[\"×\",{\"1\":{\"156\":6}}],[\"√\",{\"1\":{\"156\":6}}],[\"除非这个对象的引用链上的任何一个对象建立关联\",{\"1\":{\"452\":1}}],[\"除非数据是被本身事务自己所修改\",{\"1\":{\"156\":1}}],[\"除此之外\",{\"1\":{\"213\":1}}],[\"除了追求低停顿外\",{\"1\":{\"467\":1}}],[\"除了使用多线程进行垃圾收集外\",{\"1\":{\"462\":1}}],[\"除了\",{\"1\":{\"407\":1,\"462\":1,\"478\":1,\"494\":1,\"495\":1}}],[\"除了提供了更为好用和强大的\",{\"1\":{\"396\":1}}],[\"除了抽象了线程和内存之间的关系之外\",{\"1\":{\"355\":1}}],[\"除了具备临时\",{\"1\":{\"210\":1}}],[\"除了具有持久\",{\"1\":{\"210\":1}}],[\"除了做缓存\",{\"0\":{\"179\":1}}],[\"除了意向共享锁\",{\"1\":{\"105\":1}}],[\"除了更大的地址空间之外\",{\"1\":{\"75\":1}}],[\"总空间不变的情况下\",{\"1\":{\"513\":1}}],[\"总活跃用户数\",{\"1\":{\"189\":1}}],[\"总结\",{\"0\":{\"154\":1}}],[\"总是需要知道下一跳\",{\"1\":{\"39\":1,\"79\":1}}],[\"找出需要回收的对象\",{\"1\":{\"467\":1}}],[\"找出最优的查询方案\",{\"1\":{\"108\":1}}],[\"找到存放位置之后判断当前位置元素和要存入的元素hash值和key是否相同\",{\"1\":{\"267\":1}}],[\"找到\",{\"1\":{\"153\":1,\"160\":1}}],[\"隐藏字段\",{\"0\":{\"161\":1},\"1\":{\"153\":1,\"160\":1}}],[\"隐式转换\",{\"1\":{\"143\":1}}],[\"恢复大数据集的时候\",{\"1\":{\"246\":1}}],[\"恢复机制是通过\",{\"1\":{\"153\":1}}],[\"恢复出来的这一行c值是0\",{\"1\":{\"152\":1}}],[\"回收策略等等\",{\"1\":{\"462\":1}}],[\"回收\",{\"1\":{\"383\":1}}],[\"回滚指针\",{\"1\":{\"161\":1}}],[\"回滚日志会先于数据持久化到磁盘上\",{\"1\":{\"153\":1}}],[\"回滚日志\",{\"0\":{\"153\":1},\"1\":{\"153\":2,\"154\":1}}],[\"回表\",{\"1\":{\"132\":1}}],[\"原始快照就是将那些被删除的引用记录保存下来\",{\"1\":{\"470\":1}}],[\"原理\",{\"0\":{\"412\":1},\"1\":{\"407\":1}}],[\"原理就是基于反射获取到对应类上的注解\",{\"1\":{\"316\":1}}],[\"原理也比较简单\",{\"1\":{\"206\":1}}],[\"原理很简单\",{\"1\":{\"152\":1}}],[\"原子性\",{\"1\":{\"96\":1,\"360\":1}}],[\"原子性atomicity\",{\"1\":{\"96\":1}}],[\"两种\",{\"1\":{\"433\":1}}],[\"两种典型用法\",{\"1\":{\"408\":1}}],[\"两值相等才会进行更新\",{\"1\":{\"366\":1}}],[\"两小\",{\"1\":{\"289\":1}}],[\"两同\",{\"1\":{\"289\":1}}],[\"两同两小一大\",{\"1\":{\"289\":1}}],[\"两次备份之间的操作会丢失\",{\"1\":{\"246\":1}}],[\"两个子类\",{\"1\":{\"375\":1}}],[\"两个方法都能暂停线程的执行\",{\"1\":{\"349\":1}}],[\"两个或者以上的线程因为竞争资源导致阻塞\",{\"1\":{\"346\":1}}],[\"两个不同对象的引用指向同一个对象\",{\"1\":{\"297\":1}}],[\"两个又有很大的不同\",{\"1\":{\"177\":1}}],[\"两个隔离级别下\",{\"1\":{\"158\":1}}],[\"两者本质都是对对象监视器monitor的获取\",{\"1\":{\"372\":1}}],[\"两者的性能都非常高\",{\"1\":{\"172\":1}}],[\"两者都是先进后出的数据结构\",{\"1\":{\"424\":1}}],[\"两者都是可重入锁\",{\"1\":{\"377\":1}}],[\"两者都是由\",{\"1\":{\"177\":1}}],[\"两者都是行级锁\",{\"1\":{\"104\":1}}],[\"两者都是负责邮件接收的协议\",{\"1\":{\"37\":1,\"56\":1}}],[\"两阶段提交\",{\"0\":{\"152\":1}}],[\"虽然经常说\",{\"1\":{\"197\":1}}],[\"虽然引入了多线程\",{\"1\":{\"196\":1}}],[\"虽然文件事件处理器以单线程方式运行\",{\"1\":{\"193\":1}}],[\"虽然\",{\"1\":{\"165\":1,\"246\":1,\"259\":1,\"467\":1}}],[\"虽然redo\",{\"1\":{\"152\":1}}],[\"虽然它们都属于持久化的保证\",{\"1\":{\"152\":1}}],[\"虽然性能得到提升\",{\"1\":{\"151\":1}}],[\"虽然索引能带来查询上的效率\",{\"1\":{\"140\":1}}],[\"指示\",{\"1\":{\"508\":1}}],[\"指针碰撞\",{\"1\":{\"433\":2}}],[\"指令之后会接着执行\",{\"1\":{\"436\":1}}],[\"指令和\",{\"1\":{\"372\":1}}],[\"指令后\",{\"1\":{\"372\":1}}],[\"指令来释放锁\",{\"1\":{\"372\":1}}],[\"指令则指明同步代码块的结束位置\",{\"1\":{\"372\":2}}],[\"指令指向同步代码块的开始位置\",{\"1\":{\"372\":2}}],[\"指令\",{\"1\":{\"372\":3}}],[\"指令流水线数据相关\",{\"1\":{\"358\":1}}],[\"指令重排可能会导致问题\",{\"1\":{\"354\":1}}],[\"指令重排序可以保证串行语义的一致\",{\"1\":{\"354\":1}}],[\"指令重排序\",{\"0\":{\"354\":1}}],[\"指令并行重排\",{\"1\":{\"354\":1}}],[\"指令计数器\",{\"1\":{\"8\":1}}],[\"指向的是堆中不同的对象\",{\"1\":{\"307\":1}}],[\"指向的是堆中的同一个对象\",{\"1\":{\"307\":2}}],[\"指向该行的\",{\"1\":{\"161\":1}}],[\"指的是子类方法的访问权限应比父类方法的访问权限更大或相等\",{\"1\":{\"289\":1}}],[\"指的是子类方法返回值类型应比父类方法返回值类型更小或相等\",{\"1\":{\"289\":1}}],[\"指定永久代\",{\"0\":{\"504\":1}}],[\"指定\",{\"1\":{\"503\":1}}],[\"指定新生代内存\",{\"0\":{\"503\":1}}],[\"指定堆内存\",{\"0\":{\"502\":1}}],[\"指定元素排名\",{\"1\":{\"186\":1,\"227\":2}}],[\"指定statement\",{\"1\":{\"150\":1}}],[\"归档日志\",{\"0\":{\"149\":1},\"1\":{\"152\":1}}],[\"归档等高级功能\",{\"1\":{\"37\":1,\"56\":1}}],[\"循环栅栏\",{\"0\":{\"409\":1}}],[\"循环链表\",{\"1\":{\"147\":1}}],[\"循环扫描算法\",{\"1\":{\"16\":1}}],[\"得停下来\",{\"1\":{\"147\":1}}],[\"硬盘上存储的\",{\"1\":{\"147\":1}}],[\"硬链接\",{\"1\":{\"15\":2}}],[\"硬链接和软链接有什么区别\",{\"0\":{\"15\":1}}],[\"日志的参数\",{\"1\":{\"507\":1}}],[\"日志记录\",{\"0\":{\"507\":1}}],[\"日志\",{\"1\":{\"246\":1}}],[\"日志刷盘流程\",{\"1\":{\"151\":1}}],[\"日志有三种格式\",{\"1\":{\"150\":1}}],[\"日志文件不只一个\",{\"1\":{\"147\":1}}],[\"日志文件组可以记录4g的内容\",{\"1\":{\"147\":1}}],[\"日志文件组\",{\"0\":{\"147\":1}}],[\"日常\",{\"1\":{\"0\":1}}],[\"秒的数据\",{\"1\":{\"246\":1}}],[\"秒的自动过期时间\",{\"1\":{\"205\":1}}],[\"秒为单位\",{\"1\":{\"205\":1}}],[\"秒杀下一人一单占位使用lua脚本\",{\"1\":{\"179\":1}}],[\"秒杀下更新数据库时使用分布式锁\",{\"1\":{\"179\":1}}],[\"秒\",{\"1\":{\"146\":1,\"206\":3}}],[\"参数表示在重新标记之前先对新生代进行垃圾清理\",{\"1\":{\"518\":1}}],[\"参数的设置值是否允许担保失败\",{\"1\":{\"447\":1}}],[\"参数的时间单位\",{\"1\":{\"388\":1}}],[\"参数来设置\",{\"1\":{\"430\":1}}],[\"参数列表必须相同\",{\"1\":{\"289\":1}}],[\"参数默认为\",{\"1\":{\"146\":1}}],[\"参数\",{\"1\":{\"146\":1,\"509\":2}}],[\"刷盘速度很快\",{\"1\":{\"148\":1}}],[\"刷盘比较耗时\",{\"1\":{\"148\":1}}],[\"刷盘\",{\"1\":{\"146\":1}}],[\"刷盘时机\",{\"0\":{\"146\":1}}],[\"刷盘到redo\",{\"1\":{\"145\":1}}],[\"理论上来说还是可能会出现数据不一致性的问题\",{\"1\":{\"175\":1}}],[\"理想情况下\",{\"1\":{\"145\":1}}],[\"理解\",{\"1\":{\"44\":1}}],[\"里面存储的是卡表的索引号\",{\"1\":{\"470\":1}}],[\"里面有一个内部类\",{\"1\":{\"375\":1}}],[\"里\",{\"1\":{\"145\":1}}],[\"里的\",{\"1\":{\"46\":1}}],[\"某个数据页上做了什么修改\",{\"1\":{\"145\":1}}],[\"让新生代的对象晋升时间更长\",{\"1\":{\"517\":1}}],[\"让长时间存活的对象尽快晋升\",{\"1\":{\"514\":1}}],[\"让所有线程继续执行下去\",{\"1\":{\"409\":1}}],[\"让代码更加灵活\",{\"1\":{\"317\":1}}],[\"让程序自动决定触发时机\",{\"1\":{\"244\":1}}],[\"让它去获取锁\",{\"1\":{\"211\":1}}],[\"让innodb存储引擎拥有了崩溃恢复能力\",{\"1\":{\"152\":1}}],[\"让mysql拥有了崩溃恢复的能力\",{\"1\":{\"145\":1}}],[\"让用户态变成内核态\",{\"1\":{\"3\":1}}],[\"时必须重写\",{\"0\":{\"301\":1}}],[\"时采用\",{\"1\":{\"271\":1}}],[\"时就已经存在\",{\"1\":{\"259\":1}}],[\"时机不同\",{\"1\":{\"165\":1}}],[\"时\",{\"1\":{\"159\":1,\"184\":1,\"445\":1,\"489\":1}}],[\"时一定要养成良好的习惯\",{\"1\":{\"143\":1}}],[\"时间的比例\",{\"1\":{\"508\":1}}],[\"时间单位\",{\"1\":{\"388\":1}}],[\"时间复杂度为\",{\"1\":{\"184\":2}}],[\"时间后才进入\",{\"0\":{\"62\":1}}],[\"时间\",{\"1\":{\"8\":1}}],[\"字面量比较接近于\",{\"1\":{\"476\":1}}],[\"字面量和符号引用\",{\"1\":{\"476\":1}}],[\"字面量包括整数\",{\"1\":{\"429\":1}}],[\"字面量是源代码中的固定值的表示法\",{\"1\":{\"429\":1}}],[\"字符串对象的引用指向堆中的字符串对象\",{\"1\":{\"430\":1}}],[\"字符串对象的引用\",{\"1\":{\"430\":1}}],[\"字符串常量池被从方法区拿到了堆中\",{\"1\":{\"454\":1}}],[\"字符串常量池和静态变量从永久代移动了\",{\"1\":{\"430\":1}}],[\"字符串常量池存放在永久代\",{\"1\":{\"430\":1}}],[\"字符串常量池\",{\"0\":{\"430\":1},\"1\":{\"430\":1}}],[\"字符串拼接用\",{\"0\":{\"305\":1}}],[\"字符串为\",{\"1\":{\"213\":1}}],[\"字符串无法正确保存\",{\"1\":{\"184\":1}}],[\"字符串时\",{\"1\":{\"184\":1}}],[\"字符串\",{\"0\":{\"213\":1},\"1\":{\"181\":1,\"212\":1,\"444\":1}}],[\"字符串转换为数值类型时\",{\"1\":{\"143\":1}}],[\"字段是否存在\",{\"1\":{\"486\":1}}],[\"字段包括类级变量以及实例变量\",{\"1\":{\"479\":1}}],[\"字段表\",{\"1\":{\"479\":1,\"481\":1}}],[\"字段表集合\",{\"0\":{\"479\":1}}],[\"字段的名称和描述符\",{\"1\":{\"476\":1}}],[\"字段符号引用\",{\"1\":{\"429\":1}}],[\"字段\",{\"1\":{\"429\":1,\"488\":1}}],[\"字段将其标记为已删除\",{\"1\":{\"161\":1}}],[\"字段c值是0\",{\"1\":{\"152\":1}}],[\"字节码可以使源程序\",{\"1\":{\"492\":1}}],[\"字节码验证\",{\"1\":{\"486\":1}}],[\"字节码语义检查\",{\"1\":{\"486\":1}}],[\"字节码\",{\"0\":{\"472\":1},\"1\":{\"489\":1}}],[\"字节码解决了传统解释语言运行效率低的问题\",{\"1\":{\"276\":1}}],[\"字节\",{\"1\":{\"53\":2}}],[\"字节的内存就成为了内部内存碎片\",{\"1\":{\"12\":1}}],[\"字节的内存\",{\"1\":{\"12\":1}}],[\"造成全表扫描效率极低\",{\"1\":{\"143\":1}}],[\"类使用委托模型来搜索类和资源\",{\"1\":{\"496\":2}}],[\"类中的\",{\"1\":{\"495\":1,\"499\":1}}],[\"类有两个关键的方法\",{\"1\":{\"495\":1}}],[\"类有什么用\",{\"0\":{\"396\":1}}],[\"类卸载\",{\"0\":{\"490\":1}}],[\"类方法\",{\"1\":{\"488\":1}}],[\"类变量所使用的内存都应该在方法区中分配\",{\"1\":{\"487\":1}}],[\"类从被加载到虚拟机内存中开始到卸载出内存为止\",{\"1\":{\"483\":1}}],[\"类都有父类\",{\"1\":{\"478\":1}}],[\"类索引用于确定这个类的全限定名\",{\"1\":{\"478\":1}}],[\"类索引\",{\"1\":{\"478\":1}}],[\"类的正确性检查\",{\"1\":{\"486\":1}}],[\"类的生命周期\",{\"0\":{\"483\":1}}],[\"类的父类索引都不为\",{\"1\":{\"478\":1}}],[\"类的继承关系由类索引\",{\"1\":{\"478\":1}}],[\"类的所有可变操作\",{\"1\":{\"412\":1}}],[\"类和接口的全限定名\",{\"1\":{\"476\":1}}],[\"类文件结构\",{\"0\":{\"471\":1}}],[\"类需要同时满足下面\",{\"1\":{\"455\":1}}],[\"类加载过程的第一步\",{\"1\":{\"485\":1}}],[\"类加载过程\",{\"0\":{\"482\":1,\"484\":1},\"1\":{\"483\":1}}],[\"类加载完成之后开始分配内存\",{\"1\":{\"433\":1}}],[\"类加载检查\",{\"0\":{\"432\":1}}],[\"类加载器在进行类加载的时候\",{\"1\":{\"497\":1,\"499\":1}}],[\"类加载器之间的父子关系一般不是以继承的关系来实现的\",{\"1\":{\"496\":1}}],[\"类加载器总结\",{\"0\":{\"494\":1}}],[\"类加载器的加载规则\",{\"0\":{\"493\":1}}],[\"类加载器的作用就是加载java类的字节码\",{\"1\":{\"492\":1}}],[\"类加载器是一个负责加载类的对象\",{\"1\":{\"492\":1}}],[\"类加载器\",{\"0\":{\"491\":1,\"492\":1},\"1\":{\"323\":1}}],[\"类\",{\"1\":{\"430\":1}}],[\"类可以解决future\",{\"1\":{\"396\":1}}],[\"类是异步思想的典型运用\",{\"1\":{\"394\":1}}],[\"类内部的\",{\"1\":{\"382\":1}}],[\"类上锁\",{\"1\":{\"371\":1}}],[\"类没有重写equals方法\",{\"1\":{\"299\":1}}],[\"类型\",{\"1\":{\"477\":1,\"509\":1}}],[\"类型是一种无序集合\",{\"1\":{\"222\":1}}],[\"类型的标志位\",{\"1\":{\"476\":1}}],[\"类型的\",{\"1\":{\"219\":1}}],[\"类型的整数\",{\"1\":{\"199\":1}}],[\"类型的底层实现并不是\",{\"1\":{\"184\":1}}],[\"类型的数据结构更加适合用来做消息队列\",{\"1\":{\"179\":1}}],[\"类型的数据\",{\"1\":{\"172\":1}}],[\"类型转换等操作\",{\"1\":{\"143\":1}}],[\"类似信号枪响\",{\"1\":{\"408\":1}}],[\"类似于\",{\"1\":{\"219\":1,\"225\":1,\"235\":1,\"246\":1}}],[\"类似aqs的实现方式\",{\"1\":{\"209\":1}}],[\"类似\",{\"1\":{\"108\":1,\"226\":2}}],[\"函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘\",{\"1\":{\"197\":1}}],[\"函数\",{\"1\":{\"143\":1}}],[\"函数依赖\",{\"1\":{\"84\":1}}],[\"耗费的时间也是较多的\",{\"1\":{\"142\":1}}],[\"耗费更多服务器资源\",{\"1\":{\"45\":1}}],[\"尽管这次\",{\"1\":{\"447\":1}}],[\"尽可能的考虑建立联合索引而不是单列索引\",{\"0\":{\"142\":1}}],[\"尽最大努力\",{\"1\":{\"38\":1}}],[\"反射获取class对象\",{\"0\":{\"318\":1}}],[\"反射的优缺点\",{\"0\":{\"317\":1}}],[\"反射的应用场景\",{\"0\":{\"316\":1}}],[\"反射可以获取任意一个类的所有属性和方法\",{\"1\":{\"315\":1}}],[\"反序列化的时候会检查serialversionuid是否和当前类的serialversionuid相同\",{\"1\":{\"314\":1}}],[\"反序列化\",{\"1\":{\"313\":1}}],[\"反而被经常修改\",{\"1\":{\"140\":1}}],[\"反之不一定\",{\"1\":{\"126\":1}}],[\"被彻底移除了\",{\"1\":{\"504\":1}}],[\"被同一个虚拟机加载\",{\"1\":{\"497\":1}}],[\"被\",{\"1\":{\"489\":1}}],[\"被判断需要执行的对象将会被放在一个队列中进行第二次标记\",{\"1\":{\"452\":1}}],[\"被唤醒的线程会重新尝试去修改\",{\"1\":{\"407\":1}}],[\"被拒绝的任务\",{\"1\":{\"389\":1}}],[\"被广泛应用于各大框架中\",{\"1\":{\"366\":1}}],[\"被广泛应用于缓存方向\",{\"1\":{\"170\":1}}],[\"被拦截的方法\",{\"1\":{\"324\":1}}],[\"被代理的对象\",{\"1\":{\"324\":1}}],[\"被代理类实现的接口\",{\"1\":{\"323\":1}}],[\"被static修饰的变量\",{\"1\":{\"487\":1}}],[\"被static修饰的变量为类所共享的\",{\"1\":{\"286\":1}}],[\"被static修饰的方法能被再次声明\",{\"1\":{\"289\":1}}],[\"被修改时\",{\"1\":{\"184\":1}}],[\"被频繁更新的字段应该慎重建立索引\",{\"0\":{\"140\":1}}],[\"被频繁查询的字段\",{\"1\":{\"139\":1}}],[\"被经常频繁用于连接的字段\",{\"1\":{\"139\":1}}],[\"被作为条件查询的字段\",{\"1\":{\"139\":1}}],[\"跟例子1很像\",{\"1\":{\"136\":1}}],[\"跟聚簇索引一样\",{\"1\":{\"132\":1}}],[\"=2\",{\"1\":{\"260\":1}}],[\"==和equals区别\",{\"0\":{\"299\":1}}],[\"==\",{\"1\":{\"204\":1,\"206\":1,\"267\":1,\"293\":3,\"307\":3,\"308\":1,\"331\":1,\"332\":2,\"408\":2,\"497\":2}}],[\"=\",{\"0\":{\"306\":1},\"1\":{\"136\":1,\"206\":3,\"253\":1,\"260\":11,\"267\":1,\"281\":3,\"285\":2,\"293\":3,\"295\":1,\"306\":2,\"307\":4,\"308\":11,\"310\":1,\"312\":2,\"314\":1,\"316\":2,\"318\":4,\"319\":1,\"329\":1,\"330\":1,\"331\":1,\"332\":1,\"333\":1,\"358\":3,\"382\":5,\"396\":5,\"407\":1,\"487\":1,\"497\":7,\"512\":1}}],[\"∞\",{\"1\":{\"136\":1}}],[\"+cmsscavengebeforeremark\",{\"1\":{\"518\":1}}],[\"+optimizestringconcat\",{\"1\":{\"509\":1}}],[\"+heapdumponoutofmemoryerror\",{\"1\":{\"508\":1}}],[\"+printsafepointstatistics\",{\"1\":{\"507\":1}}],[\"+printgcapplicationstoppedtime\",{\"1\":{\"507\":1}}],[\"+printgcdatestamps\",{\"1\":{\"507\":1}}],[\"+printgcdetails\",{\"1\":{\"507\":1}}],[\"+printreferencegc\",{\"1\":{\"507\":1}}],[\"+printheapatgc\",{\"1\":{\"507\":1}}],[\"+printtenuringdistribution\",{\"1\":{\"507\":1}}],[\"+usecompressedstrings\",{\"1\":{\"509\":1}}],[\"+uselargepages\",{\"1\":{\"509\":1}}],[\"+uselwpsynchronization\",{\"1\":{\"509\":1}}],[\"+usestringcache\",{\"1\":{\"509\":1}}],[\"+usestringdeduplication\",{\"1\":{\"509\":1}}],[\"+useserialgc\",{\"1\":{\"506\":1}}],[\"+usegcoverheadlimit\",{\"1\":{\"508\":1}}],[\"+usegclogfilerotation\",{\"1\":{\"507\":1}}],[\"+useg1gc\",{\"1\":{\"506\":1}}],[\"+useparnewgc\",{\"1\":{\"506\":1}}],[\"+useparallelgc\",{\"1\":{\"506\":1}}],[\"+volatile和native方法来保证原子操作\",{\"1\":{\"364\":1}}],[\"+和+=是java中唯二为string重载过的运算符\",{\"1\":{\"305\":1}}],[\"++j\",{\"1\":{\"260\":1}}],[\"+这是一种最简易的\",{\"1\":{\"204\":1}}],[\"+\",{\"0\":{\"305\":1},\"1\":{\"136\":1,\"158\":1,\"179\":1,\"199\":1,\"206\":4,\"219\":1,\"251\":1,\"253\":1,\"271\":2,\"272\":2,\"285\":1,\"308\":6,\"316\":2,\"358\":1}}],[\"于是在进行索引扫描的时候\",{\"1\":{\"136\":1}}],[\"哪一个字段用到了联合索引\",{\"1\":{\"136\":2}}],[\"例子二\",{\"1\":{\"136\":1}}],[\"例子一\",{\"1\":{\"136\":1}}],[\"例如使用一个static\",{\"1\":{\"512\":1}}],[\"例如integer对象头就已经占用16字节\",{\"1\":{\"512\":1}}],[\"例如自己写一个java\",{\"1\":{\"498\":1}}],[\"例如public\",{\"1\":{\"487\":1}}],[\"例如该类要使用的其他类\",{\"1\":{\"486\":1}}],[\"例如函数的参数类型是否正确\",{\"1\":{\"486\":1}}],[\"例如这个类是否有父类\",{\"1\":{\"486\":1}}],[\"例如这个对象是哪个类的实例\",{\"1\":{\"435\":1}}],[\"例如是否以魔数开头\",{\"1\":{\"486\":1}}],[\"例如在一个循环内对同一个对象进行加锁解锁\",{\"1\":{\"400\":1}}],[\"例如堆主要用来存放对象实例\",{\"1\":{\"357\":1}}],[\"例如游戏中的每一个英雄都有血量\",{\"1\":{\"295\":1}}],[\"例如javac\",{\"1\":{\"275\":1}}],[\"例如引用程序释放锁的逻辑挂掉\",{\"1\":{\"204\":1}}],[\"例如如果创建了一个\",{\"1\":{\"136\":1}}],[\"例如将10万条数据分成两个5万条数据\",{\"1\":{\"115\":1}}],[\"例如转账业务中\",{\"1\":{\"96\":1}}],[\"例如客户端只是需要某个对象的一部分\",{\"1\":{\"46\":1}}],[\"例如\",{\"1\":{\"39\":1,\"508\":1,\"509\":1}}],[\"联合使用\",{\"1\":{\"453\":1}}],[\"联合索引的最左匹配原则会一直向右匹配知道遇到范围查询就会停止匹配\",{\"1\":{\"136\":1}}],[\"联合索引就会失效\",{\"1\":{\"136\":1}}],[\"联合索引会失效\",{\"1\":{\"136\":1}}],[\"联合索引\",{\"0\":{\"135\":1},\"1\":{\"136\":3}}],[\"联合查询\",{\"1\":{\"108\":1}}],[\"叶子节点存储的是主键+列值\",{\"1\":{\"134\":1}}],[\"叶子节点也都是有序的\",{\"1\":{\"131\":1}}],[\"覆盖索引\",{\"0\":{\"134\":1}}],[\"覆盖索引和联合索引\",{\"0\":{\"133\":1}}],[\"辅助索引\",{\"1\":{\"132\":1}}],[\"辅助索引的data域存储响应记录主键的值而不是地址\",{\"1\":{\"127\":1}}],[\"库粗索引的查询速度很快\",{\"1\":{\"131\":1}}],[\"聚合操作\",{\"1\":{\"226\":1}}],[\"聚簇索引对于主键的排序查找和范围查找速度很快\",{\"1\":{\"131\":1}}],[\"聚簇索引少了一次读取数据的io操作\",{\"1\":{\"131\":1}}],[\"聚簇索引即索引结构和数据一起存放的索引\",{\"1\":{\"131\":1}}],[\"聚簇索引\",{\"0\":{\"131\":1}}],[\"聚簇索引与非聚簇索引\",{\"0\":{\"130\":1}}],[\"聚集索引\",{\"0\":{\"131\":1},\"1\":{\"127\":1}}],[\"普通索引的唯一作用就是为了快速查询数据\",{\"1\":{\"129\":1}}],[\"普通索引\",{\"1\":{\"129\":1}}],[\"否则才会尝试加载\",{\"1\":{\"493\":1,\"497\":1}}],[\"否则就会被回收\",{\"1\":{\"452\":1}}],[\"否则就用statement格式\",{\"1\":{\"150\":1}}],[\"否则报\",{\"1\":{\"417\":1}}],[\"否则重新进入阻塞队列\",{\"1\":{\"407\":1}}],[\"否则新建一个线程来处理任务\",{\"1\":{\"390\":1}}],[\"否则通过链表法解决冲突\",{\"1\":{\"267\":1}}],[\"否则还是会存在数据丢失的风险\",{\"1\":{\"240\":1}}],[\"否则加锁失败\",{\"1\":{\"208\":1}}],[\"否则取消续期操作\",{\"1\":{\"206\":1}}],[\"否则依然可能会出现锁无法被释放的问题\",{\"1\":{\"205\":1}}],[\"否则会造成索引失效触发全表扫描\",{\"1\":{\"143\":1}}],[\"否则\",{\"1\":{\"128\":1,\"209\":1}}],[\"否则需要使用dns系统\",{\"1\":{\"49\":1}}],[\"值减少为单个全局\",{\"1\":{\"509\":1}}],[\"值为\",{\"1\":{\"407\":1,\"408\":1,\"409\":1}}],[\"值是实参的地址\",{\"1\":{\"312\":1}}],[\"值是否相等\",{\"1\":{\"204\":1}}],[\"值传递\",{\"0\":{\"311\":1},\"1\":{\"311\":1}}],[\"值进行\",{\"1\":{\"226\":1}}],[\"值\",{\"1\":{\"220\":2,\"226\":1,\"417\":1}}],[\"值不存在的时候才能\",{\"1\":{\"205\":1}}],[\"值的字段\",{\"1\":{\"128\":1}}],[\"值得是计算机中正在运行的程序实例\",{\"1\":{\"5\":1}}],[\"搜索是跳跃式的\",{\"1\":{\"418\":1}}],[\"搜索的时候如果找道对应的节点\",{\"1\":{\"127\":1}}],[\"搜索引擎通常会更青睐使用\",{\"1\":{\"45\":1}}],[\"搜索引擎优化\",{\"1\":{\"45\":1}}],[\"起到索引作用\",{\"1\":{\"127\":1}}],[\"次数的旋转操作\",{\"1\":{\"126\":1}}],[\"次数的旋转和变色操作\",{\"1\":{\"126\":1}}],[\"树\",{\"0\":{\"127\":1},\"1\":{\"127\":1}}],[\"树一样进行\",{\"1\":{\"126\":1}}],[\"树不同的是\",{\"1\":{\"126\":1}}],[\"树的叶节点data域保存了完整的数据记录\",{\"1\":{\"93\":1,\"127\":1}}],[\"查找18原本要遍历18次\",{\"1\":{\"418\":1}}],[\"查找时\",{\"1\":{\"418\":1}}],[\"查找附近商铺\",{\"1\":{\"236\":1}}],[\"查找的时间复杂度是o\",{\"1\":{\"124\":1}}],[\"查看cms四个阶段中哪个阶段花的时间太长\",{\"1\":{\"518\":1}}],[\"查看fullgc前后的内存占用\",{\"1\":{\"512\":1}}],[\"查看任务是否执行完成以及获取任务执行结果的方法\",{\"1\":{\"395\":1}}],[\"查看指定哈希表中指定的字段是否存在\",{\"1\":{\"220\":1}}],[\"查看数据还有多久过期\",{\"1\":{\"199\":1}}],[\"查询过多的数据\",{\"1\":{\"512\":1}}],[\"查询应该避免使用\",{\"1\":{\"512\":1}}],[\"查询队尾元素\",{\"1\":{\"258\":1}}],[\"查询队首元素\",{\"1\":{\"258\":2}}],[\"查询前都生成一个read\",{\"1\":{\"164\":1}}],[\"查询时\",{\"1\":{\"158\":1}}],[\"查询记录的时候会从硬盘中将一页的数据加载\",{\"1\":{\"145\":1}}],[\"查询操作符左边为字符类型时发生了隐式转换\",{\"1\":{\"143\":1}}],[\"查询操作符左边为数值类型时发生了隐式转换\",{\"1\":{\"143\":1}}],[\"查询条件中使用\",{\"1\":{\"143\":1}}],[\"查询比如\",{\"1\":{\"143\":1}}],[\"查询速度非常快\",{\"1\":{\"131\":1}}],[\"查询效率非常高\",{\"1\":{\"108\":1}}],[\"查询遍历了整棵索引树\",{\"1\":{\"108\":1}}],[\"查询结果可能找到多个符合条件的行\",{\"1\":{\"108\":1}}],[\"查询执行的类型\",{\"1\":{\"108\":1}}],[\"查询的字段是什么类型\",{\"1\":{\"143\":1}}],[\"查询的时间复杂度是o\",{\"1\":{\"124\":1}}],[\"查询的结果\",{\"1\":{\"108\":1}}],[\"查询的类型\",{\"1\":{\"108\":1}}],[\"查询中如果包含子查询或其他部分\",{\"1\":{\"108\":1}}],[\"查询优化器\",{\"1\":{\"108\":1}}],[\"查询优化器的优化会后\",{\"1\":{\"108\":1}}],[\"查询不命中的情况\",{\"1\":{\"94\":1}}],[\"查询语句的执行流程如下\",{\"1\":{\"91\":1}}],[\"查询缓存\",{\"1\":{\"91\":2}}],[\"查询内核数据是否准备就绪\",{\"1\":{\"22\":1}}],[\"左边\",{\"1\":{\"217\":1}}],[\"左右\",{\"1\":{\"173\":1}}],[\"左右子树也符合上述规则\",{\"1\":{\"124\":1}}],[\"左子树的所有节点值均小于根节点\",{\"1\":{\"124\":1}}],[\"二进制安全\",{\"1\":{\"184\":1}}],[\"二级索引又称为辅助索引\",{\"1\":{\"129\":1}}],[\"二级索引\",{\"0\":{\"129\":1},\"1\":{\"132\":1}}],[\"二叉查找树是一种基于二叉树的数据结构\",{\"1\":{\"124\":1}}],[\"二叉查找树\",{\"0\":{\"124\":1}}],[\"二次握手\",{\"1\":{\"58\":1}}],[\"哈希码\",{\"1\":{\"437\":1}}],[\"哈希\",{\"0\":{\"219\":1}}],[\"哈希表结构\",{\"1\":{\"382\":1}}],[\"哈希表\",{\"1\":{\"212\":1}}],[\"哈希表示键值对的集合\",{\"1\":{\"123\":1}}],[\"哈希分片比较适合随机读写的场景\",{\"1\":{\"118\":1}}],[\"哈希分片\",{\"1\":{\"118\":1}}],[\"创建新线程的时候会用到\",{\"1\":{\"388\":1}}],[\"创建代理对象调用方法\",{\"1\":{\"323\":1}}],[\"创建string类型的对象\",{\"1\":{\"299\":1}}],[\"创建快照时\",{\"1\":{\"246\":1}}],[\"创建成功之后\",{\"1\":{\"209\":1}}],[\"创建了\",{\"1\":{\"209\":1}}],[\"创建了组合索引\",{\"1\":{\"143\":1}}],[\"创建该\",{\"1\":{\"162\":1}}],[\"创建\",{\"1\":{\"162\":1}}],[\"创建时其他未提交的活跃事务\",{\"1\":{\"162\":1}}],[\"创建索引和维护索引需要耗费许多时间\",{\"1\":{\"121\":1}}],[\"创建及删除等\",{\"1\":{\"2\":1}}],[\"缺点2\",{\"1\":{\"175\":1}}],[\"缺点1\",{\"1\":{\"175\":1}}],[\"缺点\",{\"1\":{\"121\":1,\"131\":1,\"132\":1,\"238\":1,\"317\":1,\"466\":1}}],[\"缺一不可\",{\"1\":{\"59\":1}}],[\"灵活组合多种分片算法\",{\"1\":{\"118\":1}}],[\"融合算法\",{\"1\":{\"118\":1}}],[\"地理空间索引\",{\"1\":{\"234\":1}}],[\"地理位置\",{\"1\":{\"181\":1}}],[\"地理位置分片\",{\"1\":{\"118\":1}}],[\"地址映射关系\",{\"1\":{\"79\":1}}],[\"地址有一个特殊地址\",{\"1\":{\"78\":1}}],[\"地址也就可能发生改变\",{\"1\":{\"78\":1}}],[\"地址也有一些别称\",{\"1\":{\"78\":1}}],[\"地址不具有这些性质\",{\"1\":{\"78\":1}}],[\"地址具有可携带性\",{\"1\":{\"78\":1}}],[\"地址是邮政地址\",{\"1\":{\"78\":1}}],[\"地址是身份证号\",{\"1\":{\"78\":1}}],[\"地址是一个网络设备真正的身份证号\",{\"1\":{\"78\":1}}],[\"地址只是一种不重复的定位方式\",{\"1\":{\"78\":1}}],[\"地址唯一标识\",{\"1\":{\"78\":2}}],[\"地址资源短缺的问题\",{\"1\":{\"76\":1}}],[\"地址资源充足\",{\"1\":{\"75\":1}}],[\"地址访问互联网\",{\"1\":{\"76\":1}}],[\"地址耗尽的问题\",{\"1\":{\"75\":1}}],[\"地址来判断数据包的目的地\",{\"1\":{\"74\":1}}],[\"地址来标识该\",{\"1\":{\"39\":1}}],[\"地址上托管多个域名\",{\"1\":{\"46\":1}}],[\"地址\",{\"0\":{\"78\":1},\"1\":{\"39\":1,\"50\":3,\"56\":1,\"75\":1,\"76\":5,\"78\":4,\"79\":1}}],[\"地址的全称是\",{\"1\":{\"78\":1}}],[\"地址的一些问题\",{\"1\":{\"39\":1}}],[\"地址的映射问题\",{\"1\":{\"37\":1,\"49\":1}}],[\"地址转为地址显示即可\",{\"1\":{\"107\":1}}],[\"地址转为整型\",{\"1\":{\"107\":1}}],[\"地址转\",{\"1\":{\"39\":1}}],[\"地址才是物理地址\",{\"1\":{\"39\":1,\"79\":1}}],[\"地址属于逻辑地址\",{\"1\":{\"39\":1,\"79\":1}}],[\"地址解析协议\",{\"1\":{\"39\":1,\"79\":1}}],[\"范围的缓存数据\",{\"1\":{\"280\":1}}],[\"范围内的其他元素\",{\"1\":{\"235\":1}}],[\"范围分片\",{\"1\":{\"118\":1}}],[\"范围请求的标识码\",{\"1\":{\"46\":1}}],[\"备份时间越来越长\",{\"1\":{\"117\":1}}],[\"吧一张行比较多的表拆分为多张表\",{\"1\":{\"116\":1}}],[\"水平分表\",{\"1\":{\"116\":1}}],[\"水平分库是把同一个表按一定规则拆分到不同的数据库中\",{\"1\":{\"115\":1}}],[\"垂直分表\",{\"1\":{\"116\":1}}],[\"垂直分库就是把单一数据库按照业务进行划分\",{\"1\":{\"115\":1}}],[\"部分其他收集器原本需要停顿\",{\"1\":{\"467\":1}}],[\"部分收集\",{\"1\":{\"446\":1}}],[\"部分\",{\"1\":{\"159\":1}}],[\"部分函数依赖\",{\"1\":{\"84\":1}}],[\"部署多台数据库\",{\"1\":{\"112\":1}}],[\"上下文切换更频繁\",{\"1\":{\"376\":1}}],[\"上述代码中创建对象\",{\"1\":{\"295\":1}}],[\"上分配\",{\"1\":{\"279\":1}}],[\"上面的原则都是正确的\",{\"1\":{\"400\":1}}],[\"上面介绍到的分布式锁的实现会存在一些问题\",{\"1\":{\"208\":1}}],[\"上面说了\",{\"1\":{\"159\":1}}],[\"上\",{\"1\":{\"110\":1}}],[\"上的位置\",{\"1\":{\"39\":1}}],[\"到jvm中\",{\"1\":{\"492\":1}}],[\"到底多大的对象会被直接扔到老年代\",{\"0\":{\"469\":1}}],[\"到底是如何执行查询的\",{\"1\":{\"108\":1}}],[\"到了\",{\"1\":{\"271\":1}}],[\"到页面展示到底发生了什么\",{\"0\":{\"43\":1}}],[\"数量\",{\"1\":{\"235\":1}}],[\"数量量巨大\",{\"1\":{\"233\":1}}],[\"数统计\",{\"1\":{\"233\":1}}],[\"数组来优化堆内存\",{\"1\":{\"509\":1}}],[\"数组来实现二叉堆\",{\"1\":{\"251\":1}}],[\"数组类不是通过classloader创建的\",{\"1\":{\"492\":1}}],[\"数组等方式实现了这个接口\",{\"1\":{\"410\":1}}],[\"数组+链表\",{\"1\":{\"271\":1}}],[\"数组+链表组成的\",{\"1\":{\"251\":1}}],[\"数组长度大于等于64的时候就会触发树化\",{\"1\":{\"268\":1}}],[\"数组长度大于等于64的时候会进行树化\",{\"1\":{\"251\":1}}],[\"数组容量扩为\",{\"1\":{\"253\":1}}],[\"数组是\",{\"1\":{\"251\":2,\"271\":1}}],[\"数组\",{\"1\":{\"219\":1,\"251\":3,\"444\":1}}],[\"数值越小越好\",{\"1\":{\"108\":1}}],[\"数据表示是否太臃肿\",{\"1\":{\"512\":1}}],[\"数据表的主键列使用的就是主键索引\",{\"1\":{\"128\":1}}],[\"数据是不是太多\",{\"1\":{\"512\":1}}],[\"数据恢复优先级\",{\"1\":{\"246\":1}}],[\"数据完整性更高\",{\"1\":{\"246\":1}}],[\"数据完整性\",{\"1\":{\"246\":1}}],[\"数据的可靠性\",{\"1\":{\"245\":1}}],[\"数据在\",{\"1\":{\"199\":2}}],[\"数据量巨大的场景还是\",{\"1\":{\"187\":1,\"224\":1}}],[\"数据结构散列表\",{\"1\":{\"300\":1}}],[\"数据结构散列表中除留余数法\",{\"1\":{\"269\":1}}],[\"数据结构可以用来做消息队列\",{\"1\":{\"218\":1}}],[\"数据结构可以作为一个简单的队列使用\",{\"1\":{\"179\":1}}],[\"数据结构\",{\"0\":{\"180\":1}}],[\"数据可能还没异步更新\",{\"1\":{\"177\":1}}],[\"数据更新\",{\"1\":{\"175\":1}}],[\"数据删除\",{\"1\":{\"175\":1}}],[\"数据类型\",{\"1\":{\"172\":1}}],[\"数据前生成一个read\",{\"1\":{\"164\":1}}],[\"数据页的大小是16kb\",{\"1\":{\"148\":1}}],[\"数据修改\",{\"1\":{\"146\":1}}],[\"数据文件本身就是索引文件\",{\"1\":{\"127\":1}}],[\"数据遍布在不同服务器上的数据库\",{\"1\":{\"119\":1}}],[\"数据应该放在哪个表的问题\",{\"1\":{\"118\":1}}],[\"数据保持一致\",{\"1\":{\"96\":1}}],[\"数据块被称为报文段或段\",{\"1\":{\"64\":1}}],[\"数据传送结束后要释放连接\",{\"1\":{\"53\":1}}],[\"数据包包含了源ip地址和目的ip地址\",{\"1\":{\"74\":1}}],[\"数据包\",{\"1\":{\"40\":2}}],[\"数据\",{\"1\":{\"40\":1,\"259\":1}}],[\"数据报在物理上传输的过程中\",{\"1\":{\"39\":1,\"79\":1}}],[\"数据库查询需要什么字段就返回对应字段\",{\"1\":{\"512\":1}}],[\"数据库和缓存数据强一致性场景\",{\"1\":{\"175\":1}}],[\"数据库还能够通过查询回滚日志来回滚将之前未完成的事务\",{\"1\":{\"153\":1}}],[\"数据库的数据备份\",{\"1\":{\"149\":1}}],[\"数据库的数据占用的空间越来越大\",{\"1\":{\"117\":1}}],[\"数据库的自增主键已经没办法满足生成唯一主键\",{\"1\":{\"119\":1}}],[\"数据库的三大范式\",{\"0\":{\"82\":1}}],[\"数据库读写速度比较缓慢\",{\"1\":{\"117\":1}}],[\"数据库重新启动的时候会保证数据库恢复到崩溃前的状态\",{\"1\":{\"93\":1}}],[\"数据库基础\",{\"0\":{\"81\":1}}],[\"数据库\",{\"0\":{\"29\":1}}],[\"数据从内核空间\",{\"1\":{\"22\":1}}],[\"大表\",{\"1\":{\"512\":1}}],[\"大部分对象用过即死\",{\"1\":{\"513\":1}}],[\"大部分类在具体用到的时候才会去加载\",{\"1\":{\"493\":1}}],[\"大部分情况\",{\"1\":{\"445\":1}}],[\"大部分情况下\",{\"1\":{\"400\":1}}],[\"大致可以分为初始标记\",{\"1\":{\"468\":1}}],[\"大致估算出找到所需的记录或所需读取的行数\",{\"1\":{\"108\":1}}],[\"大对象就是需要大量连续内存空间的对象\",{\"1\":{\"444\":1}}],[\"大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率\",{\"1\":{\"444\":1}}],[\"大对象直接进入老年代\",{\"0\":{\"444\":1}}],[\"大多数情况下\",{\"1\":{\"443\":1}}],[\"大量阻塞线程会导致系统的上下文切换\",{\"1\":{\"365\":1}}],[\"大量cpu和内存消耗\",{\"1\":{\"246\":1}}],[\"大类\",{\"1\":{\"210\":1}}],[\"大概都在\",{\"1\":{\"173\":1}}],[\"大于等于这个\",{\"1\":{\"162\":1}}],[\"大小\",{\"1\":{\"151\":1}}],[\"大小的内存\",{\"1\":{\"12\":1}}],[\"大幅度提升读性能\",{\"1\":{\"110\":1}}],[\"列表\",{\"0\":{\"216\":1},\"1\":{\"162\":1,\"164\":2,\"181\":1,\"212\":1}}],[\"列表示根据表统计信息及选用情况\",{\"1\":{\"108\":1}}],[\"列表示\",{\"1\":{\"108\":2}}],[\"列表示哪个索引被使用了\",{\"1\":{\"108\":1}}],[\"列也显示\",{\"1\":{\"108\":1}}],[\"列显示\",{\"1\":{\"108\":1}}],[\"列列出了使用到的索引\",{\"1\":{\"108\":1}}],[\"列名=值\",{\"1\":{\"86\":1}}],[\"方式\",{\"1\":{\"108\":1}}],[\"方法即可\",{\"1\":{\"495\":1,\"499\":1}}],[\"方法解析该类\",{\"1\":{\"495\":1}}],[\"方法在内存中的指针或者偏移量\",{\"1\":{\"488\":1}}],[\"方法在队列为空的时候会阻塞\",{\"1\":{\"417\":1}}],[\"方法句柄和调用限定符进行引用\",{\"1\":{\"488\":1}}],[\"方法类型\",{\"1\":{\"488\":1}}],[\"方法表中都可以携带自己的属性表集合\",{\"1\":{\"481\":1}}],[\"方法表的结构如同字段表一样\",{\"1\":{\"480\":1}}],[\"方法表集合\",{\"0\":{\"480\":1}}],[\"方法符号引用\",{\"1\":{\"429\":1}}],[\"方法区中常量引用的对象\",{\"1\":{\"451\":1}}],[\"方法区中静态属性引用的变量\",{\"1\":{\"451\":1}}],[\"方法区内部\",{\"0\":{\"429\":1}}],[\"方法区属于是\",{\"1\":{\"428\":1}}],[\"方法区\",{\"0\":{\"428\":1},\"1\":{\"504\":3}}],[\"方法区用来存放已经被加载的类信息\",{\"1\":{\"343\":1}}],[\"方法服务\",{\"1\":{\"425\":1}}],[\"方法调用的数据需要通过栈进行传递\",{\"1\":{\"424\":1}}],[\"方法不会\",{\"1\":{\"417\":1}}],[\"方法不定义在thread中\",{\"0\":{\"350\":1}}],[\"方法来加载类\",{\"1\":{\"499\":1}}],[\"方法来指定元素排序规则\",{\"1\":{\"417\":1}}],[\"方法来获取默认值或将其值更改为当前线程所存的副本的值\",{\"1\":{\"381\":1}}],[\"方法告诉cyclicbarrier\",{\"1\":{\"409\":1}}],[\"方法之后的语句得到执行\",{\"1\":{\"408\":1}}],[\"方法之后的语句不会被执行\",{\"1\":{\"408\":1}}],[\"方法之外\",{\"1\":{\"407\":1}}],[\"方法就会一直阻塞\",{\"1\":{\"408\":1}}],[\"方法就会被转发到实现invocationhandler接口类的invoke方法来调用\",{\"1\":{\"323\":1}}],[\"方法时\",{\"1\":{\"408\":1}}],[\"方法为阻塞调用\",{\"1\":{\"396\":1}}],[\"方法返回地址\",{\"1\":{\"424\":1}}],[\"方法返回的其实就是\",{\"1\":{\"395\":1}}],[\"方法返回string对象\",{\"1\":{\"305\":1}}],[\"方法相结合可以实现等待\",{\"1\":{\"377\":1}}],[\"方法happens\",{\"1\":{\"359\":1}}],[\"方法方可启动线程并使线程进入就绪状态\",{\"1\":{\"351\":1}}],[\"方法当成普通方法执行\",{\"1\":{\"351\":1}}],[\"方法会创建一个新的线程并让其进入就绪状态\",{\"1\":{\"351\":1}}],[\"方法会产生两个\",{\"1\":{\"40\":1}}],[\"方法是让当前线程暂停执行\",{\"1\":{\"350\":1}}],[\"方法执行完成后\",{\"1\":{\"349\":1}}],[\"方法被调用之后\",{\"1\":{\"349\":1}}],[\"方法释放了锁\",{\"1\":{\"349\":1}}],[\"方法没有释放锁\",{\"1\":{\"349\":1}}],[\"方法对比\",{\"0\":{\"349\":1}}],[\"方法和\",{\"0\":{\"349\":1}}],[\"方法有三个参数\",{\"1\":{\"323\":2}}],[\"方法有什么作用\",{\"0\":{\"307\":1}}],[\"方法接收的直接是实参所引用对象在堆中的地址\",{\"1\":{\"311\":1}}],[\"方法接收的是实参的拷贝\",{\"1\":{\"311\":1}}],[\"方法可能会导致判断是相等的两个对象但是hashcode不等\",{\"1\":{\"301\":1}}],[\"方法用来获哈希码\",{\"1\":{\"300\":1}}],[\"方法名\",{\"1\":{\"289\":1}}],[\"方法实现锁的异步续期\",{\"1\":{\"206\":1}}],[\"方法\",{\"0\":{\"287\":1,\"301\":1,\"436\":1},\"1\":{\"204\":1,\"206\":1,\"305\":1,\"323\":1,\"349\":1,\"351\":2,\"377\":1,\"382\":1,\"391\":1,\"407\":1,\"425\":1,\"429\":1,\"436\":1,\"486\":1,\"495\":1,\"499\":1}}],[\"方法的过程\",{\"1\":{\"489\":1}}],[\"方法的名称和描述符\",{\"1\":{\"476\":1}}],[\"方法的顺序就是获取许可证的顺序\",{\"1\":{\"407\":1}}],[\"方法的任务执行结果\",{\"1\":{\"395\":1}}],[\"方法的时候\",{\"1\":{\"383\":1,\"408\":1}}],[\"方法的话不会以多线程的方式执行\",{\"1\":{\"351\":1}}],[\"方法的重写要遵循\",{\"1\":{\"289\":1}}],[\"方法的长度限制是怎么回事\",{\"1\":{\"40\":1}}],[\"方法的参数应该放在\",{\"1\":{\"40\":1}}],[\"方法安全\",{\"1\":{\"40\":1}}],[\"方法比\",{\"1\":{\"40\":1}}],[\"方法参数\",{\"1\":{\"324\":1}}],[\"方法参数写法是固定的吗\",{\"1\":{\"40\":1}}],[\"方法参数应该放在\",{\"1\":{\"40\":1}}],[\"前三个阶段可以统称为连接\",{\"1\":{\"483\":1}}],[\"前驱节点\",{\"1\":{\"405\":1}}],[\"前一个操作的结果应该对后一个操作是可见的\",{\"1\":{\"358\":1}}],[\"前一张表的行在当前这张表中只有一行与之对应\",{\"1\":{\"108\":1}}],[\"前的\",{\"1\":{\"219\":1}}],[\"前面说的事件监听器其实监听的就是这个子节点删除事件\",{\"1\":{\"209\":1}}],[\"前缀索引是对文本的前几个字符创建索引\",{\"1\":{\"129\":1}}],[\"前缀索引只适用于字符串类型的数据\",{\"1\":{\"129\":1}}],[\"前缀索引\",{\"1\":{\"129\":1}}],[\"前缀是\",{\"1\":{\"45\":2}}],[\"前缀\",{\"1\":{\"45\":1}}],[\"访问标志\",{\"0\":{\"477\":1}}],[\"访问标志来辨别一个方法是否声明为同步方法\",{\"1\":{\"372\":1}}],[\"访问修饰符范围大于等于父类\",{\"1\":{\"289\":1}}],[\"访问共享内存\",{\"1\":{\"239\":1}}],[\"访问方法是\",{\"1\":{\"108\":1}}],[\"访问控制\",{\"1\":{\"2\":1}}],[\"命令追加\",{\"1\":{\"241\":1}}],[\"命令删除对应的\",{\"1\":{\"204\":1}}],[\"命令是可以帮助我们实现互斥\",{\"1\":{\"204\":1}}],[\"命令回复处理器\",{\"1\":{\"194\":1}}],[\"命令请求处理器\",{\"1\":{\"194\":1}}],[\"命令\",{\"1\":{\"186\":1,\"214\":1,\"217\":1,\"220\":1,\"223\":1,\"226\":1,\"229\":1,\"232\":1,\"235\":2}}],[\"命令可以实现一个最简易的分布式锁\",{\"1\":{\"182\":1,\"215\":1}}],[\"命令来分析\",{\"1\":{\"108\":1}}],[\"命名管道\",{\"1\":{\"9\":1}}],[\"显示数据时\",{\"1\":{\"107\":1}}],[\"转储到物理文件中\",{\"1\":{\"508\":1}}],[\"转到本地内存的原因\",{\"1\":{\"428\":1}}],[\"转化为红黑树加快查找\",{\"1\":{\"251\":1}}],[\"转为地址\",{\"1\":{\"107\":1}}],[\"转账者和收款人的总额应该是不变的\",{\"1\":{\"96\":1}}],[\"把内存化整为零\",{\"1\":{\"467\":1}}],[\"把内存中的所有数据都记录到磁盘中\",{\"1\":{\"238\":1}}],[\"把这个虚引用加入到与之关联的引用队列中\",{\"1\":{\"453\":1}}],[\"把对象按照程序员的意愿进行初始化\",{\"1\":{\"436\":1}}],[\"把缓存中的数据刷入内存中\",{\"1\":{\"362\":1}}],[\"把数据全部存在内存之中\",{\"1\":{\"172\":1}}],[\"把字段c值更新成1\",{\"1\":{\"152\":1}}],[\"把一张列比较多的表拆分成多张表\",{\"1\":{\"116\":1}}],[\"把\",{\"1\":{\"107\":1,\"147\":1}}],[\"把整型的\",{\"1\":{\"107\":2}}],[\"把ip转化为无符号整数\",{\"1\":{\"107\":1}}],[\"排队\",{\"1\":{\"250\":1}}],[\"排它锁\",{\"1\":{\"106\":1,\"159\":1}}],[\"排他锁之前\",{\"1\":{\"105\":1}}],[\"排他锁\",{\"1\":{\"104\":1}}],[\"共有\",{\"1\":{\"212\":1}}],[\"共有两种\",{\"1\":{\"105\":1}}],[\"共同的关注点\",{\"1\":{\"467\":1}}],[\"共同喜好等功能\",{\"1\":{\"222\":1}}],[\"共同关注\",{\"1\":{\"187\":1,\"224\":1}}],[\"共同粉丝\",{\"1\":{\"187\":1,\"222\":1,\"224\":1}}],[\"共同好友\",{\"1\":{\"187\":1,\"224\":1}}],[\"共同点\",{\"1\":{\"172\":1,\"296\":1}}],[\"共享\",{\"1\":{\"406\":1}}],[\"共享锁\",{\"1\":{\"104\":1,\"106\":1,\"159\":1}}],[\"共享锁和排他锁区别\",{\"0\":{\"104\":1}}],[\"共享内存\",{\"1\":{\"9\":1}}],[\"行锁只能锁住已经存在的行\",{\"1\":{\"156\":1}}],[\"行锁默认使用的是\",{\"1\":{\"103\":1}}],[\"行级锁和存储引擎有关\",{\"1\":{\"102\":1}}],[\"行级锁能大大减少数据库操作的冲突\",{\"1\":{\"102\":1}}],[\"行级锁\",{\"1\":{\"102\":1}}],[\"行级锁的粒度更小\",{\"1\":{\"102\":1}}],[\"下图展示的各种类加载器之间的层次关系被称为类加载器的\",{\"1\":{\"496\":1}}],[\"下是数据类型的默认值\",{\"1\":{\"487\":1}}],[\"下面的代码表示同一时刻\",{\"1\":{\"407\":1}}],[\"下面两个表达式其实是等价的\",{\"1\":{\"308\":1}}],[\"下最小的子节点\",{\"1\":{\"209\":1}}],[\"下\",{\"1\":{\"103\":1,\"158\":1,\"159\":1,\"164\":1,\"176\":1,\"177\":1}}],[\"下的所有\",{\"1\":{\"494\":1}}],[\"下的\",{\"1\":{\"39\":1}}],[\"临时顺序\",{\"1\":{\"210\":1}}],[\"临时顺序节点\",{\"1\":{\"209\":1}}],[\"临时节点会话消失则对应的节点消失\",{\"1\":{\"210\":1}}],[\"临时节点相比持久节点\",{\"1\":{\"210\":1}}],[\"临时节点只能做叶子节点\",{\"1\":{\"210\":1}}],[\"临时节点的生命周期是与\",{\"1\":{\"210\":1}}],[\"临时\",{\"1\":{\"210\":1}}],[\"临时表\",{\"1\":{\"94\":1}}],[\"临键锁\",{\"1\":{\"103\":1,\"166\":1}}],[\"间隙锁\",{\"1\":{\"103\":1}}],[\"资源敏感\",{\"1\":{\"466\":1}}],[\"资源的场合\",{\"1\":{\"465\":1}}],[\"资源有序分配\",{\"1\":{\"347\":1}}],[\"资源和内存资源产生影响\",{\"1\":{\"246\":1}}],[\"资源消耗快\",{\"1\":{\"102\":1}}],[\"资源已被永久转移\",{\"1\":{\"46\":1}}],[\"仅存在结点之间的关联关系\",{\"1\":{\"405\":1}}],[\"仅包含java应用程序运行时的必要环境\",{\"1\":{\"275\":1}}],[\"仅做个人学习\",{\"1\":{\"274\":1}}],[\"仅仅起占位作用\",{\"1\":{\"437\":1}}],[\"仅仅是追加命令到\",{\"1\":{\"246\":1}}],[\"仅仅支持表级锁\",{\"1\":{\"102\":1}}],[\"仅对相关的记录上锁即可\",{\"1\":{\"102\":1}}],[\"锁状态标志\",{\"1\":{\"437\":1}}],[\"锁是对自旋锁的一种改进\",{\"1\":{\"405\":1}}],[\"锁粗化\",{\"0\":{\"400\":1}}],[\"锁消除的主要判断依据来源于逃逸分析的数据支持\",{\"1\":{\"399\":1}}],[\"锁消除\",{\"0\":{\"399\":1}}],[\"锁主要存在四种状态\",{\"1\":{\"397\":1}}],[\"锁可以绑定多个条件\",{\"1\":{\"377\":1}}],[\"锁可以看做是悲观控制的模式\",{\"1\":{\"98\":1}}],[\"锁被释放之后\",{\"1\":{\"376\":2}}],[\"锁粒度更细\",{\"1\":{\"272\":1}}],[\"锁最终一定还是会被释放\",{\"1\":{\"202\":1}}],[\"锁服务是高可用的\",{\"1\":{\"202\":1}}],[\"锁只能被一个线程持有\",{\"1\":{\"202\":1}}],[\"锁则会被阻塞\",{\"1\":{\"159\":1}}],[\"锁定它们的间隙\",{\"1\":{\"166\":1}}],[\"锁定读会对读取到的记录加锁\",{\"1\":{\"159\":1}}],[\"锁定读\",{\"0\":{\"159\":1}}],[\"锁定一个范围\",{\"1\":{\"103\":2,\"166\":1}}],[\"锁不兼容\",{\"1\":{\"104\":1}}],[\"锁兼容\",{\"1\":{\"104\":1}}],[\"锁\",{\"0\":{\"101\":1},\"1\":{\"104\":2,\"105\":6,\"159\":4,\"401\":1}}],[\"锁和mvcc\",{\"1\":{\"98\":1}}],[\"幻读或不可重复读\",{\"1\":{\"156\":1}}],[\"幻读\",{\"1\":{\"97\":1,\"156\":1,\"166\":1}}],[\"读屏障\",{\"1\":{\"362\":1}}],[\"读数据\",{\"1\":{\"175\":1}}],[\"读到直接返回\",{\"1\":{\"175\":1}}],[\"读到了没有提交的数据\",{\"1\":{\"97\":1}}],[\"读\",{\"1\":{\"175\":1,\"176\":1}}],[\"读请求交给从数据库处理\",{\"1\":{\"112\":1}}],[\"读取是完全不用加锁的\",{\"1\":{\"411\":1}}],[\"读取不到的话\",{\"1\":{\"176\":1}}],[\"读取到就直接返回\",{\"1\":{\"176\":1}}],[\"读取到了一个原本没有的数据\",{\"1\":{\"97\":1}}],[\"读取的都是最新的数据\",{\"1\":{\"166\":1}}],[\"读取的是数据的最新版本\",{\"1\":{\"159\":1}}],[\"读取之前的版本数据\",{\"1\":{\"163\":1}}],[\"读取已提交\",{\"1\":{\"156\":1}}],[\"读取未提交\",{\"1\":{\"156\":1}}],[\"读取操作不会因此去等待记录上x锁的释放\",{\"1\":{\"106\":1}}],[\"读取条件相同的情况下得到的结果却是不一样的\",{\"1\":{\"97\":1}}],[\"读写穿透\",{\"0\":{\"176\":1}}],[\"读写速度非常快\",{\"1\":{\"170\":1}}],[\"读写互斥\",{\"1\":{\"104\":1}}],[\"读写分离对提升数据库的并发非常有效\",{\"1\":{\"111\":1}}],[\"读写分离会带来什么问题\",{\"0\":{\"111\":1}}],[\"读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点\",{\"1\":{\"110\":1}}],[\"读写分离和分库分表\",{\"0\":{\"109\":1}}],[\"读写分离\",{\"0\":{\"110\":1},\"1\":{\"90\":1}}],[\"读写锁\",{\"1\":{\"7\":1,\"207\":1}}],[\"脏读\",{\"1\":{\"97\":1,\"156\":1}}],[\"各线程之间计数器互不影响\",{\"1\":{\"423\":1}}],[\"各种lock实现可见性\",{\"1\":{\"360\":1}}],[\"各种排行榜比如直播间送礼物的排行榜\",{\"1\":{\"227\":1}}],[\"各并发事务之间的数据库是独立的\",{\"1\":{\"96\":1}}],[\"各主机使用的是同一个\",{\"1\":{\"39\":1}}],[\"隔离级别只会在事务开启后的第一次查询生成\",{\"1\":{\"166\":1}}],[\"隔离级别下只在事务开始后\",{\"1\":{\"164\":1}}],[\"隔离级别下的\",{\"1\":{\"164\":1}}],[\"隔离级别下\",{\"0\":{\"164\":1},\"1\":{\"165\":1}}],[\"隔离级别其实是可以解决幻读问题发生的\",{\"1\":{\"156\":1}}],[\"隔离级别定义里\",{\"1\":{\"156\":1}}],[\"隔离级别\",{\"1\":{\"156\":1}}],[\"隔离级别是基于\",{\"1\":{\"99\":1}}],[\"隔离级别是可以解决幻读问题的\",{\"1\":{\"93\":1}}],[\"隔离性之后\",{\"1\":{\"96\":1}}],[\"隔离性isolation\",{\"1\":{\"96\":1}}],[\"失效后还要销毁\",{\"1\":{\"94\":1}}],[\"性能较差一些\",{\"1\":{\"376\":1}}],[\"性能也很高效\",{\"1\":{\"204\":1}}],[\"性能非常高\",{\"1\":{\"171\":1}}],[\"性能会远远超过刷数据页面的方式\",{\"1\":{\"148\":1}}],[\"性能很差\",{\"1\":{\"148\":1}}],[\"性能更好\",{\"1\":{\"107\":1,\"376\":1}}],[\"性能太差\",{\"1\":{\"105\":1}}],[\"性能\",{\"1\":{\"93\":1}}],[\"索引集合\",{\"0\":{\"478\":1}}],[\"索引值为\",{\"1\":{\"476\":1}}],[\"索引失效是慢查询的主要原因之一\",{\"1\":{\"143\":1}}],[\"索引占用的空间也是很多的\",{\"1\":{\"142\":1}}],[\"索引过多\",{\"1\":{\"142\":1}}],[\"索引可以提高效率同样可以降低效率\",{\"1\":{\"141\":1}}],[\"索引并不是越多越好\",{\"1\":{\"141\":1}}],[\"索引下推是mysql\",{\"1\":{\"137\":1}}],[\"索引下推\",{\"0\":{\"137\":1}}],[\"索引a字段可以在联合索引的b+树中进行索引查询\",{\"1\":{\"136\":1}}],[\"索引就结束了\",{\"1\":{\"127\":1}}],[\"索引底层数据结构\",{\"0\":{\"122\":1}}],[\"索引需要占用一定的物理空间\",{\"1\":{\"121\":1}}],[\"索引是一种用于快速查询和检索数据的数据结构\",{\"1\":{\"121\":1}}],[\"索引\",{\"0\":{\"121\":1}}],[\"索引文件和数据文件是分离的\",{\"1\":{\"93\":1}}],[\"索引实现不同\",{\"1\":{\"93\":1}}],[\"请注意\",{\"1\":{\"509\":1}}],[\"请通过关系表实现\",{\"1\":{\"93\":1}}],[\"请求高峰期发生fullgc\",{\"1\":{\"518\":1}}],[\"请求并保持\",{\"1\":{\"346\":1}}],[\"请求与当前资源的规定冲突\",{\"1\":{\"46\":1}}],[\"请求\",{\"1\":{\"43\":1,\"175\":5}}],[\"请求不具有幂等性\",{\"1\":{\"41\":1}}],[\"请求会在服务器上创建新的资源\",{\"1\":{\"41\":1}}],[\"请求时\",{\"1\":{\"41\":1,\"50\":1}}],[\"请求是\",{\"1\":{\"41\":1}}],[\"请求的结果应该相同\",{\"1\":{\"41\":1}}],[\"请求具有幂等性\",{\"1\":{\"41\":1}}],[\"请求进行加载的\",{\"1\":{\"37\":1,\"56\":1}}],[\"请求才到的话\",{\"1\":{\"16\":1}}],[\"默认实现是空方法\",{\"1\":{\"495\":1}}],[\"默认认为这些新对象不是垃圾\",{\"1\":{\"467\":1}}],[\"默认模式\",{\"1\":{\"407\":1}}],[\"默认8\",{\"1\":{\"268\":1}}],[\"默认选项\",{\"1\":{\"239\":1}}],[\"默认情况下元素采用自然顺序进行排序\",{\"1\":{\"417\":1}}],[\"默认情况下redis没有开启aof方式的持久化\",{\"1\":{\"240\":1}}],[\"默认情况下\",{\"1\":{\"206\":1}}],[\"默认\",{\"1\":{\"206\":2}}],[\"默认为8\",{\"1\":{\"251\":1}}],[\"默认为\",{\"1\":{\"206\":1,\"445\":1}}],[\"默认为行级锁\",{\"1\":{\"93\":1,\"102\":1}}],[\"默认值是\",{\"1\":{\"445\":1}}],[\"默认值64mb\",{\"1\":{\"244\":1}}],[\"默认值100\",{\"1\":{\"244\":1}}],[\"默认值\",{\"1\":{\"146\":1}}],[\"默认的隔离级别\",{\"1\":{\"103\":1}}],[\"默认是不公平实现的\",{\"1\":{\"415\":1}}],[\"默认是16\",{\"1\":{\"272\":1}}],[\"默认是按\",{\"1\":{\"265\":1}}],[\"默认是0\",{\"1\":{\"151\":1}}],[\"默认是\",{\"1\":{\"45\":2}}],[\"引发的full\",{\"1\":{\"513\":1}}],[\"引用的目标并不一定是已经加载到虚拟机内存中的内容\",{\"1\":{\"488\":1}}],[\"引用类型总结\",{\"0\":{\"453\":1}}],[\"引用类型变量发出的方法调用到底是哪个类中的方法\",{\"1\":{\"295\":1}}],[\"引用失效\",{\"1\":{\"449\":1}}],[\"引用计数法\",{\"0\":{\"449\":1}}],[\"引用传递值得是\",{\"1\":{\"312\":1}}],[\"引用传递\",{\"0\":{\"311\":1},\"1\":{\"311\":1}}],[\"引用拷贝\",{\"0\":{\"297\":1},\"1\":{\"297\":1}}],[\"引用相等是指向的内存地址是否相等\",{\"1\":{\"293\":1}}],[\"引擎错误\",{\"1\":{\"246\":1}}],[\"引擎使用\",{\"1\":{\"154\":1}}],[\"引擎层是插件式的\",{\"1\":{\"91\":1}}],[\"引入了这个\",{\"1\":{\"509\":1}}],[\"引入了发布订阅\",{\"1\":{\"179\":1}}],[\"引入了\",{\"1\":{\"46\":1}}],[\"引入线程之后\",{\"1\":{\"5\":1,\"339\":1}}],[\"采用标记\",{\"1\":{\"463\":1}}],[\"采用字节码的好处\",{\"0\":{\"276\":1}}],[\"采用\",{\"1\":{\"271\":1,\"272\":2}}],[\"采用两种方式计数\",{\"1\":{\"231\":1}}],[\"采用的是插件式架构\",{\"1\":{\"91\":1}}],[\"采用互斥对象机制\",{\"1\":{\"7\":1}}],[\"插入时可能存在扩容过程\",{\"1\":{\"259\":1}}],[\"插入队列的对象必须是可比较大小的\",{\"1\":{\"417\":1}}],[\"插入队首\",{\"1\":{\"258\":1}}],[\"插入队尾\",{\"1\":{\"258\":2}}],[\"插入记录版本对当前事务并不可见\",{\"1\":{\"166\":1}}],[\"插入和删除在平均和最坏情况下的时间复杂度都是\",{\"1\":{\"125\":1}}],[\"插入数据前\",{\"1\":{\"107\":1}}],[\"插入异常\",{\"1\":{\"85\":1}}],[\"插件式存储引擎\",{\"1\":{\"91\":1}}],[\"优秀的地方\",{\"1\":{\"246\":2}}],[\"优先选择回收价值最大的\",{\"1\":{\"467\":1}}],[\"优先选择距离当前磁头位置最近的请求进行服务\",{\"1\":{\"16\":1}}],[\"优先级任务队列\",{\"1\":{\"227\":1}}],[\"优缺点\",{\"1\":{\"175\":1}}],[\"优点\",{\"1\":{\"121\":1,\"131\":1,\"132\":1,\"317\":1,\"466\":1}}],[\"优化改进得来\",{\"1\":{\"231\":1}}],[\"优化\",{\"1\":{\"108\":1}}],[\"优化器\",{\"1\":{\"91\":2}}],[\"执行流程\",{\"1\":{\"497\":1}}],[\"执行效率太低\",{\"1\":{\"394\":1}}],[\"执行效率大为提升\",{\"1\":{\"364\":1}}],[\"执行的结果看子类hero1\",{\"1\":{\"295\":1}}],[\"执行结果看右边\",{\"1\":{\"295\":1}}],[\"执行写操作后将数据写入aof缓冲区\",{\"1\":{\"242\":1}}],[\"执行写操作后\",{\"1\":{\"242\":2}}],[\"执行写操作\",{\"1\":{\"239\":1}}],[\"执行间隔很长\",{\"1\":{\"238\":1}}],[\"执行业务\",{\"1\":{\"206\":1}}],[\"执行命令仍然是单线程顺序执行\",{\"1\":{\"196\":1}}],[\"执行\",{\"0\":{\"436\":1},\"1\":{\"166\":1,\"436\":1}}],[\"执行普通\",{\"1\":{\"166\":1}}],[\"执行计划中的\",{\"1\":{\"108\":1}}],[\"执行计划是指一条\",{\"1\":{\"108\":1}}],[\"执行计划\",{\"0\":{\"108\":1},\"1\":{\"108\":1}}],[\"执行事物的前后\",{\"1\":{\"96\":1}}],[\"执行语句\",{\"1\":{\"91\":1}}],[\"执行器\",{\"1\":{\"91\":2}}],[\"执行查询语句的时候\",{\"1\":{\"91\":1,\"94\":1}}],[\"执行响应的系统调用\",{\"1\":{\"3\":1}}],[\"事务等功能\",{\"1\":{\"172\":1}}],[\"事务隔离级别\",{\"0\":{\"156\":1}}],[\"事务隔离级别和mvcc\",{\"0\":{\"155\":1}}],[\"事务提交的时候\",{\"1\":{\"151\":1}}],[\"事务执行过程中\",{\"1\":{\"151\":1}}],[\"事务一提交就会进行刷盘操作\",{\"1\":{\"145\":1}}],[\"事务问题\",{\"1\":{\"119\":1}}],[\"事务有意向对表中的某些记录加排他锁\",{\"1\":{\"105\":1}}],[\"事务有意向对表中的某些记录加共享锁\",{\"1\":{\"105\":1}}],[\"事务在第一次查询开始的时候会生成一个read\",{\"1\":{\"165\":1}}],[\"事务在每次查询开始时都会生成并设置新的\",{\"1\":{\"165\":1}}],[\"事务在修改记录的时候获取排他锁\",{\"1\":{\"104\":1}}],[\"事务在读取记录的时候获取共享锁\",{\"1\":{\"104\":1}}],[\"事务的原子性确保动作要么都完成\",{\"1\":{\"96\":1}}],[\"事务是最小的执行单位\",{\"1\":{\"96\":1}}],[\"事务是逻辑上的一组操作\",{\"1\":{\"95\":1}}],[\"事务\",{\"0\":{\"95\":1}}],[\"事务支持优秀\",{\"1\":{\"90\":1}}],[\"事件监听器\",{\"1\":{\"209\":1}}],[\"事件处理器\",{\"1\":{\"194\":1}}],[\"事件\",{\"1\":{\"7\":1}}],[\"社区活跃\",{\"1\":{\"90\":1}}],[\"兼容性好\",{\"1\":{\"90\":1}}],[\"文章信息\",{\"1\":{\"221\":1}}],[\"文章点赞\",{\"1\":{\"187\":1,\"224\":1}}],[\"文档丰富\",{\"1\":{\"90\":1}}],[\"文件格式验证\",{\"1\":{\"486\":1}}],[\"文件中其它的数据项目要求的顺序\",{\"1\":{\"481\":1}}],[\"文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式\",{\"1\":{\"480\":1}}],[\"文件存储的是每一次写命令\",{\"1\":{\"246\":1}}],[\"文件存储的内容是经过压缩的二进制数据\",{\"1\":{\"246\":1}}],[\"文件版本号\",{\"0\":{\"475\":1}}],[\"文件体积很大\",{\"1\":{\"246\":1}}],[\"文件体积小\",{\"1\":{\"246\":1}}],[\"文件体积大于多少时执行重写\",{\"1\":{\"244\":1}}],[\"文件大小\",{\"1\":{\"246\":1}}],[\"文件大很多\",{\"1\":{\"246\":1}}],[\"文件没有被重写\",{\"1\":{\"246\":1}}],[\"文件来解决一些问题\",{\"1\":{\"246\":1}}],[\"文件进行分析\",{\"1\":{\"246\":1}}],[\"文件进行检查\",{\"1\":{\"245\":1}}],[\"文件是以特定的二进制格式保存的\",{\"1\":{\"246\":1}}],[\"文件是否完整\",{\"1\":{\"245\":1}}],[\"文件恢复数据\",{\"1\":{\"246\":1}}],[\"文件所保存的数据库状态一样\",{\"1\":{\"246\":1}}],[\"文件和原有的\",{\"1\":{\"246\":1}}],[\"文件很小\",{\"1\":{\"246\":1}}],[\"文件内容进行\",{\"1\":{\"245\":1}}],[\"文件替换旧的\",{\"1\":{\"244\":1}}],[\"文件保存的数据库状态与现有的数据库状态一致\",{\"1\":{\"244\":1}}],[\"文件的方法的数量\",{\"1\":{\"480\":1}}],[\"文件的字段的个数\",{\"1\":{\"479\":1}}],[\"文件的版本号\",{\"1\":{\"475\":1}}],[\"文件的头\",{\"1\":{\"474\":1}}],[\"文件的标志\",{\"1\":{\"474\":1}}],[\"文件的常量池里保存有大量的符号引用比如方法引用的符号引用\",{\"1\":{\"424\":1}}],[\"文件的工作不会阻塞主线程\",{\"1\":{\"246\":1}}],[\"文件的工作之后\",{\"1\":{\"244\":1}}],[\"文件的过程是比较繁重的\",{\"1\":{\"246\":1}}],[\"文件的末尾\",{\"1\":{\"244\":1}}],[\"文件的读\",{\"1\":{\"2\":1}}],[\"文件期间\",{\"1\":{\"244\":1}}],[\"文件重写操作\",{\"1\":{\"244\":1}}],[\"文件重写期间\",{\"1\":{\"244\":1}}],[\"文件重写\",{\"1\":{\"241\":1}}],[\"文件同步\",{\"1\":{\"241\":1}}],[\"文件写入\",{\"1\":{\"241\":1}}],[\"文件\",{\"1\":{\"197\":1,\"244\":1,\"245\":1,\"246\":1,\"474\":1,\"481\":1}}],[\"文件事件派发器\",{\"1\":{\"194\":1}}],[\"文件事件处理器包含四个部分\",{\"1\":{\"194\":1}}],[\"文件事件处理器既实现了高性能的网络通信模型\",{\"1\":{\"193\":1}}],[\"文件事件处理器使用io多路复用程序来同时监听多个套接字\",{\"1\":{\"193\":1}}],[\"文件传输协议\",{\"1\":{\"37\":1,\"56\":1}}],[\"文件被删除\",{\"1\":{\"15\":1}}],[\"文件有相同的\",{\"1\":{\"15\":1}}],[\"文件系统\",{\"0\":{\"14\":1}}],[\"文件类型\",{\"1\":{\"8\":1}}],[\"文件加密等\",{\"1\":{\"2\":1}}],[\"文件管理\",{\"1\":{\"2\":1}}],[\"成员变量\",{\"1\":{\"285\":1,\"405\":1}}],[\"成员包装类型不赋值就是null\",{\"1\":{\"279\":1}}],[\"成功获取锁的客户端在出现故障之后\",{\"1\":{\"209\":1}}],[\"成功获取锁的客户端在执行完业务流程之后\",{\"1\":{\"209\":1}}],[\"成功\",{\"1\":{\"205\":1}}],[\"成熟稳定\",{\"1\":{\"90\":1}}],[\"成为可选项\",{\"1\":{\"75\":1}}],[\"语言层面的的常量概念\",{\"1\":{\"476\":1}}],[\"语言通过字节码的方式\",{\"1\":{\"472\":1}}],[\"语言\",{\"1\":{\"206\":1}}],[\"语言的单继承\",{\"1\":{\"478\":1}}],[\"语言的字符串是这样的\",{\"1\":{\"184\":1}}],[\"语言的最大区别是\",{\"1\":{\"87\":1}}],[\"语言中的字符串以空字符\",{\"1\":{\"184\":1}}],[\"语言中的字符串的长度通常是经过遍历计数来实现的\",{\"1\":{\"184\":1}}],[\"语言中的字符串被修改\",{\"1\":{\"184\":1}}],[\"语言中的字符串有如下提升\",{\"1\":{\"184\":1}}],[\"语言中的字符串\",{\"1\":{\"184\":1}}],[\"语言编写的\",{\"1\":{\"184\":1}}],[\"语言开发的开源数据库\",{\"1\":{\"170\":1}}],[\"语句中\",{\"1\":{\"108\":1}}],[\"语句在经过\",{\"1\":{\"108\":1}}],[\"语句\",{\"1\":{\"95\":1,\"104\":1,\"106\":1,\"158\":1}}],[\"语句更多的被数据库管理员\",{\"1\":{\"87\":1}}],[\"语句区别\",{\"0\":{\"87\":1}}],[\"语句和\",{\"0\":{\"87\":1}}],[\"语音\",{\"1\":{\"54\":1}}],[\"子加载器才会尝试自己加载\",{\"1\":{\"497\":1}}],[\"子线程2\",{\"1\":{\"408\":2}}],[\"子线程1\",{\"1\":{\"408\":2}}],[\"子类继承父类并不一定要重写父类方法\",{\"1\":{\"296\":1}}],[\"子类能对父类进行扩展\",{\"1\":{\"295\":1}}],[\"子类拥有父类的所有属性和方法\",{\"1\":{\"295\":1}}],[\"子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等\",{\"1\":{\"289\":1}}],[\"子类方法返回值类型比父类方法返回值类型更小或者是相等\",{\"1\":{\"289\":1}}],[\"子类抛出的异常应该小于或者等于父类\",{\"1\":{\"289\":1}}],[\"子节点的名称还具有顺序性\",{\"1\":{\"210\":2}}],[\"子节点删除就意味着锁被释放\",{\"1\":{\"209\":1}}],[\"子句进行条件过滤\",{\"1\":{\"108\":1}}],[\"子句和truncate\",{\"1\":{\"86\":1}}],[\"子查询中的第一个\",{\"1\":{\"108\":1}}],[\"子查询等复杂查询\",{\"1\":{\"108\":1}}],[\"子进程写入\",{\"1\":{\"246\":1}}],[\"子进程共享主进程的物理内存区域\",{\"1\":{\"239\":1}}],[\"子进程是fork主进程得到的\",{\"1\":{\"239\":1}}],[\"子进程执行\",{\"1\":{\"239\":1}}],[\"子进程被称为\",{\"1\":{\"10\":1}}],[\"子进程已经终止\",{\"1\":{\"10\":1}}],[\"开启日志文件分割\",{\"1\":{\"507\":1}}],[\"开启用户线程\",{\"1\":{\"466\":1}}],[\"开启aof持久化后没执行一条会更改redis中的数据的命令\",{\"1\":{\"240\":1}}],[\"开启一个事务\",{\"1\":{\"95\":1}}],[\"开头的\",{\"1\":{\"143\":1}}],[\"开源免费\",{\"1\":{\"90\":1}}],[\"开始的第一位是一个\",{\"1\":{\"476\":1}}],[\"开始计数的\",{\"1\":{\"476\":1}}],[\"开始\",{\"1\":{\"86\":1,\"368\":1,\"504\":1}}],[\"开放式最短路径优先\",{\"1\":{\"39\":1}}],[\"再就是二者的回收过程不同\",{\"1\":{\"468\":1}}],[\"再清空旧region\",{\"1\":{\"467\":1}}],[\"再修改tams指针\",{\"1\":{\"467\":1}}],[\"再将修改完的副本替换原来的数据\",{\"1\":{\"412\":1}}],[\"再做处理\",{\"1\":{\"316\":1}}],[\"再把\",{\"1\":{\"175\":1}}],[\"再把数据放到cache中\",{\"1\":{\"175\":1}}],[\"再把binlog\",{\"1\":{\"151\":1}}],[\"再看一个场景\",{\"1\":{\"152\":1}}],[\"再按照b字段值进行排序\",{\"1\":{\"136\":1}}],[\"再走一遍主索引\",{\"1\":{\"127\":1}}],[\"再通过data值作为地址读取相应的数据\",{\"1\":{\"127\":1}}],[\"再遍历被驱动表与驱动表进行查询\",{\"1\":{\"108\":1}}],[\"再插入数据的时候自增长\",{\"1\":{\"86\":1}}],[\"再传输给网络层\",{\"1\":{\"64\":1}}],[\"丢弃数据\",{\"1\":{\"86\":1}}],[\"删除队尾\",{\"1\":{\"258\":1}}],[\"删除队首\",{\"1\":{\"258\":2}}],[\"删除最新命令并重启即可恢复之前的状态\",{\"1\":{\"246\":1}}],[\"删除一个或多个哈希表字段\",{\"1\":{\"220\":1}}],[\"删除一个硬链接文件并不影响其他有相同inode\",{\"1\":{\"15\":1}}],[\"删除指定的\",{\"1\":{\"214\":1}}],[\"删除\",{\"1\":{\"87\":1,\"253\":1}}],[\"删除和查询\",{\"1\":{\"87\":1}}],[\"删除某一行的数据\",{\"1\":{\"86\":1}}],[\"删除数据\",{\"1\":{\"86\":1}}],[\"删除异常的问题\",{\"1\":{\"85\":1}}],[\"→\",{\"1\":{\"84\":2,\"85\":2}}],[\"系主任\",{\"1\":{\"84\":2,\"85\":2}}],[\"系名\",{\"1\":{\"84\":3,\"85\":3}}],[\"系统变量所指定的路径下的所有类\",{\"1\":{\"494\":1}}],[\"系统会首先判断当前类是否被加载过\",{\"1\":{\"493\":1}}],[\"系统会切换到硬盘读写的中断处理程序中执行后续操作等\",{\"1\":{\"3\":1}}],[\"系统需要明确知道这个方法所处的位置\",{\"1\":{\"488\":1}}],[\"系统大部分时间用来io交互\",{\"1\":{\"392\":1}}],[\"系统占用资源\",{\"1\":{\"246\":1}}],[\"系统将写请求交给主数据库处理\",{\"1\":{\"112\":1}}],[\"系统下\",{\"1\":{\"19\":1}}],[\"系统调用来回收子进程\",{\"1\":{\"10\":1}}],[\"系统调用\",{\"1\":{\"3\":1,\"18\":1}}],[\"∩z=空集合\",{\"1\":{\"84\":1}}],[\"确保数据都写入内存并清除缓存\",{\"1\":{\"362\":1}}],[\"确定目标\",{\"0\":{\"511\":1}}],[\"确定程序语义是合法的\",{\"1\":{\"486\":1}}],[\"确定\",{\"1\":{\"84\":2}}],[\"确认\",{\"1\":{\"53\":1}}],[\"zgc\",{\"1\":{\"511\":1}}],[\"zyl\",{\"1\":{\"318\":2}}],[\"zdiffstore\",{\"1\":{\"226\":1}}],[\"zunionstore\",{\"1\":{\"226\":1}}],[\"zinterstore\",{\"1\":{\"226\":3}}],[\"ziplist\",{\"1\":{\"212\":5}}],[\"zscore\",{\"1\":{\"226\":1}}],[\"zset\",{\"1\":{\"172\":1,\"181\":1,\"212\":2}}],[\"zcard\",{\"1\":{\"226\":1}}],[\"zadd\",{\"1\":{\"226\":1}}],[\"znode\",{\"1\":{\"210\":2}}],[\"zookeeper通过临时节点解决释放锁逻辑失效问题\",{\"1\":{\"210\":1}}],[\"zookeeper\",{\"0\":{\"209\":1},\"1\":{\"209\":2,\"210\":4}}],[\"zrevrank\",{\"1\":{\"186\":1,\"226\":1,\"227\":2}}],[\"zrevrange\",{\"1\":{\"186\":1,\"226\":1,\"227\":2}}],[\"zrange\",{\"1\":{\"186\":1,\"226\":1,\"227\":2}}],[\"z\",{\"1\":{\"84\":3}}],[\"young\",{\"0\":{\"503\":1},\"1\":{\"446\":1}}],[\"y\",{\"1\":{\"84\":5}}],[\"xloggc\",{\"1\":{\"507\":1}}],[\"xmn256m\",{\"1\":{\"503\":1}}],[\"xmn<young\",{\"1\":{\"503\":1}}],[\"xmx5g\",{\"1\":{\"502\":1}}],[\"xmx<heap\",{\"1\":{\"502\":1}}],[\"xmx\",{\"0\":{\"502\":1}}],[\"xms2g\",{\"1\":{\"502\":1}}],[\"xms<heap\",{\"1\":{\"502\":1}}],[\"xms\",{\"0\":{\"502\":1}}],[\"xbootclasspath参数指定的路径下的所有类\",{\"1\":{\"494\":1}}],[\"xx\",{\"1\":{\"430\":1,\"445\":2,\"447\":2,\"469\":1,\"503\":6,\"504\":5,\"506\":4,\"507\":11,\"508\":5,\"509\":10,\"514\":2,\"515\":1,\"518\":1}}],[\"xor\",{\"1\":{\"229\":1}}],[\"x∪y\",{\"1\":{\"84\":1}}],[\"x\",{\"1\":{\"84\":5,\"104\":1,\"105\":1,\"159\":3}}],[\"设计了redlock\",{\"1\":{\"208\":1}}],[\"设置每个\",{\"1\":{\"509\":1}}],[\"设置用于\",{\"1\":{\"509\":1}}],[\"设置基于\",{\"1\":{\"509\":1}}],[\"设置\",{\"1\":{\"504\":2,\"509\":1}}],[\"设置不允许冒险\",{\"1\":{\"447\":1}}],[\"设置对象头\",{\"0\":{\"435\":1}}],[\"设置多个字段的值\",{\"1\":{\"221\":1}}],[\"设置单个字段的值\",{\"1\":{\"221\":1}}],[\"设置过期时间\",{\"1\":{\"214\":1}}],[\"设置一个或多个指定\",{\"1\":{\"214\":1}}],[\"设置指定哈希表中指定字段的值\",{\"1\":{\"220\":1}}],[\"设置指定\",{\"1\":{\"214\":1,\"229\":1}}],[\"设置时间过长\",{\"1\":{\"205\":1}}],[\"设置为0表示禁用自动重写\",{\"1\":{\"244\":1}}],[\"设置为\",{\"1\":{\"146\":3}}],[\"设\",{\"1\":{\"84\":1}}],[\"设备准备好数据\",{\"1\":{\"18\":1}}],[\"设备等等\",{\"1\":{\"8\":1}}],[\"设备管理\",{\"1\":{\"2\":1}}],[\"班级内学号不能相同\",{\"1\":{\"84\":1}}],[\"班级\",{\"1\":{\"84\":4}}],[\"完全服从\",{\"1\":{\"156\":1}}],[\"完全函数依赖\",{\"1\":{\"84\":1}}],[\"完成以下三件事情\",{\"1\":{\"485\":1}}],[\"完成\",{\"1\":{\"58\":1}}],[\"完成设备\",{\"1\":{\"2\":1}}],[\"姓名\",{\"1\":{\"84\":9,\"85\":1}}],[\"学号\",{\"1\":{\"84\":10,\"85\":2}}],[\"必选\",{\"1\":{\"507\":1}}],[\"必不可少的\",{\"1\":{\"453\":1}}],[\"必须相等\",{\"1\":{\"301\":1}}],[\"必须实现对应的方法\",{\"1\":{\"296\":1}}],[\"必须包含相同数目的黑色节点\",{\"1\":{\"126\":1}}],[\"必定能确定属性y的值\",{\"1\":{\"84\":1}}],[\"必然行为\",{\"1\":{\"40\":1}}],[\"若所有线程均在工作\",{\"1\":{\"387\":1}}],[\"若多余一个任务被提交到该线程池\",{\"1\":{\"387\":1}}],[\"若没有\",{\"1\":{\"387\":1}}],[\"若无外力作用都无法向前推进\",{\"1\":{\"346\":1}}],[\"若该记录被其他事务占用或当前版本对该事务不可见\",{\"1\":{\"163\":1}}],[\"若某个非主属性数据项依赖于全部关键字称为完全函数依赖\",{\"1\":{\"84\":1}}],[\"若在一张表中\",{\"1\":{\"84\":1}}],[\"若被指向路径文件被重新创建\",{\"1\":{\"15\":1}}],[\"非空父类的类加载器无法找到相应的类\",{\"1\":{\"497\":1}}],[\"非公平模式\",{\"1\":{\"407\":1}}],[\"非公平锁\",{\"1\":{\"376\":1}}],[\"非常适合用于作为数据共享的通道\",{\"1\":{\"410\":1}}],[\"非常适合一些数据经常变化又对数据一致性要求没那么高的场景\",{\"1\":{\"177\":1}}],[\"非常不灵活\",{\"1\":{\"321\":1}}],[\"非静态方法属于实例对象\",{\"1\":{\"288\":1}}],[\"非阻塞算法来实现线程安全\",{\"1\":{\"413\":1}}],[\"非阻塞队列可以通过\",{\"1\":{\"413\":1}}],[\"非阻塞队列的典型例子是\",{\"1\":{\"413\":1}}],[\"非阻塞\",{\"1\":{\"172\":1}}],[\"非锁定一致性读\",{\"1\":{\"164\":1}}],[\"非数字开头的字符串会转化为0\",{\"1\":{\"143\":1}}],[\"非聚簇索引也依赖于有序的数据\",{\"1\":{\"132\":1}}],[\"非聚簇索引的叶子节点不是存放数据\",{\"1\":{\"132\":1}}],[\"非聚簇索引的叶子节点并不一定存放数据的指针\",{\"1\":{\"132\":1}}],[\"非聚簇索引即索引结构和数据分开存放的索引\",{\"1\":{\"132\":1}}],[\"非聚簇索引\",{\"0\":{\"132\":1}}],[\"非聚集索引\",{\"0\":{\"132\":1},\"1\":{\"127\":1}}],[\"非主属性都依赖于主键\",{\"1\":{\"84\":1}}],[\"非幂等\",{\"1\":{\"40\":1}}],[\"展示了第一范式到第二范式的过渡\",{\"1\":{\"84\":1}}],[\"消耗在垃圾收集上的时间不得超过\",{\"1\":{\"467\":1}}],[\"消耗的内存约是\",{\"1\":{\"183\":1}}],[\"消费者模型中\",{\"1\":{\"261\":1,\"414\":1}}],[\"消除了非主属性对于码的传递函数依赖\",{\"1\":{\"85\":1}}],[\"消除了非主属性对于码的部分函数依赖\",{\"1\":{\"84\":1}}],[\"消息持久化\",{\"1\":{\"179\":1}}],[\"消息也只能被消费一次\",{\"1\":{\"179\":1}}],[\"消息不一定要以先进先出的次序读取\",{\"1\":{\"9\":1}}],[\"消息队列克服了信号承载信息量少\",{\"1\":{\"9\":1}}],[\"消息队列可以实现消息的随机查询\",{\"1\":{\"9\":1}}],[\"消息队列是消息的链表\",{\"1\":{\"9\":1}}],[\"消息队列\",{\"1\":{\"9\":1,\"179\":1,\"218\":1}}],[\"属性表集合的限制稍微宽松一些\",{\"1\":{\"481\":1}}],[\"属性表集合\",{\"0\":{\"481\":1},\"1\":{\"481\":1}}],[\"属性表集合几项\",{\"1\":{\"480\":1}}],[\"属性的初始化值\",{\"1\":{\"409\":1}}],[\"属性判断字符串是否结束\",{\"1\":{\"184\":1}}],[\"属性即可\",{\"1\":{\"184\":1}}],[\"属性检查空间大小是否满足要求\",{\"1\":{\"184\":1}}],[\"属性\",{\"1\":{\"83\":1}}],[\"属于重量级锁\",{\"1\":{\"370\":1}}],[\"属于mysql\",{\"1\":{\"149\":1}}],[\"属于innodb存储引擎\",{\"1\":{\"149\":1}}],[\"属于单个行记录上的锁\",{\"1\":{\"103\":1}}],[\"属于网络层的协议\",{\"1\":{\"39\":1,\"73\":1}}],[\"属于同步阻塞\",{\"1\":{\"21\":1}}],[\"典型值为\",{\"1\":{\"79\":1}}],[\"三者的异同\",{\"0\":{\"257\":1}}],[\"三元组的形式存储\",{\"1\":{\"79\":1}}],[\"三次握手就能确认双方收发功能都正常\",{\"1\":{\"59\":1}}],[\"三次握手的目的是建立可靠的通信信道\",{\"1\":{\"59\":1}}],[\"三次握手的延迟\",{\"1\":{\"55\":1}}],[\"三次握手\",{\"1\":{\"58\":2}}],[\"三次握手和四次挥手\",{\"0\":{\"57\":1}}],[\"三次握手过程\",{\"1\":{\"55\":1}}],[\"全屏障\",{\"1\":{\"362\":1}}],[\"全文索引主要为了检索大文本数据中的关键字信息\",{\"1\":{\"129\":1}}],[\"全文索引\",{\"1\":{\"129\":1}}],[\"全表扫描\",{\"1\":{\"108\":1}}],[\"全称多路平衡查找树\",{\"1\":{\"127\":1}}],[\"全称\",{\"1\":{\"79\":1}}],[\"全\",{\"1\":{\"78\":1}}],[\"身份认证和权限相关\",{\"1\":{\"91\":1}}],[\"身份证号\",{\"1\":{\"84\":4}}],[\"身份证号永久地标识一个人的身份\",{\"1\":{\"78\":1}}],[\"身披\",{\"1\":{\"56\":1}}],[\"物理地址\",{\"1\":{\"78\":1}}],[\"物理上的下一个目的地\",{\"1\":{\"39\":1,\"79\":1}}],[\"他们会随着竞争的激烈而逐渐升级\",{\"1\":{\"397\":1}}],[\"他们都是不安全的\",{\"1\":{\"40\":1}}],[\"他的身份证号才是他的\",{\"1\":{\"78\":1}}],[\"媒体访问控制地址\",{\"1\":{\"78\":1}}],[\"映射为公有\",{\"1\":{\"76\":1}}],[\"路径\",{\"1\":{\"75\":1}}],[\"路由信息协议\",{\"1\":{\"39\":1}}],[\"源ip地址用于标识数据包的发送来源\",{\"1\":{\"74\":1}}],[\"主版本号是否在当前虚拟机的处理范围内\",{\"1\":{\"486\":1}}],[\"主版本号都会加1\",{\"1\":{\"475\":1}}],[\"主线程\",{\"1\":{\"408\":2}}],[\"主线程继续工作\",{\"1\":{\"408\":1}}],[\"主线程调用\",{\"1\":{\"242\":3}}],[\"主内存\",{\"1\":{\"356\":1}}],[\"主动放出已经保持的资源\",{\"1\":{\"347\":1}}],[\"主进程执行写的时候\",{\"1\":{\"239\":1}}],[\"主进程进行读的时候\",{\"1\":{\"239\":1}}],[\"主节点依然可以获取锁\",{\"1\":{\"208\":1}}],[\"主节点宕机了\",{\"1\":{\"208\":1}}],[\"主节点获取到锁后\",{\"1\":{\"208\":1}}],[\"主节点写\",{\"1\":{\"110\":1}}],[\"主主\",{\"1\":{\"149\":1,\"154\":1}}],[\"主备\",{\"1\":{\"149\":1,\"154\":1}}],[\"主键索引\",{\"0\":{\"128\":1}}],[\"主库会创建一个\",{\"1\":{\"113\":1}}],[\"主库将数据库中数据的变化写入到\",{\"1\":{\"113\":1}}],[\"主从都离不开binlog\",{\"1\":{\"149\":1,\"154\":1}}],[\"主从复制的原理是什么\",{\"0\":{\"113\":1}}],[\"主从同步延迟\",{\"1\":{\"111\":1}}],[\"主机可以直接通过根据接口标识和网络前缀生成全局唯一的\",{\"1\":{\"75\":1}}],[\"主作用是定义数据包的格式\",{\"1\":{\"73\":1}}],[\"主要负责加载\",{\"1\":{\"494\":1}}],[\"主要负责数据的存储和读取\",{\"1\":{\"91\":1}}],[\"主要目的是保证输入的字节流能正确的解析并存储于方法区内\",{\"1\":{\"486\":1}}],[\"主要目的是为了避免字符串的重复创建\",{\"1\":{\"430\":1}}],[\"主要目的是为了简化编程\",{\"1\":{\"355\":1}}],[\"主要目的是为了解决幻读问题\",{\"1\":{\"103\":1,\"166\":1}}],[\"主要针对配备多颗处理器及大容量内存的机器\",{\"1\":{\"467\":1}}],[\"主要服务一个方法需要调用其他方法的场景\",{\"1\":{\"424\":1}}],[\"主要作为方法调用的中转站使用\",{\"1\":{\"424\":1}}],[\"主要作用是定义数据包的格式\",{\"1\":{\"39\":1}}],[\"主要存放了编译期可知的各种数据类型\",{\"1\":{\"424\":1}}],[\"主要使用\",{\"1\":{\"413\":1}}],[\"主要用来加载\",{\"1\":{\"494\":1}}],[\"主要用来构建锁和同步器\",{\"1\":{\"403\":1}}],[\"主要用在一些需要执行耗时任务的场景\",{\"1\":{\"394\":1}}],[\"主要用于存储地理位置信息\",{\"1\":{\"234\":1}}],[\"主要用于区分普通查询\",{\"1\":{\"108\":1}}],[\"主要用于在不同网络之间转换\",{\"1\":{\"76\":1}}],[\"主要解决的是多个线程之间访问资源的同步性\",{\"1\":{\"370\":1}}],[\"主要逻辑是单线程完成的\",{\"1\":{\"197\":1}}],[\"主要在于内存和网络\",{\"1\":{\"195\":1}}],[\"主要需要用到下面这两个命令\",{\"1\":{\"190\":1}}],[\"主要是磁盘io资源\",{\"1\":{\"246\":1}}],[\"主要是单线程事件循环和\",{\"1\":{\"171\":1}}],[\"主要是为\",{\"1\":{\"37\":1,\"56\":1}}],[\"主要有两个作用\",{\"1\":{\"163\":1}}],[\"主要有以下字段\",{\"1\":{\"162\":1}}],[\"主要有下面两种情况\",{\"1\":{\"156\":1}}],[\"主要分为\",{\"1\":{\"91\":1}}],[\"主要包括表记录的插入\",{\"1\":{\"87\":1}}],[\"主要包含下面几部分的内容\",{\"1\":{\"8\":1}}],[\"凡是接收窗口中的序号都接收并返回确认帧\",{\"1\":{\"70\":1}}],[\"凡位于发送窗口内的分组可以连续发送出去\",{\"1\":{\"69\":1}}],[\"表长时扩容\",{\"1\":{\"264\":1}}],[\"表明锁被释放\",{\"1\":{\"372\":1}}],[\"表明查询使用了\",{\"1\":{\"108\":1}}],[\"表明查询使用了覆盖索引\",{\"1\":{\"108\":1}}],[\"表明到这个分组为止的所有分组都已经正确收到了\",{\"1\":{\"69\":1}}],[\"表示要写入文件的路径\",{\"1\":{\"508\":1}}],[\"表示方法表\",{\"1\":{\"480\":1}}],[\"表示方法的数量\",{\"1\":{\"480\":1}}],[\"表示阻塞队列\",{\"1\":{\"410\":1}}],[\"表示这是这一代最后一个线程到达栅栏\",{\"1\":{\"409\":1}}],[\"表示同步状态\",{\"1\":{\"405\":1}}],[\"表示线程运行完毕\",{\"1\":{\"344\":1}}],[\"表示一个对象具有多种状态\",{\"1\":{\"295\":1}}],[\"表示最后一次插入或更新该行的事务\",{\"1\":{\"161\":1}}],[\"表示每次提交事务都write\",{\"1\":{\"151\":1}}],[\"表示每次提交事务都会执行fsync\",{\"1\":{\"151\":1}}],[\"表示每次提交事务都只write\",{\"1\":{\"151\":1}}],[\"表示每次事务提交时都只把\",{\"1\":{\"146\":1}}],[\"表示每次事务提交时都将进行刷盘操作\",{\"1\":{\"146\":1}}],[\"表示每次事务提交时不进行刷盘操作\",{\"1\":{\"146\":1}}],[\"表示日志文件组满了\",{\"1\":{\"147\":1}}],[\"表示当被驱动表的没有使用索引的时候\",{\"1\":{\"108\":1}}],[\"表示查询优化器选择使用了索引条件下推这个特性\",{\"1\":{\"108\":1}}],[\"表示开启了\",{\"1\":{\"108\":1}}],[\"表示接收到了断开连接的请求\",{\"1\":{\"61\":1}}],[\"表中最多只有一行匹配的记录\",{\"1\":{\"108\":1}}],[\"表级锁\",{\"1\":{\"102\":1}}],[\"表级锁和行级锁对比\",{\"1\":{\"102\":1}}],[\"表级锁和行级锁了解吗\",{\"0\":{\"102\":1}}],[\"表名作用类似\",{\"1\":{\"86\":1}}],[\"表名\",{\"1\":{\"86\":3,\"108\":1}}],[\"表记录了某些其他网络设备的\",{\"1\":{\"79\":1}}],[\"表\",{\"1\":{\"79\":1}}],[\"连cas操作都不做了\",{\"1\":{\"402\":1}}],[\"连表查询的方式\",{\"1\":{\"108\":1}}],[\"连续\",{\"1\":{\"69\":1}}],[\"连接应答处理器\",{\"1\":{\"194\":1}}],[\"连接器\",{\"1\":{\"91\":1}}],[\"连接的每一方都有固定大小的缓冲空间\",{\"1\":{\"64\":1}}],[\"连接上的所有流被阻塞\",{\"1\":{\"55\":1}}],[\"连接上使用了多路复用\",{\"1\":{\"55\":1}}],[\"连接传输的数据\",{\"1\":{\"53\":1}}],[\"连接方式\",{\"1\":{\"46\":1}}],[\"连接结束\",{\"1\":{\"43\":1}}],[\"连接\",{\"1\":{\"2\":1,\"43\":1}}],[\"自定义加载器的话\",{\"1\":{\"499\":1}}],[\"自定义类加载器\",{\"0\":{\"495\":1}}],[\"自身的一部分之外\",{\"1\":{\"494\":1}}],[\"自然受到方法区内存的限制\",{\"1\":{\"429\":1}}],[\"自旋\",{\"1\":{\"398\":1}}],[\"自旋锁重试次数是固定的\",{\"1\":{\"398\":1}}],[\"自旋锁与自适应自旋\",{\"0\":{\"398\":1}}],[\"自旋锁\",{\"1\":{\"207\":1}}],[\"自平衡的排序二叉树\",{\"1\":{\"251\":1}}],[\"自动拆装箱\",{\"0\":{\"281\":1}}],[\"自动续期机制\",{\"1\":{\"206\":3}}],[\"自动重传请求\",{\"1\":{\"68\":1}}],[\"自带了给缓存数据设置过期时间的功能\",{\"1\":{\"199\":1}}],[\"自带的\",{\"1\":{\"179\":1,\"490\":1}}],[\"自己发送\",{\"1\":{\"59\":3}}],[\"自己接收正常\",{\"1\":{\"59\":2}}],[\"其余的类加载器都应有自己的父类加载器\",{\"1\":{\"496\":1}}],[\"其余的三个验证阶段都是基于方法区的存储结构上进行\",{\"1\":{\"486\":1}}],[\"其余的意向锁和共享或者排他锁都互斥\",{\"1\":{\"105\":1}}],[\"其余行为\",{\"1\":{\"462\":1}}],[\"其并发控制采用可重入锁\",{\"1\":{\"415\":1}}],[\"其实准确分类只有两大种\",{\"1\":{\"446\":1}}],[\"其实使用了tryreleaseshared方法以\",{\"1\":{\"408\":1}}],[\"其实已经修改了两次\",{\"1\":{\"367\":1}}],[\"其实就是链表数据结构的实现\",{\"1\":{\"216\":1}}],[\"其与\",{\"1\":{\"260\":1}}],[\"其它和\",{\"1\":{\"226\":2}}],[\"其它事务也可以加s\",{\"1\":{\"159\":1}}],[\"其底层实现主要依赖这\",{\"1\":{\"212\":1}}],[\"其内置了多种类型的锁比如可重入锁\",{\"1\":{\"207\":1}}],[\"其提供了一个专门用来监控和续期锁的\",{\"1\":{\"206\":1}}],[\"其本质可以看成是一种排序好的数据结构\",{\"1\":{\"121\":1}}],[\"其他类加载器均由\",{\"1\":{\"495\":1}}],[\"其他所有的类加载器都是在\",{\"1\":{\"494\":1}}],[\"其他阻塞的线程才能获取到\",{\"1\":{\"407\":1}}],[\"其他线程都会阻塞\",{\"1\":{\"407\":1}}],[\"其他线程可以尝试获取锁\",{\"1\":{\"372\":1}}],[\"其他的诸如\",{\"1\":{\"403\":1}}],[\"其他的一台或者多台作为从数据库\",{\"1\":{\"112\":1}}],[\"其他\",{\"0\":{\"509\":1},\"1\":{\"328\":1}}],[\"其他命令都会被阻塞\",{\"1\":{\"239\":1}}],[\"其他方法都需要依靠expire命令来设置过期时间\",{\"1\":{\"199\":1}}],[\"其他节点只存放key\",{\"1\":{\"127\":1}}],[\"其他不互斥\",{\"1\":{\"104\":1}}],[\"其他都一样\",{\"1\":{\"40\":1}}],[\"其查询结果也不会被缓存\",{\"1\":{\"94\":1}}],[\"其表数据文件本身就是按b+tree阻止的一个索引结构\",{\"1\":{\"93\":1}}],[\"其数据文件本身就是索引文件\",{\"1\":{\"93\":1}}],[\"其中连接过程分为\",{\"1\":{\"483\":1}}],[\"其中阻塞队列的典型例子是\",{\"1\":{\"413\":1}}],[\"其中的method就是反射类\",{\"1\":{\"316\":1}}],[\"其中编译的是热点代码\",{\"1\":{\"276\":1}}],[\"其中\",{\"1\":{\"79\":1,\"372\":2,\"483\":1}}],[\"其重传时间应比数据在分组传输的平均往返时间更长一些\",{\"1\":{\"68\":1}}],[\"认为是线程私有的\",{\"1\":{\"399\":1}}],[\"认为共享资源总是会被其他线程修改了\",{\"1\":{\"365\":1}}],[\"认为刚才发送过的分组丢失了\",{\"1\":{\"68\":1}}],[\"认为最适合发送的数据块\",{\"1\":{\"64\":1}}],[\"快速列表\",{\"1\":{\"212\":1}}],[\"快速创建秒杀单之后写回数据库使用消息队列\",{\"1\":{\"179\":1}}],[\"快照可以进行数据库备份\",{\"1\":{\"246\":1}}],[\"快照持久化是redis默认采用的持久化方式\",{\"1\":{\"238\":1}}],[\"快照即记录的历史版本\",{\"1\":{\"106\":1}}],[\"快照读的方式读取数据\",{\"1\":{\"166\":1}}],[\"快照读的情况下\",{\"1\":{\"106\":1}}],[\"快照读总是读取本事务开始时的行数据版本\",{\"1\":{\"106\":1}}],[\"快照读总是读取被锁定行的最新一份快照数据\",{\"1\":{\"106\":1}}],[\"快照读\",{\"1\":{\"106\":1,\"156\":1}}],[\"快照读和当前读的区别\",{\"0\":{\"106\":1}}],[\"快恢复\",{\"1\":{\"66\":1}}],[\"快重传\",{\"1\":{\"66\":1}}],[\"快重传与快恢复\",{\"1\":{\"66\":1}}],[\"快捷方式\",{\"1\":{\"15\":1}}],[\"缓刑\",{\"1\":{\"452\":1}}],[\"缓存\",{\"1\":{\"215\":1}}],[\"缓存相同数量的对象数据\",{\"1\":{\"183\":1}}],[\"缓存失效\",{\"1\":{\"175\":1}}],[\"缓存之后很容易达到\",{\"1\":{\"173\":1}}],[\"缓存虽然能提升数据库的查询能力\",{\"1\":{\"94\":1}}],[\"缓存建立之后\",{\"1\":{\"94\":1}}],[\"缓存机制\",{\"1\":{\"46\":1}}],[\"缓慢增大\",{\"1\":{\"66\":1}}],[\"加快fork速度\",{\"1\":{\"239\":1}}],[\"加载过了会直接返回\",{\"1\":{\"497\":1}}],[\"加载指定二进制名称的类\",{\"1\":{\"495\":1}}],[\"加载的呢\",{\"1\":{\"494\":1}}],[\"加载的\",{\"1\":{\"494\":1}}],[\"加载的类是不会被卸载的\",{\"1\":{\"490\":1}}],[\"加载这一步通过类加载器完成的\",{\"1\":{\"485\":1}}],[\"加载该类的\",{\"1\":{\"455\":1}}],[\"加载\",{\"0\":{\"485\":1},\"1\":{\"176\":1,\"483\":3}}],[\"加载日志文件组恢复数据时\",{\"1\":{\"147\":1}}],[\"加排他锁之前必须先取得该表的\",{\"1\":{\"105\":1}}],[\"加共享锁前必须先取得该表的\",{\"1\":{\"105\":1}}],[\"加锁的锁名\",{\"1\":{\"205\":1}}],[\"加锁慢\",{\"1\":{\"102\":1}}],[\"加锁粒度最小\",{\"1\":{\"102\":1}}],[\"加\",{\"1\":{\"66\":1}}],[\"加倍\",{\"1\":{\"66\":1}}],[\"加密采用对称加密\",{\"1\":{\"45\":1}}],[\"每当一个类加载器接收到加载请求的时候\",{\"1\":{\"497\":1}}],[\"每当一个线程到了栅栏这里了\",{\"1\":{\"409\":1}}],[\"每当java发布大版本的时候\",{\"1\":{\"475\":1}}],[\"每上面一层链表都是下面一层的子集\",{\"1\":{\"418\":1}}],[\"每一次方法调用都会有一个对应的栈帧被压入栈中\",{\"1\":{\"424\":1}}],[\"每一个java类都有一个引用指向加载它的classloader\",{\"1\":{\"492\":1}}],[\"每一个region都可以根据需要扮演eden空间\",{\"1\":{\"467\":1}}],[\"每一个方法调用结束后\",{\"1\":{\"424\":1}}],[\"每一个object都有对象锁\",{\"1\":{\"350\":1}}],[\"每一个线程都有一个tlab\",{\"1\":{\"433\":1}}],[\"每一个线程都需要一个程序计数器\",{\"1\":{\"423\":1}}],[\"每一个线程拥有自己的虚拟机栈\",{\"1\":{\"340\":1}}],[\"每一个线程有自己的程序计数器\",{\"1\":{\"339\":1}}],[\"每一个线程共享进程的堆和方法区\",{\"1\":{\"339\":1}}],[\"每一把锁锁住一个segment\",{\"1\":{\"271\":1}}],[\"每月访问\",{\"1\":{\"233\":1}}],[\"每周\",{\"1\":{\"233\":1}}],[\"每过\",{\"1\":{\"206\":1}}],[\"每隔一段时间抽取一批key执行删除过期key操作\",{\"1\":{\"200\":1}}],[\"每隔1\",{\"1\":{\"146\":1}}],[\"每次根据允许的收集时间\",{\"1\":{\"467\":1}}],[\"每次收集都有大量对象死去\",{\"1\":{\"459\":1}}],[\"每次使用其中的一块\",{\"1\":{\"458\":1}}],[\"每次使用它都到主存中进行读取\",{\"1\":{\"361\":1}}],[\"每次对string类型进行修改的时候\",{\"1\":{\"303\":1}}],[\"每次扩容变为原来的两倍\",{\"1\":{\"264\":1}}],[\"每次都需要重新分配内存\",{\"1\":{\"184\":1}}],[\"每次select\",{\"1\":{\"164\":1}}],[\"每次读取的都是最新数据\",{\"1\":{\"159\":1}}],[\"每次变更都需要先修改buffer\",{\"1\":{\"148\":1}}],[\"每次\",{\"1\":{\"147\":1}}],[\"每次刷盘\",{\"1\":{\"147\":1}}],[\"每次磁盘io只能读取一个节点的数据\",{\"1\":{\"125\":1}}],[\"每次查询后都要做一次缓存操作\",{\"1\":{\"94\":1}}],[\"每行记录可能存在多个历史版本\",{\"1\":{\"106\":1}}],[\"每经过一个传播轮次\",{\"1\":{\"66\":1}}],[\"每个文件上限大小\",{\"1\":{\"507\":1}}],[\"每个文件的大小是\",{\"1\":{\"147\":1}}],[\"每个thread中都具备一个threadlocalmap\",{\"1\":{\"382\":1}}],[\"每个线程都有私有的本地内存来存储共享变量的副本\",{\"1\":{\"356\":1}}],[\"每个数据节点在\",{\"1\":{\"210\":1}}],[\"每个事务读到的数据版本可能是不一样的\",{\"1\":{\"153\":1,\"160\":1}}],[\"每个的redo日志文件大小都是一样的\",{\"1\":{\"147\":1}}],[\"每个叶子节点都是黑色的空节点\",{\"1\":{\"126\":1}}],[\"每个节点不是红色就是黑色\",{\"1\":{\"126\":1}}],[\"每个树节点仅存储一个数据\",{\"1\":{\"125\":1}}],[\"每个库可以位于不同的数据库上\",{\"1\":{\"115\":1}}],[\"每个网络设备都自己维护了一个\",{\"1\":{\"79\":1}}],[\"每个连入互联网的设备或域都被分配一个ip地址\",{\"1\":{\"74\":1}}],[\"每个\",{\"1\":{\"50\":1,\"474\":1,\"494\":1,\"496\":1}}],[\"每个进程都对应着一个独立的\",{\"1\":{\"8\":1}}],[\"较好的方法是先探测一下\",{\"1\":{\"66\":1}}],[\"减少内存复制开销\",{\"1\":{\"469\":1}}],[\"减少内存分配次数\",{\"1\":{\"184\":1}}],[\"减少传统的重量级锁使用操作系统互斥量产生的性能消耗\",{\"1\":{\"401\":1}}],[\"减少\",{\"1\":{\"184\":1}}],[\"减少回表次数\",{\"1\":{\"137\":1}}],[\"减少了处理开销\",{\"1\":{\"75\":1}}],[\"减少了对cpu资源的消耗\",{\"1\":{\"22\":1}}],[\"减少数据的发送\",{\"1\":{\"64\":1}}],[\"能让使用者明确指定在一个长度为\",{\"1\":{\"467\":1}}],[\"能充分利用\",{\"1\":{\"467\":1}}],[\"能轻易实现交集\",{\"1\":{\"222\":1}}],[\"能够在后台自动重写\",{\"1\":{\"246\":1}}],[\"能够唯一标示锁的随机字符串\",{\"1\":{\"205\":1}}],[\"能够提供更高的安全性和用户隐私保护\",{\"1\":{\"45\":1}}],[\"能提示发送方降低发送的速率\",{\"1\":{\"64\":1}}],[\"超时\",{\"1\":{\"375\":1}}],[\"超时后线程会自动苏醒\",{\"1\":{\"349\":1}}],[\"超时等待状态\",{\"1\":{\"344\":1}}],[\"超时重传\",{\"1\":{\"64\":1}}],[\"超过就触发分割\",{\"1\":{\"507\":1}}],[\"超过之后从头文件开始写\",{\"1\":{\"507\":1}}],[\"超过这个值将会抛出\",{\"1\":{\"504\":1}}],[\"超过这个数就直接放入老年代\",{\"1\":{\"469\":1}}],[\"超过long\",{\"0\":{\"284\":1}}],[\"超过容量之后触发扩容\",{\"1\":{\"253\":1}}],[\"超过该时间\",{\"1\":{\"79\":1}}],[\"超文本传输协议\",{\"1\":{\"37\":1,\"56\":1}}],[\"目录下的\",{\"1\":{\"494\":1}}],[\"目的是保证对于提交的任务\",{\"1\":{\"390\":1}}],[\"目的是检测数据在传输过程中的任何变化\",{\"1\":{\"64\":1}}],[\"目的主要是简化多线程编程\",{\"1\":{\"357\":1}}],[\"目的ip地址用来表示数据包的接收方设备地址\",{\"1\":{\"74\":1}}],[\"目前是原生支持\",{\"1\":{\"172\":1}}],[\"目前出现过的最大的事务\",{\"1\":{\"162\":1}}],[\"目前主要包括\",{\"1\":{\"91\":1}}],[\"目前世界上只有\",{\"1\":{\"50\":1}}],[\"目前这两种协议都在使用\",{\"1\":{\"39\":1}}],[\"目前\",{\"1\":{\"39\":1}}],[\"将老年代内存预设调大1\",{\"1\":{\"515\":1}}],[\"将附加到文件名中\",{\"1\":{\"508\":1}}],[\"将搜索类或资源的任务委托给其父类加载器\",{\"1\":{\"496\":2}}],[\"将字节流所代表的静态存储结构转化为方法区的运行时数据结构\",{\"1\":{\"485\":1}}],[\"将字符串对象\",{\"1\":{\"307\":1}}],[\"将第\",{\"1\":{\"476\":1}}],[\"将计数器\",{\"1\":{\"449\":1}}],[\"将尝试进行一次\",{\"1\":{\"447\":1}}],[\"将被移动到\",{\"1\":{\"445\":1}}],[\"将被标记为\",{\"1\":{\"108\":1}}],[\"将用过的内存整理到一边\",{\"1\":{\"433\":1}}],[\"将修改的内容写入副本\",{\"1\":{\"412\":1}}],[\"将每条请求共享资源的线程封装成一个\",{\"1\":{\"405\":1}}],[\"将返回线程池进行复用\",{\"1\":{\"387\":1}}],[\"将需要存储的值放入到这个哈希表中\",{\"1\":{\"382\":1}}],[\"将锁计数器设为\",{\"1\":{\"372\":1}}],[\"将锁的超时时间设置为\",{\"1\":{\"206\":1}}],[\"将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程\",{\"1\":{\"313\":1}}],[\"将数组的第一个元素变为0\",{\"1\":{\"312\":1}}],[\"将数据结构或对象转换成二进制字节流的过程\",{\"1\":{\"313\":1}}],[\"将数据\",{\"1\":{\"175\":1}}],[\"将原本对象内部的所有属性都单独复制一份\",{\"1\":{\"297\":1}}],[\"将链表转化为红黑树\",{\"1\":{\"268\":1}}],[\"将aof缓冲区的数据写入到aof文件中\",{\"1\":{\"241\":1}}],[\"将多个\",{\"1\":{\"232\":1}}],[\"将给定所有有序集合的交集存储在\",{\"1\":{\"226\":1}}],[\"将给定所有集合的差集存储在\",{\"1\":{\"223\":1}}],[\"将给定所有集合的并集存储在\",{\"1\":{\"223\":1}}],[\"将给定所有集合的交集存储在\",{\"1\":{\"223\":1}}],[\"将其所有粉丝存在一个集合\",{\"1\":{\"222\":1}}],[\"将其降级为\",{\"1\":{\"103\":1}}],[\"将指定列表索引\",{\"1\":{\"217\":1}}],[\"将\",{\"1\":{\"214\":2,\"244\":1}}],[\"将state值变为0\",{\"1\":{\"408\":1}}],[\"将state值\",{\"1\":{\"408\":2}}],[\"将socket关联到相应的事件处理器\",{\"1\":{\"194\":1}}],[\"将sync\",{\"1\":{\"151\":1}}],[\"将访问指定页面的每个用户\",{\"1\":{\"190\":1}}],[\"将热点数据提前放入cache中\",{\"1\":{\"175\":1}}],[\"将当前未提交事务\",{\"1\":{\"162\":1}}],[\"将当前可见的版本号与对应记录的版本号进行比对\",{\"1\":{\"158\":1}}],[\"将redo\",{\"1\":{\"152\":1}}],[\"将会自动创建一个\",{\"1\":{\"128\":1}}],[\"将丢弃这个报文段和不确认收到此报文段\",{\"1\":{\"64\":1}}],[\"将保持它首部和数据的检验和\",{\"1\":{\"64\":1}}],[\"将弃用\",{\"1\":{\"55\":1}}],[\"防止内存溢出\",{\"1\":{\"453\":1}}],[\"防止其他线程修改\",{\"1\":{\"365\":1}}],[\"防止其它事务在查询范围内插入数据\",{\"1\":{\"166\":1}}],[\"防止当前系统进入不安全状态\",{\"1\":{\"348\":1}}],[\"防止了部分幻读\",{\"1\":{\"159\":1}}],[\"防止包丢失\",{\"1\":{\"64\":1}}],[\"防止\",{\"1\":{\"62\":1}}],[\"防止恶意构造长\",{\"1\":{\"40\":1}}],[\"断开服务器到客户端的数据传送\",{\"1\":{\"61\":1}}],[\"断开连接\",{\"0\":{\"60\":1}}],[\"后\",{\"1\":{\"509\":1}}],[\"后的接口顺序从左到右排列在接口索引集合中\",{\"1\":{\"478\":1}}],[\"后仍然能够存活\",{\"1\":{\"445\":1}}],[\"后继节点\",{\"1\":{\"405\":1}}],[\"后申请的线程可能会先获取到锁\",{\"1\":{\"376\":1}}],[\"后过期\",{\"1\":{\"199\":2}}],[\"后台线程每秒调用fsync保存aof文件\",{\"1\":{\"242\":1}}],[\"后台线程调用fsync保存aof文件到磁盘\",{\"1\":{\"242\":1}}],[\"后台线程调用\",{\"1\":{\"197\":1}}],[\"后台线程来释放\",{\"1\":{\"197\":1}}],[\"后返回响应\",{\"1\":{\"176\":1}}],[\"后删除\",{\"1\":{\"175\":1}}],[\"后更新\",{\"1\":{\"175\":1}}],[\"后续复用这个read\",{\"1\":{\"165\":1}}],[\"后续即使它们修改了记录行的值\",{\"1\":{\"162\":1}}],[\"后续的查找都是从buffer\",{\"1\":{\"145\":1}}],[\"后移更新\",{\"1\":{\"147\":1}}],[\"后退n帧协议\",{\"0\":{\"69\":1}}],[\"后依然没有收到回复\",{\"1\":{\"60\":1}}],[\"后面\",{\"1\":{\"40\":1}}],[\"接口方法\",{\"1\":{\"488\":1}}],[\"接口方法符号\",{\"1\":{\"429\":1}}],[\"接口索引集合用来描述这个类实现了那些接口\",{\"1\":{\"478\":1}}],[\"接口等描述信息\",{\"1\":{\"429\":1}}],[\"接口的有界队列实现类\",{\"1\":{\"415\":1}}],[\"接口的基本实现\",{\"1\":{\"395\":1}}],[\"接口的实现类\",{\"1\":{\"257\":1}}],[\"接口中的成员变量只能是public\",{\"1\":{\"296\":1}}],[\"接口强调行为的约束\",{\"1\":{\"296\":1}}],[\"接口和抽象类的共同点\",{\"0\":{\"296\":1}}],[\"接口让\",{\"1\":{\"265\":1}}],[\"接口\",{\"0\":{\"478\":1},\"1\":{\"265\":1,\"375\":1,\"478\":1}}],[\"接收窗口>1\",{\"1\":{\"70\":1}}],[\"接收窗口每收到一个序号就会发送一个确认帧\",{\"1\":{\"69\":1}}],[\"接收窗口=1\",{\"1\":{\"69\":1}}],[\"接收方一般采用累计确认\",{\"1\":{\"69\":1}}],[\"接收端实体对已成功收到的包发回一个相应的确认信息\",{\"1\":{\"64\":1}}],[\"接收正常\",{\"1\":{\"59\":6}}],[\"接受了\",{\"1\":{\"44\":1}}],[\"第\",{\"1\":{\"475\":2}}],[\"第二范式在第一范式的基础上增加了一个列\",{\"1\":{\"84\":1}}],[\"第二次挥手\",{\"1\":{\"60\":1}}],[\"第二次握手\",{\"1\":{\"59\":1}}],[\"第四次挥手时\",{\"1\":{\"62\":1}}],[\"第四次挥手\",{\"1\":{\"60\":1}}],[\"第三次挥手\",{\"1\":{\"60\":1}}],[\"第三次握手\",{\"1\":{\"59\":1}}],[\"第一次select\",{\"1\":{\"164\":1}}],[\"第一次挥手\",{\"1\":{\"60\":1}}],[\"第一次握手\",{\"1\":{\"59\":1}}],[\">验证\",{\"1\":{\"483\":1}}],[\">解析\",{\"1\":{\"483\":2}}],[\">准备\",{\"1\":{\"483\":2}}],[\">初始化\",{\"1\":{\"483\":2}}],[\">连接\",{\"1\":{\"483\":1}}],[\">survivor\",{\"1\":{\"445\":1}}],[\">>>\",{\"1\":{\"267\":2}}],[\">>\",{\"1\":{\"253\":1}}],[\">请求\",{\"1\":{\"175\":1}}],[\">=\",{\"1\":{\"136\":1,\"260\":2,\"407\":1}}],[\">redo\",{\"1\":{\"91\":1,\"146\":2}}],[\">binlog\",{\"1\":{\"91\":1}}],[\">引擎\",{\"1\":{\"91\":2}}],[\">执行器\",{\"1\":{\"91\":2}}],[\">权限校验\",{\"1\":{\"91\":2}}],[\">优化器\",{\"1\":{\"91\":1}}],[\">分析器\",{\"1\":{\"91\":1}}],[\">查询缓存\",{\"1\":{\"91\":1}}],[\">y\",{\"1\":{\"84\":3}}],[\">客户端请求关闭连接\",{\"1\":{\"60\":1}}],[\">客户端\",{\"1\":{\"60\":1}}],[\">服务端并且进入time\",{\"1\":{\"60\":1}}],[\">服务端\",{\"1\":{\"60\":1}}],[\">\",{\"1\":{\"58\":3,\"84\":6,\"108\":11,\"175\":3,\"189\":7,\"204\":3,\"323\":1,\"396\":4,\"495\":1,\"497\":1,\"508\":2}}],[\">用户空间\",{\"1\":{\"22\":1}}],[\"建议同时开启\",{\"1\":{\"246\":1}}],[\"建议使用\",{\"1\":{\"204\":1}}],[\"建议单张表索引不超过\",{\"1\":{\"141\":1}}],[\"建议在传输敏感数据时使用更安全的协议\",{\"1\":{\"37\":1,\"56\":1}}],[\"建立大顶堆\",{\"1\":{\"260\":1}}],[\"建立唯一索引的目的大部分都是为了属性列的数据唯一性\",{\"1\":{\"129\":1}}],[\"建立连接\",{\"0\":{\"58\":1}}],[\"建立在可靠的传输协议\",{\"1\":{\"56\":1}}],[\"利用滑动窗口实现流量控制\",{\"1\":{\"64\":1,\"65\":1}}],[\"利用\",{\"1\":{\"56\":1,\"182\":1,\"215\":1}}],[\"零往返时间\",{\"1\":{\"55\":1}}],[\"个阶段\",{\"1\":{\"483\":1}}],[\"个字节称为魔数\",{\"1\":{\"474\":1}}],[\"个条件的无用类进行回收\",{\"1\":{\"455\":1}}],[\"个条件才能算是\",{\"1\":{\"455\":1}}],[\"个线程阻塞在一个地方\",{\"1\":{\"408\":1}}],[\"个线程能获取到共享资源\",{\"1\":{\"407\":1}}],[\"个线程中只有\",{\"1\":{\"407\":1}}],[\"个线程来获取\",{\"1\":{\"407\":1}}],[\"个最重要的参数\",{\"1\":{\"388\":1}}],[\"个\",{\"1\":{\"55\":2,\"141\":1,\"228\":1}}],[\"另一种用途是作为\",{\"1\":{\"464\":1}}],[\"另一种是较新的\",{\"1\":{\"39\":1}}],[\"另一个比较常用的与之对应的方法是\",{\"1\":{\"407\":1}}],[\"另一个作用是\",{\"1\":{\"163\":1}}],[\"另外一部分是类型指针\",{\"1\":{\"437\":1}}],[\"另外如果对于某个锁自旋很少成功获得\",{\"1\":{\"398\":1}}],[\"另外是new在堆中创建的对象\",{\"1\":{\"306\":1}}],[\"另外在停止等待协议中若收到重复分组\",{\"1\":{\"68\":1}}],[\"另外\",{\"1\":{\"55\":1,\"146\":1,\"435\":1,\"496\":1}}],[\"受到\",{\"1\":{\"55\":1}}],[\"此参数默认用于\",{\"1\":{\"509\":1}}],[\"此类的属性表中的属性数\",{\"1\":{\"481\":1}}],[\"此内存区域的唯一目的就是存放对象实例\",{\"1\":{\"427\":1}}],[\"此策略将丢弃最早的未处理的任务请求\",{\"1\":{\"389\":1}}],[\"此外\",{\"1\":{\"161\":1}}],[\"此时与用户线程并发执行\",{\"1\":{\"470\":1}}],[\"此时才会将栅栏放开\",{\"1\":{\"409\":1}}],[\"此时调用内存中不存在的非静态成员不合法\",{\"1\":{\"288\":1}}],[\"此时并没有同步到磁盘\",{\"1\":{\"241\":1}}],[\"此时会创建一个\",{\"1\":{\"407\":1}}],[\"此时会阻塞主进程\",{\"1\":{\"239\":1}}],[\"此时会以\",{\"1\":{\"166\":1}}],[\"此时新的\",{\"1\":{\"208\":1}}],[\"此时缓存中无数据\",{\"1\":{\"175\":1}}],[\"此时执行计划中的\",{\"1\":{\"108\":1}}],[\"此时\",{\"1\":{\"60\":1,\"454\":1}}],[\"此时服务端进入\",{\"1\":{\"60\":1}}],[\"此变化解决了\",{\"1\":{\"55\":1}}],[\"此方法主要用于在客户端和服务器之间通过网络进行通信\",{\"1\":{\"9\":1}}],[\"直至\",{\"1\":{\"408\":1}}],[\"直至所有线程的任务都执行完毕\",{\"1\":{\"408\":1}}],[\"直接引用是可以直接指向目标的指针\",{\"1\":{\"488\":1}}],[\"直接就会在准备阶段赋值\",{\"1\":{\"487\":1}}],[\"直接指针\",{\"0\":{\"439\":1}}],[\"直接进行栈上分配\",{\"1\":{\"427\":1}}],[\"直接丢弃掉\",{\"1\":{\"389\":1}}],[\"直接从线程池中获取线程来处理\",{\"1\":{\"385\":1}}],[\"直接执行\",{\"1\":{\"351\":1}}],[\"直接执行会导致与原库的数据不一致\",{\"1\":{\"150\":1}}],[\"直接调用run\",{\"0\":{\"351\":1}}],[\"直接返回字符串常量池中字符串对象\",{\"1\":{\"307\":2}}],[\"直接使用stringbuilder进行拼接就能解决这个问题\",{\"1\":{\"305\":1}}],[\"直接使用下面这几个命令就可以了\",{\"1\":{\"188\":1}}],[\"直接解析还原数据即可\",{\"1\":{\"246\":1}}],[\"直接利用临时节点的特性即可\",{\"1\":{\"210\":1}}],[\"直接通过\",{\"1\":{\"204\":1}}],[\"直接更新\",{\"1\":{\"176\":1}}],[\"直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的\",{\"1\":{\"173\":1}}],[\"直接找到key所在的节点即可取出数据\",{\"1\":{\"127\":1}}],[\"直接将表都删除掉\",{\"1\":{\"86\":1}}],[\"直播等等\",{\"1\":{\"54\":1}}],[\"直到它收集结束\",{\"1\":{\"461\":1}}],[\"直到等待的时间超过了\",{\"1\":{\"388\":1}}],[\"直到有有元素\",{\"1\":{\"261\":1,\"414\":1}}],[\"直到将其删除\",{\"1\":{\"210\":1}}],[\"直到某条记录不符合a>1条件位置\",{\"1\":{\"136\":1}}],[\"直到找到查找的上限\",{\"1\":{\"127\":1}}],[\"直到在内核把数据拷贝到用户空间\",{\"1\":{\"22\":1}}],[\"直到到达磁盘边界\",{\"1\":{\"16\":1}}],[\"直到到达磁盘的边界\",{\"1\":{\"16\":1}}],[\"直到所有线程都到达屏障后\",{\"1\":{\"7\":1}}],[\"视为主要数据存储\",{\"1\":{\"176\":1}}],[\"视为进程的大脑\",{\"1\":{\"8\":1}}],[\"视频\",{\"1\":{\"54\":1,\"184\":1}}],[\"什么情况下需要分库分表\",{\"0\":{\"117\":1}}],[\"什么时候选\",{\"0\":{\"54\":1}}],[\"什么时候选择\",{\"0\":{\"54\":1}}],[\"什么是线程池\",{\"0\":{\"385\":1}}],[\"什么是悲观锁\",{\"0\":{\"365\":1}}],[\"什么是乐观锁\",{\"0\":{\"364\":1}}],[\"什么是本地内存\",{\"0\":{\"356\":1}}],[\"什么是主内存\",{\"0\":{\"356\":1}}],[\"什么是java内存模型\",{\"0\":{\"355\":1}}],[\"什么是死锁\",{\"0\":{\"345\":1}}],[\"什么是字节码\",{\"0\":{\"276\":1}}],[\"什么是分表\",{\"0\":{\"116\":1}}],[\"什么是分库\",{\"0\":{\"115\":1}}],[\"什么是关系型数据库\",{\"0\":{\"89\":1}}],[\"什么是\",{\"0\":{\"78\":1,\"170\":1}}],[\"什么是ip地址\",{\"0\":{\"74\":1}}],[\"什么是内存碎片\",{\"0\":{\"12\":1}}],[\"什么是僵尸进程和孤儿进程\",{\"0\":{\"10\":1}}],[\"什么是进程和线程\",{\"0\":{\"5\":1}}],[\"什么是用户态和内核态\",{\"0\":{\"3\":1}}],[\"～\",{\"1\":{\"53\":1}}],[\"进一步让老年代fullgc不再频繁\",{\"1\":{\"517\":1}}],[\"进一步提高程序的运行性能\",{\"1\":{\"402\":1}}],[\"进入\",{\"1\":{\"507\":1}}],[\"进而使得查询元素的操作陷入死循环无法结束\",{\"1\":{\"270\":1}}],[\"进而保证锁不会因为超时而被释放\",{\"1\":{\"206\":1}}],[\"进而造成共享资源无法再被其他线程\",{\"1\":{\"204\":1}}],[\"进而\",{\"1\":{\"173\":1}}],[\"进而将一个数据库的压力分担到多个数据库\",{\"1\":{\"115\":1}}],[\"进行fullgc\",{\"1\":{\"467\":1}}],[\"进行了封装\",{\"1\":{\"395\":1}}],[\"进行访问\",{\"1\":{\"286\":1}}],[\"进行比较\",{\"1\":{\"279\":1}}],[\"进行运算\",{\"1\":{\"229\":1}}],[\"进行有序排列\",{\"1\":{\"225\":1}}],[\"进行加锁来保证不出现幻读\",{\"1\":{\"156\":1}}],[\"进行刷盘\",{\"1\":{\"146\":1}}],[\"进行优化\",{\"1\":{\"103\":1}}],[\"进行传输的时候多了连接\",{\"1\":{\"53\":1}}],[\"进程是程序的一次执行过程\",{\"1\":{\"338\":1}}],[\"进程访问\",{\"1\":{\"204\":1}}],[\"进程所分配的内存可能会比其实际所需要的大\",{\"1\":{\"12\":1}}],[\"进程来回收孤儿进程的资源\",{\"1\":{\"10\":1}}],[\"进程号为\",{\"1\":{\"10\":1}}],[\"进程间的通信方式有哪些\",{\"0\":{\"9\":1}}],[\"进程间的通信等\",{\"1\":{\"2\":1}}],[\"进程打开的文件信息\",{\"1\":{\"8\":1}}],[\"进程对资源的需求情况\",{\"1\":{\"8\":1}}],[\"进程优先级\",{\"1\":{\"8\":1}}],[\"进程状态\",{\"1\":{\"8\":1}}],[\"进程的调度信息\",{\"1\":{\"8\":1}}],[\"进程的描述信息\",{\"1\":{\"8\":1}}],[\"进程的创建\",{\"1\":{\"2\":1}}],[\"进程切换的成本大于线程切换\",{\"1\":{\"6\":1}}],[\"进程\",{\"0\":{\"338\":1},\"1\":{\"5\":1,\"10\":1}}],[\"进程和线程\",{\"0\":{\"4\":1,\"337\":1}}],[\"进程和线程的管理\",{\"1\":{\"2\":1}}],[\"相连的对象\",{\"1\":{\"466\":1}}],[\"相当于v操作\",{\"1\":{\"407\":1}}],[\"相当于p操作\",{\"1\":{\"407\":1}}],[\"相当于定位到了数据\",{\"1\":{\"131\":1}}],[\"相同二进制名称的类只会被加载一次\",{\"1\":{\"493\":1}}],[\"相同情况下使用stringbuilder会带来一点性能提升\",{\"1\":{\"303\":1}}],[\"相同则直接覆盖\",{\"1\":{\"267\":1}}],[\"相对偏移量或者是一个能定位到目标的句柄\",{\"1\":{\"488\":1}}],[\"相对于\",{\"1\":{\"467\":1}}],[\"相对于静态代理\",{\"1\":{\"322\":1}}],[\"相对完整\",{\"1\":{\"246\":1}}],[\"相对来说\",{\"1\":{\"218\":1}}],[\"相对应\",{\"1\":{\"53\":1}}],[\"相关的方法\",{\"1\":{\"507\":1}}],[\"相关的问题\",{\"1\":{\"507\":1}}],[\"相关的一些\",{\"1\":{\"186\":1}}],[\"相关命令\",{\"1\":{\"215\":2,\"218\":1,\"221\":1,\"224\":3,\"227\":2,\"230\":1,\"233\":1,\"236\":1}}],[\"相关信息\",{\"1\":{\"70\":1,\"103\":1,\"175\":1,\"305\":1}}],[\"相反地\",{\"1\":{\"158\":1}}],[\"相比起来具有更高的吞吐量\",{\"1\":{\"416\":1}}],[\"相比\",{\"1\":{\"225\":1,\"246\":1}}],[\"相比较于\",{\"1\":{\"215\":1}}],[\"相比于\",{\"1\":{\"184\":1,\"213\":1}}],[\"相比于非聚簇索引\",{\"1\":{\"131\":1}}],[\"相比于同步阻塞io模型\",{\"1\":{\"22\":1}}],[\"相比普通索引建立的数据更小\",{\"1\":{\"129\":1}}],[\"相比myisam\",{\"1\":{\"93\":1}}],[\"相较于\",{\"1\":{\"75\":1}}],[\"拥塞避免算法的思路是让拥塞窗口\",{\"1\":{\"66\":1}}],[\"拥塞避免\",{\"1\":{\"66\":1}}],[\"拥塞控制\",{\"1\":{\"64\":1}}],[\"拥塞控制的影响\",{\"1\":{\"55\":1}}],[\"拥塞控制机制\",{\"1\":{\"53\":1}}],[\"拥有分析操作类的能力\",{\"1\":{\"317\":1}}],[\"拥有非常高的权限\",{\"1\":{\"3\":1}}],[\"拥有较低的权限\",{\"1\":{\"3\":1}}],[\"重点关注吞吐量\",{\"1\":{\"463\":1}}],[\"重量级\",{\"1\":{\"401\":1}}],[\"重量级锁状态\",{\"1\":{\"397\":1}}],[\"重试的次数默认是10次\",{\"1\":{\"398\":1}}],[\"重新标记花的时间就少了\",{\"1\":{\"518\":1}}],[\"重新标记会扫描所有新生代对象\",{\"1\":{\"518\":1}}],[\"重新标记阶段会花费很长的时间\",{\"1\":{\"518\":1}}],[\"重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录\",{\"1\":{\"466\":1}}],[\"重新标记和清除\",{\"1\":{\"468\":1}}],[\"重新标记和并发清理\",{\"1\":{\"468\":1}}],[\"重新标记\",{\"1\":{\"466\":1}}],[\"重新安排语句执行顺序\",{\"1\":{\"354\":1}}],[\"重新赋值\",{\"1\":{\"296\":1}}],[\"重新开始循环\",{\"1\":{\"16\":1}}],[\"重载\",{\"1\":{\"289\":1}}],[\"重载就是对同一个方法根据输入的不同作出不同的方法处理\",{\"1\":{\"289\":1}}],[\"重载和重写\",{\"0\":{\"289\":1}}],[\"重写loadclass方法\",{\"1\":{\"497\":1}}],[\"重写equals\",{\"1\":{\"301\":1}}],[\"重写了equals方法\",{\"1\":{\"299\":1}}],[\"重写发生在运行时\",{\"1\":{\"289\":1}}],[\"重写\",{\"1\":{\"289\":1}}],[\"重写一般在子类继承父类\",{\"1\":{\"289\":1}}],[\"重写缓冲区\",{\"1\":{\"244\":1}}],[\"重写程序放到子进程里执行\",{\"1\":{\"244\":1}}],[\"重写会进行大量的写入操作\",{\"1\":{\"244\":1}}],[\"重启加载\",{\"1\":{\"241\":1}}],[\"重启的时候可以再次加载进行使用\",{\"1\":{\"172\":1}}],[\"重做日志\",{\"0\":{\"145\":1},\"1\":{\"152\":1,\"154\":1}}],[\"重要\",{\"0\":{\"332\":1,\"333\":1},\"1\":{\"108\":3,\"260\":1,\"271\":1,\"328\":2}}],[\"重传等机制\",{\"1\":{\"53\":1}}],[\"重传\",{\"1\":{\"53\":1}}],[\"窗口\",{\"1\":{\"53\":1}}],[\"与用户线程并发执行\",{\"1\":{\"467\":1}}],[\"与软引用的区别在于\",{\"1\":{\"453\":1}}],[\"与可创建的最大线程数不是一个意思\",{\"1\":{\"387\":1}}],[\"与此线程有关的inheritablethreadlocal值\",{\"1\":{\"382\":1}}],[\"与此线程有关的threadlocal值\",{\"1\":{\"382\":1}}],[\"与代理类对象调用的方法相对应\",{\"1\":{\"323\":1}}],[\"与快照持久化相比\",{\"1\":{\"240\":1}}],[\"与传统数据库不同的是\",{\"1\":{\"170\":1}}],[\"与b=2无关\",{\"1\":{\"136\":1}}],[\"与存储引擎无关\",{\"1\":{\"102\":1}}],[\"与\",{\"0\":{\"52\":1,\"53\":1,\"86\":1,\"255\":1,\"259\":1},\"1\":{\"108\":2,\"205\":1,\"246\":1,\"416\":1,\"467\":1,\"481\":1}}],[\"与管道\",{\"1\":{\"9\":1}}],[\"层主要包括连接器\",{\"1\":{\"91\":1}}],[\"层和引擎层\",{\"1\":{\"91\":1}}],[\"层级结构\",{\"1\":{\"50\":1}}],[\"层次结构中\",{\"1\":{\"50\":1}}],[\"都需要获取到锁才能进行操作\",{\"1\":{\"415\":1}}],[\"都会有一个栈帧被弹出\",{\"1\":{\"424\":1}}],[\"都会新生成一个string类型\",{\"1\":{\"303\":1}}],[\"都会产生binlog日志\",{\"1\":{\"149\":1}}],[\"都可以优先考虑\",{\"1\":{\"465\":1}}],[\"都可以有默认的实现方法\",{\"1\":{\"296\":1}}],[\"都可以包含抽象方法\",{\"1\":{\"296\":1}}],[\"都不能被实例化\",{\"1\":{\"296\":1}}],[\"都支持封装继承多态\",{\"1\":{\"277\":1}}],[\"都继承自abstractmap\",{\"1\":{\"265\":1}}],[\"都能保证元素唯一\",{\"1\":{\"257\":1}}],[\"都属于可重入锁\",{\"1\":{\"207\":1}}],[\"都有过期策略\",{\"1\":{\"172\":1}}],[\"都有一个自己的本地\",{\"1\":{\"50\":1}}],[\"都是通过创建底层数组的新副本来实现的\",{\"1\":{\"412\":1}}],[\"都是一次只允许一个线程访问某个资源\",{\"1\":{\"407\":1}}],[\"都是\",{\"1\":{\"257\":1}}],[\"都是基于内存的数据库\",{\"1\":{\"172\":1}}],[\"都是这种机制\",{\"1\":{\"7\":1}}],[\"都通过\",{\"1\":{\"165\":1}}],[\"本类内部创建对象实例\",{\"1\":{\"329\":1}}],[\"本身会极大的节省储存空间\",{\"1\":{\"228\":1}}],[\"本章的所有知识都属于计算机统考408计算机学科专业基础中的知识点\",{\"1\":{\"70\":1}}],[\"本地内存是jmm抽象出的概念\",{\"1\":{\"356\":1}}],[\"本地内存\",{\"1\":{\"356\":1,\"428\":1}}],[\"本地方法栈中的对象\",{\"1\":{\"451\":1}}],[\"本地方法栈和虚拟机栈发挥的作用类似\",{\"1\":{\"342\":1}}],[\"本地方法栈用于存放native方法\",{\"1\":{\"342\":1}}],[\"本地方法栈\",{\"0\":{\"425\":1},\"1\":{\"339\":1,\"340\":1}}],[\"本地\",{\"1\":{\"50\":1}}],[\"本质不是同一个文件\",{\"1\":{\"15\":1}}],[\"本质是同一个文件\",{\"1\":{\"15\":1}}],[\"本质区别\",{\"1\":{\"15\":1}}],[\"记录命令\",{\"1\":{\"246\":1}}],[\"记录每一次执行的命令\",{\"1\":{\"246\":1}}],[\"记录服务器执行的所有写命令\",{\"1\":{\"244\":1}}],[\"记录下来\",{\"1\":{\"162\":1}}],[\"记录内容如下\",{\"1\":{\"150\":1}}],[\"记录内容是语句的原始逻辑\",{\"1\":{\"149\":1}}],[\"记录内容是\",{\"1\":{\"149\":1}}],[\"记录的内容不再是简单的sql语句了\",{\"1\":{\"150\":1}}],[\"记录的内容如下\",{\"1\":{\"150\":1}}],[\"记录的内容是sql语句原文\",{\"1\":{\"150\":1}}],[\"记录格式\",{\"0\":{\"150\":1}}],[\"记录到日志文件组中\",{\"1\":{\"147\":1}}],[\"记录到重做日志缓存\",{\"1\":{\"145\":1}}],[\"记录锁只能锁住已经存在的记录\",{\"1\":{\"103\":1,\"166\":1}}],[\"记录锁\",{\"1\":{\"103\":1}}],[\"记录\",{\"1\":{\"50\":1,\"146\":1,\"147\":3}}],[\"国家也有自己的顶级域\",{\"1\":{\"50\":1}}],[\"顶级域是指域名的后缀\",{\"1\":{\"50\":1}}],[\"顶级域\",{\"1\":{\"50\":1}}],[\"我并不修改原有内容\",{\"1\":{\"412\":1}}],[\"我国境内目前仍没有根服务器\",{\"1\":{\"50\":1}}],[\"我们不需要自己手动实现\",{\"1\":{\"207\":1}}],[\"我们可以更好地利用虚拟内存硬件资源\",{\"1\":{\"509\":1}}],[\"我们可以设置参数\",{\"1\":{\"508\":1}}],[\"我们可以很方便地完成很多复杂的业务场景比如通过\",{\"1\":{\"179\":1}}],[\"我们可以自己约定参数的写法\",{\"1\":{\"40\":1}}],[\"我们都是基于\",{\"1\":{\"179\":1}}],[\"我们也就提高了系统整体的并发\",{\"1\":{\"173\":1}}],[\"我们直接利用\",{\"1\":{\"153\":1}}],[\"我们在写\",{\"1\":{\"143\":1}}],[\"我们知道\",{\"1\":{\"40\":1}}],[\"我们通常约定get\",{\"1\":{\"40\":1}}],[\"我们网页就是通过\",{\"1\":{\"37\":1,\"56\":1}}],[\"我们的参数是写在\",{\"1\":{\"40\":1}}],[\"我们的应用程序实际上只是发起了\",{\"1\":{\"18\":1}}],[\"我们的应用程序对操作系统的内核发起\",{\"1\":{\"18\":1}}],[\"我们的春夏秋冬\",{\"1\":{\"0\":1}}],[\"我们后面介绍的分段机制就会导致外部内存碎片\",{\"1\":{\"12\":1}}],[\"根节点枚举都是需要stw的\",{\"1\":{\"470\":1}}],[\"根节点总是黑色\",{\"1\":{\"126\":1}}],[\"根据类的二进制名称来查找类\",{\"1\":{\"495\":1}}],[\"根据均值\",{\"1\":{\"468\":1}}],[\"根据虚拟机当前运行状态的不同\",{\"1\":{\"435\":1}}],[\"根据数据的变化来确定同步代码块是否多个线程抢占共享变量\",{\"1\":{\"401\":1}}],[\"根据应用场景不同\",{\"1\":{\"257\":1}}],[\"根据\",{\"1\":{\"159\":1}}],[\"根据主键再回表查询数据\",{\"1\":{\"132\":1}}],[\"根据主索引搜索时\",{\"1\":{\"127\":1}}],[\"根\",{\"1\":{\"50\":2}}],[\"端口为53\",{\"1\":{\"49\":1}}],[\"端口号\",{\"1\":{\"45\":1}}],[\"允许\",{\"1\":{\"408\":1}}],[\"允许读取并发事务已经提交的数据\",{\"1\":{\"156\":1}}],[\"允许读取尚未提交的数据变更\",{\"1\":{\"156\":1}}],[\"允许多个事务同时获取\",{\"1\":{\"104\":1}}],[\"允许多个线程同时读取共享资源\",{\"1\":{\"7\":1}}],[\"允许在\",{\"1\":{\"75\":1}}],[\"允许在第一次连接时发送数据\",{\"1\":{\"55\":1}}],[\"允许在同一\",{\"1\":{\"46\":1}}],[\"处理并发阶段结束后仍遗留下来的少量satb记录\",{\"1\":{\"467\":1}}],[\"处理原始快照在并发时变动的对象\",{\"1\":{\"467\":1}}],[\"处理完之后线程并不会立即被销毁\",{\"1\":{\"385\":1}}],[\"处理器可以改变语句对应机器指令的执行顺序\",{\"1\":{\"354\":1}}],[\"处理\",{\"0\":{\"508\":1},\"1\":{\"46\":1}}],[\"处理机的状态信息\",{\"1\":{\"8\":1}}],[\"头插法可能会导致链表中的节点指向错误的位置\",{\"1\":{\"270\":1}}],[\"头字段\",{\"1\":{\"46\":2}}],[\"头\",{\"1\":{\"46\":1}}],[\"头域\",{\"1\":{\"46\":1}}],[\"带来非常大的执行开销\",{\"1\":{\"368\":1}}],[\"带参数的方法中的局部变量\",{\"1\":{\"285\":1}}],[\"带参数时\",{\"1\":{\"40\":1}}],[\"带宽\",{\"1\":{\"46\":1}}],[\"来自定义类加载器\",{\"1\":{\"497\":1}}],[\"来标识常量的类型\",{\"1\":{\"476\":1}}],[\"来缩短\",{\"1\":{\"467\":1}}],[\"来了解被引用的对象是否将要被垃圾回收\",{\"1\":{\"453\":1}}],[\"来设置老年代与新生代内存的比值\",{\"1\":{\"503\":1}}],[\"来设置\",{\"1\":{\"445\":2}}],[\"来指定排序规则\",{\"1\":{\"417\":1}}],[\"来替代\",{\"1\":{\"413\":1}}],[\"来完成获取资源线程的排队工作\",{\"1\":{\"405\":1}}],[\"来处理\",{\"1\":{\"394\":1}}],[\"来创建\",{\"1\":{\"387\":1}}],[\"来判断\",{\"1\":{\"204\":1}}],[\"来判断数据的可见性\",{\"1\":{\"153\":1,\"160\":1}}],[\"来保证并发安全\",{\"1\":{\"271\":1}}],[\"来保证事务的原子性\",{\"1\":{\"154\":1}}],[\"来保存数据过期的时间\",{\"1\":{\"199\":1}}],[\"来作为底层实现\",{\"1\":{\"184\":1}}],[\"来实现锁的分配\",{\"1\":{\"405\":1}}],[\"来实现这个机制\",{\"1\":{\"377\":1}}],[\"来实现\",{\"1\":{\"179\":1}}],[\"来实现分布式锁\",{\"1\":{\"179\":1}}],[\"来做消息队列\",{\"1\":{\"179\":1}}],[\"来做消息队列的话\",{\"1\":{\"179\":1}}],[\"来做分布式锁是一种比较常见的方式\",{\"1\":{\"179\":1}}],[\"来做为缓存判断的标准\",{\"1\":{\"46\":1}}],[\"来读取快照数据\",{\"1\":{\"165\":1}}],[\"来生成聚簇索引\",{\"1\":{\"161\":1}}],[\"来防止其它事务在间隙间插入数据\",{\"1\":{\"159\":1}}],[\"来攻击\",{\"1\":{\"40\":1}}],[\"光是错误响应状态码就新增了\",{\"1\":{\"46\":1}}],[\"状态\",{\"0\":{\"62\":1},\"1\":{\"58\":3,\"60\":5,\"91\":2}}],[\"状态响应码\",{\"1\":{\"46\":1}}],[\"状态码再发送\",{\"1\":{\"40\":1}}],[\"为新生代分配256mb内存\",{\"1\":{\"503\":1}}],[\"为jvm堆内存分配最大5gb\",{\"1\":{\"502\":1}}],[\"为类的二进制名称\",{\"1\":{\"495\":1}}],[\"为null就是\",{\"1\":{\"494\":1}}],[\"为null的话\",{\"1\":{\"494\":1}}],[\"为每个region设置两个tams指针\",{\"1\":{\"467\":1}}],[\"为各种框架提供开箱即用的便利\",{\"1\":{\"317\":1}}],[\"为形参\",{\"1\":{\"310\":1}}],[\"为实参\",{\"1\":{\"310\":1}}],[\"为集合数量\",{\"1\":{\"226\":1}}],[\"为例来说明如何使用\",{\"1\":{\"206\":1}}],[\"为\",{\"1\":{\"162\":1,\"185\":2,\"189\":1,\"383\":3,\"408\":1,\"497\":1}}],[\"为空\",{\"1\":{\"162\":1}}],[\"为0的时候\",{\"1\":{\"151\":1}}],[\"为该映射关系的生存周期\",{\"1\":{\"79\":1}}],[\"为什么需要java内存模型\",{\"0\":{\"355\":1}}],[\"为什么wait\",{\"0\":{\"350\":1}}],[\"为什么重写\",{\"0\":{\"301\":1}}],[\"为什么\",{\"1\":{\"243\":1}}],[\"为什么要设置对前一个节点的监听\",{\"0\":{\"211\":1}}],[\"为什么要用线程池\",{\"0\":{\"386\":1}}],[\"为什么要用临时顺序节点\",{\"0\":{\"210\":1}}],[\"为什么要用缓存\",{\"0\":{\"173\":1}}],[\"为什么要用\",{\"0\":{\"173\":1}}],[\"为什么要三次握手\",{\"0\":{\"59\":1}}],[\"为什么这么快\",{\"0\":{\"171\":1}}],[\"为什么第四次挥手客户端需要等待\",{\"0\":{\"62\":1}}],[\"为什么不能把服务器发送的\",{\"0\":{\"61\":1}}],[\"为此\",{\"1\":{\"53\":1}}],[\"为短连接\",{\"1\":{\"46\":1}}],[\"为了提升性能和减少内存消耗针对字符串\",{\"1\":{\"430\":1}}],[\"为了线程切换之后能恢复到正确的执行位置\",{\"1\":{\"423\":1}}],[\"为了防止\",{\"1\":{\"416\":1}}],[\"为了防止误删到其他的锁\",{\"1\":{\"204\":1}}],[\"为了将读取的性能发挥到极致\",{\"1\":{\"411\":1}}],[\"为了调用private方法取消安全检查\",{\"1\":{\"319\":1}}],[\"为了满足不同的业务场景\",{\"1\":{\"170\":1}}],[\"为了安全起见\",{\"1\":{\"151\":1}}],[\"为了避免对\",{\"1\":{\"244\":1}}],[\"为了避免单点故障\",{\"1\":{\"208\":1}}],[\"为了避免锁无法被释放\",{\"1\":{\"205\":1}}],[\"为了避免修改\",{\"1\":{\"184\":1}}],[\"为了避免插入新行\",{\"1\":{\"156\":1}}],[\"为了避免插入新记录\",{\"1\":{\"103\":1,\"166\":1}}],[\"为了避免孤儿进程占用系统资源\",{\"1\":{\"10\":1}}],[\"为了解决标记\",{\"1\":{\"458\":1}}],[\"为了解决这个问题\",{\"1\":{\"324\":1}}],[\"为了解决这种问题\",{\"1\":{\"150\":1}}],[\"为了解决两份日志之间的逻辑一致问题\",{\"1\":{\"152\":1}}],[\"为了解决\",{\"1\":{\"75\":1}}],[\"为了保证不发生丢包\",{\"1\":{\"64\":1}}],[\"为了性能和安全\",{\"1\":{\"40\":1}}],[\"为了克服这个缺点\",{\"1\":{\"9\":1}}],[\"0<\",{\"1\":{\"324\":1}}],[\"0111\",{\"1\":{\"269\":1}}],[\"000\",{\"1\":{\"269\":1}}],[\"0000\",{\"1\":{\"269\":19}}],[\"0引入多线程主要是为了提高网络io读写性能\",{\"1\":{\"196\":1}}],[\"0之后为何引入了多线程\",{\"0\":{\"196\":1}}],[\"0之后的版本中就已经加入了对多线程的支持\",{\"1\":{\"195\":1}}],[\"0之后引入了多线程来处理网络请求\",{\"1\":{\"192\":1}}],[\"0之前为什么不使用多线程\",{\"0\":{\"195\":1}}],[\"0版本之后引入了多线程来执行一些大键值对的异步删除操作\",{\"1\":{\"192\":1}}],[\"0版本之后缓存被移除\",{\"1\":{\"94\":1}}],[\"0版本后移除\",{\"1\":{\"91\":1}}],[\"0\",{\"0\":{\"46\":1},\"1\":{\"46\":4,\"55\":5,\"146\":2,\"172\":1,\"179\":4,\"184\":2,\"189\":4,\"199\":6,\"201\":1,\"204\":2,\"205\":2,\"206\":1,\"218\":1,\"228\":1,\"230\":1,\"231\":1,\"267\":1,\"280\":1,\"285\":1,\"312\":5,\"372\":2,\"387\":1,\"407\":1,\"408\":4,\"409\":1,\"476\":2,\"478\":1}}],[\"产生影响\",{\"1\":{\"45\":1}}],[\"高版本的jvm能运行低版本编译器生成的\",{\"1\":{\"475\":1}}],[\"高效利用cpu\",{\"1\":{\"463\":1}}],[\"高效的并发队列\",{\"1\":{\"410\":1}}],[\"高并发的场景下\",{\"1\":{\"365\":1}}],[\"高并发的应用\",{\"1\":{\"22\":1}}],[\"高并发\",{\"1\":{\"173\":1}}],[\"高性能\",{\"1\":{\"173\":1}}],[\"高级功能\",{\"1\":{\"172\":1}}],[\"高可用\",{\"1\":{\"90\":1,\"202\":1}}],[\"高\",{\"1\":{\"45\":1,\"246\":2}}],[\"所需要的内存大小在类加载完成之后就能确定\",{\"1\":{\"433\":1}}],[\"所储存的字符串值的长度\",{\"1\":{\"214\":1}}],[\"所谓可重入锁指的是在一个线程中可以多次获取同一把锁\",{\"1\":{\"207\":1}}],[\"所有\",{\"1\":{\"478\":1}}],[\"所有被同步锁持有的对象\",{\"1\":{\"451\":1}}],[\"所有线程在当前任务执行完毕后\",{\"1\":{\"387\":1}}],[\"所有线程创建的对象实例都放在主内存中\",{\"1\":{\"356\":1}}],[\"所有的new操作的内存分配非常廉价\",{\"1\":{\"513\":1}}],[\"所有的\",{\"1\":{\"478\":1}}],[\"所有的写命令会追加到aof缓冲区中\",{\"1\":{\"241\":1}}],[\"所有的事务依次逐个执行\",{\"1\":{\"156\":1}}],[\"所有尝试获取锁的客户端都会对持有锁的子节点加监听器\",{\"1\":{\"210\":1}}],[\"所有事务进行的修改都会先记录到这个回滚日志中\",{\"1\":{\"153\":1}}],[\"所有值的顺序从最优到最差排序为system\",{\"1\":{\"108\":1}}],[\"所有传输的内容都经过加密\",{\"1\":{\"45\":1}}],[\"所有传输的内容都是明文\",{\"1\":{\"45\":1}}],[\"所使用\",{\"1\":{\"87\":1}}],[\"所以同时也解决了并发问题\",{\"1\":{\"513\":1}}],[\"所以能使用基本数据类型的情况下不要使用包装类型\",{\"1\":{\"512\":1}}],[\"所以拿到的结果是\",{\"1\":{\"494\":1}}],[\"所以父类索引只有一个\",{\"1\":{\"478\":1}}],[\"所以降低了内存碎片的产生数量\",{\"1\":{\"468\":1}}],[\"所以这个算法里会跟踪记录这些发生引用更新的地方\",{\"1\":{\"466\":1}}],[\"所以选择\",{\"1\":{\"459\":1}}],[\"所以可以采用\",{\"1\":{\"459\":1}}],[\"所以可以保证公共资源不会被多个线程同时访问\",{\"1\":{\"7\":1}}],[\"所以最多只能创建核心线程数的线程\",{\"1\":{\"390\":1}}],[\"所以定义在thread类中\",{\"1\":{\"350\":1}}],[\"所以程序计数器的作用就是线程切换之后能恢复到正确的位置\",{\"1\":{\"341\":1}}],[\"所以线程之间的切换开销远远小于进程\",{\"1\":{\"339\":1}}],[\"所以是线程不安全的\",{\"1\":{\"303\":1}}],[\"所以所有的对象都有这个方法\",{\"1\":{\"300\":1}}],[\"所以java也是编译与解释共存的语言\",{\"1\":{\"276\":1}}],[\"所以存在老版本的\",{\"1\":{\"246\":1}}],[\"所以存在非主属性系主任对于学号的传递函数依赖\",{\"1\":{\"84\":1,\"85\":1}}],[\"所以多个应用服务就可以同时获取到锁\",{\"1\":{\"208\":1}}],[\"所以一般说redis是单线程模型\",{\"1\":{\"193\":1}}],[\"所以我们可以考虑把数据库中的部分数据转移到缓存中去\",{\"1\":{\"173\":1}}],[\"所以速度相当快\",{\"1\":{\"173\":1}}],[\"所以速度比较快\",{\"1\":{\"151\":1}}],[\"所以导致不可重复读\",{\"1\":{\"165\":1}}],[\"所以mysql认为是完整的\",{\"1\":{\"152\":1}}],[\"所以mysql没有使用其作为索引的数据结构\",{\"1\":{\"123\":1}}],[\"所以redo\",{\"1\":{\"152\":1}}],[\"所以系统会给每个线程分配一个块内存作为binlog\",{\"1\":{\"151\":1}}],[\"所以用redo\",{\"1\":{\"148\":1}}],[\"所以对于这个查询ab都用到了联合索引进行查询\",{\"1\":{\"136\":1}}],[\"所以对于并发写入操作来说\",{\"1\":{\"102\":1}}],[\"所以在jvm生命周期内\",{\"1\":{\"490\":1}}],[\"所以在访问资源的时候采取加锁的方案\",{\"1\":{\"365\":1}}],[\"所以在生成\",{\"1\":{\"166\":1}}],[\"所以在执行查询的时候\",{\"1\":{\"136\":1}}],[\"所以在传输上\",{\"1\":{\"40\":1}}],[\"所以符合a>1条件的二级索引记录是肯定相邻的\",{\"1\":{\"136\":1}}],[\"所以a字段在where中的顺序并不重要\",{\"1\":{\"136\":1}}],[\"所以需要意向锁来快速判断是否可以对某个表使用表锁\",{\"1\":{\"105\":1}}],[\"所以该表的设计\",{\"1\":{\"85\":1}}],[\"所以姓名完全函数依赖与\",{\"1\":{\"84\":1}}],[\"所以姓名部分函数依赖与\",{\"1\":{\"84\":1}}],[\"所以说\",{\"1\":{\"45\":1}}],[\"所以\",{\"1\":{\"40\":1,\"53\":1,\"159\":1,\"228\":1,\"373\":1,\"383\":1,\"466\":1,\"472\":1}}],[\"之外\",{\"1\":{\"478\":1}}],[\"之外最好的\",{\"1\":{\"108\":1}}],[\"之间的比例为\",{\"1\":{\"509\":1}}],[\"之间的元素\",{\"1\":{\"226\":2}}],[\"之间的还空着的部分可以用来写入新的\",{\"1\":{\"147\":1}}],[\"之间\",{\"1\":{\"217\":1}}],[\"之父\",{\"1\":{\"208\":1}}],[\"之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小\",{\"1\":{\"504\":1}}],[\"之前运行时常量池逻辑包含字符串常量池存放在方法区\",{\"1\":{\"454\":1}}],[\"之前的方法区实现\",{\"1\":{\"428\":1}}],[\"之前的\",{\"1\":{\"271\":1}}],[\"之前值为\",{\"1\":{\"229\":1}}],[\"之前\",{\"0\":{\"267\":1},\"1\":{\"179\":1,\"251\":1,\"430\":1,\"447\":1}}],[\"之前已经提交的修改和该事务本身做的修改\",{\"1\":{\"153\":1,\"160\":1}}],[\"之前是基于\",{\"1\":{\"55\":1}}],[\"之后变成元空间使用操作系统的空间\",{\"1\":{\"519\":1}}],[\"之后没有任何机制再次对其设置值\",{\"1\":{\"408\":1}}],[\"之后对synchronized\",{\"1\":{\"370\":1}}],[\"之后又有一个线程将b改为a\",{\"1\":{\"367\":1}}],[\"之后复用\",{\"1\":{\"276\":1}}],[\"之后其它事务所做的更新\",{\"1\":{\"166\":1}}],[\"之后用binlog日志恢复数据时\",{\"1\":{\"152\":1}}],[\"之后出现的\",{\"1\":{\"108\":1}}],[\"之后\",{\"0\":{\"268\":1},\"1\":{\"92\":1}}],[\"之后请求会自动再次发送\",{\"1\":{\"44\":1}}],[\"之上进行了封装\",{\"1\":{\"176\":1}}],[\"之上的\",{\"1\":{\"45\":1}}],[\"之上\",{\"1\":{\"45\":2,\"56\":1}}],[\"8u20\",{\"1\":{\"509\":1}}],[\"8的默认收集器\",{\"1\":{\"463\":1}}],[\"8位补码的表示范围\",{\"1\":{\"280\":1}}],[\"8最大并发度是node的个数\",{\"1\":{\"272\":1}}],[\"8采用拉链法+红黑树\",{\"1\":{\"272\":1}}],[\"8中的扰动函数源码\",{\"1\":{\"267\":1}}],[\"8之前hashmap底层是数组和链表集合一起\",{\"1\":{\"267\":1}}],[\"8之后通过尾插法解决上述问题\",{\"1\":{\"270\":1}}],[\"8之后hashmap使用数组+链表\",{\"1\":{\"268\":1}}],[\"8之后hashmap底层使用数组+链表\",{\"1\":{\"264\":1}}],[\"8之后的元空间\",{\"1\":{\"5\":1,\"340\":1}}],[\"8以无参数构造方法创建arraylist时\",{\"1\":{\"253\":1}}],[\"81\",{\"1\":{\"231\":1}}],[\"8g\",{\"1\":{\"173\":1}}],[\"8\",{\"0\":{\"267\":1,\"268\":1,\"272\":1},\"1\":{\"53\":1,\"91\":1,\"212\":1,\"219\":1,\"228\":1,\"251\":2,\"271\":3,\"272\":1,\"382\":1,\"396\":1,\"428\":2,\"454\":1,\"475\":1,\"504\":3}}],[\"80\",{\"1\":{\"45\":1}}],[\"授权了也没用\",{\"1\":{\"44\":1}}],[\"几乎所有的对象实例以及数组都在这里分配内存\",{\"1\":{\"427\":1}}],[\"几乎所有的浏览器都会把post改成get\",{\"1\":{\"44\":1}}],[\"几乎所有现代电子邮件客户端和服务器都支持\",{\"1\":{\"37\":1,\"56\":1}}],[\"首次请求的数据一定不在cache中\",{\"1\":{\"175\":1}}],[\"首先\",{\"1\":{\"470\":1,\"497\":1}}],[\"首先cms是老年代的收集器\",{\"1\":{\"468\":1}}],[\"首先标记出所有不需要回收的对象\",{\"1\":{\"457\":1}}],[\"首先两者都不是线程安全的实现\",{\"1\":{\"255\":1}}],[\"首先我们要有一个持久节点\",{\"1\":{\"209\":1}}],[\"首先要找到查找的下限\",{\"1\":{\"127\":1}}],[\"首先说明一点\",{\"1\":{\"40\":1}}],[\"首部开销\",{\"1\":{\"53\":3}}],[\"首部location字段标示重定向的url\",{\"1\":{\"44\":1}}],[\"报文段最长寿命\",{\"0\":{\"62\":1}}],[\"报文后\",{\"1\":{\"53\":1}}],[\"报文\",{\"1\":{\"43\":1}}],[\"客户端会话\",{\"1\":{\"210\":1}}],[\"客户端获取锁就是在locks下创建临时顺序节点\",{\"1\":{\"209\":1}}],[\"客户端连接\",{\"1\":{\"194\":1}}],[\"客户端和服务端就可以继续传输数据\",{\"1\":{\"60\":1}}],[\"客户端和服务器端都无法验证对方的身份\",{\"1\":{\"45\":1}}],[\"客户端也可以关闭连接了\",{\"1\":{\"60\":1}}],[\"客户端进入\",{\"1\":{\"60\":2}}],[\"客户端发送给服务器的\",{\"1\":{\"62\":1}}],[\"客户端发送\",{\"1\":{\"60\":1}}],[\"客户端发送一个\",{\"1\":{\"60\":1}}],[\"客户端发送带有\",{\"1\":{\"58\":2}}],[\"客户端\",{\"1\":{\"58\":1,\"206\":1,\"209\":1}}],[\"客户端可以只发送部分资源内容\",{\"1\":{\"41\":1}}],[\"客户端将数据提交到服务器\",{\"1\":{\"41\":1}}],[\"客户端需要发送完整的资源内容\",{\"1\":{\"41\":1}}],[\"客户端需要将整个资源的新版本发送到服务器\",{\"1\":{\"41\":1}}],[\"则这种情况属于永久代内存不足导致fullgc\",{\"1\":{\"519\":1}}],[\"则这两个类不同\",{\"1\":{\"497\":1}}],[\"则这两个操作就没有顺序保障\",{\"1\":{\"359\":1}}],[\"则占用的内存比基本数据类型大很多\",{\"1\":{\"512\":1}}],[\"则使用大页面内存\",{\"1\":{\"509\":1}}],[\"则使用空闲线程来处理\",{\"1\":{\"390\":1}}],[\"则当前进程的进程\",{\"1\":{\"508\":1}}],[\"则调用findclass方法来加载该类\",{\"1\":{\"497\":1}}],[\"则调用启动类加载器来加载该类\",{\"1\":{\"497\":1}}],[\"则抛出异常\",{\"1\":{\"497\":1}}],[\"则说明该类没有被加载过\",{\"1\":{\"497\":1}}],[\"则说明有其他的客户端已经成功获取锁\",{\"1\":{\"209\":1}}],[\"则引用目标必定在虚拟机的内存中\",{\"1\":{\"488\":1}}],[\"则引入了更多的缓存控制策略例如\",{\"1\":{\"46\":1}}],[\"则采用的是原始快照\",{\"1\":{\"470\":1}}],[\"则和没有任何引用一样\",{\"1\":{\"453\":1}}],[\"则证明此对象是不可用的\",{\"1\":{\"450\":1}}],[\"则虚拟机会先查看\",{\"1\":{\"447\":1}}],[\"则虚拟机会把加锁的范围扩展\",{\"1\":{\"400\":1}}],[\"则获取令牌成功\",{\"1\":{\"407\":1}}],[\"则获取锁成功\",{\"1\":{\"209\":1}}],[\"则将当前请求资源的线程设置为有效的工作线程\",{\"1\":{\"405\":1}}],[\"则将此确认帧还有之后已经发送的序号全部重发\",{\"1\":{\"69\":1}}],[\"则持有偏向锁的线程将永远不需要再进行同步\",{\"1\":{\"402\":1}}],[\"则以后在获取锁失败之后很可能会省略自旋的过程\",{\"1\":{\"398\":1}}],[\"则新的任务会被暂存在一个任务队列中\",{\"1\":{\"387\":1}}],[\"则立即执行\",{\"1\":{\"387\":1}}],[\"则认为没有逃逸\",{\"1\":{\"427\":1}}],[\"则认为此次的自旋也有较大概率获得锁\",{\"1\":{\"398\":1}}],[\"则认为变量没有被修改\",{\"1\":{\"367\":1}}],[\"则认为前面需要的数据在接收端都受到了\",{\"1\":{\"69\":1}}],[\"则第三个线程采用cas进行修改的时候发现预期值a正确\",{\"1\":{\"367\":1}}],[\"则对这个变量读写的时候会添加上特定的读写屏障保证可见性\",{\"1\":{\"362\":1}}],[\"则对象不一定相等\",{\"1\":{\"301\":1}}],[\"则a\",{\"1\":{\"359\":1}}],[\"则目标类和代理类都要修改\",{\"1\":{\"326\":1}}],[\"则不会在编译期间确定结果\",{\"1\":{\"308\":1}}],[\"则返回引用\",{\"1\":{\"307\":1}}],[\"则执行的是子类中的方法\",{\"1\":{\"295\":1}}],[\"则可以看成常量\",{\"1\":{\"487\":1}}],[\"则可以通过继承复用减少开发难度\",{\"1\":{\"295\":1}}],[\"则可以通过\",{\"1\":{\"163\":1}}],[\"则可能通过标量替换来实现栈\",{\"1\":{\"279\":1}}],[\"则通过父类的loadclass来加载该类\",{\"1\":{\"497\":1}}],[\"则通过equals比较两个对象的时候等价于==\",{\"1\":{\"299\":1}}],[\"则通过链表来实现\",{\"1\":{\"259\":1}}],[\"则通过数据行的\",{\"1\":{\"153\":1,\"160\":1}}],[\"则需要先初始化父类\",{\"1\":{\"489\":1}}],[\"则需要先进行初始化\",{\"1\":{\"489\":1}}],[\"则需要先取出主键的值\",{\"1\":{\"127\":1}}],[\"则需要一套线程阻塞等待以及被唤醒分配的机制\",{\"1\":{\"405\":1}}],[\"则需要依次执行每个写命令\",{\"1\":{\"246\":1}}],[\"则重写\",{\"1\":{\"244\":1}}],[\"则该线程可以直接执行调用的方法即可重入\",{\"1\":{\"207\":1}}],[\"则先扩展至所需大小再进行修改操作\",{\"1\":{\"184\":1}}],[\"则先更新\",{\"1\":{\"176\":1}}],[\"则是通过调用线程来运行的\",{\"1\":{\"351\":1}}],[\"则是object类的本地方法\",{\"1\":{\"349\":1}}],[\"则是比较两个对象内部的属性是否相等\",{\"1\":{\"299\":1}}],[\"则是只更新缓存\",{\"1\":{\"177\":1}}],[\"则是\",{\"1\":{\"176\":1}}],[\"则为空\",{\"1\":{\"161\":1}}],[\"则表示许可证数量不足\",{\"1\":{\"407\":1}}],[\"则表示可以获取成功\",{\"1\":{\"407\":1}}],[\"则表示锁可以被获取\",{\"1\":{\"372\":1}}],[\"则表示该记录可见\",{\"1\":{\"158\":1}}],[\"则表示未用到索引\",{\"1\":{\"108\":1}}],[\"则选择该字段为默认的主键\",{\"1\":{\"128\":1}}],[\"则会直接返回\",{\"1\":{\"498\":1}}],[\"则会丢弃该任务\",{\"1\":{\"389\":1}}],[\"则会创建新的线程处理任务\",{\"1\":{\"387\":1}}],[\"则会创建一个新的资源\",{\"1\":{\"41\":1}}],[\"则会优先使用可复用的线程\",{\"1\":{\"387\":1}}],[\"则会浪费内存\",{\"1\":{\"330\":1}}],[\"则会在堆中创建1个字符串对象\",{\"1\":{\"306\":1}}],[\"则会在堆中创建2个字符串对象\",{\"1\":{\"306\":1}}],[\"则会拷贝一份数据\",{\"1\":{\"239\":1}}],[\"则会导致锁提前释放\",{\"1\":{\"205\":1}}],[\"则会对读取的记录使用\",{\"1\":{\"159\":1}}],[\"则会使用\",{\"1\":{\"158\":1}}],[\"则会将节点的data值拿出\",{\"1\":{\"127\":1}}],[\"则它的子节点必须是黑色\",{\"1\":{\"126\":1}}],[\"则\",{\"1\":{\"108\":1,\"162\":1}}],[\"则称为覆盖索引\",{\"1\":{\"134\":1}}],[\"则称\",{\"1\":{\"84\":1}}],[\"则y对x部分函数依赖\",{\"1\":{\"84\":1}}],[\"则直接进行解析\",{\"1\":{\"49\":1}}],[\"则在请求头引入了\",{\"1\":{\"46\":1}}],[\"则用客户端提交的新版本替换原有的资源\",{\"1\":{\"41\":1}}],[\"则相关软连接被称为死链接\",{\"1\":{\"15\":1}}],[\"发布\",{\"1\":{\"179\":1}}],[\"发生fullgc\",{\"1\":{\"519\":1}}],[\"发生在类加载阶段的解析阶段\",{\"1\":{\"486\":1}}],[\"发生在请求2更新数据之前则会出现数据不一致\",{\"1\":{\"175\":1}}],[\"发生读请求的时候\",{\"1\":{\"176\":1}}],[\"发生隐式转换\",{\"1\":{\"143\":1}}],[\"发生了某些事先不可知的异常\",{\"1\":{\"3\":1}}],[\"发送方能将发送窗口内的所有序号发送\",{\"1\":{\"69\":1}}],[\"发送方维持一个发送窗口\",{\"1\":{\"69\":1}}],[\"发送窗口>1\",{\"1\":{\"69\":1,\"70\":1}}],[\"发送窗口=接收窗口=1\",{\"1\":{\"68\":1}}],[\"发送和接收邮件\",{\"1\":{\"54\":1}}],[\"发送\",{\"1\":{\"43\":1}}],[\"发现redo\",{\"1\":{\"152\":1}}],[\"发现buffer\",{\"1\":{\"145\":1}}],[\"发现等功能的改进\",{\"1\":{\"75\":1}}],[\"发现\",{\"1\":{\"40\":1}}],[\"服务\",{\"1\":{\"425\":1}}],[\"服务不兼容新版本的\",{\"1\":{\"246\":1}}],[\"服务干宕机\",{\"1\":{\"246\":1}}],[\"服务通常是集群化部署的\",{\"1\":{\"208\":1}}],[\"服务可能就就挂掉了\",{\"1\":{\"177\":1}}],[\"服务来负责\",{\"1\":{\"177\":1}}],[\"服务自己来写入缓存的\",{\"1\":{\"176\":1}}],[\"服务自己更新\",{\"1\":{\"176\":1}}],[\"服务负责将此数据读取和写入\",{\"1\":{\"176\":1}}],[\"服务端同时维护db和cache\",{\"1\":{\"175\":1}}],[\"服务端就会重发\",{\"1\":{\"62\":1}}],[\"服务端在收到\",{\"1\":{\"60\":1}}],[\"服务端进入\",{\"1\":{\"60\":1}}],[\"服务端关闭与客户端的连接并发送一个\",{\"1\":{\"60\":1}}],[\"服务端发送带有\",{\"1\":{\"58\":1}}],[\"服务端\",{\"1\":{\"58\":2}}],[\"服务端允许请求访问资源\",{\"1\":{\"44\":1}}],[\"服务端返回\",{\"1\":{\"40\":1}}],[\"服务器用新的\",{\"1\":{\"244\":1}}],[\"服务器会将重写缓冲区中的所有内容追加到新\",{\"1\":{\"244\":1}}],[\"服务器会返回一个表示新资源的\",{\"1\":{\"41\":1}}],[\"服务器每秒可以执行的查询次数\",{\"1\":{\"173\":1}}],[\"服务器收到这个\",{\"1\":{\"60\":1}}],[\"服务器的\",{\"1\":{\"50\":2}}],[\"服务器提供了权威\",{\"1\":{\"50\":1}}],[\"服务器提供\",{\"1\":{\"50\":1}}],[\"服务器\",{\"1\":{\"50\":7,\"75\":1}}],[\"服务器有哪些\",{\"0\":{\"50\":1}}],[\"服务器处理请求并返回\",{\"1\":{\"43\":1}}],[\"服务器根据数据进行处理\",{\"1\":{\"41\":1}}],[\"服务器是因为处理长\",{\"1\":{\"40\":1}}],[\"服务器之间的通信而设计的\",{\"1\":{\"37\":1,\"56\":1}}],[\"考虑以下几个问题\",{\"1\":{\"512\":1}}],[\"考虑\",{\"1\":{\"40\":1}}],[\"考虑了链路的带宽\",{\"1\":{\"39\":1}}],[\"浏览器解析渲染页面\",{\"1\":{\"43\":1}}],[\"浏览器原因就不说了\",{\"1\":{\"40\":1}}],[\"浏览器与\",{\"1\":{\"37\":1,\"56\":1}}],[\"要求\",{\"1\":{\"486\":1}}],[\"要更新的变量值\",{\"1\":{\"366\":1}}],[\"要等锁释放\",{\"1\":{\"362\":1}}],[\"要么所有的操作都能全部执行不会收到任何外界因素干扰而中断\",{\"1\":{\"360\":1}}],[\"要么都不完成\",{\"1\":{\"96\":1}}],[\"要么都不执行\",{\"1\":{\"95\":1,\"360\":1}}],[\"要么都执行\",{\"1\":{\"95\":1}}],[\"要释放当前线程占有的对象锁并让其进入waiting状态\",{\"1\":{\"350\":1}}],[\"要实现动态代理\",{\"1\":{\"323\":1}}],[\"要大\",{\"1\":{\"53\":1}}],[\"要解决的是域名和\",{\"1\":{\"49\":1}}],[\"要消耗比较多的资源\",{\"1\":{\"40\":1}}],[\"要想安全传输\",{\"1\":{\"40\":1}}],[\"要从邮件服务器接收邮件\",{\"1\":{\"37\":1,\"56\":1}}],[\"然而\",{\"1\":{\"40\":1,\"509\":1}}],[\"然后cms在可达性分析的时候有两个步骤需要stw\",{\"1\":{\"470\":1}}],[\"然后根据用户的期望停顿时间制定回收计划\",{\"1\":{\"467\":1}}],[\"然后根据哈希值确定数据应被放置在哪个表中\",{\"1\":{\"118\":1}}],[\"然后再把使用的空间一次清理掉\",{\"1\":{\"458\":1}}],[\"然后再执行相关的操作\",{\"1\":{\"153\":1}}],[\"然后当前线程被阻塞\",{\"1\":{\"409\":1}}],[\"然后主线程调用countdown\",{\"1\":{\"408\":1}}],[\"然后自动调用run\",{\"1\":{\"351\":1}}],[\"然后将引用指向新的string对象\",{\"1\":{\"303\":1}}],[\"然后用对象执行方法的方式解决问题\",{\"1\":{\"292\":1}}],[\"然后用户\",{\"1\":{\"189\":1}}],[\"然后直接删除cache\",{\"1\":{\"175\":1}}],[\"然后master线程\",{\"1\":{\"148\":1}}],[\"然后调用\",{\"1\":{\"146\":1}}],[\"然后会把在\",{\"1\":{\"145\":1}}],[\"然后在a字段相同的情况下\",{\"1\":{\"136\":1}}],[\"然后沿着记录所在的链表向后扫描\",{\"1\":{\"136\":1}}],[\"然后对b树进行中序遍历\",{\"1\":{\"127\":1}}],[\"然后从存储引擎返回数据\",{\"1\":{\"91\":1}}],[\"然后\",{\"1\":{\"60\":3,\"176\":1,\"408\":1}}],[\"然后客户端和服务器端都进入established\",{\"1\":{\"58\":1}}],[\"然后客户端进入\",{\"1\":{\"58\":1}}],[\"然后服务端进入\",{\"1\":{\"58\":1}}],[\"然后回到磁盘起点\",{\"1\":{\"16\":1}}],[\"然后改变移动方向\",{\"1\":{\"16\":1}}],[\"从局部上来看是基于\",{\"1\":{\"467\":1}}],[\"从整体来看是基于\",{\"1\":{\"467\":1}}],[\"从这些节点开始向下搜索\",{\"1\":{\"450\":1}}],[\"从内存分布图中可以看出永久代是\",{\"1\":{\"428\":1}}],[\"从内存中读取数据\",{\"1\":{\"362\":1}}],[\"从方法调用到执行完成的过程\",{\"1\":{\"342\":1}}],[\"从jvm层面来说\",{\"1\":{\"321\":1}}],[\"从磁盘中读取快照文件\",{\"1\":{\"238\":1}}],[\"从高到底\",{\"1\":{\"226\":1}}],[\"从低到高\",{\"1\":{\"226\":1}}],[\"从数据集\",{\"1\":{\"201\":1}}],[\"从数据库和备份数据库通过binlog同步数据\",{\"1\":{\"152\":1}}],[\"从已设置过期时间的数据集\",{\"1\":{\"201\":4}}],[\"从大到小排序\",{\"1\":{\"186\":1,\"226\":1,\"227\":2}}],[\"从小到大排序\",{\"1\":{\"186\":1,\"227\":2}}],[\"从中读取数据并将数据写入其中\",{\"1\":{\"176\":1}}],[\"从\",{\"0\":{\"340\":1},\"1\":{\"175\":2,\"176\":1,\"504\":1}}],[\"从cache中读取数据\",{\"1\":{\"175\":1}}],[\"从头开始写\",{\"1\":{\"147\":1}}],[\"从根节点到叶节点或空子节点的每一条路径\",{\"1\":{\"126\":1}}],[\"从库的\",{\"1\":{\"113\":2}}],[\"从库中的\",{\"1\":{\"113\":1}}],[\"从库会创建一个\",{\"1\":{\"113\":1}}],[\"从库连接主库\",{\"1\":{\"113\":1}}],[\"从节点读\",{\"1\":{\"110\":1}}],[\"从上往下一次执行\",{\"1\":{\"108\":1}}],[\"从而方法才能被调用\",{\"1\":{\"488\":1}}],[\"从而导致\",{\"1\":{\"390\":1}}],[\"从而执行相应的同步调用\",{\"1\":{\"372\":1}}],[\"从而避免了线程安全问题\",{\"1\":{\"381\":1}}],[\"从而避免synchronized的高开销\",{\"1\":{\"364\":1}}],[\"从而避免子类破坏string的不变性\",{\"1\":{\"304\":1}}],[\"从而形成一个环形链表\",{\"1\":{\"270\":1}}],[\"从而判断\",{\"1\":{\"245\":1}}],[\"从而减少内存的使用\",{\"1\":{\"184\":1}}],[\"从而减轻了应用程序的职责\",{\"1\":{\"176\":1}}],[\"从而在\",{\"1\":{\"165\":1}}],[\"从而实现局域网内的多个设备通过单一公有\",{\"1\":{\"76\":1}}],[\"从而实现了设备间的通信\",{\"1\":{\"74\":1}}],[\"从而提高了内部网络的安全性\",{\"1\":{\"76\":1}}],[\"从而提升了网络的可靠性和性能\",{\"1\":{\"75\":1}}],[\"从而提取参数\",{\"1\":{\"40\":1}}],[\"从而支持虚拟主机的功能\",{\"1\":{\"46\":1}}],[\"从而对\",{\"1\":{\"45\":1}}],[\"从输入\",{\"0\":{\"43\":1}}],[\"从传输的角度来说\",{\"1\":{\"40\":1}}],[\"从应用程序的视角来看的话\",{\"1\":{\"18\":1}}],[\"解锁happens\",{\"1\":{\"359\":1}}],[\"解锁规则\",{\"1\":{\"359\":1}}],[\"解锁逻辑挂了又会影响性能\",{\"1\":{\"205\":1}}],[\"解决aba问题就是添加版本号或者是时间戳\",{\"1\":{\"367\":1}}],[\"解决办法\",{\"1\":{\"175\":2}}],[\"解决了\",{\"1\":{\"179\":1}}],[\"解决了单表的存储和性能瓶颈的问题\",{\"1\":{\"115\":1}}],[\"解决了饥饿问题\",{\"1\":{\"16\":1}}],[\"解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程\",{\"1\":{\"488\":1}}],[\"解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程\",{\"1\":{\"488\":1}}],[\"解析动作主要针对类或接口\",{\"1\":{\"488\":1}}],[\"解析和初始化\",{\"1\":{\"432\":1}}],[\"解析查询的额外信息\",{\"1\":{\"108\":1}}],[\"解析方式分为迭代查询和递归查询\",{\"1\":{\"50\":1}}],[\"解析\",{\"0\":{\"488\":1},\"1\":{\"43\":1,\"483\":1}}],[\"解析报文的过程是通过获取\",{\"1\":{\"40\":1}}],[\"且之后每次\",{\"1\":{\"504\":1}}],[\"且其它事务不能加任何锁\",{\"1\":{\"159\":1}}],[\"且\",{\"1\":{\"143\":1}}],[\"且修改索引时\",{\"1\":{\"142\":1}}],[\"且表中只有一行记录的情况下\",{\"1\":{\"108\":1}}],[\"且有\",{\"1\":{\"84\":1}}],[\"且可缓存\",{\"1\":{\"40\":1}}],[\"且父进程没有调用\",{\"1\":{\"10\":1}}],[\"和卸载\",{\"1\":{\"483\":1}}],[\"和第\",{\"1\":{\"475\":2}}],[\"和用户线程\",{\"1\":{\"466\":1}}],[\"和另外一边的边界划定一个对象内存大小的区域\",{\"1\":{\"433\":1}}],[\"和虚拟机栈所发挥的作用非常相似\",{\"1\":{\"425\":1}}],[\"和数据结构上的栈类似\",{\"1\":{\"424\":1}}],[\"和share\",{\"1\":{\"406\":1}}],[\"和start\",{\"0\":{\"351\":1}}],[\"和notify\",{\"1\":{\"377\":1}}],[\"和nio中的selector组件很像\",{\"1\":{\"194\":1}}],[\"和非公平锁\",{\"1\":{\"375\":1}}],[\"和hashmap\",{\"1\":{\"265\":1}}],[\"和专业的消息队列相比\",{\"1\":{\"218\":1}}],[\"和间隙锁\",{\"1\":{\"156\":1}}],[\"和共享锁兼容\",{\"1\":{\"105\":1}}],[\"和\",{\"0\":{\"46\":1,\"47\":1,\"61\":1,\"75\":1,\"93\":1,\"164\":1,\"172\":1,\"246\":1,\"257\":1,\"264\":1,\"265\":1,\"271\":1,\"272\":1,\"277\":1,\"373\":1,\"377\":1,\"395\":1,\"502\":1},\"1\":{\"40\":6,\"99\":1,\"108\":1,\"126\":1,\"147\":1,\"153\":1,\"158\":1,\"160\":1,\"164\":1,\"165\":1,\"176\":2,\"177\":3,\"179\":1,\"189\":1,\"207\":1,\"209\":1,\"217\":1,\"225\":1,\"226\":2,\"228\":1,\"229\":1,\"246\":2,\"257\":1,\"271\":2,\"307\":3,\"372\":2,\"375\":1,\"381\":1,\"390\":2,\"395\":1,\"407\":1,\"430\":1,\"433\":1,\"457\":1,\"462\":1,\"467\":1,\"509\":1}}],[\"和异步\",{\"1\":{\"19\":1}}],[\"gb\",{\"1\":{\"509\":1}}],[\"gbn\",{\"0\":{\"69\":1}}],[\"g1的记忆集和cms的不一样\",{\"1\":{\"470\":1}}],[\"g1宏观上采用标记清除\",{\"1\":{\"468\":1}}],[\"g1存在着很多问题\",{\"1\":{\"467\":1}}],[\"g1也是遵循分代收集理论设计的\",{\"1\":{\"467\":1}}],[\"g1\",{\"0\":{\"467\":1},\"1\":{\"467\":11,\"468\":3,\"470\":2,\"506\":1,\"511\":1}}],[\"gc时老年代内存占用\",{\"1\":{\"515\":1}}],[\"gc的概率就更大\",{\"1\":{\"513\":1}}],[\"gc的时间远低于full\",{\"1\":{\"513\":1}}],[\"gc的时候同步完成\",{\"1\":{\"467\":1}}],[\"gc调优\",{\"0\":{\"510\":1}}],[\"gclogfilesize=50m\",{\"1\":{\"507\":1}}],[\"gc日志输出的文件路径\",{\"1\":{\"507\":1}}],[\"gc区域\",{\"0\":{\"446\":1}}],[\"gc分代年龄\",{\"1\":{\"437\":1}}],[\"gc\",{\"0\":{\"451\":1,\"507\":1},\"1\":{\"383\":1,\"435\":1,\"443\":1,\"445\":1,\"446\":9,\"447\":5,\"450\":2,\"466\":3,\"467\":3,\"468\":1,\"504\":2,\"506\":1,\"507\":5,\"508\":1,\"509\":1,\"513\":1}}],[\"generation\",{\"0\":{\"503\":1}}],[\"geohash\",{\"1\":{\"235\":1}}],[\"georadiusbymember\",{\"1\":{\"235\":1,\"236\":1}}],[\"georadius\",{\"1\":{\"235\":2,\"236\":1}}],[\"geodist\",{\"1\":{\"235\":1}}],[\"geopos\",{\"1\":{\"235\":1}}],[\"geoadd\",{\"1\":{\"235\":1,\"236\":1}}],[\"geospatial\",{\"0\":{\"234\":1},\"1\":{\"181\":1,\"234\":1}}],[\"geo\",{\"1\":{\"170\":1,\"234\":2,\"235\":3}}],[\"getfindclasses\",{\"1\":{\"497\":1}}],[\"getfindclasstime\",{\"1\":{\"497\":1}}],[\"getfirst\",{\"1\":{\"258\":1}}],[\"getparentdelegationtime\",{\"1\":{\"497\":1}}],[\"getstatic\",{\"1\":{\"489\":1}}],[\"getsystemclassloader\",{\"1\":{\"318\":1}}],[\"getbyid\",{\"1\":{\"396\":1}}],[\"getbit\",{\"1\":{\"229\":1,\"230\":1}}],[\"getmap\",{\"1\":{\"382\":2}}],[\"getteachernum\",{\"1\":{\"358\":1}}],[\"getusernum\",{\"1\":{\"358\":1}}],[\"getinstance\",{\"1\":{\"329\":1,\"330\":1,\"331\":1,\"332\":1,\"333\":1,\"362\":1}}],[\"getdeclaredmethod\",{\"1\":{\"319\":1}}],[\"getclassloadinglock\",{\"1\":{\"497\":1}}],[\"getclass\",{\"1\":{\"318\":1}}],[\"getname\",{\"1\":{\"316\":2}}],[\"getlast\",{\"1\":{\"258\":1}}],[\"getlock\",{\"1\":{\"206\":1}}],[\"getlockname\",{\"1\":{\"206\":1}}],[\"getlockwatchdogtimeout\",{\"1\":{\"206\":2}}],[\"getrawname\",{\"1\":{\"206\":2}}],[\"get\",{\"1\":{\"40\":7,\"204\":1,\"214\":1,\"215\":2,\"381\":1,\"383\":1,\"396\":2}}],[\"get和post的区别\",{\"0\":{\"40\":1}}],[\"groupid>\",{\"1\":{\"324\":1}}],[\"group\",{\"1\":{\"108\":1}}],[\"garbage\",{\"1\":{\"467\":2}}],[\"gap\",{\"1\":{\"103\":1,\"156\":1}}],[\"gateway\",{\"1\":{\"39\":3,\"44\":2}}],[\"gone\",{\"1\":{\"46\":1}}],[\"边界网关协议\",{\"1\":{\"39\":1}}],[\"边扫描边观察算法\",{\"1\":{\"16\":1}}],[\"使得上面的结构可以保持键值对的插入顺序\",{\"1\":{\"251\":1}}],[\"使得新的\",{\"1\":{\"244\":1}}],[\"使得集合中的元素能够按\",{\"1\":{\"225\":1}}],[\"使得树始终平衡\",{\"1\":{\"126\":1}}],[\"使得外部网络无法直接访问内部网络中的设备\",{\"1\":{\"76\":1}}],[\"使得多个进程可以访问同一块内存空间\",{\"1\":{\"9\":1}}],[\"使用双亲委派通过启动类加载器bootstrapclassloader发现这个类已经加载了\",{\"1\":{\"498\":1}}],[\"使用这两个调用就要先使用findstaticvarhandle来初始化要调用的类\",{\"1\":{\"489\":1}}],[\"使用这些命令就会使用主线程之外的其他线程来异步处理\",{\"1\":{\"195\":1}}],[\"使用java\",{\"1\":{\"489\":1}}],[\"使用多个\",{\"1\":{\"467\":1}}],[\"使用多线程和\",{\"1\":{\"465\":1}}],[\"使用软引用的情况较多\",{\"1\":{\"453\":1}}],[\"使用空闲列表的gc收集器\",{\"1\":{\"433\":1}}],[\"使用指针碰撞分配方式的gc收集器\",{\"1\":{\"433\":1}}],[\"使用链表作为其数据结构\",{\"1\":{\"413\":1}}],[\"使用链表实现\",{\"1\":{\"410\":1}}],[\"使用跳表的数据结构进行快速查找\",{\"1\":{\"410\":1}}],[\"使用await\",{\"1\":{\"409\":1}}],[\"使用完毕后\",{\"1\":{\"408\":1}}],[\"使用线程池的好处\",{\"1\":{\"386\":1}}],[\"使用volatile关键字可以禁止指令进行重排序优化\",{\"1\":{\"360\":1}}],[\"使用动态代理类调用方法的时候\",{\"1\":{\"323\":1}}],[\"使用代理对象来代替真实对象的访问\",{\"1\":{\"320\":1}}],[\"使用final修饰则看成常量\",{\"1\":{\"308\":1}}],[\"使用bigdecimal类进行浮点数运算\",{\"1\":{\"283\":1}}],[\"使用bgrewriteaof可以手动让aof文件执行重写功能\",{\"1\":{\"244\":1}}],[\"使用二叉堆实现结构\",{\"1\":{\"260\":1}}],[\"使用键值对存储\",{\"1\":{\"250\":1}}],[\"使用场景\",{\"1\":{\"246\":1}}],[\"使用顺序节点之后\",{\"1\":{\"210\":1}}],[\"使用起来非常简单\",{\"1\":{\"206\":1}}],[\"使用单线程的多路\",{\"1\":{\"172\":1}}],[\"使用两阶段提交后\",{\"1\":{\"152\":1}}],[\"使用索引的建议\",{\"0\":{\"138\":1}}],[\"使用索引可以大大加快数据的检索速度\",{\"1\":{\"121\":1}}],[\"使用联合索引时存在最左匹配原则\",{\"1\":{\"136\":1}}],[\"使用表中的多个字段创建搜因\",{\"1\":{\"135\":1}}],[\"使用表中的多个字段创建索引\",{\"1\":{\"135\":1}}],[\"使用普通索引作为查询条件\",{\"1\":{\"108\":1}}],[\"使用innodb的数据库在异常崩溃之后\",{\"1\":{\"93\":1}}],[\"使用的都是非聚簇索引\",{\"1\":{\"132\":1}}],[\"使用的流量控制协议是可变大小的滑动窗口协议\",{\"1\":{\"64\":1}}],[\"使用的第一个重要协议\",{\"1\":{\"49\":1}}],[\"使用\",{\"0\":{\"56\":2,\"186\":1,\"188\":1,\"189\":1,\"190\":1},\"1\":{\"41\":1,\"45\":1,\"107\":1,\"154\":1,\"156\":1,\"166\":1,\"184\":1,\"190\":1,\"210\":1,\"235\":1,\"246\":1,\"405\":1,\"407\":1,\"483\":1}}],[\"使用put请求时\",{\"1\":{\"41\":1}}],[\"使用固定的跳数作为度量标准\",{\"1\":{\"39\":1}}],[\"工具就使用了\",{\"1\":{\"39\":1}}],[\"常量\",{\"1\":{\"343\":1}}],[\"常量池主要存放两大常量\",{\"1\":{\"476\":1}}],[\"常量池计数器是从\",{\"1\":{\"476\":1}}],[\"常量池的数量是\",{\"1\":{\"476\":1}}],[\"常量池的数量\",{\"1\":{\"476\":1}}],[\"常量池\",{\"0\":{\"476\":1},\"1\":{\"476\":1}}],[\"常量池表会在类加载后存放到方法区的运行时常量池中\",{\"1\":{\"429\":1}}],[\"常量池等信息\",{\"1\":{\"342\":1}}],[\"常量池中每一项常量都是一个表\",{\"1\":{\"476\":1}}],[\"常量池中的对象\",{\"1\":{\"308\":2}}],[\"常量池中创建的对象\",{\"1\":{\"308\":1}}],[\"常规数据\",{\"1\":{\"182\":1}}],[\"常用来封装\",{\"1\":{\"395\":1}}],[\"常用命令\",{\"0\":{\"214\":1,\"217\":1,\"220\":1,\"223\":1,\"226\":1,\"229\":1,\"232\":1,\"235\":1}}],[\"常用的为hotspot\",{\"1\":{\"275\":1}}],[\"常用的过期数据的删除策略就两个\",{\"1\":{\"200\":1}}],[\"常用的数据结构有哪些\",{\"0\":{\"181\":1}}],[\"常用于生产者\",{\"1\":{\"261\":1,\"414\":1}}],[\"常用于使用主键或唯一索引的所有字段作为连表条件\",{\"1\":{\"108\":1}}],[\"常用于使用主键或唯一索引的所有字段作为查询条件\",{\"1\":{\"108\":1}}],[\"常用于网络诊断和故障排除\",{\"1\":{\"39\":1}}],[\"常见规则\",{\"0\":{\"359\":1}}],[\"常见于\",{\"1\":{\"108\":1}}],[\"常见的符号引用包括类符号引用\",{\"1\":{\"429\":1}}],[\"常见的阻塞队列\",{\"1\":{\"390\":1}}],[\"常见的缓存读写策略\",{\"0\":{\"174\":1}}],[\"常见的导致索引失效的情况\",{\"1\":{\"143\":1}}],[\"常见的分片算法有哪些\",{\"0\":{\"118\":1}}],[\"常见的值如下\",{\"1\":{\"108\":1}}],[\"常见的网络协议\",{\"0\":{\"36\":1}}],[\"常见的磁盘调度算法有哪些\",{\"0\":{\"16\":1}}],[\"互斥\",{\"1\":{\"202\":1,\"346\":1}}],[\"互斥锁\",{\"1\":{\"7\":1}}],[\"互联网中每一个资源都由\",{\"1\":{\"78\":1}}],[\"互联网服务提供商\",{\"1\":{\"50\":1}}],[\"互联网控制报文协议\",{\"1\":{\"39\":1}}],[\"一定会配置上打印\",{\"1\":{\"507\":1}}],[\"一定要保证设置指定key的值和过期时间是一个原子操作\",{\"1\":{\"205\":1}}],[\"一共有两种指定新生代内存大小的办法\",{\"1\":{\"503\":1}}],[\"一半作为to\",{\"1\":{\"458\":1}}],[\"一半作为from区\",{\"1\":{\"458\":1}}],[\"一部分用于存储对象自身的运行时数据\",{\"1\":{\"437\":1}}],[\"一块很小的内存区域\",{\"1\":{\"423\":1}}],[\"一段时间之后\",{\"1\":{\"394\":1}}],[\"一大\",{\"1\":{\"289\":1}}],[\"一切就从这里开始吧\",{\"1\":{\"274\":1}}],[\"一直等到队列可以放入新元素时再放入\",{\"1\":{\"261\":1,\"414\":1}}],[\"一旦发现被查找的元素处于两个元素值的区间\",{\"1\":{\"418\":1}}],[\"一旦创建\",{\"1\":{\"415\":1}}],[\"一旦创建就一直存在即使\",{\"1\":{\"210\":1}}],[\"一旦线程申请了锁\",{\"1\":{\"378\":1}}],[\"一旦没有分配足够长度的内存空间\",{\"1\":{\"184\":1}}],[\"一些特殊的场景可能会需要使用可重入的分布式锁\",{\"1\":{\"207\":1}}],[\"一些概念\",{\"1\":{\"84\":1}}],[\"一样\",{\"1\":{\"151\":1,\"176\":1}}],[\"一行记录就占用很少的空间\",{\"1\":{\"148\":1}}],[\"一行一行遍历肯定是不行\",{\"1\":{\"105\":1}}],[\"一边写一边后移\",{\"1\":{\"147\":1}}],[\"一张表允许创建多个普通索引\",{\"1\":{\"129\":1}}],[\"一张表允许创建多个唯一索引\",{\"1\":{\"129\":1}}],[\"一张表只能有一个主键\",{\"1\":{\"128\":1}}],[\"一次操作或者多次操作\",{\"1\":{\"360\":1}}],[\"一次性分配所需要的所有资源\",{\"1\":{\"347\":1}}],[\"一次编译\",{\"1\":{\"276\":1}}],[\"一次查询就可以找到\",{\"1\":{\"108\":1}}],[\"一次握手\",{\"1\":{\"58\":1}}],[\"一锁就锁整张表\",{\"1\":{\"102\":1}}],[\"一致性锁定读\",{\"1\":{\"106\":1}}],[\"一致性非锁定读和锁定读\",{\"0\":{\"157\":1}}],[\"一致性非锁定读\",{\"0\":{\"158\":1},\"1\":{\"106\":1,\"158\":1}}],[\"一致性才能得到保障\",{\"1\":{\"96\":1}}],[\"一致性consistency\",{\"1\":{\"96\":1}}],[\"一个类可以有个多个方法\",{\"1\":{\"480\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"478\":1}}],[\"一个类会可以有个字段\",{\"1\":{\"479\":1}}],[\"一个类只能extends一个类\",{\"1\":{\"296\":1}}],[\"一个是自己写的\",{\"1\":{\"498\":1}}],[\"一个是jre里面的\",{\"1\":{\"498\":1}}],[\"一个是最终标记\",{\"1\":{\"470\":1}}],[\"一个是重新标记\",{\"1\":{\"470\":1}}],[\"一个是初始标记\",{\"1\":{\"470\":2}}],[\"一个是原始快照\",{\"1\":{\"468\":1}}],[\"一个是增量更新\",{\"1\":{\"468\":1}}],[\"一个是在字符串常量池中创建的\",{\"1\":{\"306\":1}}],[\"一个region复制到另外一个region\",{\"1\":{\"467\":1}}],[\"一个时刻同时执行\",{\"1\":{\"462\":1}}],[\"一个时间段内同时执行\",{\"1\":{\"462\":1}}],[\"一个节点表示一个线程\",{\"1\":{\"405\":1}}],[\"一个节点获取了锁之后\",{\"1\":{\"202\":1}}],[\"一个线程内\",{\"1\":{\"359\":1}}],[\"一个注重内部属性\",{\"1\":{\"292\":1}}],[\"一个注重过程\",{\"1\":{\"292\":1}}],[\"一个最基本的分布式锁需要满足\",{\"1\":{\"202\":1}}],[\"一个没有提交事务的\",{\"1\":{\"146\":1}}],[\"一个事务被提交之后\",{\"1\":{\"96\":1}}],[\"一个用户的事物不被其他事务所干扰\",{\"1\":{\"96\":1}}],[\"一个进程只需要\",{\"1\":{\"12\":1}}],[\"一个进程的父进程已经终止或者不存在\",{\"1\":{\"10\":1}}],[\"一个进程能有很多个线程\",{\"1\":{\"340\":1}}],[\"一个进程能在运行的时候产生多个线程\",{\"1\":{\"339\":1}}],[\"一个进程能创建多个线程\",{\"1\":{\"6\":1}}],[\"一个进程能拥有很多个线程\",{\"1\":{\"5\":1}}],[\"一对一\",{\"1\":{\"89\":1}}],[\"一对多\",{\"1\":{\"53\":1,\"89\":1}}],[\"一般配合parnew使用\",{\"1\":{\"468\":1}}],[\"一般将\",{\"1\":{\"459\":1}}],[\"一般情况很难出现碰撞\",{\"1\":{\"269\":1}}],[\"一般像\",{\"1\":{\"173\":1}}],[\"一般都用来当做缓存使用\",{\"1\":{\"172\":1}}],[\"一般在没有使用到索引的时候会出现\",{\"1\":{\"108\":1}}],[\"一般的开发人员很少使用\",{\"1\":{\"87\":1}}],[\"一般是通过\",{\"1\":{\"179\":1}}],[\"一般是\",{\"1\":{\"55\":1}}],[\"一般用于即时通信\",{\"1\":{\"54\":1}}],[\"一种建立在关系模型基础上的数据库\",{\"1\":{\"89\":1}}],[\"一种用途是在\",{\"1\":{\"464\":1}}],[\"一种用来在路由选择域之间交换网络层可达性信息\",{\"1\":{\"39\":1}}],[\"一种用于传输网络状态和错误消息的协议\",{\"1\":{\"39\":1}}],[\"一种内部网关协议\",{\"1\":{\"39\":2}}],[\"一种是过去的\",{\"1\":{\"39\":1}}],[\"无用的类\",{\"1\":{\"455\":2}}],[\"无锁状态\",{\"1\":{\"397\":1}}],[\"无界队列\",{\"1\":{\"390\":1}}],[\"无效\",{\"1\":{\"368\":1}}],[\"无法被父类加载器加载的类最终会通过这个方法被加载\",{\"1\":{\"495\":1,\"499\":1}}],[\"无法处理浮动垃圾\",{\"1\":{\"466\":1}}],[\"无法在任何地方通过反射访问该类的方法\",{\"1\":{\"455\":1}}],[\"无法通知gc回收器回收它们\",{\"1\":{\"449\":1}}],[\"无法访问其他线程的本地内存\",{\"1\":{\"356\":1}}],[\"无法实现虚拟主机\",{\"1\":{\"46\":1}}],[\"无符号右移\",{\"1\":{\"267\":1}}],[\"无序\",{\"1\":{\"251\":1}}],[\"无状态地址自动配置\",{\"1\":{\"75\":1}}],[\"无差错\",{\"1\":{\"53\":1}}],[\"无论这两个操作是不是在同一个线程里\",{\"1\":{\"358\":1}}],[\"无论这个事务多大\",{\"1\":{\"151\":1}}],[\"无论创建了多少个类实例\",{\"1\":{\"286\":1}}],[\"无论事务是否成功\",{\"1\":{\"96\":1}}],[\"无论\",{\"1\":{\"40\":1}}],[\"无连接\",{\"1\":{\"38\":1}}],[\"无名管道\",{\"1\":{\"9\":1}}],[\"可选\",{\"1\":{\"507\":1}}],[\"可选的扩展头\",{\"1\":{\"75\":1}}],[\"可预测的停顿\",{\"1\":{\"467\":1}}],[\"可用内存缩小为原来的一半\",{\"1\":{\"458\":1}}],[\"可用内存变小\",{\"1\":{\"458\":1}}],[\"可用运算符有\",{\"1\":{\"229\":1}}],[\"可有可无的\",{\"1\":{\"453\":2}}],[\"可达性分析中不可达的对象被第一次标记并且进行一次筛选\",{\"1\":{\"452\":1}}],[\"可达性分析\",{\"0\":{\"450\":1}}],[\"可传入\",{\"1\":{\"395\":1}}],[\"可创建的最大线程数\",{\"1\":{\"387\":1}}],[\"可中断锁\",{\"1\":{\"378\":1}}],[\"可中断锁和不可中断锁有什么区别\",{\"0\":{\"378\":1}}],[\"可实现选择性通知\",{\"1\":{\"377\":1}}],[\"可实现公平锁\",{\"1\":{\"377\":1}}],[\"可见性\",{\"1\":{\"360\":1,\"362\":1}}],[\"可串行化\",{\"1\":{\"156\":1}}],[\"可能存在所有的新生代对象都在这次gc之后晋升至老年代\",{\"1\":{\"447\":1}}],[\"可能存在数据丢失的风险\",{\"1\":{\"238\":1}}],[\"可能1\",{\"1\":{\"358\":1}}],[\"可能就修改了几byte数据\",{\"1\":{\"148\":1}}],[\"可能会崩溃\",{\"1\":{\"509\":1}}],[\"可能会受到本机内存的限制\",{\"1\":{\"428\":1}}],[\"可能会创建大量线程\",{\"1\":{\"390\":1}}],[\"可能会阻塞后续其他命令的执行\",{\"1\":{\"243\":1}}],[\"可能会影响性能\",{\"1\":{\"195\":1}}],[\"可能会导致锁无法被释放\",{\"1\":{\"204\":1}}],[\"可能会导致脏读\",{\"1\":{\"156\":1}}],[\"可能会导致树的高度较高\",{\"1\":{\"126\":1}}],[\"可能会二次查询\",{\"1\":{\"132\":1}}],[\"可能还没有到达叶子节点\",{\"1\":{\"127\":1}}],[\"可能还有一些数据没有发完\",{\"1\":{\"61\":1}}],[\"可重复\",{\"1\":{\"253\":1}}],[\"可重复的\",{\"1\":{\"250\":2}}],[\"可重复读\",{\"1\":{\"93\":1,\"156\":2}}],[\"可重入\",{\"1\":{\"202\":1}}],[\"可重读\",{\"1\":{\"100\":1,\"156\":1}}],[\"可靠\",{\"1\":{\"38\":1}}],[\"可以有效防止恶意代码的执行\",{\"1\":{\"486\":1}}],[\"可以理解的代码就叫做字节码\",{\"1\":{\"472\":1}}],[\"可以理解为线程数是可以无限扩展的\",{\"1\":{\"390\":1}}],[\"可以理解为\",{\"1\":{\"78\":1}}],[\"可以不需要其他收集器配合就能独立管理整个\",{\"1\":{\"467\":1}}],[\"可以\",{\"1\":{\"455\":1}}],[\"可以维护系统的运行安全\",{\"1\":{\"453\":1}}],[\"可以作为\",{\"0\":{\"451\":1}}],[\"可以确保是安全的\",{\"1\":{\"447\":1}}],[\"可以通过getparent\",{\"1\":{\"494\":1}}],[\"可以通过参数\",{\"1\":{\"445\":1}}],[\"可以通过\",{\"1\":{\"430\":1,\"445\":1}}],[\"可以通过binlog\",{\"1\":{\"150\":1,\"151\":1}}],[\"可以简单理解为一个固定大小的hashtable\",{\"1\":{\"430\":1}}],[\"可以简单理解为每个索引都对应着一颗\",{\"1\":{\"142\":1}}],[\"可以当做无界队列也可以当做有界队列来使用\",{\"1\":{\"416\":1}}],[\"可以分为阻塞队列和非阻塞队列\",{\"1\":{\"413\":1}}],[\"可以从顶级链表开始找\",{\"1\":{\"418\":1}}],[\"可以从\",{\"1\":{\"394\":1}}],[\"可以保证每次出队的任务都是当前队列中执行时间最靠前的\",{\"1\":{\"390\":1}}],[\"可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行\",{\"1\":{\"370\":1}}],[\"可以保证数据库表中每一行数据的唯一性\",{\"1\":{\"121\":1}}],[\"可以把多个变量放在一个对象里来进行\",{\"1\":{\"368\":1}}],[\"可以在重新标记前进行一次垃圾回收\",{\"1\":{\"518\":1}}],[\"可以在等待一段时间之后自行返回\",{\"1\":{\"344\":1}}],[\"可以在子类中被重新定义\",{\"1\":{\"296\":1}}],[\"可以在非聚簇索引遍历过程中\",{\"1\":{\"137\":1}}],[\"可以随机访问\",{\"1\":{\"255\":1}}],[\"可以重复\",{\"1\":{\"250\":1}}],[\"可以容忍数据部分不完整\",{\"1\":{\"246\":1}}],[\"可以选择使用\",{\"1\":{\"246\":1}}],[\"可以轻松地导出\",{\"1\":{\"246\":1}}],[\"可以轻松实现两个位置距离的计算\",{\"1\":{\"234\":1}}],[\"可以加载aof文件进行数据恢复\",{\"1\":{\"241\":1}}],[\"可以组成一个\",{\"1\":{\"228\":1}}],[\"可以非常方便的实现如共同关注\",{\"1\":{\"222\":1}}],[\"可以看做一个线程安全的\",{\"1\":{\"410\":1}}],[\"可以看做是命令日志文件\",{\"1\":{\"240\":1}}],[\"可以看做是hash表\",{\"1\":{\"199\":1}}],[\"可以看做是不同主机之间的进程进行双向通信的端点\",{\"1\":{\"9\":1}}],[\"可以看成常量\",{\"1\":{\"303\":1}}],[\"可以看出\",{\"1\":{\"210\":1}}],[\"可以给出任何文件名\",{\"1\":{\"508\":1}}],[\"可以给锁添加一个过期时间\",{\"1\":{\"205\":1}}],[\"可以给全球每个设备一个独立的地址\",{\"1\":{\"75\":1}}],[\"可以获取部分字段的信息\",{\"1\":{\"183\":1}}],[\"可以用来控制同时访问特定资源的线程数量\",{\"1\":{\"407\":1}}],[\"可以用来存储任何类型的数据比如字符串\",{\"1\":{\"182\":1,\"213\":1}}],[\"可以用来标识一个资源\",{\"1\":{\"47\":1}}],[\"可以短暂地允许数据库和缓存数据不一致的场景\",{\"1\":{\"175\":1}}],[\"可以先删除\",{\"1\":{\"175\":1}}],[\"可以将多个异步任务串联起来\",{\"1\":{\"396\":1}}],[\"可以将threadlocal类形象的比喻成存放数据的盒子\",{\"1\":{\"381\":1}}],[\"可以将不用的数据放到磁盘上\",{\"1\":{\"172\":1}}],[\"可以将内存中的数据保持在磁盘中\",{\"1\":{\"172\":1}}],[\"可以将ip地址转换成整形数据存储\",{\"1\":{\"107\":1}}],[\"可以阻止脏读和不可重复读\",{\"1\":{\"156\":1}}],[\"可以阻止脏读\",{\"1\":{\"156\":1}}],[\"可以提高\",{\"1\":{\"245\":1}}],[\"可以提升性能\",{\"1\":{\"151\":1}}],[\"可以提供该资源的路径\",{\"1\":{\"47\":1}}],[\"可以设置为n\",{\"1\":{\"151\":1}}],[\"可以设置为1\",{\"1\":{\"151\":1}}],[\"可以由参数sync\",{\"1\":{\"151\":1}}],[\"可以定位到符合a>1条件的第一条记录\",{\"1\":{\"136\":1}}],[\"可以解决单一表数据量过大的问题\",{\"1\":{\"116\":1}}],[\"可以是垂直拆分\",{\"1\":{\"116\":1}}],[\"可以垂直分库\",{\"1\":{\"115\":1}}],[\"可以更准确的理解\",{\"1\":{\"108\":1}}],[\"可以更新整个资源\",{\"1\":{\"41\":1}}],[\"可以使用以下参数声明这些实现\",{\"1\":{\"506\":1}}],[\"可以使用cglib动态代理\",{\"1\":{\"324\":1}}],[\"可以使用日期\",{\"1\":{\"189\":1}}],[\"可以使用\",{\"1\":{\"108\":1,\"381\":1}}],[\"可以避免类的重复加载\",{\"1\":{\"498\":1}}],[\"可以避免缓冲区溢出\",{\"1\":{\"184\":1}}],[\"可以避免\",{\"1\":{\"55\":1}}],[\"可以唯一标识一个资源\",{\"1\":{\"47\":1}}],[\"可以创建新的资源或提交数据到服务器进行处理\",{\"1\":{\"41\":1}}],[\"可以屏蔽操作系统和文件存储方式\",{\"1\":{\"37\":1,\"56\":1}}],[\"可以说这是最有用的进程间通信方式\",{\"1\":{\"9\":1}}],[\"可以实现本机任意两个进程通信\",{\"1\":{\"9\":1}}],[\"面对内存不足错误是非常常见的\",{\"1\":{\"508\":1}}],[\"面向用户的加载器\",{\"1\":{\"494\":1}}],[\"面向整堆进行收集\",{\"1\":{\"468\":1}}],[\"面向过程把解决问题的过程拆成一个个方法\",{\"1\":{\"292\":1}}],[\"面向对象的三个特征\",{\"0\":{\"295\":1}}],[\"面向对象会先抽象出对象\",{\"1\":{\"292\":1}}],[\"面向对象和面向过程的区别\",{\"0\":{\"292\":1}}],[\"面向对象\",{\"0\":{\"291\":1}}],[\"面向连接\",{\"1\":{\"38\":1}}],[\"面经\",{\"1\":{\"0\":1}}],[\"传入\",{\"1\":{\"395\":1}}],[\"传入类路径获取\",{\"1\":{\"318\":1}}],[\"传入类的全路径名\",{\"1\":{\"318\":1}}],[\"传递规则\",{\"1\":{\"359\":1}}],[\"传递函数依赖会导致数据冗余和异常\",{\"1\":{\"84\":1}}],[\"传递函数依赖于\",{\"1\":{\"84\":1}}],[\"传递函数依赖\",{\"1\":{\"84\":1}}],[\"传输可靠性保障\",{\"0\":{\"63\":1}}],[\"传输形式\",{\"1\":{\"53\":1}}],[\"传输效率\",{\"1\":{\"53\":1}}],[\"传输是有状态的\",{\"1\":{\"53\":1}}],[\"传输控制协议\",{\"1\":{\"38\":1}}],[\"传输层\",{\"0\":{\"38\":1,\"57\":1,\"63\":1}}],[\"传统的bio模型是无能为力的\",{\"1\":{\"21\":1}}],[\"d\",{\"1\":{\"308\":2}}],[\"dirs\",{\"1\":{\"494\":1}}],[\"discardoldestpolicy\",{\"1\":{\"389\":1}}],[\"discardpolicy\",{\"1\":{\"389\":1}}],[\"distance\",{\"1\":{\"235\":3}}],[\"dict\",{\"1\":{\"201\":1}}],[\"double\",{\"1\":{\"278\":1}}],[\"dog\",{\"1\":{\"206\":6}}],[\"domain\",{\"1\":{\"37\":1,\"49\":1,\"56\":1}}],[\"db\",{\"1\":{\"153\":2,\"160\":2,\"161\":3,\"175\":6,\"176\":5,\"177\":6,\"201\":5}}],[\"dba\",{\"1\":{\"87\":1}}],[\"dump\",{\"1\":{\"113\":1}}],[\"default\",{\"1\":{\"489\":1}}],[\"definition\",{\"1\":{\"87\":1}}],[\"dependency>\",{\"1\":{\"324\":1}}],[\"debuginvocationhandler\",{\"1\":{\"316\":2}}],[\"deque\",{\"1\":{\"258\":1}}],[\"deque是双端队列\",{\"1\":{\"258\":1}}],[\"desc\",{\"1\":{\"235\":1}}],[\"destkey\",{\"1\":{\"229\":1,\"232\":3}}],[\"destination\",{\"1\":{\"223\":6,\"226\":4}}],[\"desk2\",{\"1\":{\"189\":2}}],[\"desk1\",{\"1\":{\"189\":2}}],[\"decr\",{\"1\":{\"214\":1,\"215\":1}}],[\"delegation\",{\"1\":{\"496\":1}}],[\"deleted\",{\"1\":{\"161\":1}}],[\"delete操作\",{\"1\":{\"106\":1}}],[\"delete\",{\"0\":{\"86\":1},\"1\":{\"86\":2,\"106\":1,\"158\":1,\"159\":2,\"161\":1,\"166\":1}}],[\"delayedworkqueue\",{\"1\":{\"390\":3}}],[\"delayedworkqueue延迟阻塞队列\",{\"1\":{\"387\":1}}],[\"del\",{\"1\":{\"204\":3,\"214\":1}}],[\"derived\",{\"1\":{\"108\":2}}],[\"ddl\",{\"0\":{\"87\":1},\"1\":{\"87\":2}}],[\"dml\",{\"0\":{\"87\":1},\"1\":{\"87\":3}}],[\"drop\",{\"0\":{\"86\":1},\"1\":{\"86\":2}}],[\"dynamic\",{\"1\":{\"75\":1,\"184\":1,\"213\":1}}],[\"dhcp\",{\"1\":{\"56\":1,\"75\":1}}],[\"dns是应用层协议\",{\"1\":{\"49\":1}}],[\"dns\",{\"0\":{\"48\":1,\"49\":1,\"50\":1},\"1\":{\"37\":1,\"43\":1,\"49\":2,\"50\":12,\"56\":2}}],[\"dangling\",{\"1\":{\"15\":1}}],[\"database\",{\"1\":{\"238\":1}}],[\"datagram\",{\"1\":{\"38\":1}}],[\"data\",{\"1\":{\"15\":1,\"87\":2,\"127\":1}}],[\"u1\",{\"1\":{\"476\":1}}],[\"u2\",{\"1\":{\"475\":2,\"476\":1,\"477\":1,\"478\":4,\"479\":1,\"480\":1,\"481\":1}}],[\"u4\",{\"1\":{\"474\":1}}],[\"util\",{\"1\":{\"364\":1,\"403\":1,\"410\":1}}],[\"uv\",{\"0\":{\"190\":1},\"1\":{\"187\":1,\"190\":4,\"224\":1,\"233\":1}}],[\"up\",{\"1\":{\"162\":2}}],[\"update\",{\"1\":{\"106\":2,\"150\":2,\"158\":2,\"159\":4,\"166\":2}}],[\"usegcoverheadlimit\",{\"1\":{\"508\":1}}],[\"used\",{\"1\":{\"201\":4}}],[\"usernum\",{\"1\":{\"358\":2}}],[\"usern\",{\"1\":{\"190\":1}}],[\"user2\",{\"1\":{\"190\":1}}],[\"user1\",{\"1\":{\"190\":1}}],[\"user\",{\"1\":{\"38\":1}}],[\"using\",{\"1\":{\"108\":6,\"483\":1}}],[\"u\",{\"1\":{\"84\":2}}],[\"unloading\",{\"1\":{\"483\":1}}],[\"unlock\",{\"1\":{\"206\":1}}],[\"undo\",{\"0\":{\"153\":1,\"163\":1},\"1\":{\"153\":3,\"154\":1,\"160\":2,\"161\":1,\"163\":2}}],[\"uncommitted\",{\"1\":{\"97\":3,\"156\":2}}],[\"unit\",{\"1\":{\"388\":2,\"502\":2,\"503\":1}}],[\"uniquevalue\",{\"1\":{\"204\":2,\"205\":2}}],[\"unique\",{\"1\":{\"108\":1}}],[\"union\",{\"1\":{\"108\":6}}],[\"uniform\",{\"1\":{\"47\":2}}],[\"unix\",{\"1\":{\"19\":1}}],[\"unmodified\",{\"1\":{\"46\":1}}],[\"uri\",{\"0\":{\"47\":1},\"1\":{\"41\":2,\"47\":2}}],[\"url\",{\"0\":{\"43\":1,\"47\":1},\"1\":{\"40\":6,\"45\":3,\"47\":2}}],[\"udp\",{\"0\":{\"52\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1},\"1\":{\"37\":2,\"38\":1,\"53\":7,\"54\":1,\"55\":1,\"56\":1}}],[\"实例的父类加载器\",{\"1\":{\"496\":1}}],[\"实例会在试图亲自查找类或资源之前\",{\"1\":{\"496\":2}}],[\"实例都有一个相关的父类加载器\",{\"1\":{\"496\":1}}],[\"实例变量会在对象实例化的时候随着对象一块分配在java堆中\",{\"1\":{\"487\":1}}],[\"实例数据部分是对象真正存储的有效信息\",{\"1\":{\"437\":1}}],[\"实例数据和对齐填充\",{\"1\":{\"437\":1}}],[\"实例依次请求申请加锁\",{\"1\":{\"208\":1}}],[\"实际调用的是methodinterceptor中的intercept方法\",{\"1\":{\"324\":1}}],[\"实际就是通过stringbuilder调用append\",{\"1\":{\"305\":1}}],[\"实际上\",{\"1\":{\"395\":1}}],[\"实际上初始化赋值的是一个空数组\",{\"1\":{\"253\":1}}],[\"实际上刷盘的实际是根据策略来进行的\",{\"1\":{\"145\":1}}],[\"实际只是在\",{\"1\":{\"176\":1}}],[\"实际使用的索引的最大长度\",{\"1\":{\"108\":1}}],[\"实际使用到的索引\",{\"1\":{\"108\":1}}],[\"实际给人的感觉区别也不大\",{\"1\":{\"54\":1}}],[\"实际应用中\",{\"1\":{\"16\":1}}],[\"实现且全部继承自java\",{\"1\":{\"495\":1}}],[\"实现中已经考虑了这种情况\",{\"1\":{\"383\":1}}],[\"实现可见性\",{\"1\":{\"332\":1}}],[\"实现类\",{\"1\":{\"321\":1,\"326\":1}}],[\"实现某个接口就相当于有某个责任\",{\"1\":{\"296\":1}}],[\"实现关系\",{\"1\":{\"295\":1}}],[\"实现有什么不同\",{\"0\":{\"272\":1}}],[\"实现线程安全的方式\",{\"1\":{\"271\":1}}],[\"实现sortedmap接口让\",{\"1\":{\"265\":1}}],[\"实现分布式锁的时候\",{\"1\":{\"210\":1}}],[\"实现分布式锁可靠性更高\",{\"1\":{\"209\":1}}],[\"实现分布式锁性能较高\",{\"1\":{\"209\":1}}],[\"实现分布式锁\",{\"0\":{\"203\":1,\"209\":1},\"1\":{\"206\":1}}],[\"实现一个最简易的分布式锁\",{\"0\":{\"204\":1}}],[\"实现一个最简易的分布式锁如何基于\",{\"0\":{\"204\":1}}],[\"实现一个简单的抽奖系统的话\",{\"1\":{\"188\":1}}],[\"实现一个排行榜怎么做\",{\"0\":{\"186\":1}}],[\"实现抽奖系统怎么做\",{\"0\":{\"188\":1}}],[\"实现消息队列没有广播机制的问题\",{\"1\":{\"179\":1}}],[\"实现消息队列功能太简单\",{\"1\":{\"179\":1}}],[\"实现方式比较简单\",{\"1\":{\"204\":1}}],[\"实现方式\",{\"1\":{\"127\":1}}],[\"实现了双亲委派机制\",{\"1\":{\"495\":1}}],[\"实现了\",{\"1\":{\"375\":1}}],[\"实现了invocationhandler接口的对象\",{\"1\":{\"323\":1}}],[\"实现了访问顺序相关逻辑\",{\"1\":{\"251\":1}}],[\"实现了空间预分配和惰性空间释放两种优化策略\",{\"1\":{\"184\":1}}],[\"实现了可重复读和防止快照读下的\",{\"1\":{\"166\":1}}],[\"实现了可重复读和防止部分幻读\",{\"1\":{\"158\":1}}],[\"实现了水平扩展\",{\"1\":{\"115\":1}}],[\"实现了sql标准定义的四个隔离级别\",{\"1\":{\"93\":1}}],[\"实现简单\",{\"1\":{\"102\":1}}],[\"实现的类加载器在\",{\"1\":{\"494\":1}}],[\"实现的\",{\"1\":{\"99\":1,\"153\":1,\"156\":1,\"209\":1,\"364\":1}}],[\"实现\",{\"1\":{\"37\":1,\"234\":1,\"265\":1,\"271\":2,\"323\":1,\"324\":1,\"494\":1,\"506\":1}}],[\"实时传输协议\",{\"1\":{\"37\":1}}],[\"run\",{\"1\":{\"351\":1,\"389\":1}}],[\"runnable\",{\"1\":{\"344\":1,\"382\":1,\"395\":3}}],[\"radius\",{\"1\":{\"235\":2}}],[\"random\",{\"1\":{\"201\":2}}],[\"range\",{\"1\":{\"44\":1,\"46\":1,\"108\":2}}],[\"rpop\",{\"1\":{\"217\":1}}],[\"rpush\",{\"1\":{\"217\":1}}],[\"rlock\",{\"1\":{\"206\":2}}],[\"rdb创建快照的时候会阻塞主线程吗\",{\"0\":{\"239\":1}}],[\"rdb持久化\",{\"0\":{\"238\":1}}],[\"rdb\",{\"0\":{\"246\":1},\"1\":{\"179\":1,\"197\":1,\"246\":17}}],[\"rr\",{\"0\":{\"164\":1},\"1\":{\"164\":2,\"165\":2,\"166\":1}}],[\"rc\",{\"0\":{\"164\":1},\"1\":{\"164\":2,\"165\":2}}],[\"root\",{\"1\":{\"466\":1}}],[\"roots直接引用的对象标记一遍\",{\"1\":{\"470\":1}}],[\"roots能直接关联到的对象\",{\"1\":{\"467\":1}}],[\"roots\",{\"0\":{\"451\":1},\"1\":{\"450\":2}}],[\"roll\",{\"1\":{\"153\":1,\"160\":1,\"161\":1}}],[\"rows\",{\"1\":{\"108\":2}}],[\"row\",{\"1\":{\"102\":1,\"150\":1,\"161\":1}}],[\"routing\",{\"1\":{\"39\":1}}],[\"r\",{\"1\":{\"84\":6,\"85\":1,\"260\":15,\"508\":1}}],[\"rt\",{\"1\":{\"494\":1}}],[\"rtt\",{\"1\":{\"55\":2,\"64\":1,\"66\":1}}],[\"rtp\",{\"1\":{\"37\":1}}],[\"rip\",{\"1\":{\"39\":1}}],[\"region\",{\"1\":{\"467\":2}}],[\"region中还有一类特殊的humongous区域\",{\"1\":{\"467\":1}}],[\"release\",{\"1\":{\"407\":2}}],[\"relay\",{\"1\":{\"113\":2}}],[\"rejectedexecution\",{\"1\":{\"391\":1}}],[\"rejectedexecutionexception来拒绝新任务的处理\",{\"1\":{\"389\":1}}],[\"rejectedexecutionhandler\",{\"1\":{\"388\":1}}],[\"removelast\",{\"1\":{\"258\":1}}],[\"removefirst\",{\"1\":{\"258\":1}}],[\"remove\",{\"1\":{\"258\":1,\"383\":1}}],[\"rewrite\",{\"1\":{\"241\":1,\"244\":2}}],[\"reentrantreadwritelock\",{\"1\":{\"403\":1}}],[\"reentrant\",{\"1\":{\"207\":1}}],[\"reentrantlock也可以实现\",{\"1\":{\"377\":1}}],[\"reentrantlock可以指定是公平锁还是非公平锁\",{\"1\":{\"377\":1}}],[\"reentrantlock提供了一种能够中断等待锁的线程的机制\",{\"1\":{\"377\":1}}],[\"reentrantlock\",{\"0\":{\"374\":1,\"375\":1,\"377\":1},\"1\":{\"207\":1,\"272\":1,\"375\":3,\"377\":2,\"378\":1,\"403\":1,\"407\":1,\"415\":1}}],[\"renewexpirationasync\",{\"1\":{\"206\":2}}],[\"return\",{\"1\":{\"204\":2,\"206\":5,\"267\":1,\"316\":1,\"329\":1,\"330\":1,\"331\":1,\"332\":1,\"333\":1,\"362\":1,\"382\":1,\"396\":1,\"497\":1}}],[\"redlock\",{\"1\":{\"207\":1,\"208\":2}}],[\"redis能在后台自动重写aof产生一个新的aof文件\",{\"1\":{\"244\":1}}],[\"redis就会将命令写入到aof缓冲区中\",{\"1\":{\"240\":1}}],[\"redis处理的每一个命令都会记录在aof文件中\",{\"1\":{\"240\":1}}],[\"redis提供了两个命令来生成rdb快照文件\",{\"1\":{\"239\":1}}],[\"redis停机时会自动执行一次rdb\",{\"1\":{\"238\":1}}],[\"redis自己构建了一种\",{\"1\":{\"213\":1}}],[\"rediscommands\",{\"1\":{\"206\":1}}],[\"redis内存淘汰机制\",{\"0\":{\"201\":1}}],[\"redis内存管理\",{\"0\":{\"198\":1}}],[\"redis通过过期字典\",{\"1\":{\"199\":1}}],[\"redis通过io多路复用程序来监听来自客户端的大量连接\",{\"1\":{\"194\":1}}],[\"redis是如何判断数据是否过期的\",{\"1\":{\"199\":1}}],[\"redis中除了字符串类型有自己独有设置过期时间的命令setex外\",{\"1\":{\"199\":1}}],[\"redis给缓存数据设置过期时间有啥用\",{\"0\":{\"199\":1}}],[\"redis后台线程了解吗\",{\"0\":{\"197\":1}}],[\"redis的性能瓶颈不再cpu\",{\"1\":{\"195\":1}}],[\"redis基于reactor模式设计开发了一套高效的事件处理模型\",{\"1\":{\"193\":1}}],[\"redis基础一\",{\"0\":{\"168\":1}}],[\"redis单线程了解吗\",{\"0\":{\"193\":1}}],[\"redis一直是单线程模型\",{\"1\":{\"192\":1}}],[\"redis读写单线程\",{\"1\":{\"192\":1}}],[\"redis线程模型\",{\"0\":{\"192\":1}}],[\"redis持久化\",{\"0\":{\"191\":1,\"237\":1},\"1\":{\"191\":1}}],[\"redis数据结构\",{\"0\":{\"212\":1},\"1\":{\"180\":1}}],[\"redisson\",{\"1\":{\"179\":2,\"206\":6,\"207\":1}}],[\"redis\",{\"0\":{\"170\":1,\"171\":1,\"172\":1,\"173\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":1,\"186\":1,\"195\":1,\"196\":1,\"203\":1,\"204\":2,\"208\":1,\"247\":1},\"1\":{\"170\":7,\"171\":4,\"172\":11,\"173\":3,\"179\":10,\"182\":1,\"184\":4,\"186\":2,\"187\":1,\"192\":1,\"193\":1,\"196\":1,\"197\":1,\"199\":1,\"201\":1,\"204\":4,\"206\":6,\"208\":15,\"209\":1,\"210\":1,\"212\":2,\"213\":3,\"216\":2,\"218\":2,\"219\":2,\"222\":1,\"231\":4,\"238\":1,\"244\":3,\"245\":4,\"246\":5}}],[\"redo\",{\"0\":{\"145\":1,\"148\":1},\"1\":{\"91\":1,\"145\":2,\"146\":5,\"147\":6,\"148\":1,\"149\":1,\"151\":1,\"152\":3,\"154\":1}}],[\"redolog\",{\"1\":{\"91\":1}}],[\"referencequeue\",{\"1\":{\"453\":1}}],[\"reference\",{\"1\":{\"439\":1,\"440\":1}}],[\"reflect包的方法对类进行反射调用时如果类没有初始化\",{\"1\":{\"489\":1}}],[\"reflect\",{\"1\":{\"324\":1}}],[\"ref\",{\"1\":{\"108\":5}}],[\"resultset\",{\"1\":{\"512\":1}}],[\"result\",{\"1\":{\"108\":1,\"316\":2}}],[\"resove\",{\"1\":{\"495\":1}}],[\"resolveclass\",{\"1\":{\"495\":1,\"497\":1}}],[\"resolve\",{\"1\":{\"495\":1,\"497\":2}}],[\"resolution\",{\"1\":{\"39\":1,\"79\":1,\"483\":1}}],[\"resources\",{\"1\":{\"494\":1}}],[\"resource\",{\"1\":{\"47\":2}}],[\"recently\",{\"1\":{\"201\":2}}],[\"record\",{\"1\":{\"103\":3,\"156\":1,\"161\":1,\"166\":1}}],[\"recv\",{\"1\":{\"58\":1}}],[\"request\",{\"1\":{\"67\":1}}],[\"request代表客户端的请求服务器理解不了\",{\"1\":{\"44\":1}}],[\"repeatable\",{\"1\":{\"97\":1,\"99\":1,\"100\":1,\"103\":1,\"156\":5,\"158\":2,\"159\":1}}],[\"repeat\",{\"1\":{\"67\":1}}],[\"reactor\",{\"1\":{\"171\":1}}],[\"reachability\",{\"1\":{\"39\":1}}],[\"real\",{\"1\":{\"37\":1}}],[\"readwritelock\",{\"1\":{\"207\":1}}],[\"readview\",{\"0\":{\"162\":1}}],[\"read调用的过程\",{\"1\":{\"22\":1}}],[\"read\",{\"0\":{\"176\":1},\"1\":{\"7\":1,\"93\":1,\"97\":6,\"99\":2,\"100\":1,\"103\":1,\"153\":3,\"156\":9,\"158\":4,\"159\":5,\"160\":3,\"162\":3,\"164\":1,\"165\":2,\"166\":2,\"176\":5,\"177\":2}}],[\"安全性没有\",{\"1\":{\"45\":1}}],[\"安全性和资源消耗\",{\"1\":{\"45\":1}}],[\"安全\",{\"1\":{\"40\":1}}],[\"安全的网络传输协议\",{\"1\":{\"37\":1}}],[\"安全管理\",{\"1\":{\"2\":1}}],[\"均摊性能相比更慢\",{\"1\":{\"259\":1}}],[\"均以明文形式发送\",{\"1\":{\"37\":1,\"56\":1}}],[\"均衡循环扫描算法\",{\"1\":{\"16\":1}}],[\"远远比并发标记阶段时间短\",{\"1\":{\"466\":1}}],[\"远远好于\",{\"1\":{\"410\":1}}],[\"远程登录等等\",{\"1\":{\"54\":1}}],[\"远程登陆协议\",{\"1\":{\"37\":1}}],[\"远地主机在收到\",{\"1\":{\"53\":1}}],[\"远离磁头的请求长时间得不到响应\",{\"1\":{\"16\":1}}],[\"分代收集\",{\"1\":{\"467\":1}}],[\"分代收集算法\",{\"0\":{\"459\":1}}],[\"分代年龄等信息\",{\"1\":{\"435\":1}}],[\"分配内存\",{\"0\":{\"433\":1}}],[\"分配好内存\",{\"1\":{\"184\":1}}],[\"分段锁的设计\",{\"1\":{\"272\":1}}],[\"分段锁来保证安全\",{\"1\":{\"272\":1}}],[\"分段的segment\",{\"1\":{\"271\":2}}],[\"分段分页\",{\"0\":{\"13\":1}}],[\"分为\",{\"1\":{\"210\":1}}],[\"分布锁直接失效\",{\"1\":{\"205\":1}}],[\"分布式锁是基于\",{\"1\":{\"209\":1}}],[\"分布式锁服务就是正常的\",{\"1\":{\"208\":1}}],[\"分布式锁实现\",{\"1\":{\"204\":1}}],[\"分布式锁\",{\"0\":{\"202\":1},\"1\":{\"179\":2,\"182\":1,\"215\":1}}],[\"分布式id\",{\"1\":{\"119\":1}}],[\"分别是list\",{\"1\":{\"249\":1}}],[\"分别是用来存放单一元素的collection和用来存放键值对的map接口\",{\"1\":{\"249\":1}}],[\"分别是hash的key\",{\"1\":{\"220\":1}}],[\"分别是\",{\"1\":{\"147\":1}}],[\"分片算法主要解决了数据被水平分片之后\",{\"1\":{\"118\":1}}],[\"分表\",{\"1\":{\"116\":1}}],[\"分库之后\",{\"1\":{\"119\":1}}],[\"分库就是将数据库中的数据分散到不同的数据库上\",{\"1\":{\"115\":1}}],[\"分库分表会带来什么问题呢\",{\"0\":{\"119\":1}}],[\"分库分表\",{\"0\":{\"114\":1}}],[\"分析explain结果\",{\"1\":{\"108\":1}}],[\"分析sql语句操作\",{\"1\":{\"91\":1}}],[\"分析器\",{\"1\":{\"91\":3}}],[\"分钟\",{\"1\":{\"79\":1}}],[\"分开发送是部分浏览器或框架的请求方法\",{\"1\":{\"40\":1}}],[\"分开发送\",{\"1\":{\"40\":1}}],[\"分割\",{\"1\":{\"40\":1}}],[\"分类\",{\"1\":{\"37\":1,\"56\":1}}],[\"标准差\",{\"1\":{\"468\":1}}],[\"标准误差为\",{\"1\":{\"231\":1}}],[\"标准的\",{\"1\":{\"156\":1}}],[\"标示这个锁有一个\",{\"1\":{\"205\":1}}],[\"标头中添加不同的扩展头\",{\"1\":{\"75\":1}}],[\"标头结构相较于\",{\"1\":{\"75\":1}}],[\"标志的数据包后进入\",{\"1\":{\"60\":1}}],[\"标志的数据包\",{\"1\":{\"58\":3,\"60\":5}}],[\"标记复制算法\",{\"1\":{\"513\":1}}],[\"标记一下gc\",{\"1\":{\"467\":1}}],[\"标记清除后会产生大量不连续的内存碎片\",{\"1\":{\"457\":1}}],[\"标记和清除两个过程效率都不高\",{\"1\":{\"457\":1}}],[\"标记\",{\"0\":{\"457\":1},\"1\":{\"37\":1,\"56\":1,\"457\":2,\"459\":3,\"465\":1,\"466\":2,\"467\":3,\"508\":1}}],[\"标识\",{\"1\":{\"372\":1}}],[\"标识进程的重要程度\",{\"1\":{\"8\":1}}],[\"标识符等等\",{\"1\":{\"8\":1}}],[\"支持秒级数据丢失\",{\"1\":{\"246\":1}}],[\"支持修改\",{\"1\":{\"206\":1}}],[\"支持多个客户端连接的关键\",{\"1\":{\"194\":1}}],[\"支持手动释放\",{\"1\":{\"184\":1}}],[\"支持\",{\"1\":{\"179\":1,\"235\":1,\"259\":1}}],[\"支持消息持久化以及\",{\"1\":{\"179\":1}}],[\"支持发布订阅模型\",{\"1\":{\"172\":1}}],[\"支持数据的持久化\",{\"1\":{\"172\":1}}],[\"支持更多的编程语言\",{\"1\":{\"172\":1}}],[\"支持更复杂的应用场景\",{\"1\":{\"172\":1}}],[\"支持更丰富的数据类型\",{\"1\":{\"172\":1}}],[\"支持的数据类型\",{\"1\":{\"172\":1}}],[\"支持innodb\",{\"1\":{\"91\":1}}],[\"支持分库分表\",{\"1\":{\"90\":1}}],[\"支持一对一\",{\"1\":{\"53\":1}}],[\"支持长连接\",{\"1\":{\"46\":1}}],[\"支持邮件搜索\",{\"1\":{\"37\":1,\"56\":1}}],[\"支持面向缓冲\",{\"1\":{\"22\":1}}],[\"更强大\",{\"1\":{\"375\":1}}],[\"更灵活\",{\"1\":{\"375\":1}}],[\"更快的重启以及解决\",{\"1\":{\"246\":1}}],[\"更适合做消息队列一些\",{\"1\":{\"218\":1}}],[\"更方便操作\",{\"1\":{\"216\":1}}],[\"更不会涉及到其他对象\",{\"1\":{\"87\":1}}],[\"更新region的统计数据\",{\"1\":{\"467\":1}}],[\"更新db的时候同样更新cache\",{\"1\":{\"175\":1}}],[\"更新db的时候同时更新cache\",{\"1\":{\"175\":1}}],[\"更新表数据的时候\",{\"1\":{\"145\":1}}],[\"更新代价比聚簇索引小\",{\"1\":{\"132\":2}}],[\"更新代价大\",{\"1\":{\"131\":1}}],[\"更新语句执行流程如下\",{\"1\":{\"91\":1}}],[\"更新\",{\"1\":{\"87\":1,\"175\":1}}],[\"更新的协议\",{\"1\":{\"37\":1,\"56\":1}}],[\"更加简化和高效\",{\"1\":{\"75\":1}}],[\"更安全的超文本传输协议\",{\"1\":{\"56\":1}}],[\"更有优势\",{\"1\":{\"9\":1}}],[\"邮件接收协议\",{\"1\":{\"37\":1}}],[\"需要吞吐量使用\",{\"1\":{\"511\":1}}],[\"需要低延时使用\",{\"1\":{\"511\":1}}],[\"需要要找到一个合适的\",{\"1\":{\"507\":1}}],[\"需要继承\",{\"1\":{\"499\":1}}],[\"需要查找类或资源时\",{\"1\":{\"496\":1}}],[\"需要满足三个条件才能卸载\",{\"1\":{\"490\":1}}],[\"需要满足fifo使用linkedhashset\",{\"1\":{\"257\":1}}],[\"需要stw\",{\"1\":{\"467\":1}}],[\"需要被回收\",{\"1\":{\"450\":1}}],[\"需要被修改的时候\",{\"1\":{\"412\":1}}],[\"需要注意的是\",{\"1\":{\"446\":1}}],[\"需要将常量池中指向方法的符号引用转化为其\",{\"1\":{\"424\":1}}],[\"需要future1完成之后才能执行\",{\"1\":{\"396\":1}}],[\"需要别的线程调用同一个对象的notify\",{\"1\":{\"349\":1}}],[\"需要等待其他线程作出动作\",{\"1\":{\"344\":1}}],[\"需要等待锁释放\",{\"1\":{\"344\":1}}],[\"需要增强的对象\",{\"1\":{\"324\":1}}],[\"需要增加字符串时\",{\"1\":{\"184\":1}}],[\"需要自定义接口methodintercepter并重写intercept方法\",{\"1\":{\"324\":1}}],[\"需要通过类的实例对象去调用\",{\"1\":{\"288\":1}}],[\"需要定期对aof文件进行重写\",{\"1\":{\"241\":1}}],[\"需要管理使用地理空间数据的场景\",{\"1\":{\"236\":1}}],[\"需要保存状态信息\",{\"1\":{\"230\":1}}],[\"需要随机获取数据源中的元素根据某个权重进行排序的场景\",{\"1\":{\"227\":1}}],[\"需要随机获取数据源中的元素的场景\",{\"1\":{\"187\":1,\"224\":1}}],[\"需要存储的数据有优先级或者重要程度的场景\",{\"1\":{\"227\":1}}],[\"需要存储常规数据的场景\",{\"1\":{\"215\":1}}],[\"需要存放的数据不能重复的场景\",{\"1\":{\"224\":1}}],[\"需要计数的场景\",{\"1\":{\"215\":1}}],[\"需要才会执行续期\",{\"1\":{\"206\":1}}],[\"需要获取多个数据源交集\",{\"1\":{\"187\":1,\"224\":1}}],[\"需要减少字符串时\",{\"1\":{\"184\":1}}],[\"需要指定为row\",{\"1\":{\"150\":1}}],[\"需要依靠客户端来实现往集群中分片写入数据\",{\"1\":{\"172\":1}}],[\"需要依靠binlog来同步数据\",{\"1\":{\"149\":1,\"154\":1}}],[\"需要依赖间隙锁\",{\"1\":{\"103\":1,\"156\":1,\"166\":1}}],[\"需要创建临时表来存储查询的结果\",{\"1\":{\"108\":1}}],[\"需要经过经典的\",{\"1\":{\"55\":1}}],[\"需要维持复杂的连接状态表\",{\"1\":{\"53\":1}}],[\"需要一个统一的\",{\"1\":{\"39\":1}}],[\"需要使用包装类\",{\"1\":{\"253\":1}}],[\"需要使用\",{\"1\":{\"37\":1,\"56\":1}}],[\"需要优化一下该算法的实现\",{\"1\":{\"16\":1}}],[\"而在请求高峰期会产生很多新生代对象\",{\"1\":{\"518\":1}}],[\"而在处理io的时候不会占用cpu资源\",{\"1\":{\"392\":1}}],[\"而符号引用则属于编译原理方面的概念\",{\"1\":{\"476\":1}}],[\"而cms的卡表比较简单\",{\"1\":{\"470\":1}}],[\"而g1通过衰减均值来建立可预测的停顿模型\",{\"1\":{\"468\":1}}],[\"而老年代中对象存活的久\",{\"1\":{\"459\":1}}],[\"而并不是和对象一样不使用了就会必然被回收\",{\"1\":{\"455\":1}}],[\"而要判定一个类是否是\",{\"1\":{\"455\":1}}],[\"而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息\",{\"1\":{\"440\":1}}],[\"而本地方法栈则为虚拟机使用到的\",{\"1\":{\"425\":1}}],[\"而每个栈帧中都拥有\",{\"1\":{\"424\":1}}],[\"而每一个栈帧就对应着一个java方法\",{\"1\":{\"342\":1}}],[\"而threadlocalmap存储以threadlocal为key\",{\"1\":{\"382\":1}}],[\"而semaphore\",{\"1\":{\"407\":1}}],[\"而synchronized只能是非公平锁\",{\"1\":{\"377\":1}}],[\"而string类型是两个参数\",{\"1\":{\"220\":1}}],[\"而wait\",{\"1\":{\"349\":1}}],[\"而main函数所在的线程称为主线程\",{\"1\":{\"338\":1}}],[\"而动态代理是在运行时产生class文件\",{\"1\":{\"326\":1}}],[\"而包装类型通过equals\",{\"1\":{\"279\":1}}],[\"而包装类型属于对象类型\",{\"1\":{\"279\":1}}],[\"而基本类型有默认值并且不是null\",{\"1\":{\"279\":1}}],[\"而基本类型不可以\",{\"1\":{\"279\":1}}],[\"而消费者线程会从队列中取出数据进行处理\",{\"1\":{\"261\":1,\"414\":1}}],[\"而linkedlist\",{\"1\":{\"259\":1}}],[\"而redis\",{\"1\":{\"243\":1}}],[\"而无需重新获得锁\",{\"1\":{\"207\":1}}],[\"而无需依赖\",{\"1\":{\"75\":1}}],[\"而原库因为redo\",{\"1\":{\"152\":1}}],[\"而binlog只有在提交事务时才写入\",{\"1\":{\"152\":1}}],[\"而binlog是逻辑日志\",{\"1\":{\"149\":1}}],[\"而b+树的范围查询\",{\"1\":{\"127\":1}}],[\"而b+树任何查找都是根节点到叶子节点的过程\",{\"1\":{\"127\":1}}],[\"而b+树只有叶子节点存放key和data\",{\"1\":{\"127\":1}}],[\"而覆盖搜因就是要查询出的列和索引是对应的\",{\"1\":{\"134\":1}}],[\"而其余的索引都成为辅助索引\",{\"1\":{\"127\":1}}],[\"而索引一般在内存中\",{\"1\":{\"108\":1}}],[\"而innodb支持\",{\"1\":{\"93\":2}}],[\"而innodb支持行级锁和表级锁\",{\"1\":{\"93\":1}}],[\"而是把请求委派给父类加载器去完成\",{\"1\":{\"497\":1,\"499\":1}}],[\"而是把连续的java堆划分为多个大小相等的独立区域\",{\"1\":{\"467\":1}}],[\"而是通常使用组合关系来复用父加载器的代码\",{\"1\":{\"496\":1}}],[\"而是通过一定的概率统计方法预估基数值\",{\"1\":{\"231\":1}}],[\"而是通过\",{\"1\":{\"108\":1}}],[\"而是根据需要去动态加载\",{\"1\":{\"493\":1}}],[\"而是处于\",{\"1\":{\"452\":1}}],[\"而是对原有数据进行一次复制\",{\"1\":{\"412\":1}}],[\"而是采用忙循环\",{\"1\":{\"398\":1}}],[\"而是会按照延迟的时间长短对任务进行排序\",{\"1\":{\"390\":1}}],[\"而是会等待\",{\"1\":{\"388\":1}}],[\"而是会去读取行的一个快照\",{\"1\":{\"106\":1}}],[\"而是等待下一个任务\",{\"1\":{\"385\":1}}],[\"而是每次循环都创建一个stringbuilder\",{\"1\":{\"305\":1}}],[\"而是在前一个节点比如\",{\"1\":{\"209\":1}}],[\"而是自己编写了\",{\"1\":{\"184\":1}}],[\"而是改为异步批量的方式来更新\",{\"1\":{\"177\":1}}],[\"而是以一个日志文件组的形式出现的\",{\"1\":{\"147\":1}}],[\"而是数据对应的地址\",{\"1\":{\"132\":1}}],[\"而是大致的平衡\",{\"1\":{\"126\":1}}],[\"而是直接设置为ssthresh阈值的一半\",{\"1\":{\"66\":1}}],[\"而是使用一种称为\",{\"1\":{\"37\":1,\"56\":1}}],[\"而不需要像\",{\"1\":{\"126\":1}}],[\"而不需要等待对方确认\",{\"1\":{\"69\":1}}],[\"而不涉及到表的定义\",{\"1\":{\"87\":1}}],[\"而不是基于线程的同步\",{\"1\":{\"509\":1}}],[\"而不是像waiting一样一直等待\",{\"1\":{\"344\":1}}],[\"而不是为了查询效率\",{\"1\":{\"129\":1}}],[\"而不是范围\",{\"1\":{\"103\":1}}],[\"而不是gbn中的当前帧和后续的所有帧\",{\"1\":{\"70\":1}}],[\"而不是接收\",{\"1\":{\"37\":1,\"56\":1}}],[\"而不断重发\",{\"1\":{\"62\":1}}],[\"而服务器却将整个对象送过来了\",{\"1\":{\"46\":1}}],[\"而且\",{\"1\":{\"472\":1}}],[\"而且还能防止反序列化重新创建新的对象\",{\"1\":{\"334\":1}}],[\"而且还指明了如何\",{\"1\":{\"47\":1}}],[\"而且是顺序写\",{\"1\":{\"148\":1}}],[\"而且数据页刷盘是随机写\",{\"1\":{\"148\":1}}],[\"而且聚簇索引的叶子节点还存放着数据\",{\"1\":{\"131\":1}}],[\"而且在数据传递时\",{\"1\":{\"53\":1}}],[\"而且没有任何已知的转发地址\",{\"1\":{\"46\":1}}],[\"而且实际测试\",{\"1\":{\"40\":1}}],[\"而且可以在多个设备之间同步邮件状态\",{\"1\":{\"37\":1,\"56\":1}}],[\"而\",{\"1\":{\"39\":1,\"40\":1,\"46\":1,\"53\":2,\"55\":1,\"78\":1,\"79\":1,\"172\":3,\"176\":1,\"177\":1,\"210\":1,\"246\":1,\"259\":1,\"373\":1,\"377\":1,\"383\":2,\"480\":1}}],[\"而进程只能在一个时间干一件事\",{\"1\":{\"6\":1}}],[\"⚠️\",{\"1\":{\"37\":2,\"56\":2}}],[\"注意锁可以升级不可降级\",{\"1\":{\"397\":1}}],[\"注意使用volatile修饰singleton\",{\"1\":{\"332\":1}}],[\"注意\",{\"1\":{\"37\":2,\"56\":2,\"105\":1,\"387\":1,\"427\":1}}],[\"协议用来ip地址转mac地址\",{\"1\":{\"79\":1}}],[\"协议内容\",{\"1\":{\"78\":1}}],[\"协议可提高信道利用率\",{\"1\":{\"69\":1}}],[\"协议可以有效防止远程管理过程中的信息泄露问题\",{\"1\":{\"56\":1}}],[\"协议之上的协议\",{\"1\":{\"56\":2}}],[\"协议运行在\",{\"1\":{\"45\":1}}],[\"协议没有\",{\"1\":{\"40\":1}}],[\"协议是基于\",{\"1\":{\"40\":1}}],[\"协议是比\",{\"1\":{\"37\":1,\"56\":1}}],[\"协议中的一种请求方法\",{\"1\":{\"41\":1}}],[\"协议中没有明确说明\",{\"1\":{\"40\":1}}],[\"协议中两种请求方式\",{\"1\":{\"40\":1}}],[\"协议中最重要的协议之一\",{\"1\":{\"39\":1}}],[\"协议的特性\",{\"1\":{\"55\":1}}],[\"协议的\",{\"1\":{\"55\":1}}],[\"协议的网站在搜索结果中可能会被优先显示\",{\"1\":{\"45\":1}}],[\"协议的网站\",{\"1\":{\"45\":1}}],[\"协议的应用场景如同它的名称\",{\"1\":{\"39\":1}}],[\"协议的最大缺点之一是所有数据\",{\"1\":{\"37\":1,\"56\":1}}],[\"协议来测试网络连通性\",{\"1\":{\"39\":1}}],[\"协议解决了什么问题\",{\"0\":{\"79\":1}}],[\"协议解决了\",{\"1\":{\"39\":1}}],[\"协议解决的是网络层地址和链路层地址之间的转换问题\",{\"1\":{\"39\":1}}],[\"协议主要分为两种\",{\"1\":{\"39\":1}}],[\"协议只负责邮件的发送\",{\"1\":{\"37\":1,\"56\":1}}],[\"协议\",{\"1\":{\"37\":10,\"45\":1,\"55\":1,\"56\":9,\"79\":1}}],[\"hprof格式\",{\"1\":{\"508\":1}}],[\"hprof\",{\"1\":{\"508\":1}}],[\"home\",{\"1\":{\"494\":2}}],[\"hotspot为什么要分代\",{\"0\":{\"459\":1}}],[\"hotspot\",{\"1\":{\"430\":1,\"437\":1,\"445\":1,\"446\":1,\"454\":3,\"466\":1,\"487\":1,\"504\":1,\"509\":1}}],[\"host\",{\"1\":{\"46\":4,\"75\":1}}],[\"h\",{\"1\":{\"267\":3,\"323\":2}}],[\"high\",{\"1\":{\"260\":2}}],[\"hincrby\",{\"1\":{\"220\":1}}],[\"hlen\",{\"1\":{\"220\":1}}],[\"hdel\",{\"1\":{\"220\":1}}],[\"hmget\",{\"1\":{\"220\":1,\"221\":1}}],[\"hmset\",{\"1\":{\"220\":1,\"221\":1}}],[\"hgetall\",{\"1\":{\"220\":1}}],[\"hget\",{\"1\":{\"220\":1,\"221\":1}}],[\"hsetnx\",{\"1\":{\"220\":1}}],[\"hset\",{\"1\":{\"220\":1,\"221\":1}}],[\"heap\",{\"1\":{\"508\":1}}],[\"heapdumppath\",{\"1\":{\"508\":1}}],[\"heapdumppath=\",{\"1\":{\"508\":1}}],[\"heapdumponoutofmemoryerror\",{\"1\":{\"508\":1}}],[\"headsort\",{\"1\":{\"260\":1}}],[\"headers\",{\"1\":{\"75\":1}}],[\"header\",{\"1\":{\"40\":5,\"46\":2,\"161\":1}}],[\"hero1\",{\"1\":{\"295\":1}}],[\"hero\",{\"1\":{\"295\":3}}],[\"hexists\",{\"1\":{\"206\":1,\"220\":1}}],[\"hyperloglog更适合一些\",{\"1\":{\"187\":1,\"224\":1}}],[\"hyperloglogs\",{\"1\":{\"181\":1}}],[\"hyperloglog\",{\"0\":{\"190\":1,\"231\":1},\"1\":{\"170\":1,\"190\":4,\"231\":4,\"232\":3}}],[\"hypertext\",{\"1\":{\"37\":1,\"56\":2}}],[\"handle\",{\"1\":{\"447\":1}}],[\"handlepromotionfailure\",{\"1\":{\"447\":2}}],[\"handler\",{\"1\":{\"388\":2}}],[\"happens\",{\"0\":{\"358\":1,\"359\":1},\"1\":{\"359\":3}}],[\"hash解决碰撞办法\",{\"1\":{\"272\":1}}],[\"hashentry数组+链表\",{\"1\":{\"271\":2}}],[\"hash值为0111\",{\"1\":{\"269\":1}}],[\"hash值的取值为32位补码的取值范围\",{\"1\":{\"269\":1}}],[\"hashcode\",{\"0\":{\"300\":1,\"301\":1},\"1\":{\"267\":2,\"300\":3}}],[\"hash计算元素存放的位置\",{\"1\":{\"267\":1}}],[\"hashtable使用同一个锁进行并发控制\",{\"1\":{\"271\":1}}],[\"hashtable则没有转化为红黑树的机制\",{\"1\":{\"264\":1}}],[\"hashtable默认初始大小是11\",{\"1\":{\"264\":1}}],[\"hashtable不能有nullkey和value\",{\"1\":{\"264\":1}}],[\"hashtable是线程安全的\",{\"1\":{\"264\":1}}],[\"hashtable\",{\"0\":{\"264\":1,\"271\":1},\"1\":{\"251\":2,\"271\":2}}],[\"hash数据结构添加需要三个参数\",{\"1\":{\"220\":1}}],[\"hashmap通过计算hash值使得查找元素的时间复杂度为1\",{\"1\":{\"300\":1}}],[\"hashmap默认大小是16\",{\"1\":{\"264\":1}}],[\"hashmap能存储null的key和value\",{\"1\":{\"264\":1}}],[\"hashmap的效率要稍微好点\",{\"1\":{\"264\":1}}],[\"hashmap是非线程安全的\",{\"1\":{\"264\":1}}],[\"hashmap\",{\"0\":{\"264\":1,\"265\":1,\"266\":1,\"269\":1,\"270\":1},\"1\":{\"219\":1,\"225\":1,\"251\":4,\"270\":1,\"271\":2,\"410\":1}}],[\"hashset底层是哈希表\",{\"1\":{\"257\":1}}],[\"hashset\",{\"0\":{\"257\":1},\"1\":{\"187\":1,\"222\":1,\"251\":1,\"257\":1}}],[\"hash\",{\"0\":{\"183\":1,\"185\":1,\"219\":1},\"1\":{\"170\":1,\"172\":1,\"181\":1,\"183\":3,\"185\":1,\"212\":4,\"215\":1,\"219\":3,\"267\":1,\"269\":2}}],[\"hash表\",{\"0\":{\"123\":1}}],[\"hard\",{\"1\":{\"15\":1}}],[\"http状态码\",{\"0\":{\"44\":1}}],[\"https与http的区别\",{\"0\":{\"45\":1}}],[\"https\",{\"1\":{\"40\":1,\"45\":9,\"56\":2}}],[\"http\",{\"0\":{\"42\":1,\"46\":2,\"55\":1},\"1\":{\"37\":2,\"40\":5,\"41\":1,\"43\":2,\"45\":7,\"46\":9,\"55\":6,\"56\":4}}],[\"拍拍\",{\"0\":{\"34\":1}}],[\"⭐龙凤头浪花\",{\"1\":{\"33\":1}}],[\"⭐北部湾生态长廊\",{\"1\":{\"33\":1}}],[\"⭐长江澳风车田\",{\"1\":{\"33\":1}}],[\"⭐环岛路旁\",{\"1\":{\"33\":1}}],[\"⭐去北线的路上\",{\"1\":{\"33\":1}}],[\"⭐猴研岛\",{\"1\":{\"33\":1}}],[\"今年四月又来看海了\",{\"1\":{\"33\":1}}],[\"世间浪漫海占一半\",{\"0\":{\"33\":1}}],[\"平潭四月\",{\"0\":{\"32\":1}}],[\"平均寻道时间较长\",{\"1\":{\"16\":1}}],[\"导航\",{\"0\":{\"28\":1}}],[\"导致concurrent\",{\"1\":{\"468\":1}}],[\"导致他们的计数值都不为0\",{\"1\":{\"449\":1}}],[\"导致无法使用join操作\",{\"1\":{\"119\":1}}],[\"导致内部内存碎片的主要原因是\",{\"1\":{\"12\":1}}],[\"导致子进程的\",{\"1\":{\"10\":1}}],[\"欢迎\",{\"0\":{\"27\":1}}],[\"框架的工具类\",{\"1\":{\"387\":1}}],[\"框架中也使用了动态代理\",{\"1\":{\"316\":1}}],[\"框架\",{\"0\":{\"26\":1}}],[\"异步任务编排组合\",{\"1\":{\"396\":1}}],[\"异步缓存写入\",{\"0\":{\"177\":1}}],[\"异步io是基于事件和回调机制实现的\",{\"1\":{\"23\":1}}],[\"异常\",{\"1\":{\"3\":1,\"417\":1,\"504\":1}}],[\"7采用永久代\",{\"1\":{\"519\":1}}],[\"7采用拉链法\",{\"1\":{\"272\":1}}],[\"7开启了逃逸分析\",{\"1\":{\"427\":1}}],[\"7位无符号数的表示范围\",{\"1\":{\"280\":1}}],[\"7中最大的并发度是segment的个数\",{\"1\":{\"272\":1}}],[\"7的时候\",{\"1\":{\"271\":1}}],[\"7取消循环\",{\"1\":{\"255\":1}}],[\"7取消\",{\"1\":{\"251\":1}}],[\"7字节\",{\"1\":{\"161\":1}}],[\"7\",{\"0\":{\"272\":1},\"1\":{\"23\":1,\"270\":1,\"271\":1,\"272\":1,\"430\":2,\"454\":2,\"475\":1,\"483\":1,\"487\":1,\"504\":1,\"509\":1,\"519\":1}}],[\"awit\",{\"1\":{\"408\":1}}],[\"await\",{\"1\":{\"408\":7}}],[\"aqs资源共享方式\",{\"0\":{\"406\":1}}],[\"aqs的核心原理图如下\",{\"1\":{\"405\":1}}],[\"aqs的核心思想是如果被请求的共享资源空闲\",{\"1\":{\"405\":1}}],[\"aqs核心思想\",{\"0\":{\"405\":1}}],[\"aqs原理\",{\"0\":{\"404\":1}}],[\"aqs抽象队列同步器\",{\"0\":{\"403\":1}}],[\"aqs\",{\"1\":{\"375\":1,\"403\":3,\"405\":2,\"406\":1,\"407\":1,\"408\":1}}],[\"after\",{\"1\":{\"316\":1}}],[\"abstract\",{\"1\":{\"477\":1,\"496\":1}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"375\":1,\"403\":1}}],[\"abortpolicy\",{\"1\":{\"389\":1}}],[\"aba问题\",{\"0\":{\"367\":1}}],[\"ab\",{\"1\":{\"308\":1}}],[\"abc\",{\"0\":{\"306\":1},\"1\":{\"143\":1,\"306\":7,\"310\":1,\"454\":3}}],[\"age\",{\"1\":{\"285\":1,\"445\":1}}],[\"addelapsedtimefrom\",{\"1\":{\"497\":1}}],[\"addtime\",{\"1\":{\"497\":1}}],[\"addlast\",{\"1\":{\"258\":1}}],[\"addfirst\",{\"1\":{\"258\":1}}],[\"add\",{\"1\":{\"258\":1,\"412\":1}}],[\"address\",{\"1\":{\"39\":2,\"75\":2,\"76\":1,\"78\":1,\"79\":1}}],[\"always\",{\"1\":{\"242\":1}}],[\"allof\",{\"1\":{\"396\":1}}],[\"allkeys\",{\"1\":{\"201\":3}}],[\"all\",{\"1\":{\"108\":3}}],[\"appclassloader\",{\"1\":{\"490\":1,\"494\":1}}],[\"appendfsync\",{\"1\":{\"242\":3}}],[\"appendonly开启\",{\"1\":{\"242\":1}}],[\"append\",{\"1\":{\"240\":1,\"241\":1}}],[\"app0000000002\",{\"1\":{\"210\":1}}],[\"app0000000001\",{\"1\":{\"210\":1}}],[\"api\",{\"1\":{\"184\":1,\"213\":1,\"231\":1,\"377\":1}}],[\"antirez\",{\"1\":{\"208\":1}}],[\"and\",{\"1\":{\"136\":6,\"189\":1,\"229\":1,\"364\":1,\"366\":1,\"457\":1}}],[\"aof重写了解吗\",{\"0\":{\"244\":1}}],[\"aof记录日志不会对命令进行语法检查\",{\"1\":{\"243\":1}}],[\"aof为什么是在执行完命令之后记录日志\",{\"0\":{\"243\":1}}],[\"aof缓冲区根据对应的持久化方式向磁盘做同步操作\",{\"1\":{\"241\":1}}],[\"aof工作基本流程\",{\"0\":{\"241\":1}}],[\"aof持久化机制是在执行完命令之后再记录日志\",{\"1\":{\"243\":1}}],[\"aof持久化方式有哪些\",{\"0\":{\"242\":1}}],[\"aof持久化功能的实现可以简单分为5步\",{\"1\":{\"241\":1}}],[\"aof持久化的实时性更好\",{\"1\":{\"240\":1}}],[\"aof持久化\",{\"0\":{\"240\":1}}],[\"aof\",{\"0\":{\"245\":1,\"246\":1},\"1\":{\"179\":1,\"197\":3,\"244\":13,\"245\":6,\"246\":21}}],[\"ascii\",{\"1\":{\"509\":1}}],[\"asc\",{\"1\":{\"235\":1}}],[\"aside\",{\"0\":{\"175\":1},\"1\":{\"175\":1,\"176\":3}}],[\"asynchronous\",{\"0\":{\"23\":1}}],[\"attribute\",{\"1\":{\"481\":1}}],[\"attributes\",{\"0\":{\"481\":1},\"1\":{\"481\":3}}],[\"atomicinteger类主要利用cas\",{\"1\":{\"364\":1}}],[\"atomic包下面的原子变量类\",{\"1\":{\"364\":1}}],[\"aton\",{\"1\":{\"107\":2}}],[\"at\",{\"1\":{\"146\":2}}],[\"a>1\",{\"1\":{\"136\":1}}],[\"a=1\",{\"1\":{\"136\":3}}],[\"a\",{\"1\":{\"136\":4,\"175\":6,\"289\":2,\"293\":3,\"308\":3}}],[\"avl\",{\"1\":{\"126\":2}}],[\"avl树需要频繁的进行旋转来保持平衡\",{\"1\":{\"125\":1}}],[\"avl树是自平衡的二叉查找树\",{\"1\":{\"125\":1}}],[\"avl树\",{\"0\":{\"125\":1}}],[\"acquire\",{\"1\":{\"407\":4}}],[\"acc\",{\"1\":{\"372\":2}}],[\"access\",{\"0\":{\"477\":1},\"1\":{\"78\":1,\"477\":1}}],[\"acid\",{\"1\":{\"96\":1,\"156\":1}}],[\"acid特性\",{\"0\":{\"96\":1}}],[\"ack=y+1\",{\"1\":{\"58\":1,\"60\":2}}],[\"ack=x+1\",{\"1\":{\"58\":1,\"60\":1}}],[\"ack\",{\"0\":{\"61\":1},\"1\":{\"58\":1,\"60\":4,\"61\":1,\"62\":4,\"64\":1,\"179\":1}}],[\"auto\",{\"1\":{\"244\":2}}],[\"autoconfiguration\",{\"1\":{\"75\":1}}],[\"automatic\",{\"1\":{\"67\":1}}],[\"artifactid>\",{\"1\":{\"324\":1}}],[\"args\",{\"1\":{\"312\":1,\"316\":2,\"323\":2,\"324\":2,\"508\":3}}],[\"argv\",{\"1\":{\"204\":1,\"206\":2}}],[\"arr\",{\"1\":{\"312\":4}}],[\"arrylist和vector区别\",{\"0\":{\"254\":1}}],[\"arrayblockingqueue\",{\"0\":{\"415\":1},\"1\":{\"415\":2,\"416\":1}}],[\"array为引用类型\",{\"1\":{\"312\":1}}],[\"array\",{\"1\":{\"312\":2}}],[\"arraydeque\",{\"0\":{\"259\":1},\"1\":{\"259\":4}}],[\"arrayqueue\",{\"1\":{\"251\":1}}],[\"arraylist实现了randomaccess接口\",{\"1\":{\"255\":1}}],[\"arraylist底层使用object\",{\"1\":{\"255\":1}}],[\"arraylist是list的主要实现类\",{\"1\":{\"254\":1}}],[\"arraylist能插入null\",{\"1\":{\"253\":1}}],[\"arraylist支持插入\",{\"1\":{\"253\":1}}],[\"arraylist只能存储对象\",{\"1\":{\"253\":1}}],[\"arraylist会根据实际存储的元素动态扩容或者缩容\",{\"1\":{\"253\":1}}],[\"arraylist存储元素的特点是顺序\",{\"1\":{\"253\":1}}],[\"arraylist\",{\"0\":{\"255\":1},\"1\":{\"251\":1}}],[\"arq\",{\"1\":{\"67\":1,\"68\":1,\"69\":1}}],[\"arq称为自动重传请求\",{\"1\":{\"67\":1}}],[\"arq协议\",{\"0\":{\"67\":1}}],[\"arp\",{\"0\":{\"77\":1,\"79\":1},\"1\":{\"39\":3,\"79\":4}}],[\"aio\",{\"0\":{\"23\":1},\"1\":{\"23\":1}}],[\"概念\",{\"1\":{\"22\":1}}],[\"还要看类的加载器是否相同\",{\"1\":{\"497\":1}}],[\"还要实现invocationhandler接口\",{\"1\":{\"323\":1}}],[\"还有一个是筛选回收\",{\"1\":{\"470\":1}}],[\"还有用于存放各种字面量和符号引用的常量池表\",{\"1\":{\"429\":1}}],[\"还具备高吞吐量性能特征\",{\"1\":{\"467\":1}}],[\"还具有很好的可移植性\",{\"1\":{\"276\":1}}],[\"还提供了函数式编程\",{\"1\":{\"396\":1}}],[\"还规定了java源代码到cpu可执行指令这个转化过程要遵循哪些和并发相关的原则和规范\",{\"1\":{\"355\":1}}],[\"还能建立可预测的停顿时间模型\",{\"1\":{\"467\":1}}],[\"还能调用这些方法和属性\",{\"1\":{\"315\":1}}],[\"还能做什么\",{\"0\":{\"179\":1}}],[\"还会维护一个\",{\"1\":{\"244\":1}}],[\"还支持如果队列已满\",{\"1\":{\"261\":1,\"414\":1}}],[\"还支持\",{\"1\":{\"206\":1}}],[\"还支持事务\",{\"1\":{\"170\":1}}],[\"还支持行级锁\",{\"1\":{\"102\":1}}],[\"还包含操作的具体数据\",{\"1\":{\"150\":1}}],[\"还需要根据主键去聚簇索引中去查找对应行的数据\",{\"1\":{\"132\":1}}],[\"还可以通过\",{\"1\":{\"225\":1,\"503\":1}}],[\"还可以再次获取锁\",{\"1\":{\"202\":1}}],[\"还可以隐藏内部网络的实际拓扑结构\",{\"1\":{\"76\":1}}],[\"还可以方便的实现多线程优先级的比较操作\",{\"1\":{\"7\":1}}],[\"还是跨代引用的问题\",{\"1\":{\"467\":1}}],[\"还是有很多欠缺的地方比如消息丢失和堆积问题不好解决\",{\"1\":{\"218\":1}}],[\"还是\",{\"0\":{\"55\":1,\"183\":1,\"185\":1,\"305\":1},\"1\":{\"40\":1}}],[\"还是阻塞的\",{\"1\":{\"22\":1}}],[\"应该在\",{\"1\":{\"508\":1}}],[\"应用场景\",{\"0\":{\"215\":1,\"218\":1,\"221\":1,\"224\":1,\"227\":1,\"230\":1,\"233\":1,\"236\":1}}],[\"应用\",{\"0\":{\"178\":1}}],[\"应用的并发量太大\",{\"1\":{\"117\":1}}],[\"应用数据被分割成\",{\"1\":{\"64\":1}}],[\"应用于内部网到外部网的地址转换过程中\",{\"1\":{\"39\":1}}],[\"应用层\",{\"0\":{\"37\":1}}],[\"应用程序类加载器\",{\"1\":{\"494\":1}}],[\"应用程序不断进行i\",{\"1\":{\"22\":1}}],[\"应用程序会一直发起read调用\",{\"1\":{\"22\":1}}],[\"应用程序发起read调用后\",{\"1\":{\"21\":1}}],[\"应使用nio\",{\"1\":{\"22\":1}}],[\"基数计数概率算法为了节省内存并不会直接存储元数据\",{\"1\":{\"231\":1}}],[\"基数统计\",{\"1\":{\"181\":1}}],[\"基础\",{\"0\":{\"169\":1}}],[\"基本上\",{\"1\":{\"466\":1}}],[\"基本上解决了数据冗余过大\",{\"1\":{\"85\":1}}],[\"基本类型和包装类型\",{\"0\":{\"279\":1}}],[\"基本数据类型使用==进行比较\",{\"1\":{\"279\":1}}],[\"基本数据类型的成员变量没有被static修饰的话放在堆中\",{\"1\":{\"279\":1}}],[\"基本数据类型的局部变量存放在java虚拟机栈中的局部变量表中\",{\"1\":{\"279\":1}}],[\"基本数据类型\",{\"0\":{\"278\":1}}],[\"基本数据结构的底层数据结构实现如下\",{\"1\":{\"212\":1}}],[\"基本思想和电梯非常类似\",{\"1\":{\"16\":1}}],[\"基于hashmap实现\",{\"1\":{\"251\":1}}],[\"基于内存\",{\"1\":{\"171\":1}}],[\"基于mvcc和next\",{\"1\":{\"93\":1}}],[\"基于数据块传输\",{\"1\":{\"64\":1}}],[\"基于udp协议之上\",{\"1\":{\"49\":1}}],[\"基于距离向量算法\",{\"1\":{\"39\":1}}],[\"基于链路状态算法\",{\"1\":{\"39\":1}}],[\"基于\",{\"0\":{\"55\":1,\"203\":1,\"209\":1},\"1\":{\"37\":7,\"55\":1,\"171\":1,\"222\":1,\"231\":1,\"234\":1}}],[\"基于通道的i\",{\"1\":{\"22\":1}}],[\"提交给了\",{\"1\":{\"394\":1}}],[\"提交事务\",{\"1\":{\"95\":1}}],[\"提高线程的可管理性\",{\"1\":{\"386\":1}}],[\"提高响应速度\",{\"1\":{\"386\":1}}],[\"提高资源利用率\",{\"1\":{\"386\":1}}],[\"提高网络io读写性能\",{\"1\":{\"192\":1}}],[\"提高了网络性能\",{\"1\":{\"75\":1}}],[\"提供一个静态的共有方法\",{\"1\":{\"331\":1}}],[\"提供额外的功能\",{\"1\":{\"320\":1}}],[\"提供的线程安全的\",{\"1\":{\"413\":1}}],[\"提供的这些容器大部分在\",{\"1\":{\"410\":1}}],[\"提供的\",{\"1\":{\"231\":1}}],[\"提供的数据结构\",{\"1\":{\"179\":1}}],[\"提供了一些参数\",{\"1\":{\"508\":1}}],[\"提供了\",{\"1\":{\"395\":1}}],[\"提供了atomicreference类来保证引用对象之间的原子性\",{\"1\":{\"368\":1}}],[\"提供了很多开箱即用的功能\",{\"1\":{\"206\":1}}],[\"提供了channel\",{\"1\":{\"22\":1}}],[\"提供可靠的传输服务\",{\"1\":{\"53\":1}}],[\"提供面向连接的服务\",{\"1\":{\"53\":1}}],[\"提供\",{\"1\":{\"38\":2,\"201\":1}}],[\"提出了有名管道\",{\"1\":{\"9\":1}}],[\"对类进行link操作\",{\"1\":{\"497\":1}}],[\"对类对象加锁\",{\"1\":{\"362\":1}}],[\"对字节码描述的信息进行语义分析\",{\"1\":{\"486\":1}}],[\"对各个region的回收价值和成本进行排序\",{\"1\":{\"467\":1}}],[\"对垃圾内存的回收速度\",{\"1\":{\"453\":1}}],[\"对整个新生代和部分老年代进行垃圾收集\",{\"1\":{\"446\":1}}],[\"对齐填充部分不是必然存在的\",{\"1\":{\"437\":1}}],[\"对外暴露一个静态的公共方法\",{\"1\":{\"329\":1}}],[\"对某一个类只会存在一个对象实例\",{\"1\":{\"327\":1}}],[\"对方法的增强是手动完成的\",{\"1\":{\"321\":1}}],[\"对方发送正常\",{\"1\":{\"59\":1}}],[\"对方发送\",{\"1\":{\"59\":3}}],[\"对形参本身修改会导致实参变化\",{\"1\":{\"312\":1}}],[\"对形参的修改将会影响到实参\",{\"1\":{\"311\":1}}],[\"对内部方法加了同步锁\",{\"1\":{\"303\":1}}],[\"对象使用\",{\"1\":{\"509\":1}}],[\"对象一起存放在\",{\"1\":{\"487\":1}}],[\"对象没有在任何地方被引用\",{\"1\":{\"455\":1}}],[\"对象没有覆盖finalize方法\",{\"1\":{\"452\":1}}],[\"对象可以被回收\",{\"0\":{\"452\":1}}],[\"对象晋升到老年代的年龄阈值\",{\"1\":{\"445\":1}}],[\"对象都会首先在\",{\"1\":{\"445\":1}}],[\"对象在\",{\"1\":{\"445\":1}}],[\"对象在新生代中\",{\"1\":{\"443\":1}}],[\"对象在内存中的布局可以分为\",{\"1\":{\"437\":1}}],[\"对象优先在eden中分配\",{\"0\":{\"443\":1}}],[\"对象头包含两部分信息\",{\"1\":{\"437\":1}}],[\"对象头\",{\"1\":{\"437\":1}}],[\"对象头会有不同的设置方式\",{\"1\":{\"435\":1}}],[\"对象的类型转换是否合理\",{\"1\":{\"486\":1}}],[\"对象的访问定位就是如何找到创建的对象信息\",{\"1\":{\"438\":1}}],[\"对象的访问定位\",{\"0\":{\"438\":1}}],[\"对象的内存布局\",{\"0\":{\"437\":1}}],[\"对象的\",{\"1\":{\"435\":1}}],[\"对象的哈希码\",{\"1\":{\"435\":1}}],[\"对象的相等是是比较内存中存放的对象是否相等\",{\"1\":{\"293\":1}}],[\"对象的相等和引用的相等\",{\"0\":{\"293\":1}}],[\"对象引用该字符串常量的话\",{\"1\":{\"454\":1}}],[\"对象引用\",{\"1\":{\"424\":1}}],[\"对象时\",{\"1\":{\"416\":1}}],[\"对象也会在方法内部转换为callable\",{\"1\":{\"395\":1}}],[\"对象\",{\"1\":{\"395\":2}}],[\"对象锁的的拥有者线程才可以执行\",{\"1\":{\"372\":1}}],[\"对象类型和引用类型之间具有继承\",{\"1\":{\"295\":1}}],[\"对象数据存储场景\",{\"1\":{\"221\":1}}],[\"对元素顺序无要求则用hashset\",{\"1\":{\"257\":1}}],[\"对数据完整性安全性要求较高的场景\",{\"1\":{\"246\":1}}],[\"对数据包进行路由和寻址\",{\"1\":{\"39\":1,\"73\":1}}],[\"对其进行强制磁盘同步\",{\"1\":{\"241\":1}}],[\"对一些代码上要求同步\",{\"1\":{\"399\":1}}],[\"对一个或多个\",{\"1\":{\"229\":1}}],[\"对一行或者多行记录加锁\",{\"1\":{\"102\":1}}],[\"对相同元素对应的\",{\"1\":{\"226\":1}}],[\"对指定哈希中的指定字段做运算操作\",{\"1\":{\"220\":1}}],[\"对设置到指定哈希表中\",{\"1\":{\"220\":1}}],[\"对性能更友好\",{\"1\":{\"210\":1}}],[\"对记录加\",{\"1\":{\"159\":2}}],[\"对同一字段的多次读取结果都是一致的\",{\"1\":{\"156\":1}}],[\"对索引中包含的字段做判断\",{\"1\":{\"137\":1}}],[\"对索引列进行范围查询\",{\"1\":{\"108\":1}}],[\"对排序查找和范围查找优化\",{\"1\":{\"131\":1}}],[\"对语句进行分析\",{\"1\":{\"108\":1}}],[\"对修改的记录加一个x锁\",{\"1\":{\"106\":1}}],[\"对读的记录加一个s锁\",{\"1\":{\"106\":1}}],[\"对读的记录加一个x锁\",{\"1\":{\"106\":1}}],[\"对当前操作的整张表加锁\",{\"1\":{\"102\":1}}],[\"对应到新生代就是survivor中的from区和to区\",{\"1\":{\"458\":1}}],[\"对应的引用\",{\"1\":{\"307\":2}}],[\"对应的子节点由于是临时顺序节点\",{\"1\":{\"209\":1}}],[\"对应的是\",{\"1\":{\"205\":1}}],[\"对应的\",{\"1\":{\"204\":1,\"205\":1}}],[\"对应的扫描区间是\",{\"1\":{\"136\":1}}],[\"对应\",{\"1\":{\"204\":1}}],[\"对应于表中的字段\",{\"1\":{\"83\":1}}],[\"对应java\",{\"1\":{\"22\":1}}],[\"对标头结构进行了改进\",{\"1\":{\"75\":1}}],[\"对按序到达的最后一个分组发送确认\",{\"1\":{\"69\":1}}],[\"对失序数据包重新排序以及去重\",{\"1\":{\"64\":1}}],[\"对\",{\"0\":{\"160\":1},\"1\":{\"40\":1,\"146\":1,\"231\":1,\"466\":1,\"509\":1}}],[\"对于大型应用程序来说\",{\"1\":{\"508\":1}}],[\"对于已经加载的类会被放在\",{\"1\":{\"493\":1}}],[\"对于初始化\",{\"1\":{\"489\":1}}],[\"对于在编译期间就能确定的字符串\",{\"1\":{\"308\":1}}],[\"对于string\",{\"1\":{\"308\":1}}],[\"对于引用类型来说==是比较地址\",{\"1\":{\"299\":1}}],[\"对于基本类型来说==是比较值\",{\"1\":{\"299\":1}}],[\"对于collection接口有三个子接口\",{\"1\":{\"249\":1}}],[\"对于读写来说\",{\"1\":{\"192\":1}}],[\"对于热点数据可以提前放入缓存中\",{\"1\":{\"176\":1}}],[\"对于当前事务也是不可见的\",{\"1\":{\"162\":1}}],[\"对于这种读取历史数据的方式\",{\"1\":{\"158\":1}}],[\"对于一个类加载器来说\",{\"1\":{\"493\":1}}],[\"对于一个volatile变量的写操作happens\",{\"1\":{\"359\":1}}],[\"对于一致性非锁定读的实现\",{\"1\":{\"158\":1}}],[\"对于一般的\",{\"1\":{\"104\":1}}],[\"对于快照数据\",{\"1\":{\"106\":2}}],[\"对于高负载\",{\"1\":{\"22\":1}}],[\"对于java来说\",{\"1\":{\"5\":1}}],[\"响应不了其他请求\",{\"1\":{\"21\":1}}],[\"在名称中找到一个\",{\"1\":{\"508\":1}}],[\"在遇到\",{\"1\":{\"508\":1}}],[\"在父类加载器没有找到所请求的类情况下\",{\"1\":{\"497\":1}}],[\"在加载时调用\",{\"1\":{\"495\":1}}],[\"在内存中生成一个类的\",{\"1\":{\"485\":1}}],[\"在内部\",{\"1\":{\"161\":1}}],[\"在内部实现中\",{\"1\":{\"153\":1,\"160\":1}}],[\"在常量池结束之后\",{\"1\":{\"477\":1}}],[\"在并发标记的最后以及最终标记中进行处理\",{\"1\":{\"470\":1}}],[\"在并发标记阶段用户新产生的垃圾\",{\"1\":{\"466\":1}}],[\"在重新标记阶段进行处理\",{\"1\":{\"470\":1}}],[\"在重新标记阶段不会标记浮动的新垃圾\",{\"1\":{\"466\":1}}],[\"在判断对象是否可达的时候\",{\"1\":{\"467\":1}}],[\"在注重吞吐量以及\",{\"1\":{\"465\":1}}],[\"在进行垃圾收集工作的时候必须暂停其他所有的工作线程\",{\"1\":{\"461\":1}}],[\"在新生代中\",{\"1\":{\"459\":1}}],[\"在标记完成后统一回收掉所有没有被标记的对象\",{\"1\":{\"457\":1}}],[\"在程序运行的时候就会产生两个object类\",{\"1\":{\"498\":1}}],[\"在程序运行的时候才能确定\",{\"1\":{\"295\":1}}],[\"在程序设计中一般很少使用弱引用与虚引用\",{\"1\":{\"453\":1}}],[\"在发生\",{\"1\":{\"447\":1}}],[\"在有的语境中也用于指代整堆收集\",{\"1\":{\"446\":1}}],[\"在分配的时候找到一块能满足分配大小的空闲内存进行分配\",{\"1\":{\"433\":1}}],[\"在jdk1\",{\"1\":{\"427\":1}}],[\"在虚拟机启动时创建\",{\"1\":{\"427\":1}}],[\"在读多写少的场合性能非常好\",{\"1\":{\"410\":1}}],[\"在编写代码的时候\",{\"1\":{\"400\":1}}],[\"在编译期间就会优化放入字符串常量池中\",{\"1\":{\"308\":1}}],[\"在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列\",{\"1\":{\"413\":1}}],[\"在实际使用过程中存在一些局限性比如不支持异步任务的编排组合\",{\"1\":{\"396\":1}}],[\"在实现repeatable\",{\"1\":{\"159\":1}}],[\"在这期间还可以取消任务以及获取任务的执行状态\",{\"1\":{\"394\":1}}],[\"在调用\",{\"1\":{\"383\":1}}],[\"在垃圾回收的时候\",{\"1\":{\"383\":1}}],[\"在cpu的物理世界里\",{\"1\":{\"362\":1}}],[\"在线程中对象分配内存的时候先会在tlab中分配\",{\"1\":{\"433\":1}}],[\"在线程并发执行的时候\",{\"1\":{\"358\":1}}],[\"在线活跃用户数\",{\"1\":{\"189\":1}}],[\"在多线程下\",{\"1\":{\"341\":1,\"354\":1}}],[\"在多线程环境下扩容操作可能存在死循环问题\",{\"1\":{\"270\":1}}],[\"在静态代码块中创建单例对象\",{\"1\":{\"330\":1}}],[\"在堆中创建字符串对象\",{\"1\":{\"307\":1}}],[\"在堆上创建一个新对象n\",{\"1\":{\"297\":1}}],[\"在类加载的时候\",{\"1\":{\"493\":1,\"497\":1}}],[\"在类加载的时候就会分配内存\",{\"1\":{\"288\":1}}],[\"在类的非静态成员不存在的时候静态方法就已经存在\",{\"1\":{\"288\":1}}],[\"在hotspot虚拟机中引入jit优化之后\",{\"1\":{\"279\":1}}],[\"在队列两端都能插入和删除元素\",{\"1\":{\"258\":1}}],[\"在上面结构的基础上\",{\"1\":{\"251\":1}}],[\"在启动时会比较计算出的校验和与文件末尾保存的校验和\",{\"1\":{\"245\":1}}],[\"在启动时对\",{\"1\":{\"245\":1}}],[\"在命令执行完之后再记录\",{\"1\":{\"243\":1}}],[\"在指定列表的头部\",{\"1\":{\"217\":1}}],[\"在指定列表的尾部\",{\"1\":{\"217\":1}}],[\"在没有同步到其他节点时\",{\"1\":{\"208\":1}}],[\"在键空间中\",{\"1\":{\"201\":2}}],[\"在写数据的过程中\",{\"1\":{\"175\":2}}],[\"在服务器内存使用完之后\",{\"1\":{\"172\":2}}],[\"在当前读下\",{\"1\":{\"166\":1}}],[\"在快照读的情况下\",{\"1\":{\"166\":1}}],[\"在事务隔离级别\",{\"1\":{\"164\":1}}],[\"在第一次查询时生成\",{\"1\":{\"159\":1}}],[\"在一定程度上解决了传统解释型语言执行效率低的问题\",{\"1\":{\"472\":1}}],[\"在一段代码中\",{\"1\":{\"399\":1}}],[\"在一致性非锁定读下\",{\"1\":{\"159\":1}}],[\"在一个事务内开启多次读\",{\"1\":{\"97\":1}}],[\"在一个关系中\",{\"1\":{\"84\":1}}],[\"在一个局域网内\",{\"1\":{\"79\":1}}],[\"在一个小的子网\",{\"1\":{\"39\":1}}],[\"在锁定读下\",{\"1\":{\"159\":1}}],[\"在更新数据的同时版本号\",{\"1\":{\"158\":1}}],[\"在同一个事务中\",{\"1\":{\"153\":1,\"160\":1}}],[\"在同步非阻塞io模型中\",{\"1\":{\"22\":1}}],[\"在执行任务前先countdownlatch\",{\"1\":{\"408\":1}}],[\"在执行\",{\"1\":{\"372\":1}}],[\"在执行monitorenter时\",{\"1\":{\"372\":1}}],[\"在执行更新语句过程\",{\"1\":{\"152\":1}}],[\"在执行运行在用户态下的程序时\",{\"1\":{\"3\":1}}],[\"在出现io瓶颈的场景里\",{\"1\":{\"151\":1}}],[\"在某个数据页上做了什么修改\",{\"1\":{\"149\":1}}],[\"在个日志文件组中还有两个重要的属性\",{\"1\":{\"147\":1}}],[\"在索引列上进行计算\",{\"1\":{\"143\":1}}],[\"在使用联合索引进行查询的时候\",{\"1\":{\"136\":1}}],[\"在innodb引擎中\",{\"1\":{\"134\":1}}],[\"在根据辅助索引查找时\",{\"1\":{\"127\":1}}],[\"在b树中进行范围查询时\",{\"1\":{\"127\":1}}],[\"在排序时使用了外部的索引排序\",{\"1\":{\"108\":1}}],[\"在满足需求的前提下越短越好\",{\"1\":{\"108\":1}}],[\"在redis\",{\"1\":{\"195\":1}}],[\"在rr隔离级别下\",{\"1\":{\"165\":1}}],[\"在rr级别下\",{\"1\":{\"106\":1}}],[\"在rc级别下\",{\"1\":{\"106\":1}}],[\"在为数据行加共享\",{\"1\":{\"105\":1}}],[\"在清空表中数据的时候使用\",{\"1\":{\"86\":1}}],[\"在删除表的时候使用\",{\"1\":{\"86\":1}}],[\"在关系模式\",{\"1\":{\"84\":1}}],[\"在属性x\",{\"1\":{\"84\":1}}],[\"在互联网中使用的\",{\"1\":{\"76\":1}}],[\"在网络发生拥塞之后\",{\"1\":{\"66\":1}}],[\"在网络上是明文传输的\",{\"1\":{\"40\":1}}],[\"在单个\",{\"1\":{\"55\":1}}],[\"在传递数据之前\",{\"1\":{\"53\":1}}],[\"在传送数据之前必须先建立连接\",{\"1\":{\"53\":1}}],[\"在传送数据之前不需要先建立连接\",{\"1\":{\"53\":1}}],[\"在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的\",{\"1\":{\"50\":1}}],[\"在\",{\"1\":{\"46\":1,\"84\":2,\"103\":1,\"108\":2,\"128\":1,\"153\":1,\"158\":2,\"159\":1,\"164\":2,\"165\":1,\"176\":1,\"204\":1,\"361\":1,\"364\":1,\"405\":1,\"437\":1,\"472\":1,\"481\":1}}],[\"在请求大资源前的预热请求\",{\"1\":{\"46\":1}}],[\"在约定中\",{\"1\":{\"40\":1}}],[\"在整个\",{\"1\":{\"39\":1}}],[\"在广域网\",{\"1\":{\"39\":1}}],[\"在客户端连接数量不高的情况下是没有问题的\",{\"1\":{\"21\":1}}],[\"多核环境下的硬件优势\",{\"1\":{\"467\":1}}],[\"多余的空闲线程存活的最长时间\",{\"1\":{\"388\":1}}],[\"多态不能调用只在子类中存在\",{\"1\":{\"295\":1}}],[\"多态\",{\"1\":{\"295\":1}}],[\"多线程下使用stringbuffer\",{\"1\":{\"303\":1}}],[\"多线程操作导致死链问题\",{\"0\":{\"270\":1}}],[\"多线程就会存在死锁\",{\"1\":{\"195\":1}}],[\"多重锁\",{\"1\":{\"207\":1}}],[\"多个任务等待异步完成\",{\"1\":{\"396\":1}}],[\"多个socket\",{\"1\":{\"194\":1}}],[\"多个线程可同时执行\",{\"1\":{\"406\":1}}],[\"多个线程共享本进程的堆和方法区\",{\"1\":{\"340\":1}}],[\"多个线程共享进程的堆和方法区\",{\"1\":{\"5\":1}}],[\"多个线程同时对链表进行操作\",{\"1\":{\"270\":1}}],[\"多个线程能并发处理不同的任务\",{\"1\":{\"6\":1}}],[\"多种开箱即用的集群方案\",{\"1\":{\"170\":1}}],[\"多版本并发控制就是对非锁定读的实现\",{\"1\":{\"158\":1}}],[\"多版本并发控制是乐观控制的模式\",{\"1\":{\"98\":1}}],[\"多条收集线程并发执行\",{\"1\":{\"467\":1}}],[\"多条\",{\"1\":{\"95\":1}}],[\"多对多\",{\"1\":{\"53\":1,\"89\":1}}],[\"多对一\",{\"1\":{\"53\":1}}],[\"多路复用\",{\"1\":{\"19\":1,\"171\":1}}],[\"种表有一个共同的特点\",{\"1\":{\"476\":1}}],[\"种包装类默认创建了数值\",{\"1\":{\"280\":1}}],[\"种数据结构\",{\"1\":{\"212\":1}}],[\"种数据结构是直接提供给用户使用的\",{\"1\":{\"212\":1}}],[\"种数据淘汰策略\",{\"1\":{\"201\":1}}],[\"种基本数据结构\",{\"1\":{\"212\":1}}],[\"种基础数据结构\",{\"1\":{\"181\":1}}],[\"种特殊数据结构\",{\"1\":{\"181\":1}}],[\"种常见\",{\"0\":{\"20\":1}}],[\"种\",{\"1\":{\"19\":1,\"46\":1,\"371\":1}}],[\"具备\",{\"1\":{\"206\":1}}],[\"具有四种类型的\",{\"1\":{\"506\":1}}],[\"具有弱引用的对象具有更短的声明周期\",{\"1\":{\"453\":1}}],[\"具有取消任务\",{\"1\":{\"395\":1}}],[\"具有以下特点\",{\"1\":{\"124\":1,\"126\":1}}],[\"具有提交和回滚事务的能力\",{\"1\":{\"93\":1}}],[\"具有高度的灵活性和可扩展性\",{\"1\":{\"39\":1}}],[\"具有特定的格式\",{\"1\":{\"9\":1}}],[\"具体来说就是jvm将符号引用转化为直接引用的时候\",{\"1\":{\"486\":1}}],[\"具体的执行方式\",{\"1\":{\"108\":1}}],[\"具体地说\",{\"1\":{\"39\":1}}],[\"具体\",{\"1\":{\"18\":1}}],[\"操作字节流了\",{\"1\":{\"486\":1}}],[\"操作实现\",{\"1\":{\"413\":1}}],[\"操作去修改\",{\"1\":{\"407\":2}}],[\"操作的结果还没有存入变量中\",{\"1\":{\"358\":1}}],[\"操作的调用而已\",{\"1\":{\"18\":1}}],[\"操作数栈\",{\"1\":{\"342\":1,\"424\":2}}],[\"操作轻量\",{\"1\":{\"246\":1}}],[\"操作缓存就是直接操作内存\",{\"1\":{\"173\":1}}],[\"操作在内部被视为更新\",{\"1\":{\"161\":1}}],[\"操作才能查询到\",{\"1\":{\"126\":1}}],[\"操作\",{\"1\":{\"18\":1,\"158\":1,\"159\":1,\"368\":1}}],[\"操作系统基本特征\",{\"1\":{\"462\":1}}],[\"操作系统负责的内核执行具体的\",{\"1\":{\"18\":1}}],[\"操作系统负责管理计算机网络的使用\",{\"1\":{\"2\":1}}],[\"操作系统会通知相应的线程进行后续的操作\",{\"1\":{\"23\":1}}],[\"操作系统会将孤儿进程的父进程设置为\",{\"1\":{\"10\":1}}],[\"操作系统会根据这些信息来管理和调度进程\",{\"1\":{\"8\":1}}],[\"操作系统重启\",{\"1\":{\"9\":1}}],[\"操作系统需要管理计算机网络的配置\",{\"1\":{\"2\":1}}],[\"操作系统的功能\",{\"0\":{\"2\":1}}],[\"操作系统\",{\"0\":{\"1\":1}}],[\"输入了两个参数\",{\"1\":{\"289\":1}}],[\"输入了一个参数\",{\"1\":{\"289\":1}}],[\"输入的数据一样\",{\"1\":{\"289\":1}}],[\"输入输出设备和外部存储设备等\",{\"1\":{\"2\":1}}],[\"输出为\",{\"1\":{\"312\":1}}],[\"输出\",{\"1\":{\"18\":1}}],[\"何为io\",{\"0\":{\"18\":1}}],[\"依次包括了访问标志\",{\"1\":{\"480\":1}}],[\"依次是\",{\"1\":{\"397\":1}}],[\"依赖于\",{\"1\":{\"377\":2}}],[\"依赖于有序的数据\",{\"1\":{\"131\":1,\"132\":1}}],[\"依此往复\",{\"1\":{\"16\":2}}],[\"依然存在于系统中\",{\"1\":{\"10\":1}}],[\"磁头沿着一个方向扫描磁盘\",{\"1\":{\"16\":1}}],[\"磁盘等\",{\"1\":{\"2\":1}}],[\"扫描算法\",{\"1\":{\"16\":1}}],[\"避免程序一直原地等待耗时任务执行完成\",{\"1\":{\"394\":1}}],[\"避免了线程同步问题\",{\"1\":{\"330\":1}}],[\"避免了锁无法被释放\",{\"1\":{\"209\":1}}],[\"避免堆上分配对象\",{\"1\":{\"279\":1}}],[\"避免额外的检查开销\",{\"1\":{\"243\":1}}],[\"避免竞争锁\",{\"1\":{\"210\":1}}],[\"避免无效自旋\",{\"1\":{\"209\":1}}],[\"避免锁的误释放\",{\"1\":{\"204\":1}}],[\"避免索引失效\",{\"0\":{\"143\":1}}],[\"避免出现饥饿问题\",{\"1\":{\"16\":1}}],[\"避免僵尸进程的产生\",{\"1\":{\"10\":1}}],[\"t1\",{\"1\":{\"497\":3}}],[\"t0\",{\"1\":{\"497\":2}}],[\"to\",{\"1\":{\"507\":1}}],[\"totalnum\",{\"1\":{\"358\":1}}],[\"token\",{\"1\":{\"182\":1,\"215\":1}}],[\"the\",{\"1\":{\"461\":1,\"467\":1}}],[\"thenacceptasync\",{\"1\":{\"396\":1}}],[\"then\",{\"1\":{\"204\":1,\"206\":1}}],[\"threadfactory\",{\"1\":{\"388\":3}}],[\"threadpoolexecutor其他常见参数\",{\"1\":{\"388\":1}}],[\"threadpoolexecutor\",{\"1\":{\"387\":1,\"388\":1,\"389\":4}}],[\"thread\",{\"1\":{\"382\":5,\"405\":1}}],[\"thread类源码\",{\"1\":{\"382\":1}}],[\"threadlocal中就存在内存泄漏\",{\"1\":{\"512\":1}}],[\"threadlocal内存泄露\",{\"0\":{\"383\":1}}],[\"threadlocal类的set\",{\"1\":{\"382\":1}}],[\"threadlocal类主要解决的就是让每个线程绑定自己的值\",{\"1\":{\"381\":1}}],[\"threadlocal可以理解为threadlocalmap的封装\",{\"1\":{\"382\":1}}],[\"threadlocals\",{\"1\":{\"382\":3}}],[\"threadlocalmap是threadlocal的静态内部类\",{\"1\":{\"382\":1}}],[\"threadlocalmap\",{\"1\":{\"382\":4,\"383\":3}}],[\"threadlocal原理\",{\"0\":{\"382\":1}}],[\"threadlocal\",{\"0\":{\"380\":1,\"381\":1},\"1\":{\"382\":2,\"383\":2}}],[\"thread对象的start\",{\"1\":{\"359\":1}}],[\"threadid\",{\"1\":{\"206\":2}}],[\"throwable\",{\"1\":{\"323\":1,\"324\":1}}],[\"throws\",{\"1\":{\"316\":1,\"323\":2,\"324\":1,\"497\":1}}],[\"through\",{\"0\":{\"176\":1},\"1\":{\"176\":6,\"177\":2}}],[\"this\",{\"0\":{\"478\":1},\"1\":{\"206\":2,\"316\":1,\"382\":1,\"396\":1,\"478\":1,\"496\":1}}],[\"t\",{\"1\":{\"136\":2,\"150\":1,\"152\":1,\"318\":2,\"382\":6,\"507\":1}}],[\"teachernum\",{\"1\":{\"358\":2}}],[\"terminated\",{\"1\":{\"344\":1}}],[\"temp\",{\"1\":{\"260\":6}}],[\"temporary\",{\"1\":{\"108\":1}}],[\"telnet\",{\"1\":{\"37\":3,\"56\":3}}],[\"type\",{\"1\":{\"108\":2}}],[\"take\",{\"1\":{\"417\":1}}],[\"targetsurvivorratio=percent\",{\"1\":{\"445\":1}}],[\"targetobject\",{\"1\":{\"319\":1}}],[\"targetclass\",{\"1\":{\"319\":1}}],[\"target\",{\"1\":{\"316\":5,\"318\":5}}],[\"table\",{\"1\":{\"86\":3,\"102\":2,\"108\":1,\"136\":2,\"212\":2}}],[\"tag\",{\"1\":{\"46\":1,\"476\":1}}],[\"try\",{\"1\":{\"497\":1}}],[\"tryacquire\",{\"1\":{\"407\":1}}],[\"true\",{\"1\":{\"293\":3,\"307\":2,\"308\":1,\"319\":1,\"495\":1}}],[\"truncate\",{\"0\":{\"86\":1},\"1\":{\"86\":2}}],[\"treemap还实现了navigablemap接口和sortedmap\",{\"1\":{\"265\":1}}],[\"treemap\",{\"0\":{\"265\":1},\"1\":{\"265\":3}}],[\"treeset底层是红黑树\",{\"1\":{\"257\":1}}],[\"treeset\",{\"0\":{\"257\":1},\"1\":{\"225\":1,\"251\":1,\"257\":1}}],[\"trx\",{\"1\":{\"146\":2,\"153\":1,\"160\":1,\"161\":1,\"162\":1}}],[\"transaction\",{\"1\":{\"95\":1}}],[\"translation\",{\"1\":{\"39\":1,\"75\":1,\"76\":1}}],[\"transmission\",{\"1\":{\"38\":1}}],[\"transport\",{\"1\":{\"37\":1}}],[\"transfer\",{\"1\":{\"37\":3,\"56\":4}}],[\"ttl\",{\"1\":{\"79\":1,\"199\":1,\"201\":1}}],[\"ttl>\",{\"1\":{\"79\":1}}],[\"tlab\",{\"1\":{\"513\":1}}],[\"tld\",{\"1\":{\"50\":3}}],[\"tls\",{\"1\":{\"45\":2}}],[\"timeout\",{\"1\":{\"349\":1}}],[\"timeout有可能是服务器断网了\",{\"1\":{\"44\":1}}],[\"timeunit\",{\"1\":{\"206\":1,\"388\":1}}],[\"time=now\",{\"1\":{\"150\":2}}],[\"time\",{\"1\":{\"16\":2,\"37\":1,\"344\":1}}],[\"tcp三次握手\",{\"0\":{\"58\":1}}],[\"tcp\",{\"0\":{\"52\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"57\":1,\"60\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1},\"1\":{\"9\":1,\"37\":7,\"38\":1,\"39\":1,\"40\":4,\"43\":1,\"45\":2,\"53\":12,\"54\":1,\"55\":7,\"56\":2,\"58\":1,\"64\":8,\"65\":1}}],[\"最快的gc是不发生gc\",{\"0\":{\"512\":1}}],[\"最多分割几个文件\",{\"1\":{\"507\":1}}],[\"最多丢失\",{\"1\":{\"246\":1}}],[\"最小2gb内存\",{\"1\":{\"502\":1}}],[\"最顶层的加载类\",{\"1\":{\"494\":1}}],[\"最低层的链表维护了跳表内所有的元素\",{\"1\":{\"418\":1}}],[\"最低的隔离级别\",{\"1\":{\"156\":1}}],[\"最近通过自旋获得过这个锁\",{\"1\":{\"398\":1}}],[\"最大大小\",{\"1\":{\"504\":1}}],[\"最大扩容可达\",{\"1\":{\"390\":1}}],[\"最大可以同时运行的线程数量\",{\"1\":{\"388\":1}}],[\"最大线程数是线程池参数\",{\"1\":{\"387\":1}}],[\"最大线程数为integer\",{\"1\":{\"387\":2}}],[\"最大线程数为1\",{\"1\":{\"387\":1}}],[\"最大线程数为n\",{\"1\":{\"387\":1}}],[\"最新动态\",{\"1\":{\"218\":1}}],[\"最新文章\",{\"1\":{\"218\":1}}],[\"最右边\",{\"1\":{\"217\":1}}],[\"最左边\",{\"1\":{\"217\":1}}],[\"最左匹配原则\",{\"0\":{\"136\":1}}],[\"最主要的是对会话失效的情况处理不一样\",{\"1\":{\"210\":1}}],[\"最要命的是没有广播机制\",{\"1\":{\"179\":1}}],[\"最高的隔离级别\",{\"1\":{\"156\":1}}],[\"最终的请求都会到顶层的启动类加载器bootstrapclassloader中\",{\"1\":{\"497\":1}}],[\"最终标记\",{\"1\":{\"467\":1}}],[\"最终数据不一致\",{\"1\":{\"152\":1}}],[\"最终需要会表查询\",{\"1\":{\"134\":1}}],[\"最后把需要回收的region里的存活对象复制到新region中\",{\"1\":{\"467\":1}}],[\"最后\",{\"1\":{\"244\":1}}],[\"最后再根据持久化方式的配置来决定何时将系统内核缓存区的数据同步到磁盘中\",{\"1\":{\"240\":1}}],[\"最后再从内核态切换为用户态\",{\"1\":{\"3\":1}}],[\"最后还有一种折中方式\",{\"1\":{\"151\":1}}],[\"最坏情况下退化为线性链表\",{\"1\":{\"124\":1}}],[\"最短寻道时间优先算法\",{\"1\":{\"16\":1}}],[\"同样满足\",{\"1\":{\"416\":1}}],[\"同样根据返回值不同分为两类方法\",{\"1\":{\"258\":1}}],[\"同样的\",{\"1\":{\"151\":1}}],[\"同一个数据库中的表分布在不同的数据库中\",{\"1\":{\"119\":2}}],[\"同一个进程的线程共享内存和文件\",{\"1\":{\"6\":1}}],[\"同步锁就没有必要加上了\",{\"1\":{\"399\":1}}],[\"同步队列\",{\"1\":{\"390\":1}}],[\"同步语句块的实现使用的是\",{\"1\":{\"372\":2}}],[\"同步代码块\",{\"1\":{\"328\":1}}],[\"同步方法\",{\"0\":{\"331\":1},\"1\":{\"328\":1}}],[\"同步更新\",{\"1\":{\"176\":1}}],[\"同步数据时\",{\"1\":{\"150\":1}}],[\"同步数据本地\",{\"1\":{\"113\":1}}],[\"同步\",{\"1\":{\"148\":1}}],[\"同步非阻塞io模型确实有很大的改进\",{\"1\":{\"22\":1}}],[\"同步非阻塞\",{\"1\":{\"19\":1}}],[\"同步阻塞io模型中\",{\"1\":{\"21\":1}}],[\"同步阻塞\",{\"1\":{\"19\":1}}],[\"同时又保留了解释型语言可移植的特点\",{\"1\":{\"472\":1}}],[\"同时开启\",{\"1\":{\"466\":1}}],[\"同时工作\",{\"1\":{\"466\":1}}],[\"同时对队列的读写存在多个线程同时进行的场景\",{\"1\":{\"413\":1}}],[\"同时会唤醒同步队列中的一个线程\",{\"1\":{\"407\":1}}],[\"同时通过对链表进行相应的操作\",{\"1\":{\"251\":1}}],[\"同时也带来了风险\",{\"1\":{\"243\":1}}],[\"同时将一个或多个\",{\"1\":{\"220\":1}}],[\"同时使用了惰性删除与定期删除\",{\"1\":{\"172\":1}}],[\"同时还能减少传统的重量级锁使用操作系统互斥量产生的性能消耗\",{\"1\":{\"401\":1}}],[\"同时还提供\",{\"1\":{\"172\":1}}],[\"同时还有一个日志模块\",{\"1\":{\"91\":1}}],[\"同时\",{\"1\":{\"16\":1,\"417\":1,\"466\":1}}],[\"先判断这个类是否已经加载过了\",{\"1\":{\"497\":1}}],[\"先会检查指令的参数能否在常量池中找到这个参数对应类的符号引用\",{\"1\":{\"432\":1}}],[\"先申请的线程先得到锁\",{\"1\":{\"376\":1}}],[\"先比较锁对应的\",{\"1\":{\"204\":1}}],[\"先从\",{\"1\":{\"176\":1}}],[\"先查\",{\"1\":{\"176\":1}}],[\"先更新\",{\"1\":{\"175\":1}}],[\"先更新db\",{\"1\":{\"175\":1}}],[\"先把\",{\"1\":{\"175\":1}}],[\"先把日志写到binlog\",{\"1\":{\"151\":1}}],[\"先是按照a字段的值排序\",{\"1\":{\"136\":1}}],[\"先用\",{\"1\":{\"107\":1}}],[\"先发送\",{\"1\":{\"40\":1}}],[\"先到达的请求的先被服务\",{\"1\":{\"16\":1}}],[\"先来先服务算法\",{\"1\":{\"16\":1}}],[\"先进先出\",{\"1\":{\"9\":1}}],[\"又有新的任务提交\",{\"1\":{\"387\":1}}],[\"又可以很好地与redis服务器中其他同样以单线程方式运行的模块进行对阶\",{\"1\":{\"193\":1}}],[\"又称写锁\",{\"1\":{\"104\":1}}],[\"又称读锁\",{\"1\":{\"104\":1}}],[\"又称为管态\",{\"1\":{\"3\":1}}],[\"又称为目态\",{\"1\":{\"3\":1}}],[\"又从\",{\"1\":{\"86\":1}}],[\"又被叫为符号链接\",{\"1\":{\"15\":1}}],[\"号的文件\",{\"1\":{\"15\":1}}],[\"56\",{\"1\":{\"199\":1}}],[\"5之前\",{\"1\":{\"92\":1}}],[\"50\",{\"1\":{\"445\":2}}],[\"504\",{\"1\":{\"44\":1}}],[\"502\",{\"1\":{\"44\":1}}],[\"500服务端内部出现错误\",{\"1\":{\"44\":1}}],[\"5开头的表示服务端错误\",{\"1\":{\"44\":1}}],[\"5\",{\"0\":{\"436\":1},\"1\":{\"15\":1,\"19\":1,\"92\":2,\"137\":1,\"141\":1,\"179\":2,\"181\":1,\"212\":2,\"218\":1,\"260\":1,\"312\":1,\"368\":1,\"407\":2,\"464\":1,\"475\":1}}],[\"4~1\",{\"1\":{\"515\":1}}],[\"4种整数类型\",{\"1\":{\"278\":1}}],[\"410\",{\"1\":{\"46\":1}}],[\"443\",{\"1\":{\"45\":1}}],[\"409\",{\"1\":{\"46\":1}}],[\"404not\",{\"1\":{\"44\":1}}],[\"403服务器拒绝执行该请求\",{\"1\":{\"44\":1}}],[\"401未授权\",{\"1\":{\"44\":1}}],[\"400\",{\"1\":{\"44\":1}}],[\"4开头的表示客户端错误\",{\"1\":{\"44\":1}}],[\"4平潭\",{\"0\":{\"33\":1}}],[\"4中引入\",{\"1\":{\"22\":1}}],[\"4\",{\"0\":{\"435\":1},\"1\":{\"15\":1,\"173\":1,\"192\":1,\"195\":1,\"201\":1,\"206\":1,\"210\":1,\"280\":1,\"312\":1,\"474\":1}}],[\"3操作已经开始执行\",{\"1\":{\"358\":1}}],[\"3nf在2nf的基础上\",{\"1\":{\"85\":1}}],[\"3nf\",{\"0\":{\"85\":1},\"1\":{\"85\":1}}],[\"30s\",{\"1\":{\"206\":1}}],[\"30秒\",{\"1\":{\"206\":1}}],[\"30\",{\"1\":{\"206\":3}}],[\"30w+\",{\"1\":{\"173\":1}}],[\"303响应状态码返回时\",{\"1\":{\"44\":1}}],[\"302\",{\"1\":{\"44\":1}}],[\"302表示临时性的重定向\",{\"1\":{\"44\":1}}],[\"304表示客户端发送附带条件的请求时\",{\"1\":{\"44\":1}}],[\"301表示永久性的重定向\",{\"1\":{\"44\":1}}],[\"3开头的表示重定向\",{\"1\":{\"44\":1}}],[\"3\",{\"0\":{\"20\":1,\"434\":1},\"1\":{\"15\":1,\"55\":4,\"181\":1,\"205\":3,\"206\":1,\"312\":1,\"324\":1,\"358\":1,\"371\":1,\"388\":1,\"437\":1,\"455\":2,\"515\":1}}],[\"及之后\",{\"1\":{\"487\":1}}],[\"及之前版本的\",{\"1\":{\"270\":1}}],[\"及以后方法区的实现变成了元空间\",{\"1\":{\"428\":1}}],[\"及\",{\"1\":{\"15\":1}}],[\"lwp\",{\"1\":{\"509\":1}}],[\"lfence\",{\"1\":{\"362\":1}}],[\"lfu\",{\"1\":{\"201\":2}}],[\"llc\",{\"1\":{\"231\":1}}],[\"llen\",{\"1\":{\"217\":1}}],[\"lrange\",{\"1\":{\"217\":1,\"218\":1}}],[\"lru\",{\"1\":{\"201\":2}}],[\"lpop\",{\"1\":{\"217\":1}}],[\"lpush\",{\"1\":{\"217\":1,\"218\":1}}],[\"lset\",{\"1\":{\"217\":1}}],[\"lua\",{\"1\":{\"170\":1,\"172\":1,\"179\":1,\"204\":2}}],[\"lib\",{\"1\":{\"494\":1}}],[\"lib目录下的\",{\"1\":{\"494\":1}}],[\"list\",{\"0\":{\"216\":1,\"250\":1,\"252\":1},\"1\":{\"172\":1,\"179\":4,\"181\":1,\"212\":2,\"216\":2,\"218\":1,\"250\":1,\"251\":1,\"410\":1,\"412\":1}}],[\"limit\",{\"1\":{\"162\":4,\"512\":1}}],[\"like\",{\"1\":{\"143\":2}}],[\"linking\",{\"1\":{\"483\":1}}],[\"linkedblockingqueue\",{\"0\":{\"416\":1},\"1\":{\"390\":1,\"416\":3}}],[\"linkedblockingqueue无界队列\",{\"1\":{\"387\":2}}],[\"linkedhashset底层是链表和哈希表\",{\"1\":{\"257\":1}}],[\"linkedhashset\",{\"0\":{\"257\":1},\"1\":{\"257\":1}}],[\"linkedhashset是hashset子类\",{\"1\":{\"251\":1}}],[\"linkedhashmap\",{\"1\":{\"251\":4}}],[\"linkedlist不支持随机访问\",{\"1\":{\"255\":1}}],[\"linkedlist底层使用双向链表存储数据\",{\"1\":{\"255\":1}}],[\"linkedlist\",{\"0\":{\"255\":1,\"259\":1},\"1\":{\"212\":2,\"251\":1,\"259\":3,\"410\":1}}],[\"link\",{\"1\":{\"15\":4}}],[\"least\",{\"1\":{\"201\":4}}],[\"len\",{\"1\":{\"108\":3,\"184\":3}}],[\"level\",{\"1\":{\"102\":3}}],[\"largepagesizeinbytes\",{\"1\":{\"509\":1}}],[\"latitude\",{\"1\":{\"235\":1}}],[\"latitude1\",{\"1\":{\"235\":1}}],[\"lazy\",{\"1\":{\"197\":1}}],[\"last\",{\"1\":{\"60\":1}}],[\"layer\",{\"1\":{\"39\":1}}],[\"lang\",{\"1\":{\"324\":1,\"455\":1,\"478\":2,\"489\":1,\"495\":1,\"498\":1,\"504\":1}}],[\"language\",{\"1\":{\"87\":2}}],[\"lan\",{\"1\":{\"39\":4,\"78\":1}}],[\"loading\",{\"1\":{\"483\":1}}],[\"loader\",{\"1\":{\"323\":2,\"496\":1}}],[\"loadclass\",{\"1\":{\"318\":1,\"495\":2,\"497\":2,\"499\":1}}],[\"loadclasss\",{\"1\":{\"318\":1}}],[\"load\",{\"1\":{\"241\":1,\"362\":1}}],[\"longadder\",{\"1\":{\"364\":1}}],[\"longitude\",{\"1\":{\"235\":1}}],[\"longitude1\",{\"1\":{\"235\":1}}],[\"longcodec\",{\"1\":{\"206\":1}}],[\"long\",{\"1\":{\"199\":1,\"206\":4,\"278\":1,\"280\":1,\"314\":1,\"349\":1,\"388\":1,\"497\":2}}],[\"low\",{\"1\":{\"162\":2,\"260\":2}}],[\"loop\",{\"1\":{\"108\":1}}],[\"look\",{\"1\":{\"16\":5}}],[\"loglog\",{\"1\":{\"231\":1}}],[\"log设置commit阶段发生异常\",{\"1\":{\"152\":1}}],[\"log还处于prepare阶段\",{\"1\":{\"152\":1}}],[\"log的写入拆成了两个步骤prepare和commit\",{\"1\":{\"152\":1}}],[\"log日志恢复数据时\",{\"1\":{\"152\":1}}],[\"log日志恢复\",{\"1\":{\"152\":1}}],[\"log日志后\",{\"1\":{\"152\":1}}],[\"log与binlog的写入时机不一样\",{\"1\":{\"152\":1}}],[\"log与binlog两块日志\",{\"1\":{\"152\":1}}],[\"log在事务执行过程中可以不断写入\",{\"1\":{\"152\":1}}],[\"log是处于prepare阶段\",{\"1\":{\"152\":1}}],[\"log是物理日志\",{\"1\":{\"149\":1}}],[\"log是重做日志\",{\"1\":{\"145\":1}}],[\"log形式记录修改内容\",{\"1\":{\"148\":1}}],[\"log刷盘和从buffer\",{\"1\":{\"148\":1}}],[\"log文件里\",{\"1\":{\"145\":1}}],[\"logn\",{\"1\":{\"125\":1,\"126\":1,\"260\":1}}],[\"log2\",{\"1\":{\"124\":1}}],[\"log\",{\"0\":{\"145\":1,\"148\":1,\"153\":1,\"163\":1},\"1\":{\"91\":2,\"93\":1,\"113\":2,\"145\":1,\"146\":8,\"147\":6,\"148\":1,\"151\":1,\"152\":1,\"153\":3,\"154\":2,\"160\":2,\"161\":1,\"163\":2,\"507\":1}}],[\"locate\",{\"1\":{\"47\":1}}],[\"locator\",{\"1\":{\"47\":1}}],[\"lockinterruptibly\",{\"1\":{\"377\":1}}],[\"locking\",{\"1\":{\"102\":3}}],[\"lock0上注册一个事件监听器\",{\"1\":{\"209\":1}}],[\"lock1是最小的子节点\",{\"1\":{\"209\":1}}],[\"lock1是否是\",{\"1\":{\"209\":1}}],[\"lock1节点\",{\"1\":{\"209\":1}}],[\"locks\",{\"1\":{\"209\":4,\"403\":1}}],[\"lockwatchdogtimeout\",{\"1\":{\"206\":5}}],[\"lockkey\",{\"1\":{\"204\":3,\"205\":3}}],[\"lock来防止这种情况\",{\"1\":{\"166\":1}}],[\"lock来解决幻读问题\",{\"1\":{\"166\":1}}],[\"lock防止幻读\",{\"0\":{\"166\":1}}],[\"lock+gap\",{\"1\":{\"103\":1,\"166\":1}}],[\"lock可解决幻读\",{\"1\":{\"97\":1}}],[\"lock\",{\"1\":{\"7\":2,\"93\":1,\"103\":7,\"105\":2,\"106\":1,\"156\":4,\"158\":1,\"159\":3,\"166\":3,\"206\":7,\"207\":3,\"375\":1,\"377\":1}}],[\"eden\",{\"1\":{\"443\":2,\"445\":3,\"509\":2}}],[\"e\",{\"1\":{\"258\":12,\"366\":1,\"497\":1}}],[\"ephemeral\",{\"1\":{\"210\":3}}],[\"entry\",{\"1\":{\"383\":1}}],[\"entity\",{\"1\":{\"46\":1}}],[\"enum\",{\"1\":{\"334\":1}}],[\"end\",{\"1\":{\"204\":1,\"206\":1,\"217\":2,\"226\":4,\"229\":2}}],[\"else\",{\"1\":{\"204\":1,\"260\":1,\"382\":1,\"497\":1}}],[\"element\",{\"1\":{\"258\":1}}],[\"element2\",{\"1\":{\"190\":1,\"232\":1}}],[\"element1\",{\"1\":{\"190\":1,\"232\":1}}],[\"elevator\",{\"1\":{\"16\":1}}],[\"everysec\",{\"1\":{\"242\":1,\"246\":1}}],[\"event\",{\"1\":{\"7\":1}}],[\"eval\",{\"1\":{\"206\":1}}],[\"evalwriteasync\",{\"1\":{\"206\":1}}],[\"eviction\",{\"1\":{\"201\":1}}],[\"equals存在两种情况\",{\"1\":{\"299\":1}}],[\"equals\",{\"0\":{\"301\":1},\"1\":{\"293\":2}}],[\"eq\",{\"1\":{\"108\":2}}],[\"executequery\",{\"1\":{\"512\":1}}],[\"executorservice\",{\"1\":{\"395\":1}}],[\"executors\",{\"1\":{\"387\":1}}],[\"executor\",{\"1\":{\"387\":1,\"388\":1,\"396\":4}}],[\"example\",{\"1\":{\"285\":1,\"289\":1}}],[\"exists\",{\"1\":{\"204\":1,\"214\":1}}],[\"ex\",{\"1\":{\"199\":1,\"205\":4}}],[\"ext\",{\"1\":{\"494\":2}}],[\"extclassloader\",{\"1\":{\"490\":1}}],[\"extra\",{\"1\":{\"108\":1}}],[\"extends\",{\"1\":{\"324\":1}}],[\"extensionclassloader\",{\"1\":{\"494\":1}}],[\"extension\",{\"1\":{\"75\":1}}],[\"external\",{\"1\":{\"12\":1}}],[\"expected\",{\"1\":{\"366\":1}}],[\"expire\",{\"1\":{\"199\":1,\"214\":1}}],[\"expires\",{\"1\":{\"46\":1,\"201\":4}}],[\"explain\",{\"1\":{\"108\":2}}],[\"exclusive\",{\"1\":{\"105\":1,\"406\":1}}],[\"外部实现的\",{\"1\":{\"494\":1}}],[\"外部内存碎片指的是那些并为分配给进程但又不能使用的内存\",{\"1\":{\"12\":1}}],[\"外部内存碎片\",{\"1\":{\"12\":1}}],[\"外\",{\"1\":{\"478\":1}}],[\"外层的\",{\"1\":{\"108\":1}}],[\"外键对于维护数据的一致性非常有帮助\",{\"1\":{\"93\":1}}],[\"外衣的\",{\"1\":{\"56\":1}}],[\"外存\",{\"1\":{\"2\":1}}],[\"固定分区分配\",{\"1\":{\"12\":1}}],[\"6中引入的一项锁优化\",{\"1\":{\"402\":1}}],[\"6之中加入的新型锁机制\",{\"1\":{\"401\":1}}],[\"6之后引入自适应锁\",{\"1\":{\"398\":1}}],[\"6之前为循环链表\",{\"1\":{\"251\":1,\"255\":1}}],[\"64\",{\"1\":{\"509\":1}}],[\"64位补码的范围数字应该如何表示\",{\"0\":{\"284\":1}}],[\"64mb\",{\"1\":{\"244\":1}}],[\"6种数字类型\",{\"1\":{\"278\":1}}],[\"6\",{\"0\":{\"195\":1,\"196\":1},\"1\":{\"172\":1,\"192\":1,\"196\":1,\"201\":1,\"259\":1,\"370\":1,\"475\":1,\"509\":1}}],[\"6字节\",{\"1\":{\"161\":2}}],[\"6版本中提供的索引优化功能\",{\"1\":{\"137\":1}}],[\"6byte\",{\"1\":{\"128\":1}}],[\"60s\",{\"1\":{\"199\":2}}],[\"60\",{\"1\":{\"53\":1,\"199\":2}}],[\"68海里景区\",{\"1\":{\"33\":1}}],[\"6379>\",{\"1\":{\"199\":3,\"205\":1}}],[\"63\",{\"1\":{\"12\":1}}],[\"65\",{\"1\":{\"12\":1}}],[\"那该接口要在其之前被初始化\",{\"1\":{\"489\":1}}],[\"那这时就要改为进行一次\",{\"1\":{\"447\":1}}],[\"那这一次\",{\"1\":{\"447\":1}}],[\"那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小\",{\"1\":{\"447\":1}}],[\"那会不会回滚事务呢\",{\"1\":{\"152\":1}}],[\"那偏向锁就是在无竞争的情况下把整个同步都消除掉\",{\"1\":{\"402\":1}}],[\"那里直接取出任务执行结果\",{\"1\":{\"394\":1}}],[\"那就会直接放到humongous里\",{\"1\":{\"469\":1}}],[\"那就证明任务还没有执行完毕\",{\"1\":{\"408\":1}}],[\"那就在常量池中创建一个指向该字符串对象的引用并返回\",{\"1\":{\"307\":1}}],[\"那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了\",{\"1\":{\"173\":1}}],[\"那其他事务不能再对这条事务加任何类型的锁\",{\"1\":{\"104\":1}}],[\"那么该类是通过\",{\"1\":{\"494\":1}}],[\"那么value变量在准备阶段的的初始值是0而不是111\",{\"1\":{\"487\":1}}],[\"那么\",{\"1\":{\"440\":1}}],[\"那么当前任务会被拒绝\",{\"1\":{\"391\":1}}],[\"那么当这个表的数据达到一个体量后\",{\"1\":{\"142\":1}}],[\"那么访问这个变量的每一个线程都有这个变量的副本\",{\"1\":{\"381\":1}}],[\"那么它就会从内存重新读取\",{\"1\":{\"362\":1}}],[\"那么另外的线程都是能立即看到的\",{\"1\":{\"360\":1}}],[\"那么校验和也会随之改变\",{\"1\":{\"245\":1}}],[\"那么我们就可以很放心地将该用户访问的数据存在缓存中\",{\"1\":{\"173\":1}}],[\"那么会导致索引失效\",{\"1\":{\"143\":1}}],[\"那么对效率影响不大\",{\"1\":{\"143\":1}}],[\"那么对应的索引也将会被修改\",{\"1\":{\"131\":1}}],[\"那么对应的数据包就被假设为已丢失open\",{\"1\":{\"64\":1}}],[\"那么就可以在所引用的对象的内存被回收之前采取必要的行动\",{\"1\":{\"453\":1}}],[\"那么就将计数器减\",{\"1\":{\"409\":1}}],[\"那么就把该任务放入到任务队列里等待执行\",{\"1\":{\"391\":1}}],[\"那么就会新建一个线程来执行任务\",{\"1\":{\"391\":1}}],[\"那么就更不应该在这种字段上建立索引了\",{\"1\":{\"140\":1}}],[\"那么就需要在插入时排序\",{\"1\":{\"131\":1}}],[\"那么索引也需要改动\",{\"1\":{\"121\":1}}],[\"那么数据库自带的事物就无法满足要求\",{\"1\":{\"119\":1}}],[\"那么和这张表的所有缓存数据都失效\",{\"1\":{\"94\":1}}],[\"那么可以说y函数依赖于x\",{\"1\":{\"84\":1}}],[\"那么可能会引起网络阻塞\",{\"1\":{\"66\":1}}],[\"那么一切网络设备都由\",{\"1\":{\"78\":1}}],[\"那\",{\"1\":{\"12\":1}}],[\"2个字节\",{\"1\":{\"475\":2}}],[\"2n\",{\"1\":{\"392\":1}}],[\"2nf在1nf的基础上\",{\"1\":{\"84\":1}}],[\"2nf\",{\"0\":{\"84\":1}}],[\"2种浮点数类型\",{\"1\":{\"278\":1}}],[\"2msl\",{\"1\":{\"60\":1,\"62\":1}}],[\"24\",{\"1\":{\"46\":1}}],[\"20210309\",{\"1\":{\"189\":3}}],[\"20210308~20210309\",{\"1\":{\"189\":2}}],[\"20210308\",{\"1\":{\"189\":4}}],[\"2023\",{\"0\":{\"33\":1}}],[\"20\",{\"1\":{\"53\":1,\"79\":1}}],[\"206\",{\"1\":{\"46\":2}}],[\"200表示请求成功\",{\"1\":{\"44\":1}}],[\"2开头的表示客户端的请求成功被接收\",{\"1\":{\"44\":1}}],[\"2^7\",{\"1\":{\"12\":1}}],[\"2\",{\"0\":{\"62\":1,\"269\":1,\"433\":1},\"1\":{\"12\":1,\"15\":2,\"23\":2,\"55\":3,\"60\":1,\"62\":1,\"136\":2,\"146\":2,\"166\":1,\"173\":1,\"175\":2,\"179\":2,\"189\":2,\"190\":1,\"206\":2,\"259\":1,\"260\":3,\"312\":1,\"358\":2,\"390\":1,\"458\":1,\"503\":2}}],[\"简化了网络配置和管理\",{\"1\":{\"75\":1}}],[\"简称\",{\"1\":{\"75\":1,\"234\":1}}],[\"简称为外部碎片\",{\"1\":{\"12\":1}}],[\"简称为内存碎片\",{\"1\":{\"12\":1}}],[\"简单地说\",{\"1\":{\"417\":1}}],[\"简单理解\",{\"1\":{\"394\":1}}],[\"简单动态字符串\",{\"1\":{\"184\":1,\"212\":1,\"213\":1}}],[\"简单限流可以用到\",{\"1\":{\"182\":1,\"215\":1}}],[\"简单查询\",{\"1\":{\"108\":1}}],[\"简单来说\",{\"1\":{\"87\":1}}],[\"简单来说就是不管发出去之后的事情了\",{\"1\":{\"53\":1}}],[\"简单邮件传输协议\",{\"1\":{\"56\":1}}],[\"简单邮件发送协议\",{\"1\":{\"37\":1}}],[\"简单高效\",{\"1\":{\"38\":1,\"449\":1,\"461\":1}}],[\"简单的说就是通信的两方的一种约定\",{\"1\":{\"9\":1}}],[\"fullgc和minorgc频繁\",{\"1\":{\"517\":1}}],[\"full\",{\"1\":{\"446\":1,\"447\":1,\"504\":2}}],[\"fulltext\",{\"1\":{\"108\":1}}],[\"future4\",{\"1\":{\"396\":2}}],[\"future3\",{\"1\":{\"396\":2}}],[\"future2\",{\"1\":{\"396\":2}}],[\"future1\",{\"1\":{\"396\":3}}],[\"futuretask相当于对callable\",{\"1\":{\"395\":1}}],[\"futuretask\",{\"1\":{\"395\":3}}],[\"future类有什么用\",{\"0\":{\"394\":1}}],[\"future\",{\"0\":{\"393\":1,\"395\":1},\"1\":{\"394\":3,\"395\":2,\"396\":2}}],[\"fence\",{\"1\":{\"362\":3}}],[\"failure进而full\",{\"1\":{\"468\":1}}],[\"failure\",{\"1\":{\"447\":1}}],[\"fairsync\",{\"1\":{\"375\":1}}],[\"fair\",{\"1\":{\"207\":1}}],[\"false\",{\"1\":{\"293\":2,\"307\":1,\"407\":1,\"497\":1}}],[\"ft\",{\"1\":{\"235\":1}}],[\"ftp\",{\"1\":{\"37\":2,\"56\":3}}],[\"float\",{\"1\":{\"278\":1}}],[\"flags\",{\"0\":{\"477\":1},\"1\":{\"477\":1}}],[\"flag\",{\"1\":{\"161\":1}}],[\"flush\",{\"1\":{\"146\":2}}],[\"fsync将阻塞直到写入磁盘完成之后返回\",{\"1\":{\"241\":1}}],[\"fsync针对单个文件操作\",{\"1\":{\"241\":1}}],[\"fsync超时将数据持久化到磁盘的操作\",{\"1\":{\"151\":1}}],[\"fsync\",{\"1\":{\"146\":2,\"197\":2,\"241\":1,\"246\":1}}],[\"ff\",{\"1\":{\"78\":6}}],[\"forname\",{\"1\":{\"318\":2}}],[\"fork采用copy\",{\"1\":{\"239\":1}}],[\"fork出一个子进程\",{\"1\":{\"239\":1}}],[\"fork子进程\",{\"1\":{\"238\":1}}],[\"format参数指定\",{\"1\":{\"150\":1}}],[\"for\",{\"1\":{\"75\":1,\"106\":1,\"158\":1,\"159\":2,\"166\":1,\"260\":2}}],[\"found请求路径不存在\",{\"1\":{\"44\":1}}],[\"frequently\",{\"1\":{\"201\":2}}],[\"free后台线程释放大对象\",{\"1\":{\"197\":1}}],[\"from\",{\"1\":{\"86\":1,\"108\":1,\"136\":2,\"512\":1}}],[\"fr和ca\",{\"1\":{\"50\":1}}],[\"fragmentation\",{\"1\":{\"12\":2}}],[\"fcfs\",{\"1\":{\"16\":2}}],[\"fixedthreadpool最多只能创建核心线程数的线程\",{\"1\":{\"390\":1}}],[\"fixedthreadpool\",{\"1\":{\"387\":2,\"390\":1}}],[\"fields\",{\"0\":{\"479\":1},\"1\":{\"479\":3}}],[\"field2\",{\"1\":{\"220\":3}}],[\"field1\",{\"1\":{\"220\":3}}],[\"field\",{\"1\":{\"185\":1,\"219\":1,\"220\":6,\"479\":2}}],[\"findbootstrapclassornull\",{\"1\":{\"497\":1}}],[\"findloadedclass\",{\"1\":{\"497\":1}}],[\"findclass\",{\"1\":{\"495\":2,\"497\":1,\"499\":1}}],[\"finalize\",{\"1\":{\"507\":1}}],[\"final类型\",{\"1\":{\"296\":1}}],[\"final\",{\"1\":{\"267\":1,\"289\":1,\"304\":2,\"308\":2,\"314\":1,\"316\":1,\"329\":1,\"333\":1,\"407\":1,\"476\":1,\"477\":1,\"496\":1}}],[\"fin\",{\"0\":{\"61\":1},\"1\":{\"60\":5,\"61\":1,\"62\":3}}],[\"filesort\",{\"1\":{\"108\":1}}],[\"file\",{\"1\":{\"37\":1,\"56\":1,\"146\":1,\"197\":1,\"238\":1,\"240\":1}}],[\"fifo\",{\"1\":{\"9\":1,\"407\":1,\"416\":1}}],[\"first\",{\"1\":{\"9\":2,\"16\":4,\"39\":1,\"467\":2}}],[\"由jvm自带的类加载器\",{\"1\":{\"490\":1}}],[\"由inheritablethreadlocal类维护\",{\"1\":{\"382\":1}}],[\"由threadlocal类维护\",{\"1\":{\"382\":1}}],[\"由数组+链表组成的\",{\"1\":{\"251\":1}}],[\"由操作系统决定什么时候写回磁盘\",{\"1\":{\"242\":1}}],[\"由主进程执行save\",{\"1\":{\"239\":1}}],[\"由远到近\",{\"1\":{\"235\":1}}],[\"由近到远\",{\"1\":{\"235\":1}}],[\"由此可见\",{\"1\":{\"173\":1}}],[\"由系统自行判断什么时候执行fsync\",{\"1\":{\"151\":1}}],[\"由于是线程私有的\",{\"1\":{\"513\":1}}],[\"由于这个\",{\"1\":{\"494\":1}}],[\"由于字节码并不针对一种特定的机器\",{\"1\":{\"472\":1}}],[\"由于队列永远不会被放满\",{\"1\":{\"390\":1}}],[\"由于指令重排序问题\",{\"1\":{\"360\":1}}],[\"由于静态内部类在singleton被装载的时候\",{\"1\":{\"333\":1}}],[\"由于linkedlist内部包含前驱和后继\",{\"1\":{\"255\":1}}],[\"由于文件事件处理器是单线程方式运行的\",{\"1\":{\"193\":1}}],[\"由于购物车中的商品频繁修改和变动\",{\"1\":{\"185\":1}}],[\"由于binlog没写完就异常\",{\"1\":{\"152\":1}}],[\"由于联合索引是先按照a字段的值排序的\",{\"1\":{\"136\":1}}],[\"由于非聚簇索引的叶子节点存放的是主键\",{\"1\":{\"132\":1}}],[\"由于\",{\"1\":{\"55\":2,\"104\":1,\"208\":1,\"244\":1,\"478\":1}}],[\"由于使用不断扩容到\",{\"1\":{\"504\":1}}],[\"由于使用\",{\"1\":{\"53\":1}}],[\"由于没有考虑磁头移动的路径和方向\",{\"1\":{\"16\":1}}],[\"由于未分配的连续内存区域太小\",{\"1\":{\"12\":1}}],[\"由\",{\"1\":{\"10\":1,\"156\":1,\"494\":2}}],[\"由处理机的各种寄存器中的内容组成的\",{\"1\":{\"8\":1}}],[\"14\",{\"1\":{\"476\":1}}],[\"15\",{\"1\":{\"445\":1}}],[\"1905122041950251207l\",{\"1\":{\"314\":1}}],[\"1种布尔类型\",{\"1\":{\"278\":1}}],[\"1种字符类型\",{\"1\":{\"278\":1}}],[\"111\",{\"1\":{\"487\":1}}],[\"1111\",{\"1\":{\"269\":1}}],[\"1110\",{\"1\":{\"269\":2}}],[\"1101\",{\"1\":{\"269\":3}}],[\"16\",{\"1\":{\"267\":1}}],[\"12k\",{\"1\":{\"231\":2}}],[\"127\",{\"1\":{\"199\":3,\"205\":1,\"280\":2}}],[\"128\",{\"1\":{\"12\":1,\"280\":1}}],[\"10\",{\"1\":{\"206\":2,\"253\":1,\"281\":1,\"285\":1}}],[\"10w+\",{\"1\":{\"173\":1}}],[\"1001\",{\"1\":{\"269\":4}}],[\"1000\",{\"1\":{\"206\":1}}],[\"100\",{\"1\":{\"40\":1,\"46\":1,\"244\":1}}],[\"1w\",{\"1\":{\"173\":1}}],[\"1gb\",{\"1\":{\"147\":1}}],[\"1nf是所有关系型数据库的最基本要求\",{\"1\":{\"83\":1}}],[\"1nf\",{\"0\":{\"83\":1}}],[\"13\",{\"1\":{\"50\":1}}],[\"1开头的表示临时响应\",{\"1\":{\"44\":1}}],[\"1\",{\"0\":{\"46\":3,\"272\":2,\"432\":1},\"1\":{\"10\":1,\"15\":2,\"22\":1,\"46\":14,\"60\":1,\"66\":2,\"78\":1,\"86\":1,\"126\":1,\"136\":1,\"146\":3,\"158\":1,\"166\":1,\"173\":1,\"175\":4,\"184\":1,\"189\":10,\"190\":3,\"199\":4,\"204\":5,\"205\":1,\"206\":6,\"209\":4,\"213\":1,\"228\":1,\"229\":1,\"230\":1,\"246\":1,\"253\":1,\"255\":1,\"259\":1,\"260\":5,\"267\":1,\"269\":2,\"272\":1,\"312\":1,\"325\":1,\"340\":1,\"358\":1,\"368\":1,\"372\":2,\"387\":3,\"390\":1,\"401\":1,\"402\":1,\"407\":2,\"408\":2,\"409\":1,\"428\":2,\"445\":3,\"449\":1,\"458\":1,\"476\":3,\"503\":2,\"504\":2,\"509\":1,\"519\":2}}],[\"该类型可以用纯\",{\"1\":{\"509\":1}}],[\"该类才会尝试去加载\",{\"1\":{\"497\":1}}],[\"该类的类加载器的实例已经被gc\",{\"1\":{\"490\":1}}],[\"该类的所有实例对象都被gc\",{\"1\":{\"490\":1}}],[\"该类没有在其他任何地方被引用\",{\"1\":{\"490\":1}}],[\"该类对应的\",{\"1\":{\"455\":1}}],[\"该类所有的实例都已经被回收\",{\"1\":{\"455\":1}}],[\"该锁没有被其他的线程获取\",{\"1\":{\"402\":1}}],[\"该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池\",{\"1\":{\"387\":1}}],[\"该线程池中的线程数量始终不变\",{\"1\":{\"387\":1}}],[\"该方法如果获取不到许可就立即返回\",{\"1\":{\"407\":1}}],[\"该方法返回一个可根据实际情况调整线程数量的线程池\",{\"1\":{\"387\":1}}],[\"该方法返回一个只有一个线程的线程池\",{\"1\":{\"387\":1}}],[\"该方法返回一个固定线程数量的线程池\",{\"1\":{\"387\":1}}],[\"该方法中又调用了另一个需要相同锁的方法\",{\"1\":{\"207\":1}}],[\"该标识指明了该方法是一个同步方法\",{\"1\":{\"372\":1}}],[\"该缓冲区会在子进程创建新\",{\"1\":{\"244\":1}}],[\"该级别可以防止脏读\",{\"1\":{\"156\":1}}],[\"该条目将被丢弃\",{\"1\":{\"79\":1}}],[\"该映射关系以\",{\"1\":{\"79\":1}}],[\"该地址表示广播地址\",{\"1\":{\"78\":1}}],[\"该请求被发往本地\",{\"1\":{\"50\":1}}],[\"该去往何处\",{\"1\":{\"39\":1,\"79\":1}}],[\"该算法容易出现饥饿问题\",{\"1\":{\"16\":1}}],[\"该进程就是孤儿进程\",{\"1\":{\"10\":1}}],[\"该消息队列才会被真正的删除\",{\"1\":{\"9\":1}}],[\"孤儿进程通常是由于父进程意外终止或未及时调用\",{\"1\":{\"10\":1}}],[\"孤儿进程\",{\"1\":{\"10\":1}}],[\"等问题的产生\",{\"1\":{\"453\":1}}],[\"等到state值为0的时候才不会被阻塞\",{\"1\":{\"408\":1}}],[\"等到有线程释放了共享资源\",{\"1\":{\"407\":1}}],[\"等到数据发完之后再发\",{\"1\":{\"61\":1}}],[\"等能力\",{\"1\":{\"396\":1}}],[\"等价于string\",{\"1\":{\"308\":1}}],[\"等价于int\",{\"1\":{\"281\":1}}],[\"等参数\",{\"1\":{\"235\":1}}],[\"等场景\",{\"1\":{\"224\":1}}],[\"等多种部署架构\",{\"1\":{\"206\":1}}],[\"等过程中产生的临时文件资源\",{\"1\":{\"197\":1}}],[\"等数据结构的存储\",{\"1\":{\"172\":1}}],[\"等当前读\",{\"1\":{\"166\":1}}],[\"等号右边的条件一定要用引号引起来标明这是一个字符串\",{\"1\":{\"143\":1}}],[\"等号右边的条件就写成对应的类型\",{\"1\":{\"143\":1}}],[\"等\",{\"1\":{\"91\":1}}],[\"等待state值变为0\",{\"1\":{\"408\":1}}],[\"等待n个线程准备\",{\"1\":{\"408\":1}}],[\"等待n个线程完成任务之后\",{\"1\":{\"408\":1}}],[\"等待两个线程执行完成\",{\"1\":{\"408\":1}}],[\"等待可中断\",{\"1\":{\"377\":1}}],[\"等待状态\",{\"1\":{\"344\":1}}],[\"等待运行\",{\"1\":{\"344\":1}}],[\"等待后续使用\",{\"1\":{\"184\":1}}],[\"等待目的端确认收到这个报文段\",{\"1\":{\"64\":1}}],[\"等待服务器的确认\",{\"1\":{\"58\":1}}],[\"等待数据从内核空间拷贝到用户空间的这段时间\",{\"1\":{\"22\":1}}],[\"等更多可供选择的缓存头来控制缓存策略\",{\"1\":{\"46\":1}}],[\"等内核把数据准备好了\",{\"1\":{\"22\":1}}],[\"等系统调用来回收子进程导致的\",{\"1\":{\"10\":1}}],[\"等系统调用来获取子进程的状态信息\",{\"1\":{\"10\":1}}],[\"等等\",{\"1\":{\"8\":1,\"187\":1,\"412\":1,\"477\":1}}],[\"或属性组\",{\"1\":{\"84\":1}}],[\"或者其他要测试\",{\"1\":{\"507\":1}}],[\"或者finalize方法已经被虚拟机调用过\",{\"1\":{\"452\":1}}],[\"或者初始化时通过构造器参数\",{\"1\":{\"417\":1}}],[\"或者\",{\"1\":{\"395\":1,\"445\":1,\"447\":1,\"467\":1,\"477\":1}}],[\"或者是其他原因导致任务暂停带来的影响\",{\"1\":{\"392\":1}}],[\"或者也可以使用\",{\"1\":{\"349\":1}}],[\"或者notifyall\",{\"1\":{\"349\":1}}],[\"或者说是监听多个socket\",{\"1\":{\"194\":1}}],[\"或者更新时间戳\",{\"1\":{\"158\":1}}],[\"或者子查询\",{\"1\":{\"108\":1}}],[\"或者x锁\",{\"1\":{\"106\":1}}],[\"或者反向映射\",{\"1\":{\"76\":1}}],[\"或者显式地删除一个消息队列时\",{\"1\":{\"9\":1}}],[\"或\",{\"1\":{\"10\":3,\"15\":1,\"37\":1,\"56\":1,\"158\":1,\"459\":1}}],[\"僵尸进程\",{\"1\":{\"10\":2}}],[\"套接字是支持\",{\"1\":{\"9\":1}}],[\"套接字\",{\"1\":{\"9\":1}}],[\"如文本字符串\",{\"1\":{\"476\":1}}],[\"如是否启用偏向锁等\",{\"1\":{\"435\":1}}],[\"如semaphore\",{\"1\":{\"406\":1}}],[\"如reentrantlock\",{\"1\":{\"406\":1}}],[\"如不可见\",{\"1\":{\"153\":1,\"160\":1}}],[\"如下图所示\",{\"1\":{\"84\":1,\"147\":1}}],[\"如在局域网中使用的\",{\"1\":{\"76\":1}}],[\"如邻居发现\",{\"1\":{\"75\":1}}],[\"如何判断一个类是无用的类\",{\"0\":{\"455\":1}}],[\"如何判断一个常量是废弃常量\",{\"0\":{\"454\":1}}],[\"如何判断表中的记录没有行锁呢\",{\"1\":{\"105\":1}}],[\"如何才能找到类的元数据信息\",{\"1\":{\"435\":1}}],[\"如何设定线程池的大小\",{\"0\":{\"392\":1}}],[\"如何创建线程池\",{\"0\":{\"387\":1}}],[\"如何预防死锁\",{\"0\":{\"347\":1}}],[\"如何避免死锁\",{\"0\":{\"348\":1}}],[\"如何避免\",{\"0\":{\"345\":1}}],[\"如何解决浮点数运算的时候精度丢失问题\",{\"0\":{\"283\":1}}],[\"如何解决集群情况下分布式锁的可靠性\",{\"0\":{\"208\":1}}],[\"如何选择\",{\"0\":{\"246\":1}}],[\"如何防止释放锁逻辑失效导致的锁无法释放\",{\"0\":{\"205\":1}}],[\"如何基于\",{\"0\":{\"204\":1}}],[\"如何实现可重入锁\",{\"0\":{\"207\":1}}],[\"如何实现锁的优雅续期\",{\"0\":{\"206\":1}}],[\"如何实现读写分离\",{\"0\":{\"112\":1}}],[\"如何实现流量控制\",{\"0\":{\"65\":1}}],[\"如何保证传输的可靠性\",{\"0\":{\"64\":1}}],[\"如uk\",{\"1\":{\"50\":1}}],[\"如com\",{\"1\":{\"50\":1}}],[\"如\",{\"1\":{\"37\":1,\"56\":1,\"78\":1,\"108\":1}}],[\"如果系统支持\",{\"1\":{\"509\":1}}],[\"如果系统对性能和资源消耗非常敏感的话\",{\"1\":{\"183\":1}}],[\"如果想打破双亲委派模型则需要重写\",{\"1\":{\"495\":1,\"499\":1}}],[\"如果想要使用\",{\"1\":{\"179\":1,\"188\":1,\"189\":1}}],[\"如果我们想在内存不足时重启服务器\",{\"1\":{\"508\":1}}],[\"如果我们没有指定\",{\"1\":{\"504\":1}}],[\"如果我们要自定义自己的类加载器\",{\"1\":{\"495\":1}}],[\"如果我们将变量声明为\",{\"1\":{\"361\":1}}],[\"如果回收速度赶不上分配速度\",{\"1\":{\"467\":1}}],[\"如果存活对象数量比较大\",{\"1\":{\"458\":1}}],[\"如果存储内容超过了这个参数\",{\"1\":{\"151\":1}}],[\"如果内存不太够则可能会回收\",{\"1\":{\"453\":1}}],[\"如果小于\",{\"1\":{\"447\":1}}],[\"如果大于\",{\"1\":{\"447\":1}}],[\"如果允许\",{\"1\":{\"447\":1}}],[\"如果使用包装类\",{\"1\":{\"512\":1}}],[\"如果使用这个\",{\"1\":{\"509\":1}}],[\"如果使用了直接引用\",{\"1\":{\"488\":1}}],[\"如果使用句柄的话\",{\"1\":{\"440\":1}}],[\"如果使用直接指针访问\",{\"1\":{\"439\":1}}],[\"如果未指定\",{\"1\":{\"416\":1}}],[\"如果获取到\",{\"1\":{\"494\":1}}],[\"如果获取成功的话\",{\"1\":{\"407\":1}}],[\"如果获取锁失败\",{\"1\":{\"209\":1}}],[\"如果资源被占用\",{\"1\":{\"405\":1}}],[\"如果资源不存在则会创建一个新的资源\",{\"1\":{\"41\":1}}],[\"如果向任务队列投放任务失败\",{\"1\":{\"391\":1}}],[\"如果核心线程已经满了\",{\"1\":{\"390\":1}}],[\"如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话\",{\"1\":{\"389\":1}}],[\"如果当前没有任何\",{\"1\":{\"454\":1}}],[\"如果当前运行的线程数已经等同于最大线程数了\",{\"1\":{\"391\":1}}],[\"如果当前运行的线程数等于或大于核心线程数\",{\"1\":{\"391\":1}}],[\"如果当前运行的线程数小于核心线程数\",{\"1\":{\"391\":1}}],[\"如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时\",{\"1\":{\"389\":1}}],[\"如果当日活跃过就设置为\",{\"1\":{\"189\":1}}],[\"如果这个类本身是接口的话则是extends\",{\"1\":{\"478\":1}}],[\"如果这个条件成立\",{\"1\":{\"447\":1}}],[\"如果这时发生内存回收的话而且有必要的话\",{\"1\":{\"454\":1}}],[\"如果这时没有新的任务提交\",{\"1\":{\"388\":1}}],[\"如果这些表发生变化\",{\"1\":{\"94\":1}}],[\"如果达到的话\",{\"1\":{\"388\":1}}],[\"如果创建了一个threadlocal变量\",{\"1\":{\"381\":1}}],[\"如果锁的计数器为\",{\"1\":{\"372\":1}}],[\"如果长时间不成功\",{\"1\":{\"368\":1}}],[\"如果将变量通过volatile修饰\",{\"1\":{\"362\":1}}],[\"如果两个操作不满足上述条件的任意一个\",{\"1\":{\"359\":1}}],[\"如果两个对象的hashcode不同则对象一定不同\",{\"1\":{\"301\":1}}],[\"如果a\",{\"1\":{\"359\":1}}],[\"如果直接调用run\",{\"1\":{\"351\":1}}],[\"如果一直没有使用这个实例\",{\"1\":{\"330\":1}}],[\"如果一个对象仅持有虚引用\",{\"1\":{\"453\":1}}],[\"如果一个对象引用不会逃出本方法的作用范围\",{\"1\":{\"427\":1}}],[\"如果一个表的字段过多\",{\"1\":{\"142\":1}}],[\"如果一个字段不被经常查询\",{\"1\":{\"140\":1}}],[\"如果一个索引包含所有需要查询字段的值\",{\"1\":{\"134\":1}}],[\"如果一个记录已经被加了排他锁\",{\"1\":{\"104\":1}}],[\"如果字符串常量池中没有保存了对应的字符串对象的引用\",{\"1\":{\"307\":1}}],[\"如果字符串常量池中保存了对应的字符串对象的引用\",{\"1\":{\"307\":1}}],[\"如果字符串常量池中存在\",{\"1\":{\"306\":1}}],[\"如果字符串常量池中不存在\",{\"1\":{\"306\":1}}],[\"如果hashcode相同\",{\"1\":{\"301\":1}}],[\"如果子类重写了父类方法\",{\"1\":{\"295\":1}}],[\"如果自己添加了构造方法无论是否有参数都不会再自动生成无参构造方法\",{\"1\":{\"294\":1}}],[\"如果类没有声明构造方法则会默认生成一个不带参数的构造方法\",{\"1\":{\"294\":1}}],[\"如果没有需要先执行响应的类加载过程\",{\"1\":{\"432\":1}}],[\"如果没有就创建一个string对象\",{\"1\":{\"299\":1}}],[\"如果没有重写则执行的是父类中的方法\",{\"1\":{\"295\":1}}],[\"如果没有声明构造方法\",{\"0\":{\"294\":1}}],[\"如果没有设置主键且该表没有唯一非空索引时\",{\"1\":{\"161\":1}}],[\"如果父类方法访问修饰符是private\",{\"1\":{\"289\":1}}],[\"如果保存的数据要求安全性比较高的话\",{\"1\":{\"246\":1}}],[\"如果文件内容发生了变化\",{\"1\":{\"245\":1}}],[\"如果刚执行完命令redis宕机了就会导致对应的修改记录丢失\",{\"1\":{\"243\":1}}],[\"如果在接下来的执行过程中\",{\"1\":{\"402\":1}}],[\"如果在某段时间内没有多个线程访问这块同步代码那就可以不需要去指向操作系统互斥量\",{\"1\":{\"401\":1}}],[\"如果在同一个锁对象上\",{\"1\":{\"398\":1}}],[\"如果在循环内使用+进行拼接多个字符串\",{\"1\":{\"305\":1}}],[\"如果在\",{\"1\":{\"208\":1}}],[\"如果在执行过程中遇到阻塞就会挂起直到结果返回\",{\"1\":{\"6\":1}}],[\"如果操作共享资源的线程还未执行完成的话\",{\"1\":{\"206\":1}}],[\"如果操作共享资源的时间大于过期时间\",{\"1\":{\"205\":1}}],[\"如果操作的索引是唯一索引或主键\",{\"1\":{\"103\":1}}],[\"如果对象在\",{\"1\":{\"445\":1}}],[\"如果对象的作用范围没有超过当前方法\",{\"1\":{\"279\":1}}],[\"如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息\",{\"1\":{\"183\":1}}],[\"如果对索引列的数据被修改时\",{\"1\":{\"131\":1}}],[\"如果其它事务有插入新的记录\",{\"1\":{\"166\":1}}],[\"如果该行未被更新\",{\"1\":{\"161\":1}}],[\"如果加\",{\"1\":{\"159\":1}}],[\"如果执行程序已关闭\",{\"1\":{\"389\":1}}],[\"如果执行flushall命令意外地刷新了所有内容后\",{\"1\":{\"246\":1}}],[\"如果执行的是当前读\",{\"1\":{\"159\":1}}],[\"如果执行的是下列语句\",{\"1\":{\"159\":1}}],[\"如果执行过程中遇到异常的话\",{\"1\":{\"153\":1}}],[\"如果读取的行正在执行\",{\"1\":{\"158\":1}}],[\"如果读取的记录正在执行update\",{\"1\":{\"106\":1}}],[\"如果记录的版本小于可见版本\",{\"1\":{\"158\":1}}],[\"如果机器宕机\",{\"1\":{\"151\":1}}],[\"如果是类的话是否声明为\",{\"1\":{\"477\":1}}],[\"如果是出现了多个线程进行抢占共享变量\",{\"1\":{\"401\":1}}],[\"如果是就执行续期操作\",{\"1\":{\"206\":1}}],[\"如果是当前读\",{\"1\":{\"159\":1}}],[\"如果是执行普通的\",{\"1\":{\"158\":1}}],[\"如果是\",{\"1\":{\"150\":1,\"246\":1}}],[\"如果是写redo\",{\"1\":{\"148\":1}}],[\"如果不想打破双亲委派模型\",{\"1\":{\"495\":1,\"499\":1}}],[\"如果不成立\",{\"1\":{\"447\":1}}],[\"如果不存在数据依赖性\",{\"1\":{\"354\":1}}],[\"如果不指定serialversionuid\",{\"1\":{\"314\":1}}],[\"如果不同则会抛出invalidclassexception异常\",{\"1\":{\"314\":1}}],[\"如果不重写hashcode\",{\"1\":{\"301\":1}}],[\"如果不满足\",{\"1\":{\"184\":1}}],[\"如果不遵循最左匹配原则\",{\"1\":{\"136\":1}}],[\"如果不是主键索引\",{\"1\":{\"134\":1}}],[\"如果不加\",{\"1\":{\"86\":1}}],[\"如果索引的数据不是有序的\",{\"1\":{\"131\":1}}],[\"如果有这个接口的实现类发生了初始化\",{\"1\":{\"489\":1}}],[\"如果有空闲线程\",{\"1\":{\"390\":1}}],[\"如果有一个线程将变量值a改为b\",{\"1\":{\"367\":1}}],[\"如果有则直接返回这个对象的引用\",{\"1\":{\"299\":1}}],[\"如果有\",{\"1\":{\"128\":1}}],[\"如果节点是红色的\",{\"1\":{\"126\":1}}],[\"如果数据有索引\",{\"1\":{\"121\":1}}],[\"如果单个操作涉及到多个数据库\",{\"1\":{\"119\":1}}],[\"如果为\",{\"1\":{\"108\":1,\"495\":1}}],[\"如果表使用的引擎对于表行数统计是精确的\",{\"1\":{\"108\":1}}],[\"如果需要用到表锁的话\",{\"1\":{\"105\":1}}],[\"如果查询中包含任何用户自定义函数\",{\"1\":{\"94\":1}}],[\"如果命中缓存\",{\"1\":{\"91\":1}}],[\"如果\",{\"1\":{\"84\":1,\"108\":1,\"147\":1,\"162\":1,\"176\":1,\"204\":2,\"209\":1,\"383\":1,\"407\":3,\"408\":2,\"409\":1,\"497\":1,\"508\":1}}],[\"如果x\",{\"1\":{\"84\":1}}],[\"如果说轻量级锁是在无竞争的情况下使用cas操作去消除同步使用的互斥量\",{\"1\":{\"402\":1}}],[\"如果说\",{\"1\":{\"78\":1,\"173\":1}}],[\"如果发现它还有虚引用\",{\"1\":{\"453\":1}}],[\"如果发现操作的变量是共享变量\",{\"1\":{\"362\":1}}],[\"如果发现文件有问题\",{\"1\":{\"245\":1}}],[\"如果发生超时\",{\"1\":{\"70\":1}}],[\"如果发送方超时没有收到确认帧\",{\"1\":{\"69\":1}}],[\"如果发送机接收到三个重复确认\",{\"1\":{\"66\":1}}],[\"如果发送端实体在合理的往返时延\",{\"1\":{\"64\":1}}],[\"如果收到了序号n的确认\",{\"1\":{\"69\":1}}],[\"如果收到段的检验和有差错\",{\"1\":{\"64\":1}}],[\"如果立即把大量数据字节注入到网络\",{\"1\":{\"66\":1}}],[\"如果客户端发生异常导致没来得及释放锁也没关系\",{\"1\":{\"210\":1}}],[\"如果客户端能够和半数以上的实例成功地完成加锁操作\",{\"1\":{\"208\":1}}],[\"如果客户端在\",{\"1\":{\"62\":1}}],[\"如果客户端等待\",{\"1\":{\"60\":1}}],[\"如果服务端因为某些原因而没有收到\",{\"1\":{\"62\":1}}],[\"如果服务器上不存在该资源\",{\"1\":{\"41\":1}}],[\"如果服务器有这个资源\",{\"1\":{\"41\":1}}],[\"如果访问的网址在hosts文件中有对应的映射表目\",{\"1\":{\"49\":1}}],[\"如果请求成功\",{\"1\":{\"41\":1}}],[\"如果磁头移动的方向上已经没有磁道访问请求了\",{\"1\":{\"16\":1}}],[\"如果磁头移动方向上已经没有别的请求\",{\"1\":{\"16\":1}}],[\"如果磁头从一个方向刚扫描完\",{\"1\":{\"16\":1}}],[\"如果经过的磁道有请求就处理\",{\"1\":{\"16\":1}}],[\"如互斥锁和信号量等\",{\"1\":{\"9\":1}}],[\"这反过来又会迫使\",{\"1\":{\"509\":1}}],[\"这反过来会导致应用程序崩溃\",{\"1\":{\"508\":1}}],[\"这可能会导致\",{\"1\":{\"509\":1}}],[\"这可能会导致一些数据需要进行多次磁盘\",{\"1\":{\"126\":1}}],[\"这通过将重复\",{\"1\":{\"509\":1}}],[\"这两个收集器的处理策略是不同的\",{\"1\":{\"470\":1}}],[\"这两个都是过期时间设置\",{\"1\":{\"205\":1}}],[\"这二者在针对并发标记过程中用户线程对可达性分析的影响的处理方式不同\",{\"1\":{\"468\":1}}],[\"这么多region\",{\"1\":{\"467\":1}}],[\"这里说的仅仅是\",{\"1\":{\"455\":1}}],[\"这里没有提到运行时常量池\",{\"1\":{\"454\":1}}],[\"这里会获取当前系统时间\",{\"1\":{\"150\":1}}],[\"这就指示\",{\"1\":{\"361\":1}}],[\"这就是为什么\",{\"1\":{\"508\":1}}],[\"这就是为什么如今很少使用\",{\"1\":{\"37\":1,\"56\":1}}],[\"这就是两阶段提交\",{\"1\":{\"152\":1}}],[\"这句话创建了几个字符串对象\",{\"0\":{\"306\":1}}],[\"这次的文件大小比上次增长超过100\",{\"1\":{\"244\":1}}],[\"这一步\",{\"1\":{\"489\":1}}],[\"这一步的作用是确保class文件的字节流中包含的信息符合\",{\"1\":{\"486\":1}}],[\"这一步操作保证了对象的实例字段在\",{\"1\":{\"434\":1}}],[\"这一步需要调用fsync函数\",{\"1\":{\"241\":1}}],[\"这一步需要调用write函数\",{\"1\":{\"241\":1}}],[\"这一行c值是1\",{\"1\":{\"152\":1}}],[\"这\",{\"1\":{\"212\":1,\"280\":1,\"476\":1}}],[\"这是因为bootstrapclassloader\",{\"1\":{\"494\":1}}],[\"这是因为软引用可以加速\",{\"1\":{\"453\":1}}],[\"这是设置的初始值\",{\"1\":{\"487\":1}}],[\"这是\",{\"1\":{\"467\":1}}],[\"这是一个非常关键的场景\",{\"1\":{\"508\":1}}],[\"这是一个非阻塞队列\",{\"1\":{\"410\":1}}],[\"这是一个\",{\"1\":{\"410\":1}}],[\"这是一个接口\",{\"1\":{\"410\":1}}],[\"这是一个端到端的检验和\",{\"1\":{\"64\":1}}],[\"这是由于当一个桶位中有多个元素需要进行扩容时\",{\"1\":{\"270\":1}}],[\"这是redis中的一个性能瓶颈\",{\"1\":{\"196\":1}}],[\"这保持列redis内部单线程设计的简单性\",{\"1\":{\"193\":1}}],[\"这套时间处理模型对应的是redis中的文件事件处理器\",{\"1\":{\"193\":1}}],[\"这存在一些问题\",{\"1\":{\"184\":1}}],[\"这部分内存不会立即被回收\",{\"1\":{\"184\":1}}],[\"这对客户端是透明的\",{\"1\":{\"176\":1}}],[\"这类的数据库的\",{\"1\":{\"173\":1}}],[\"这边的\",{\"1\":{\"159\":1}}],[\"这也就是它的名字\",{\"1\":{\"467\":1}}],[\"这也就是说在查找过程中\",{\"1\":{\"418\":1}}],[\"这也让数据库的并发能力增强\",{\"1\":{\"148\":1}}],[\"这也是\",{\"1\":{\"126\":1}}],[\"这也是创建索引的主要原因\",{\"1\":{\"121\":1}}],[\"这被称为聚簇索引\",{\"1\":{\"127\":1}}],[\"这被称为非聚簇索引\",{\"1\":{\"127\":1}}],[\"这列包含了\",{\"1\":{\"108\":1}}],[\"这在并发写的情况下性非常差\",{\"1\":{\"102\":1}}],[\"这时可将cpu资源交给其他任务\",{\"1\":{\"392\":1}}],[\"这时得到的结果就不是正确结果\",{\"1\":{\"358\":1}}],[\"这时如果两次查询中间有其它事务插入数据\",{\"1\":{\"159\":1}}],[\"这时记录也是可以被读取的\",{\"1\":{\"159\":1}}],[\"这时读取操作不会去等待行上锁的释放\",{\"1\":{\"158\":1}}],[\"这时候进行内存分配的仅包括类变量\",{\"1\":{\"487\":1}}],[\"这时候字符串常量池还在堆\",{\"1\":{\"454\":1}}],[\"这时候binlog里面没有对应的修改记录\",{\"1\":{\"152\":1}}],[\"这时候不能再写入新的\",{\"1\":{\"147\":1}}],[\"这时先回复\",{\"1\":{\"61\":1}}],[\"这时会触发由当前运行进程切换到处理此异常的内核相关程序中\",{\"1\":{\"3\":1}}],[\"这个时候类变量则会随着\",{\"1\":{\"487\":1}}],[\"这个时候就可能会产生内存泄露\",{\"1\":{\"383\":1}}],[\"这个类是否继承了不允许继承的类\",{\"1\":{\"486\":1}}],[\"这个类在\",{\"1\":{\"403\":1}}],[\"这个\",{\"1\":{\"477\":1}}],[\"这个标志用于识别一些类或者接口层次的访问信息\",{\"1\":{\"477\":1}}],[\"这个哈希表表示我指向谁\",{\"1\":{\"470\":1}}],[\"这个humongous也被认为是老年代\",{\"1\":{\"469\":1}}],[\"这个阶段的停顿时间一般会比初始标记阶段的时间稍长\",{\"1\":{\"466\":1}}],[\"这个闭包结构并不能保证包含当前所有的可达对象\",{\"1\":{\"466\":1}}],[\"这个算法的基本思想就是通过一系列的称为\",{\"1\":{\"450\":1}}],[\"这个机制aqs是基于clh锁实现的\",{\"1\":{\"405\":1}}],[\"这个对象的内存相比较2bit的锁标志位是要大很多的\",{\"1\":{\"401\":1}}],[\"这个变量是共享且不稳定的\",{\"1\":{\"361\":1}}],[\"这个变量都是共享的\",{\"1\":{\"286\":1}}],[\"这个校验和是通过对整个\",{\"1\":{\"245\":1}}],[\"这个整数作为\",{\"1\":{\"235\":1}}],[\"这个整数保存了key所指向的数据库键的过期时间\",{\"1\":{\"199\":1}}],[\"这个监听器的作用是当前一个节点释放锁之后通知客户端\",{\"1\":{\"209\":1}}],[\"这个方法返回的是看门狗给锁续期的过期时间\",{\"1\":{\"206\":1}}],[\"这个应该没人使用吧\",{\"1\":{\"201\":1}}],[\"这个是最常用的\",{\"1\":{\"201\":1}}],[\"这个过程也被称为\",{\"1\":{\"424\":1}}],[\"这个过程是比较慢\",{\"1\":{\"173\":1}}],[\"这个过程称为主从复制\",{\"1\":{\"112\":1}}],[\"这个索引的key是数据表的主键\",{\"1\":{\"127\":1}}],[\"这个恢复过程依赖于redo\",{\"1\":{\"93\":1}}],[\"这个日志模块所有执行引擎都可以共用\",{\"1\":{\"91\":1}}],[\"这个列称为主键\",{\"1\":{\"84\":1}}],[\"这个有状态说的是\",{\"1\":{\"53\":1}}],[\"这个和上面的\",{\"1\":{\"53\":1}}],[\"这个资源\",{\"1\":{\"47\":1}}],[\"这个请求就需要等到磁头从相反方向过来之后才能得到处理\",{\"1\":{\"16\":1}}],[\"这样做的好处是用户可以自定义类加载器\",{\"1\":{\"494\":1}}],[\"这样一个真正可用的对象才算完全产生出来\",{\"1\":{\"436\":1}}],[\"这样一来\",{\"1\":{\"383\":1}}],[\"这样才能实现多线程\",{\"1\":{\"351\":1}}],[\"这样才可以避免\",{\"1\":{\"208\":1}}],[\"这样能在不改变目标对象的前提下\",{\"1\":{\"320\":1}}],[\"这样能小幅度提升写性能\",{\"1\":{\"110\":1}}],[\"这样对内存更加友好\",{\"1\":{\"493\":1}}],[\"这样对性能不友好\",{\"1\":{\"210\":1}}],[\"这样对cpu友好\",{\"1\":{\"200\":1}}],[\"这样的话\",{\"1\":{\"210\":1,\"222\":1}}],[\"这样客户端\",{\"1\":{\"209\":1}}],[\"这样可以减少连续执行字符串增长操作所需的内存重分配次数\",{\"1\":{\"184\":1}}],[\"这样可能会做很多无用功\",{\"1\":{\"16\":2}}],[\"这样用户的一部分请求会直接到缓存这里而不用经过数据库\",{\"1\":{\"173\":1}}],[\"这样有什么好处呢\",{\"1\":{\"173\":1}}],[\"这样事务之间就完全不可能产生干扰\",{\"1\":{\"156\":1}}],[\"这样就可以根据各个年代的特点选择合适的垃圾收集算法\",{\"1\":{\"459\":1}}],[\"这样就可以保证写操作不会影响读操作\",{\"1\":{\"412\":1}}],[\"这样就使每次的内存回收都是对内存区间的一半进行回收\",{\"1\":{\"458\":1}}],[\"这样就能保证即使数据不一致影响也比较小\",{\"1\":{\"175\":1}}],[\"这样就保证了即使遇到数据库突然宕机等情况\",{\"1\":{\"153\":1}}],[\"这样就方便了开发者自由的选择以便于充分利用带宽和连接\",{\"1\":{\"46\":1}}],[\"这俩请求的报文只有在http请求行的\",{\"1\":{\"40\":1}}],[\"这些参数将堆内存转储到一个物理文件中\",{\"1\":{\"508\":1}}],[\"这些内存都在方法区内分配\",{\"1\":{\"487\":1}}],[\"这些被实现的接口将按\",{\"1\":{\"478\":1}}],[\"这些humongous被当作老年代处理\",{\"1\":{\"467\":1}}],[\"这些信息存放在对象头中\",{\"1\":{\"435\":1}}],[\"这些场景对传输数据的准确性要求不是特别高\",{\"1\":{\"54\":1}}],[\"这些记录将这些主机的名字映射为\",{\"1\":{\"50\":1}}],[\"这些功能由\",{\"1\":{\"37\":1}}],[\"这些小片段且不连续的内存空间被称为外部碎片\",{\"1\":{\"12\":1}}],[\"这有潜在的安全风险\",{\"1\":{\"37\":1,\"56\":1}}],[\"这种使用\",{\"1\":{\"467\":1}}],[\"这种算法没有什么新的思想\",{\"1\":{\"459\":1}}],[\"这种策略是为了提高获得锁和释放锁的效率\",{\"1\":{\"397\":1}}],[\"这种策略在我们平时开发过程中也非常非常少见\",{\"1\":{\"177\":1}}],[\"这种方法一般是c或者c++实现的\",{\"1\":{\"342\":1}}],[\"这种方式实现分布式锁存在一些问题\",{\"1\":{\"204\":1}}],[\"这种方式对数据一致性带来了更大的挑战\",{\"1\":{\"177\":1}}],[\"这种方式需要依靠某种同步操作\",{\"1\":{\"9\":1}}],[\"这种读也被称为\",{\"1\":{\"159\":1}}],[\"这种逻辑定位是\",{\"1\":{\"78\":1}}],[\"这种确认叫做累计确认机制\",{\"1\":{\"69\":1}}],[\"这种自动重传方式常称为\",{\"1\":{\"68\":1}}],[\"这种情况下\",{\"1\":{\"10\":2}}],[\"这种通信方式主要用于解决与同步相关的问题并避免竞争条件\",{\"1\":{\"9\":1}}],[\"比n多1是为了处理线程偶然发生的缺页中断\",{\"1\":{\"392\":1}}],[\"比synchronized\",{\"1\":{\"377\":1}}],[\"比较简单\",{\"1\":{\"455\":1}}],[\"比较与交换\",{\"1\":{\"366\":1}}],[\"比较适合读请求比较多的场景\",{\"1\":{\"175\":1}}],[\"比较\",{\"0\":{\"24\":1,\"257\":1}}],[\"比\",{\"1\":{\"9\":1,\"40\":1,\"45\":1,\"53\":1,\"246\":2}}],[\"比如atomicinteger\",{\"1\":{\"364\":1}}],[\"比如是否点赞过某个视频\",{\"1\":{\"230\":1}}],[\"比如优先级任务队列\",{\"1\":{\"227\":1}}],[\"比如可以将一个用户所有的关注人存在一个集合中\",{\"1\":{\"222\":1}}],[\"比如可以配置为一组4个文件\",{\"1\":{\"147\":1}}],[\"比如一个线程在执行一个带锁的方法\",{\"1\":{\"207\":1}}],[\"比如直播间送礼物的排行榜\",{\"1\":{\"186\":1}}],[\"比如图片\",{\"1\":{\"184\":1}}],[\"比如拼接\",{\"1\":{\"184\":1}}],[\"比如浏览量\",{\"1\":{\"177\":1}}],[\"比如消息队列中消息的异步写入磁盘\",{\"1\":{\"177\":1}}],[\"比如执行一条update\",{\"1\":{\"150\":1}}],[\"比如在关系\",{\"1\":{\"84\":1,\"85\":1}}],[\"比如学生基本信息表\",{\"1\":{\"84\":2}}],[\"比如文件传输\",{\"1\":{\"54\":1}}],[\"比如你看视频即使少个一两帧\",{\"1\":{\"54\":1}}],[\"比如说住在某省某市某街道的张三\",{\"1\":{\"78\":1}}],[\"比如说\",{\"1\":{\"46\":1}}],[\"比如100表示客户端可以继续发送剩余请求\",{\"1\":{\"44\":1}}],[\"比如\",{\"1\":{\"7\":2,\"54\":1,\"170\":1,\"177\":1,\"179\":1,\"182\":1,\"199\":1,\"210\":1,\"246\":1,\"403\":1,\"444\":1}}],[\"比如缺页异常\",{\"1\":{\"3\":1}}],[\"比如硬盘读写操作完成\",{\"1\":{\"3\":1}}],[\"也保证了java的核心api不会被修改\",{\"1\":{\"498\":1}}],[\"也会导致冻结用户线程\",{\"1\":{\"467\":1}}],[\"也会被自动删除\",{\"1\":{\"209\":1}}],[\"也并不会立即被回收\",{\"1\":{\"452\":1}}],[\"也没有什么特别的含义\",{\"1\":{\"437\":1}}],[\"也不需要强制实现接口\",{\"1\":{\"322\":1}}],[\"也有首次请求数据一定不再\",{\"1\":{\"176\":1}}],[\"也要确保一次性写入\",{\"1\":{\"151\":1}}],[\"也可能会刷盘\",{\"1\":{\"146\":1}}],[\"也可以是通过工具动态生成或者是从网络上下载而来\",{\"1\":{\"492\":1}}],[\"也可以是水平拆分\",{\"1\":{\"116\":1}}],[\"也可以通过自定义类实现\",{\"1\":{\"417\":1}}],[\"也可以通过以下配置\",{\"1\":{\"244\":1}}],[\"也可以理解成如果同步代码块没有多个出现并发问题的话\",{\"1\":{\"401\":1}}],[\"也可以理解为\",{\"1\":{\"78\":1}}],[\"也可以直接操作\",{\"1\":{\"246\":1}}],[\"也可以修改或者添加部分字段\",{\"1\":{\"183\":1}}],[\"也可以水平分库\",{\"1\":{\"115\":1}}],[\"也可以按消息的类型读取\",{\"1\":{\"9\":1}}],[\"也叫作组合索引或者复合索引\",{\"1\":{\"135\":1}}],[\"也叫作组合索引或复合索引\",{\"1\":{\"135\":1}}],[\"也存放数据\",{\"1\":{\"127\":1}}],[\"也正因如此\",{\"1\":{\"126\":1}}],[\"也是往后推移\",{\"1\":{\"147\":1}}],[\"也是一种动态路由协议\",{\"1\":{\"39\":1}}],[\"也是广泛使用的一种动态路由协议\",{\"1\":{\"39\":1}}],[\"也被称为记录锁\",{\"1\":{\"103\":1}}],[\"也被称为电梯\",{\"1\":{\"16\":1}}],[\"也被称为最佳服务优先\",{\"1\":{\"16\":1}}],[\"也就是得到类或者字段\",{\"1\":{\"488\":1}}],[\"也就是保存个快照\",{\"1\":{\"470\":1}}],[\"也就是分析每个region的回收收益\",{\"1\":{\"468\":1}}],[\"也就是字节码\",{\"1\":{\"425\":1}}],[\"也就是直接在调用execute方法的线程中运行\",{\"1\":{\"389\":1}}],[\"也就是线程可以再次获取自己的内部锁\",{\"1\":{\"377\":1}}],[\"也就是加\",{\"1\":{\"372\":1}}],[\"也就是不成功就一直循环执行直到成功\",{\"1\":{\"368\":1}}],[\"也就是对这个变量的修改对其后的所有操作都可见\",{\"1\":{\"359\":1}}],[\"也就是new在堆中创建的对象\",{\"1\":{\"306\":1}}],[\"也就是通过c或者是c++实现的\",{\"1\":{\"300\":1}}],[\"也就是通过辅助索引能定位主键的位置\",{\"1\":{\"129\":1}}],[\"也就是新对象n内部对象和原来的对象o的内部对象是同一个\",{\"1\":{\"297\":1}}],[\"也就是hero能调用的方法是看父类hero的\",{\"1\":{\"295\":1}}],[\"也就是并发度固定为16\",{\"1\":{\"271\":1}}],[\"也就是前一个节点被删除\",{\"1\":{\"211\":1}}],[\"也就是范围查询的字段可以用到联合索引\",{\"1\":{\"136\":1}}],[\"也就是按照最左优先的方式进行索引的匹配\",{\"1\":{\"136\":1}}],[\"也就是再执行一遍\",{\"1\":{\"113\":1}}],[\"也就是aid是手段\",{\"1\":{\"96\":1}}],[\"也就是这个字段只能是一个值\",{\"1\":{\"83\":1}}],[\"也就是它在互联网中的定位发生了变化\",{\"1\":{\"78\":1}}],[\"也就是由小到大逐渐增大拥塞窗口数值\",{\"1\":{\"66\":1}}],[\"也就是应用操作之后会直接返回\",{\"1\":{\"23\":1}}],[\"也就是\",{\"1\":{\"23\":1,\"40\":1,\"454\":1,\"455\":1}}],[\"也就是边扫描边观察指定方向上还有无请求\",{\"1\":{\"16\":1}}],[\"也就是说堆中不存在该类的实例对象\",{\"1\":{\"490\":1}}],[\"也就是说字符串常量池被单独拿到堆\",{\"1\":{\"454\":1}}],[\"也就是说正在等待的线程可以选择放弃等待\",{\"1\":{\"377\":1}}],[\"也就是说当内存不足以容纳新写入数据时\",{\"1\":{\"201\":1}}],[\"也就是说当事务提交时会调用\",{\"1\":{\"146\":1}}],[\"也就是说关系型数据库中创建的表一定满足第一范式\",{\"1\":{\"83\":1}}],[\"也就是说\",{\"1\":{\"12\":1,\"18\":1,\"40\":1,\"146\":1,\"156\":1,\"246\":1,\"390\":1,\"408\":1,\"493\":2}}],[\"也就转到了内核态\",{\"1\":{\"3\":1}}],[\"即该类的class对象被gc\",{\"1\":{\"490\":1}}],[\"即是静态变量\",{\"1\":{\"487\":1}}],[\"即扩展名为\",{\"1\":{\"472\":1}}],[\"即对象指向他的类数据的指针\",{\"1\":{\"437\":1}}],[\"即通过字面我们就能知道其值的含义\",{\"1\":{\"429\":1}}],[\"即如果对队列加锁的成本较高则适合使用无锁的\",{\"1\":{\"413\":1}}],[\"即永远不会阻塞\",{\"1\":{\"390\":1}}],[\"即认为将要修改的数据并没有被其他线程修改\",{\"1\":{\"364\":1}}],[\"即在其他cpu中也存在该变量的副本\",{\"1\":{\"362\":1}}],[\"即读写屏障\",{\"1\":{\"362\":1}}],[\"即读取的快照数据\",{\"1\":{\"159\":1}}],[\"即立刻进行flush\",{\"1\":{\"362\":1}}],[\"即立刻让cpu\",{\"1\":{\"362\":1}}],[\"即时编译器编译之后的代码\",{\"1\":{\"343\":1}}],[\"即方法名相同\",{\"1\":{\"289\":1}}],[\"即总是优先级最高的元素先出队\",{\"1\":{\"260\":1}}],[\"即向数组中添加第一个元素时\",{\"1\":{\"253\":1}}],[\"即可表示\",{\"1\":{\"230\":1}}],[\"即可以支持反向查找和遍历\",{\"1\":{\"216\":1}}],[\"即可\",{\"1\":{\"204\":1}}],[\"即可保持基本平衡状态\",{\"1\":{\"126\":1}}],[\"即以空字符\",{\"1\":{\"184\":1}}],[\"即下一个将被分配的事务\",{\"1\":{\"162\":1}}],[\"即使两个类来源于同一个class文件\",{\"1\":{\"497\":1}}],[\"即使被标记为不可达的对象\",{\"1\":{\"452\":1}}],[\"即使部分\",{\"1\":{\"208\":1}}],[\"即使客户端的释放锁的代码逻辑出现问题\",{\"1\":{\"202\":1}}],[\"即使读取的记录已被其它事务加上\",{\"1\":{\"159\":1}}],[\"即使数据库发生故障也不应该对其有任何影响\",{\"1\":{\"96\":1}}],[\"即相同的黑色高度\",{\"1\":{\"126\":1}}],[\"即仅锁住索引本身\",{\"1\":{\"103\":1}}],[\"即每经过一个往返时间\",{\"1\":{\"66\":1}}],[\"即由小到大逐渐增大发送窗口\",{\"1\":{\"66\":1}}],[\"即返回码是\",{\"1\":{\"46\":1}}],[\"即执行多次\",{\"1\":{\"41\":1}}],[\"即输入\",{\"1\":{\"18\":1}}],[\"即磁头附近的请求不断被服务\",{\"1\":{\"16\":1}}],[\"即一些后到的磁盘请求可能需要等待很长时间才能得到服务\",{\"1\":{\"16\":1}}],[\"即\",{\"1\":{\"9\":1,\"15\":1,\"47\":1,\"204\":1}}],[\"即进程控制块\",{\"1\":{\"8\":1}}],[\"不应该查询所有返回再筛选\",{\"1\":{\"512\":1}}],[\"不再要求各个属性表具有严格的顺序\",{\"1\":{\"481\":1}}],[\"不引用任何一个常量池项\",{\"1\":{\"476\":1}}],[\"不适合老年代\",{\"1\":{\"458\":1}}],[\"不适合作为mysql底层索引的数据结构\",{\"1\":{\"124\":1}}],[\"不管内存空间是否紧张都会回收这个对象\",{\"1\":{\"453\":1}}],[\"不管是插入操作还是读取操作\",{\"1\":{\"415\":1}}],[\"不管用什么存储引擎\",{\"1\":{\"149\":1}}],[\"不为\",{\"1\":{\"408\":1}}],[\"不为null的字段\",{\"1\":{\"139\":1}}],[\"不够灵活\",{\"1\":{\"398\":1}}],[\"不存储元素\",{\"1\":{\"390\":1}}],[\"不存在时设置\",{\"1\":{\"214\":1}}],[\"不存在的话\",{\"1\":{\"204\":1}}],[\"不存在这个问题\",{\"1\":{\"184\":1}}],[\"不存在算法开销\",{\"1\":{\"16\":1}}],[\"不处理新任务\",{\"1\":{\"389\":1}}],[\"不涉及对象\",{\"1\":{\"350\":1}}],[\"不剥夺\",{\"1\":{\"346\":1}}],[\"不仅能避免多线程同步问题\",{\"1\":{\"334\":1}}],[\"不仅仅拷贝对象\",{\"1\":{\"297\":1}}],[\"不仅仅包括多种分布式锁的实现\",{\"1\":{\"206\":1}}],[\"不仅仅支持简单的\",{\"1\":{\"172\":1}}],[\"不推荐\",{\"1\":{\"328\":2}}],[\"不完整\",{\"1\":{\"246\":1}}],[\"不建议使用java中的数据结构作为缓存实现\",{\"1\":{\"512\":1}}],[\"不建议单独使用\",{\"1\":{\"246\":1}}],[\"不建议这样做\",{\"1\":{\"218\":1}}],[\"不需要一直等到获取锁之后\",{\"1\":{\"378\":1}}],[\"不需要一条一条地执行命令\",{\"1\":{\"246\":1}}],[\"不需要实现接口可以直接代理实现类\",{\"1\":{\"326\":1}}],[\"不需要对每一个目标对象创建一个代理类\",{\"1\":{\"322\":1}}],[\"不需要手动释放内存\",{\"1\":{\"277\":1}}],[\"不需要扩容\",{\"1\":{\"259\":1}}],[\"不需要给出任何确认\",{\"1\":{\"53\":1}}],[\"不具备\",{\"1\":{\"206\":1}}],[\"不设置过期时间\",{\"1\":{\"199\":1}}],[\"不直接更新\",{\"1\":{\"177\":1}}],[\"不行\",{\"1\":{\"175\":1}}],[\"不支持存储null和non\",{\"1\":{\"260\":1}}],[\"不支持存储\",{\"1\":{\"259\":1}}],[\"不支持\",{\"1\":{\"172\":1}}],[\"不是数据持久化到磁盘\",{\"1\":{\"151\":1}}],[\"不太适合经常使用范围查询的场景\",{\"1\":{\"118\":1}}],[\"不用回表\",{\"1\":{\"108\":1}}],[\"不对数据加锁的读\",{\"1\":{\"106\":1}}],[\"不允许外部直接访问这些属性\",{\"1\":{\"295\":1}}],[\"不允许多个事务同时获取\",{\"1\":{\"104\":1}}],[\"不允许分割\",{\"1\":{\"96\":1}}],[\"不包括实例变量\",{\"1\":{\"487\":1}}],[\"不包括对象头\",{\"1\":{\"434\":1}}],[\"不包括当前事务自己和已提交的事务\",{\"1\":{\"162\":1}}],[\"不包括\",{\"1\":{\"158\":1}}],[\"不包括记录本身\",{\"1\":{\"103\":1}}],[\"不包含\",{\"1\":{\"84\":1,\"108\":1}}],[\"不光可以保存文本数据还可以保存二进制数据\",{\"1\":{\"213\":1}}],[\"不光可以缓解\",{\"1\":{\"76\":1}}],[\"不光支持表级锁\",{\"1\":{\"102\":1}}],[\"不可以插入\",{\"1\":{\"417\":1}}],[\"不可中断锁\",{\"1\":{\"378\":1}}],[\"不可重复的\",{\"1\":{\"250\":1}}],[\"不可重复\",{\"1\":{\"250\":1}}],[\"不可重复读以及幻读\",{\"1\":{\"156\":1}}],[\"不可重复读\",{\"1\":{\"97\":1,\"156\":1}}],[\"不可重入的分布式锁基本可以满足绝大部分业务场景了\",{\"1\":{\"207\":1}}],[\"不可缓存\",{\"1\":{\"40\":1}}],[\"不符合\",{\"1\":{\"85\":1}}],[\"不确定\",{\"1\":{\"84\":1}}],[\"不成立\",{\"1\":{\"84\":2}}],[\"不论他到哪里都不会改变\",{\"1\":{\"78\":1}}],[\"不重复\",{\"1\":{\"53\":1}}],[\"不丢失\",{\"1\":{\"53\":1}}],[\"不属于\",{\"1\":{\"40\":1,\"50\":1}}],[\"不会加载自己写的object\",{\"1\":{\"498\":1}}],[\"不会加任何锁\",{\"1\":{\"104\":1}}],[\"不会再直接读取\",{\"1\":{\"486\":1}}],[\"不会被清理掉\",{\"1\":{\"383\":1}}],[\"不会创建副本\",{\"1\":{\"311\":1}}],[\"不会产生优化\",{\"1\":{\"308\":1}}],[\"不会生成新的对象\",{\"1\":{\"303\":1}}],[\"不会造成精度丢失问题\",{\"1\":{\"283\":1}}],[\"不会造成缓冲区溢出\",{\"1\":{\"213\":1}}],[\"不会发生死锁的问题\",{\"1\":{\"210\":1}}],[\"不会影响其他线程对共享资源的访问\",{\"1\":{\"202\":1}}],[\"不会回表\",{\"1\":{\"134\":1}}],[\"不会出现死锁\",{\"1\":{\"102\":1}}],[\"不会将拥塞窗口设置为1\",{\"1\":{\"66\":1}}],[\"不会分开发送\",{\"1\":{\"40\":1}}],[\"不会阻塞当前的命令执行\",{\"1\":{\"243\":1}}],[\"不会阻塞redis主进程\",{\"1\":{\"239\":1}}],[\"不会阻塞\",{\"1\":{\"23\":1}}],[\"不带参数时\",{\"1\":{\"40\":1}}],[\"不保证是否顺序到达\",{\"1\":{\"53\":1}}],[\"不保证数据传输的可靠性\",{\"1\":{\"38\":1}}],[\"不保证实时传输质量\",{\"1\":{\"37\":1}}],[\"不单纯是new\",{\"1\":{\"22\":1}}],[\"不过均摊后的插入操作依然为\",{\"1\":{\"259\":1}}],[\"不过带来了部分额外的内存开销\",{\"1\":{\"216\":1}}],[\"不过多线程主要是针对一些大键值对的删除操作的命令\",{\"1\":{\"195\":1}}],[\"不过在redis\",{\"1\":{\"192\":1}}],[\"不过在8\",{\"1\":{\"94\":1}}],[\"不过需要添加一个锁来保证更新cache的时候不存在线程安全问题\",{\"1\":{\"175\":1}}],[\"不过概率非常小\",{\"1\":{\"175\":1}}],[\"不过条件变成了a>=1\",{\"1\":{\"136\":1}}],[\"不过\",{\"1\":{\"16\":1,\"204\":1,\"219\":1,\"375\":1}}],[\"不能被修改而且必须有初始值\",{\"1\":{\"296\":1}}],[\"不能存储基本类型\",{\"1\":{\"253\":1}}],[\"不能创建子节点\",{\"1\":{\"210\":1}}],[\"不能重复\",{\"1\":{\"128\":1}}],[\"不能再分为多个其他的字段了\",{\"1\":{\"83\":1}}],[\"不能再被分割\",{\"1\":{\"83\":1}}],[\"不能对目录进行创建\",{\"1\":{\"15\":1}}],[\"不能交叉文件系统进行硬链接的创建\",{\"1\":{\"15\":1}}],[\"不同类型的threadpoolexecutor\",{\"1\":{\"387\":1}}],[\"不同类型的对象可能会具有相似特点\",{\"1\":{\"295\":1}}],[\"不同点\",{\"1\":{\"296\":1}}],[\"不同的key最后会得到相同的index\",{\"1\":{\"123\":1}}],[\"不同的业务使用不同的数据库\",{\"1\":{\"115\":1}}],[\"不同的是消息队列存放在内核中\",{\"1\":{\"9\":1}}],[\"不同进程可以及时看到对方进程中对共享内存中数据的更新\",{\"1\":{\"9\":1}}],[\"不学java也感谢能逛逛本站\",{\"1\":{\"0\":1}}],[\"存活对象少了\",{\"1\":{\"518\":1}}],[\"存放的数据不能重复的场景\",{\"1\":{\"187\":1}}],[\"存放的是整个对象\",{\"1\":{\"183\":1}}],[\"存放在内存中并由消息队列标识符标识\",{\"1\":{\"9\":1}}],[\"存储了\",{\"1\":{\"395\":1}}],[\"存储了主内存中的变量副本\",{\"1\":{\"356\":1}}],[\"存储任意大小的整型数据\",{\"1\":{\"284\":1}}],[\"存储元素\",{\"1\":{\"255\":1}}],[\"存储的元素无序\",{\"1\":{\"250\":1}}],[\"存储的元素是有序的\",{\"1\":{\"250\":1}}],[\"存储的是连续的二进制数字\",{\"1\":{\"189\":1,\"228\":1}}],[\"存储的是序列化后的对象数据\",{\"1\":{\"183\":1}}],[\"存储的是\",{\"1\":{\"170\":1}}],[\"存储更节省内存\",{\"1\":{\"215\":1}}],[\"存储更好呢\",{\"0\":{\"185\":1}}],[\"存储\",{\"1\":{\"185\":1,\"254\":2}}],[\"存储具有多层嵌套的对象时也方便很多\",{\"1\":{\"183\":1}}],[\"存储相对来说更加节省内存\",{\"1\":{\"183\":1}}],[\"存储对象数据更好呢\",{\"0\":{\"183\":1}}],[\"存储引擎使用\",{\"1\":{\"164\":1}}],[\"存储引擎的默认事务隔离级别\",{\"1\":{\"164\":1}}],[\"存储引擎的默认支持的隔离级别是\",{\"1\":{\"100\":1,\"156\":1}}],[\"存储引擎会去读取行的一个快照数据\",{\"1\":{\"158\":1}}],[\"存储引擎中\",{\"1\":{\"158\":1}}],[\"存储引擎有一个后台线程\",{\"1\":{\"146\":1}}],[\"存储引擎为每行数据添加了三个隐藏字段\",{\"1\":{\"161\":1}}],[\"存储引擎为\",{\"1\":{\"146\":1}}],[\"存储函数\",{\"1\":{\"94\":1}}],[\"存储管理\",{\"1\":{\"2\":1}}],[\"存在一定的误差\",{\"1\":{\"231\":1}}],[\"存在一些缺陷\",{\"1\":{\"215\":1}}],[\"存在一些浪费带宽的现象\",{\"1\":{\"46\":1}}],[\"存在于实际的磁盘介质或者文件系统\",{\"1\":{\"9\":1}}],[\"mb\",{\"1\":{\"509\":1}}],[\"monitorexit\",{\"1\":{\"372\":7}}],[\"monitorenter\",{\"1\":{\"372\":5}}],[\"model\",{\"1\":{\"496\":1}}],[\"mode\",{\"1\":{\"106\":1,\"158\":1,\"159\":2,\"166\":1,\"468\":1}}],[\"modified\",{\"1\":{\"46\":1}}],[\"mfence\",{\"1\":{\"362\":1}}],[\"misc\",{\"1\":{\"497\":3}}],[\"minorgc次数就会减少\",{\"1\":{\"517\":1}}],[\"minorgc\",{\"1\":{\"445\":1}}],[\"minor\",{\"0\":{\"475\":1},\"1\":{\"443\":1,\"445\":1,\"446\":1,\"447\":4,\"475\":1,\"513\":1}}],[\"min\",{\"1\":{\"244\":1}}],[\"mi\",{\"1\":{\"235\":1}}],[\"mixed\",{\"1\":{\"150\":1,\"446\":1}}],[\"mget\",{\"1\":{\"214\":1}}],[\"mset\",{\"1\":{\"214\":1}}],[\"msl\",{\"0\":{\"62\":1},\"1\":{\"62\":1}}],[\"multilock\",{\"1\":{\"207\":1}}],[\"mutex\",{\"1\":{\"7\":1}}],[\"m\",{\"1\":{\"162\":9,\"164\":2,\"235\":1,\"467\":1}}],[\"mvcc+next\",{\"0\":{\"166\":1}}],[\"mvcc下解决不可重复读问题\",{\"0\":{\"165\":1}}],[\"mvcc\",{\"0\":{\"160\":1,\"164\":1},\"1\":{\"99\":1,\"104\":1,\"153\":1,\"156\":1,\"158\":2,\"159\":1,\"160\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1}}],[\"mybatis等框架中都大量使用了反射机制\",{\"1\":{\"316\":1}}],[\"myisam引擎中\",{\"1\":{\"127\":1}}],[\"myisam引擎和innodb引擎都是使用b+树作为索引结构\",{\"1\":{\"127\":1}}],[\"myisam引擎innodb引擎都是使用b+tree作为索引结构\",{\"1\":{\"93\":1}}],[\"myisam和innodb都支持表级锁\",{\"1\":{\"102\":1}}],[\"myisam不支持并发\",{\"1\":{\"93\":1}}],[\"myisam不支持\",{\"1\":{\"93\":3}}],[\"myisam不提供事务\",{\"1\":{\"93\":1}}],[\"myisam一锁就是整张表\",{\"1\":{\"93\":1}}],[\"myisam只有表级锁\",{\"1\":{\"93\":1}}],[\"myisam是mysql的默认存储引擎\",{\"1\":{\"92\":1}}],[\"myisam\",{\"0\":{\"93\":1},\"1\":{\"91\":2,\"102\":1,\"108\":1}}],[\"mysql数据库的数据备份\",{\"1\":{\"154\":1}}],[\"mysql会判断这条sql语句是否可能引起数据不一致\",{\"1\":{\"150\":1}}],[\"mysql日志\",{\"0\":{\"144\":1}}],[\"mysql索引\",{\"0\":{\"120\":1}}],[\"mysql提供了两个方法来处理ip地址\",{\"1\":{\"107\":1}}],[\"mysql如何存储ip地址\",{\"0\":{\"107\":1}}],[\"mysql的myisam引擎不管是主键还是非主键\",{\"1\":{\"132\":1}}],[\"mysql的默认隔离级别是什么\",{\"0\":{\"100\":1}}],[\"mysql的隔离级别基于锁和mvcc机制共同实现的\",{\"1\":{\"99\":1}}],[\"mysql的隔离级别是基于锁实现的吗\",{\"0\":{\"99\":1}}],[\"mysql的查询缓存系统会跟踪查询中涉及的没一张表\",{\"1\":{\"94\":1}}],[\"mysql中以页为单位\",{\"1\":{\"145\":1}}],[\"mysql中锁定粒度最小的一种锁\",{\"1\":{\"102\":1}}],[\"mysql中锁定粒度最大的锁\",{\"1\":{\"102\":1}}],[\"mysql中并发事务的控制方式有两种\",{\"1\":{\"98\":1}}],[\"mysql中开启事务\",{\"1\":{\"95\":1}}],[\"mysql库中的系统表\",{\"1\":{\"94\":1}}],[\"mysql查询缓存\",{\"0\":{\"94\":1}}],[\"mysql存储引擎\",{\"0\":{\"92\":1}}],[\"mysql\",{\"0\":{\"95\":1,\"101\":1,\"167\":1},\"1\":{\"91\":2,\"92\":1,\"100\":1,\"108\":7,\"126\":1,\"128\":1,\"147\":2,\"153\":1,\"154\":1,\"156\":1,\"173\":1,\"177\":1,\"246\":1}}],[\"mysql主要由下面几个部分构成\",{\"1\":{\"91\":1}}],[\"mysql有什么优点\",{\"0\":{\"90\":1}}],[\"mysql基础架构\",{\"0\":{\"91\":1}}],[\"mysql基础\",{\"0\":{\"88\":1}}],[\"mtu\",{\"1\":{\"75\":1}}],[\"magic\",{\"0\":{\"474\":1},\"1\":{\"474\":2}}],[\"mark\",{\"1\":{\"457\":2,\"466\":2}}],[\"major\",{\"0\":{\"475\":1},\"1\":{\"446\":2,\"475\":1}}],[\"maxheapfreeratio\",{\"1\":{\"509\":1}}],[\"maxmetaspacesize=n\",{\"1\":{\"504\":1}}],[\"maxpermsize=n\",{\"1\":{\"504\":1}}],[\"maxnewsize=1024m\",{\"1\":{\"503\":1}}],[\"maxnewsize指定\",{\"1\":{\"503\":1}}],[\"maxtenuringthreshold=threshold\",{\"1\":{\"514\":1}}],[\"maxtenuringthreshold\",{\"1\":{\"445\":2}}],[\"maximumpoolsize\",{\"1\":{\"387\":1,\"388\":2}}],[\"max\",{\"1\":{\"387\":5,\"390\":3,\"416\":1}}],[\"main\",{\"1\":{\"312\":1}}],[\"mail\",{\"1\":{\"37\":1,\"56\":1}}],[\"map不断的放入对象\",{\"1\":{\"512\":1}}],[\"map\",{\"0\":{\"250\":1,\"263\":1},\"1\":{\"250\":1,\"251\":1,\"382\":3,\"410\":1,\"512\":1}}],[\"manipulation\",{\"1\":{\"87\":1}}],[\"match\",{\"1\":{\"44\":1,\"46\":2}}],[\"mac\",{\"0\":{\"78\":1},\"1\":{\"39\":2,\"78\":8,\"79\":3}}],[\"metaspacesize参数指定的量\",{\"1\":{\"504\":1}}],[\"metaspacesize=n\",{\"1\":{\"504\":1}}],[\"metaspace\",{\"1\":{\"454\":2,\"504\":5}}],[\"methodhandle和varhandle可以看做轻量级的反射调用机制\",{\"1\":{\"489\":1}}],[\"methods\",{\"0\":{\"480\":1},\"1\":{\"480\":4}}],[\"methodproxy\",{\"1\":{\"324\":1}}],[\"methodinterceptor\",{\"1\":{\"324\":1}}],[\"method2\",{\"1\":{\"285\":1}}],[\"method\",{\"1\":{\"285\":1,\"289\":2,\"310\":2,\"316\":7,\"319\":1,\"323\":3,\"324\":3,\"480\":2}}],[\"method字段不一样\",{\"1\":{\"40\":1}}],[\"member\",{\"1\":{\"223\":1,\"226\":2,\"235\":1}}],[\"member2\",{\"1\":{\"188\":1,\"223\":1,\"226\":1,\"235\":2}}],[\"member1\",{\"1\":{\"188\":1,\"223\":1,\"226\":1,\"235\":3}}],[\"memcached\",{\"0\":{\"172\":1},\"1\":{\"172\":7}}],[\"memory等多种存储引擎\",{\"1\":{\"91\":1}}],[\"memory\",{\"1\":{\"9\":1,\"12\":2,\"91\":1,\"362\":1}}],[\"merge\",{\"1\":{\"108\":3}}],[\"media\",{\"1\":{\"78\":1}}],[\"message\",{\"1\":{\"9\":1,\"39\":1,\"75\":1}}],[\"只与类有关\",{\"1\":{\"487\":1}}],[\"只面向虚拟机\",{\"1\":{\"472\":1}}],[\"只标识着某个内存区域是否为脏\",{\"1\":{\"470\":1}}],[\"只对老年代进行垃圾收集\",{\"1\":{\"446\":1}}],[\"只对新生代进行垃圾收集\",{\"1\":{\"446\":1}}],[\"只对单个共享变量有效\",{\"1\":{\"368\":1}}],[\"只会使用一条垃圾收集线程去完成垃圾收集工作\",{\"1\":{\"461\":1}}],[\"只会分配一次内存\",{\"1\":{\"286\":1}}],[\"只会在取出key的时候才对数据进行过期检查\",{\"1\":{\"200\":1}}],[\"只锁定当前链表或红黑二叉树的首节点\",{\"1\":{\"272\":1}}],[\"只需要付出少量对象的复制成本就能完成垃圾收集\",{\"1\":{\"459\":1}}],[\"只需要\",{\"1\":{\"231\":1}}],[\"只需要一个\",{\"1\":{\"228\":1}}],[\"只需要监听前一个节点就好了\",{\"1\":{\"210\":1}}],[\"只需要拍对链表进行遍历即可\",{\"1\":{\"127\":1}}],[\"只支持出栈和入栈两种操作\",{\"1\":{\"424\":1}}],[\"只支持最简单的\",{\"1\":{\"172\":1}}],[\"只支持点对点通信\",{\"1\":{\"53\":1}}],[\"只不过方法区的实现从永久代变成了元空间\",{\"1\":{\"454\":1}}],[\"只不过会在记录头\",{\"1\":{\"161\":1}}],[\"只不过扫描的是索引\",{\"1\":{\"108\":1}}],[\"只针对当前操作的行记录进行加锁\",{\"1\":{\"102\":1}}],[\"只删除表中的数据\",{\"1\":{\"86\":1}}],[\"只要加载它们的类加载器不同\",{\"1\":{\"497\":1}}],[\"只要知道这个方法在方法表中的偏移量就能调用这个方法了\",{\"1\":{\"488\":1}}],[\"只要能无歧义的定位到目标即可\",{\"1\":{\"488\":1}}],[\"只要对象大小超过region的一半\",{\"1\":{\"469\":1}}],[\"只要\",{\"1\":{\"246\":1}}],[\"只要保证\",{\"1\":{\"208\":1}}],[\"只要我不让你插入\",{\"1\":{\"166\":1}}],[\"只要发生了表数据更新\",{\"1\":{\"149\":1}}],[\"只要四次挥手没有结束\",{\"1\":{\"60\":1}}],[\"只要在网络节点上捉包\",{\"1\":{\"40\":1}}],[\"只要在服务端做好支持就好了\",{\"1\":{\"40\":1}}],[\"只要服务端能够解释出来就行\",{\"1\":{\"40\":1}}],[\"只是根据对象存活周期的不同将内存分为几块\",{\"1\":{\"459\":1}}],[\"只是参照的中心点是\",{\"1\":{\"235\":1}}],[\"只是实现了这个算法并提供了一些开箱即用的\",{\"1\":{\"231\":1}}],[\"只是功能依然非常简陋\",{\"1\":{\"218\":1}}],[\"只是功能过于简单且存在很多缺陷\",{\"1\":{\"218\":1}}],[\"只是对表内部数据的操作\",{\"1\":{\"87\":1}}],[\"只是\",{\"1\":{\"40\":1,\"496\":1}}],[\"只在磁盘的一侧进行扫描\",{\"1\":{\"16\":1}}],[\"只可对文件创建\",{\"1\":{\"15\":1}}],[\"只能通过\",{\"1\":{\"179\":1}}],[\"只能读取到第一次查询之前所插入的数据\",{\"1\":{\"159\":1}}],[\"只能对已存在的文件进行创建\",{\"1\":{\"15\":1}}],[\"只能用于亲缘关系的进程间通信\",{\"1\":{\"9\":1}}],[\"只有两者都是一样的才认为是相同的java类\",{\"1\":{\"497\":1}}],[\"只有父类加载器反馈不能完成这个加载请求的时候\",{\"1\":{\"497\":1}}],[\"只有它能与\",{\"1\":{\"462\":1}}],[\"只有写入和写入之间需要进行同步等待\",{\"1\":{\"411\":1}}],[\"只有拿到许可证的线程才能执行\",{\"1\":{\"407\":1}}],[\"只有获取到共享资源的线程才能执行\",{\"1\":{\"407\":1}}],[\"只有一个线程能执行\",{\"1\":{\"406\":1}}],[\"只有同步到磁盘中才算持久化保存\",{\"1\":{\"240\":1}}],[\"只有指定字段不存在时设置指定字段的值\",{\"1\":{\"220\":1}}],[\"只有未指定锁超时时间\",{\"1\":{\"206\":1}}],[\"只有当\",{\"1\":{\"205\":1}}],[\"只有叶子节点存储data\",{\"1\":{\"127\":1}}],[\"只有在被用到的时候才会实例化\",{\"1\":{\"333\":1}}],[\"只有在\",{\"1\":{\"214\":1}}],[\"只有在事务隔离级别rc和rr下\",{\"1\":{\"106\":1}}],[\"只有在内核重启\",{\"1\":{\"9\":1}}],[\"只有保证了事务的持久性\",{\"1\":{\"96\":1}}],[\"只有\",{\"1\":{\"91\":1}}],[\"只有到达磁盘边界时才能改变磁头移动方向\",{\"1\":{\"16\":1}}],[\"只有拥有互斥对象的线程才有访问公共资源的权限\",{\"1\":{\"7\":1}}],[\"只存在于内存中的文件\",{\"1\":{\"9\":1}}],[\"n个线程同时被唤醒\",{\"1\":{\"408\":1}}],[\"n>5\",{\"1\":{\"407\":1}}],[\"n>1\",{\"1\":{\"151\":1}}],[\"n表示cpu核心数\",{\"1\":{\"392\":1}}],[\"n+1\",{\"1\":{\"392\":1}}],[\"n对象中的内部对象是引用类型的话\",{\"1\":{\"297\":1}}],[\"numberofgclogfiles=14\",{\"1\":{\"507\":1}}],[\"number\",{\"0\":{\"474\":1},\"1\":{\"474\":1}}],[\"num2\",{\"1\":{\"285\":2}}],[\"num1\",{\"1\":{\"285\":2}}],[\"numkeys\",{\"1\":{\"226\":4}}],[\"null\",{\"1\":{\"108\":4,\"128\":1,\"259\":1,\"267\":1,\"331\":1,\"332\":2,\"382\":3,\"383\":2,\"417\":1,\"494\":2,\"497\":4}}],[\"nx\",{\"1\":{\"205\":2}}],[\"n\",{\"1\":{\"124\":2,\"184\":1,\"213\":1,\"260\":4,\"267\":1,\"269\":2,\"281\":2,\"366\":1,\"387\":5,\"407\":2,\"467\":1,\"512\":1}}],[\"ntoa\",{\"1\":{\"107\":2}}],[\"nlri\",{\"1\":{\"39\":1}}],[\"nested\",{\"1\":{\"108\":1}}],[\"next\",{\"1\":{\"103\":3,\"156\":2,\"159\":1,\"166\":2,\"405\":1}}],[\"netty的线程模型也是基于reactor模式\",{\"1\":{\"193\":1}}],[\"net和edu等\",{\"1\":{\"50\":1}}],[\"network\",{\"1\":{\"39\":2,\"75\":1,\"76\":1}}],[\"new对象手下会在tlab中分配\",{\"1\":{\"513\":1}}],[\"newratio=1\",{\"1\":{\"503\":1}}],[\"newratio=<int>\",{\"1\":{\"503\":1}}],[\"newsize=256m\",{\"1\":{\"503\":1}}],[\"newsize和\",{\"1\":{\"503\":1}}],[\"new一个thread\",{\"1\":{\"351\":1}}],[\"newproxyinstance\",{\"1\":{\"323\":2}}],[\"newcapacity\",{\"1\":{\"253\":1}}],[\"new\",{\"0\":{\"22\":1,\"306\":1},\"1\":{\"64\":1,\"293\":1,\"295\":1,\"306\":2,\"307\":1,\"318\":1,\"329\":1,\"330\":1,\"331\":1,\"332\":1,\"333\":1,\"344\":1,\"366\":1,\"407\":1,\"436\":1}}],[\"nanotime\",{\"1\":{\"497\":2}}],[\"navigablemap\",{\"1\":{\"265\":1}}],[\"native\",{\"1\":{\"425\":1}}],[\"nat作用是什么\",{\"0\":{\"76\":1}}],[\"nat\",{\"1\":{\"39\":2,\"75\":1,\"76\":2}}],[\"name\",{\"1\":{\"37\":1,\"49\":1,\"56\":1,\"285\":1,\"495\":3,\"497\":6}}],[\"named\",{\"1\":{\"9\":1}}],[\"node\",{\"1\":{\"271\":1,\"272\":1,\"405\":1,\"407\":1}}],[\"node数组+链表\",{\"1\":{\"271\":1}}],[\"node+链表\",{\"1\":{\"271\":1}}],[\"node1\",{\"1\":{\"210\":2}}],[\"not\",{\"1\":{\"204\":1,\"229\":1}}],[\"notifyall\",{\"1\":{\"377\":1}}],[\"notify\",{\"1\":{\"7\":1,\"211\":1}}],[\"no\",{\"1\":{\"201\":1,\"242\":1}}],[\"nonfairsync\",{\"1\":{\"375\":1}}],[\"none\",{\"1\":{\"46\":1}}],[\"non\",{\"0\":{\"22\":1}}],[\"nio中的n可以理解为non\",{\"1\":{\"22\":1}}],[\"nio包\",{\"1\":{\"22\":1}}],[\"nio\",{\"0\":{\"22\":1},\"1\":{\"23\":3}}],[\"匿名管道由于没有名字\",{\"1\":{\"9\":1}}],[\"匿名管道\",{\"1\":{\"9\":1}}],[\"old收集器\",{\"0\":{\"464\":1}}],[\"old\",{\"0\":{\"465\":1},\"1\":{\"446\":1,\"465\":1}}],[\"oldcapacity\",{\"1\":{\"253\":2}}],[\"oom\",{\"0\":{\"508\":1},\"1\":{\"390\":1}}],[\"obj\",{\"1\":{\"324\":2}}],[\"object类\",{\"1\":{\"498\":1}}],[\"object对象为value的键值对\",{\"1\":{\"382\":1}}],[\"object\",{\"0\":{\"298\":1},\"1\":{\"251\":4,\"267\":1,\"316\":6,\"323\":4,\"324\":3,\"478\":2}}],[\"override\",{\"1\":{\"294\":1}}],[\"offerlast\",{\"1\":{\"258\":1}}],[\"offerfirst\",{\"1\":{\"258\":1}}],[\"offer\",{\"1\":{\"258\":1}}],[\"offset\",{\"1\":{\"189\":1,\"229\":4}}],[\"onoutofmemoryerror\",{\"1\":{\"508\":1}}],[\"onoutofmemoryerror=\",{\"1\":{\"508\":2}}],[\"only\",{\"1\":{\"240\":1}}],[\"on\",{\"1\":{\"239\":1}}],[\"operation\",{\"1\":{\"229\":1}}],[\"openjdk\",{\"1\":{\"509\":1}}],[\"open\",{\"1\":{\"39\":1}}],[\"ok\",{\"1\":{\"199\":1,\"205\":1}}],[\"order\",{\"1\":{\"108\":1}}],[\"or\",{\"1\":{\"108\":1,\"143\":2,\"189\":1,\"229\":1}}],[\"org\",{\"1\":{\"50\":1}}],[\"ospf\",{\"1\":{\"39\":1}}],[\"o系统调用论文数据是否已经准备好的过程是很消耗cpu资源的\",{\"1\":{\"22\":1}}],[\"o多路复用模型\",{\"1\":{\"22\":1}}],[\"o操作方法\",{\"1\":{\"22\":1}}],[\"outofmemory\",{\"1\":{\"453\":1,\"508\":1}}],[\"outofmemoryerror\",{\"1\":{\"429\":1,\"504\":2,\"508\":1}}],[\"outpu\",{\"1\":{\"18\":1}}],[\"out\",{\"1\":{\"9\":1,\"285\":2,\"289\":2,\"293\":5,\"307\":3,\"308\":1,\"310\":1,\"312\":2,\"316\":2}}],[\"o\",{\"0\":{\"17\":1,\"21\":1,\"22\":1,\"23\":1},\"1\":{\"8\":1,\"18\":3,\"19\":5,\"113\":3,\"125\":1,\"126\":2,\"184\":2,\"213\":2,\"259\":1,\"392\":1}}],[\"illegalargumentexception\",{\"1\":{\"323\":1}}],[\"illegalaccessexception\",{\"1\":{\"316\":1}}],[\"implements\",{\"1\":{\"304\":1,\"316\":1,\"382\":1,\"478\":1}}],[\"imap\",{\"1\":{\"37\":5,\"56\":5}}],[\"i=10等价于integer\",{\"1\":{\"281\":1}}],[\"i+1\",{\"1\":{\"260\":1}}],[\"ix\",{\"1\":{\"105\":2}}],[\"is\",{\"1\":{\"105\":3}}],[\"isp\",{\"1\":{\"50\":1}}],[\"if\",{\"1\":{\"44\":2,\"46\":4,\"204\":2,\"206\":1,\"260\":2,\"331\":1,\"332\":2,\"362\":2,\"382\":1,\"497\":4}}],[\"igp\",{\"1\":{\"39\":2}}],[\"icmpv6\",{\"1\":{\"75\":2}}],[\"icmp\",{\"1\":{\"39\":2,\"75\":1}}],[\"io多路复用程序\",{\"1\":{\"194\":1}}],[\"io多路复用技术的使用让redis不需要额外创建多余的线程来监听客户端的大量连接\",{\"1\":{\"194\":1}}],[\"io多路复用\",{\"1\":{\"193\":1}}],[\"io多路复用模型\",{\"1\":{\"22\":1}}],[\"io多路复用模型中\",{\"1\":{\"22\":1}}],[\"io\",{\"0\":{\"19\":1,\"20\":1},\"1\":{\"18\":4,\"19\":1,\"21\":1,\"23\":1,\"126\":1,\"171\":1,\"172\":2,\"304\":1}}],[\"ip中的应用层\",{\"1\":{\"313\":1}}],[\"ip寻址如何工作\",{\"0\":{\"74\":1}}],[\"ip协议中最重要的协议之一\",{\"1\":{\"73\":1}}],[\"ip协议的作用是什么\",{\"0\":{\"73\":1}}],[\"ipv6采用128位的地址\",{\"1\":{\"75\":1}}],[\"ipv6\",{\"0\":{\"75\":1},\"1\":{\"39\":1,\"75\":7}}],[\"ipv4\",{\"0\":{\"75\":1},\"1\":{\"39\":1,\"75\":2,\"76\":1}}],[\"ip\",{\"0\":{\"72\":1},\"1\":{\"9\":1,\"37\":1,\"39\":8,\"40\":1,\"46\":1,\"49\":1,\"50\":3,\"56\":1,\"73\":1,\"74\":1,\"75\":1,\"76\":6,\"78\":7,\"79\":3,\"107\":3,\"233\":1}}],[\"info\",{\"1\":{\"396\":4,\"476\":1,\"479\":2,\"480\":2,\"481\":1,\"496\":1}}],[\"information\",{\"1\":{\"39\":2}}],[\"inheritablethreadlocals\",{\"1\":{\"382\":1}}],[\"invocationtargetexception\",{\"1\":{\"316\":1}}],[\"invocationhandler\",{\"1\":{\"316\":1,\"323\":2}}],[\"invokestatic这4条字节码指令\",{\"1\":{\"489\":1}}],[\"invoke\",{\"1\":{\"316\":2,\"319\":1,\"323\":2}}],[\"ing\",{\"1\":{\"308\":2}}],[\"increment\",{\"1\":{\"220\":1,\"497\":1}}],[\"incr\",{\"1\":{\"214\":1,\"215\":1}}],[\"intvalue\",{\"1\":{\"281\":1}}],[\"int\",{\"1\":{\"260\":11,\"267\":2,\"278\":1,\"281\":1,\"285\":4,\"312\":2,\"358\":3,\"388\":2,\"405\":1,\"487\":1}}],[\"intset\",{\"1\":{\"212\":2}}],[\"integer\",{\"1\":{\"189\":7,\"199\":2,\"204\":3,\"280\":1,\"281\":2,\"387\":3,\"390\":3,\"416\":1}}],[\"intention\",{\"1\":{\"105\":2}}],[\"intercept\",{\"1\":{\"324\":1}}],[\"interface\",{\"1\":{\"323\":1,\"324\":1}}],[\"interfaces\",{\"0\":{\"478\":1},\"1\":{\"323\":2,\"478\":3}}],[\"interior\",{\"1\":{\"39\":2}}],[\"intern\",{\"0\":{\"307\":1},\"1\":{\"307\":3}}],[\"internet\",{\"1\":{\"39\":3,\"75\":1}}],[\"internallockleasetime\",{\"1\":{\"206\":1}}],[\"internal\",{\"1\":{\"12\":1}}],[\"instance\",{\"1\":{\"206\":1}}],[\"insert\",{\"1\":{\"106\":1,\"159\":2,\"166\":1}}],[\"index\",{\"0\":{\"234\":1},\"1\":{\"108\":8,\"217\":2,\"234\":1}}],[\"inet\",{\"1\":{\"107\":4}}],[\"innodb存储引擎在rr隔离级别下通过mvcc和next\",{\"1\":{\"166\":1}}],[\"innodb存储引擎使用两阶段提交方案\",{\"1\":{\"152\":1}}],[\"innodb中的主键索引就属于聚簇索引\",{\"1\":{\"131\":1}}],[\"innodb中\",{\"1\":{\"127\":1}}],[\"innodb才会使用快照读\",{\"1\":{\"106\":1}}],[\"innodb会先获取该行数据所在数据表对应的意向锁\",{\"1\":{\"105\":1}}],[\"innodb读写支持并发\",{\"1\":{\"93\":1}}],[\"innodb的性能比myisam性能更好\",{\"1\":{\"93\":1}}],[\"innodb引擎中\",{\"1\":{\"93\":1}}],[\"innodb支持三种行锁定方式\",{\"1\":{\"103\":1}}],[\"innodb支持myisam不支持\",{\"1\":{\"102\":1}}],[\"innodb支持\",{\"1\":{\"93\":1}}],[\"innodb提供事务支持\",{\"1\":{\"93\":1}}],[\"innodb是mysql的默认存储引擎\",{\"1\":{\"92\":1}}],[\"innodb\",{\"0\":{\"93\":1,\"103\":1,\"160\":1},\"1\":{\"91\":2,\"100\":1,\"102\":2,\"103\":2,\"104\":1,\"128\":3,\"146\":4,\"153\":1,\"154\":1,\"156\":1,\"158\":2,\"159\":1,\"160\":1,\"161\":2,\"164\":2,\"166\":1,\"177\":1}}],[\"input\",{\"1\":{\"18\":1}}],[\"inode\",{\"1\":{\"15\":1}}],[\"initialization\",{\"1\":{\"483\":1}}],[\"init\",{\"0\":{\"436\":1},\"1\":{\"10\":2}}],[\"in\",{\"1\":{\"9\":1,\"64\":1,\"106\":1,\"158\":1,\"159\":2,\"166\":1}}],[\"i\",{\"0\":{\"17\":1,\"21\":1,\"22\":1,\"23\":1},\"1\":{\"8\":1,\"18\":3,\"19\":5,\"113\":3,\"201\":5,\"260\":15,\"281\":3,\"392\":1}}],[\"ids\",{\"1\":{\"162\":4,\"164\":2}}],[\"id+1\",{\"1\":{\"162\":1}}],[\"id=2\",{\"1\":{\"152\":1}}],[\"id=1\",{\"1\":{\"150\":1}}],[\"id如果相同\",{\"1\":{\"108\":1}}],[\"identifier\",{\"1\":{\"47\":1}}],[\"id\",{\"1\":{\"8\":1,\"86\":1,\"108\":1,\"153\":1,\"160\":1,\"161\":4,\"162\":12,\"185\":2,\"189\":1,\"190\":1,\"508\":1}}],[\"运行步骤\",{\"1\":{\"466\":1}}],[\"运行时常量池还在方法区\",{\"1\":{\"454\":1}}],[\"运行时常量池剩下的东西还在方法区\",{\"1\":{\"454\":1}}],[\"运行时常量池\",{\"0\":{\"429\":1}}],[\"运行时数据区\",{\"1\":{\"428\":1}}],[\"运行时数据区域的一块逻辑区域\",{\"1\":{\"428\":1}}],[\"运行时数据区域\",{\"0\":{\"421\":1}}],[\"运行时编译器\",{\"1\":{\"276\":1}}],[\"运行状态\",{\"1\":{\"344\":1}}],[\"运行于\",{\"1\":{\"56\":2}}],[\"运行在\",{\"1\":{\"45\":1}}],[\"运行\",{\"1\":{\"8\":1}}],[\"就已经开始了\",{\"1\":{\"504\":1}}],[\"就能破坏双亲委派\",{\"1\":{\"497\":1}}],[\"就能完整地获取数据报文\",{\"1\":{\"40\":1}}],[\"就重写\",{\"1\":{\"495\":1,\"499\":1}}],[\"就重传超时的帧\",{\"1\":{\"70\":1}}],[\"就重传前面发送过的分组\",{\"1\":{\"68\":1}}],[\"就需要每个region都维护一个remember\",{\"1\":{\"467\":1}}],[\"就将还存活的对象复制到另一块去\",{\"1\":{\"458\":1}}],[\"就说明常量\",{\"1\":{\"454\":1}}],[\"就代表一定会被回收吗\",{\"0\":{\"452\":1}}],[\"就应该尽可能的减少实现同步互斥所带来的一系列损耗\",{\"1\":{\"401\":1}}],[\"就新建一个线程来执行任务\",{\"1\":{\"391\":1}}],[\"就只能等到拿到锁以后才能进行其他的逻辑处理\",{\"1\":{\"378\":1}}],[\"就只有加密\",{\"1\":{\"40\":1}}],[\"就属于是不可中断锁\",{\"1\":{\"378\":1}}],[\"就属于是可中断锁\",{\"1\":{\"378\":1}}],[\"就属于非聚簇索引\",{\"1\":{\"132\":1}}],[\"就对应着栈帧的入栈和出栈\",{\"1\":{\"342\":1}}],[\"就加锁成功了\",{\"1\":{\"209\":1}}],[\"就认为客户端成功地获得分布式锁\",{\"1\":{\"208\":1}}],[\"就锁的过期时间设置为\",{\"1\":{\"206\":1}}],[\"就可以把它们当做栈上数据\",{\"1\":{\"399\":1}}],[\"就可以立即让磁头返回\",{\"1\":{\"16\":1}}],[\"就可以立即改变磁头移动方向\",{\"1\":{\"16\":1}}],[\"就可能包括空字符\",{\"1\":{\"184\":1}}],[\"就非常适合\",{\"1\":{\"183\":2}}],[\"就没有问题了么\",{\"1\":{\"175\":1}}],[\"就从db中读取数据返回\",{\"1\":{\"175\":1}}],[\"就单机\",{\"1\":{\"173\":1}}],[\"就不会发生幻读\",{\"1\":{\"166\":1}}],[\"就不符合最左匹配原则\",{\"1\":{\"136\":1}}],[\"就如同\",{\"1\":{\"151\":1}}],[\"就要暂存到磁盘\",{\"1\":{\"151\":1}}],[\"就用row格式\",{\"1\":{\"150\":1}}],[\"就直接在buffer\",{\"1\":{\"145\":1}}],[\"就是将gc\",{\"1\":{\"470\":1}}],[\"就是废弃常量\",{\"1\":{\"454\":1}}],[\"就是一个抽象类\",{\"1\":{\"403\":1}}],[\"就是偏心的\",{\"1\":{\"402\":1}}],[\"就是用一个预期值和要更新的变量值进行比较\",{\"1\":{\"366\":1}}],[\"就是使用了乐观锁的一种实现方式\",{\"1\":{\"364\":1}}],[\"就是锁定读\",{\"1\":{\"159\":1}}],[\"就是联合索引\",{\"1\":{\"135\":2}}],[\"就是对应元素本身\",{\"1\":{\"189\":1,\"228\":1}}],[\"就是对单表的数据进行拆分\",{\"1\":{\"116\":1}}],[\"就是对数据库内部的对象进行创建\",{\"1\":{\"87\":1}}],[\"就是给行记录加s锁\",{\"1\":{\"106\":1}}],[\"就是单纯的\",{\"1\":{\"106\":1}}],[\"就是说用户代理需要采取进一步措施才能满足要求\",{\"1\":{\"44\":1}}],[\"就丢弃该分组\",{\"1\":{\"68\":1}}],[\"就把发送方的\",{\"1\":{\"66\":1}}],[\"就给每个包一个序列号\",{\"1\":{\"64\":1}}],[\"就会导致内存泄漏\",{\"1\":{\"512\":1}}],[\"就会发生\",{\"1\":{\"504\":1}}],[\"就会被系统清理出常量池了\",{\"1\":{\"454\":1}}],[\"就会被晋升到老年代中\",{\"1\":{\"445\":1}}],[\"就会在回收对象的内存之前\",{\"1\":{\"453\":1}}],[\"就会转入下一层链表继续找\",{\"1\":{\"418\":1}}],[\"就会释放所有等待的线程\",{\"1\":{\"408\":1}}],[\"就会使用操作系统互斥量达到互斥同步\",{\"1\":{\"401\":1}}],[\"就会放入到阻塞队列中\",{\"1\":{\"390\":1}}],[\"就会将对应的机器码保存下来\",{\"1\":{\"276\":1}}],[\"就会拒绝启动并提供相应的错误信息\",{\"1\":{\"245\":1}}],[\"就会造成缓冲区溢出\",{\"1\":{\"184\":1}}],[\"就会直接报异常\",{\"1\":{\"172\":1}}],[\"就会产生幻读\",{\"1\":{\"159\":1,\"166\":1}}],[\"就会提交事务恢复数据\",{\"1\":{\"152\":1}}],[\"就会回滚该事务\",{\"1\":{\"152\":1}}],[\"就会少这一次更新\",{\"1\":{\"152\":1}}],[\"就会把\",{\"1\":{\"146\":1}}],[\"就会重新发送\",{\"1\":{\"62\":1}}],[\"就会从用户态切换为内核态\",{\"1\":{\"3\":1}}],[\"就证明服务端已正常关闭\",{\"1\":{\"60\":1}}],[\"就绪\",{\"1\":{\"8\":1}}],[\"包和类以及被\",{\"1\":{\"494\":1}}],[\"包和类\",{\"1\":{\"494\":2}}],[\"包中\",{\"1\":{\"410\":1}}],[\"包下面\",{\"1\":{\"403\":1}}],[\"包装类的缓存机制\",{\"0\":{\"280\":1}}],[\"包装类型占用的空间比基本类型要大\",{\"1\":{\"279\":1}}],[\"包装类型能用于泛型\",{\"1\":{\"279\":1}}],[\"包含jre和一些其他的工具\",{\"1\":{\"275\":1}}],[\"包含记录本身\",{\"1\":{\"103\":1,\"166\":1}}],[\"包含哪些信息\",{\"0\":{\"8\":1}}],[\"包括下面三类常量\",{\"1\":{\"476\":1}}],[\"包括实例和类数据\",{\"1\":{\"438\":1}}],[\"包括私有属性和私有方法\",{\"1\":{\"295\":1}}],[\"包括用户名和密码\",{\"1\":{\"37\":1,\"56\":1}}],[\"包括通用寄存器\",{\"1\":{\"8\":1}}],[\"包括文件描述符\",{\"1\":{\"8\":1}}],[\"包括\",{\"1\":{\"8\":1,\"477\":1}}],[\"包括进程阻塞原因\",{\"1\":{\"8\":1}}],[\"包括进程的名称\",{\"1\":{\"8\":1}}],[\"并记录下直接与\",{\"1\":{\"466\":1}}],[\"并行垃圾收集器\",{\"1\":{\"506\":1}}],[\"并行与并发\",{\"1\":{\"467\":1}}],[\"并行\",{\"1\":{\"462\":1}}],[\"并检查这个符号引用代表的类是否已经加载\",{\"1\":{\"432\":1}}],[\"并使用\",{\"1\":{\"407\":1,\"508\":1}}],[\"并使用至事务提交\",{\"1\":{\"166\":1}}],[\"并装载入cache中\",{\"1\":{\"362\":1}}],[\"并调用start\",{\"1\":{\"351\":1}}],[\"并加载到jvm中\",{\"1\":{\"322\":1,\"326\":1}}],[\"并集\",{\"1\":{\"222\":1,\"224\":2}}],[\"并集和差集的场景\",{\"1\":{\"187\":1,\"224\":1}}],[\"并根据套接字目前执行的任务来为套接字关联不同的事件处理器\",{\"1\":{\"193\":1}}],[\"并把\",{\"1\":{\"147\":1}}],[\"并不是存在threadlocal中\",{\"1\":{\"382\":1}}],[\"并不是\",{\"1\":{\"231\":1}}],[\"并不是通过\",{\"1\":{\"208\":1}}],[\"并不是一种单独的索引类型\",{\"1\":{\"131\":1,\"132\":1}}],[\"并不会一次性加载所有的类\",{\"1\":{\"493\":1}}],[\"并不会实例化静态内部类singletoninstance\",{\"1\":{\"333\":1}}],[\"并不会被序列化\",{\"1\":{\"314\":1}}],[\"并不会不停地循环去尝试加锁\",{\"1\":{\"209\":1}}],[\"并不会回滚事务\",{\"1\":{\"152\":1}}],[\"并不会真的去执行相关的语句\",{\"1\":{\"108\":1}}],[\"并允许数据重复和null\",{\"1\":{\"129\":1}}],[\"并显示对应的信息\",{\"1\":{\"108\":1}}],[\"并发收集\",{\"1\":{\"466\":1}}],[\"并发清除\",{\"1\":{\"466\":1}}],[\"并发标记\",{\"1\":{\"466\":1,\"467\":1,\"468\":2}}],[\"并发\",{\"1\":{\"462\":1}}],[\"并发现自己缓存行是无效的\",{\"1\":{\"362\":1}}],[\"并发编程\",{\"0\":{\"419\":1}}],[\"并发编程三\",{\"0\":{\"379\":1}}],[\"并发编程的三个特性\",{\"0\":{\"360\":1}}],[\"并发编程二\",{\"0\":{\"352\":1}}],[\"并发编程一\",{\"0\":{\"336\":1}}],[\"并发度更大\",{\"1\":{\"272\":1}}],[\"并发度\",{\"1\":{\"272\":1}}],[\"并发度高\",{\"1\":{\"102\":1}}],[\"并发度低\",{\"1\":{\"102\":1}}],[\"并发度不及innodb\",{\"1\":{\"93\":1}}],[\"并发事务的控制方式有哪些\",{\"0\":{\"98\":1}}],[\"并发事务带来了哪些问题\",{\"0\":{\"97\":1}}],[\"并发访问数据库时\",{\"1\":{\"96\":1}}],[\"并立即重传这些丢失的数据段\",{\"1\":{\"66\":1}}],[\"并再次等待\",{\"1\":{\"62\":1}}],[\"并将对象年龄设为\",{\"1\":{\"445\":1}}],[\"并将自身阻塞\",{\"1\":{\"409\":1}}],[\"并将共享资源的状态设置为锁定状态\",{\"1\":{\"405\":1}}],[\"并将数据包转发到正确的目的地网络或子网络\",{\"1\":{\"74\":1}}],[\"并将接收窗口向前移动\",{\"1\":{\"69\":1}}],[\"并将该请求转发到\",{\"1\":{\"50\":1}}],[\"并将结果返回给进程\",{\"1\":{\"3\":1}}],[\"并删除请求报文内的主体\",{\"1\":{\"44\":1}}],[\"并返回该资源的\",{\"1\":{\"41\":1}}],[\"并返回响应\",{\"1\":{\"41\":1}}],[\"并且全都继承自\",{\"1\":{\"494\":1}}],[\"并且只要不与已有的属性名重复\",{\"1\":{\"481\":1}}],[\"并且只按照一个方向扫描\",{\"1\":{\"16\":1}}],[\"并且收集这些region所需的停顿时间要大概率不超过期望的停顿时间\",{\"1\":{\"468\":1}}],[\"并且没有父级\",{\"1\":{\"494\":1}}],[\"并且没有额外的空间对它进行分配担保\",{\"1\":{\"459\":1}}],[\"并且没有对应binlog日志\",{\"1\":{\"152\":1}}],[\"并且能被\",{\"1\":{\"445\":1}}],[\"并且链表是分层的\",{\"1\":{\"418\":1}}],[\"并且更厉害的是\",{\"1\":{\"411\":1}}],[\"并且锁住缓存行\",{\"1\":{\"362\":1}}],[\"并且每一个线程只能访问自己的本地内存\",{\"1\":{\"356\":1}}],[\"并且类只提供一个取得对象实例的方法\",{\"1\":{\"327\":1}}],[\"并且内部没有暴露能修改这个数组的方法\",{\"1\":{\"304\":1}}],[\"并且都不是线程安全的\",{\"1\":{\"257\":1}}],[\"并且获取字符串长度复杂度为\",{\"1\":{\"213\":1}}],[\"并且redis底层会通过限制删除操作执行的时长和频率来减少删除操作对cpu时间的影响\",{\"1\":{\"200\":1}}],[\"并且根据特定的算法分配多余的内存\",{\"1\":{\"184\":1}}],[\"并且是以db的结果为准\",{\"1\":{\"175\":1}}],[\"并且是顺序写\",{\"1\":{\"149\":1}}],[\"并且刚好在当前事务查询范围内\",{\"1\":{\"166\":1}}],[\"并且在\",{\"1\":{\"158\":1,\"246\":1}}],[\"并且\",{\"1\":{\"153\":1,\"170\":2,\"172\":1,\"183\":1,\"202\":1,\"206\":1,\"210\":1,\"231\":1,\"365\":1,\"394\":1}}],[\"并且使用avl树\",{\"1\":{\"125\":1}}],[\"并且innodb默认使用repeaetable\",{\"1\":{\"93\":1}}],[\"并且存在x的一个真子集x0\",{\"1\":{\"84\":1}}],[\"并且去掉重复序列号的数据就可以实现数据包去重\",{\"1\":{\"64\":1}}],[\"并且按序到达\",{\"1\":{\"53\":1}}],[\"并且不用为每一个目标类都创建一个代理类\",{\"1\":{\"326\":1}}],[\"并且不能为null\",{\"1\":{\"128\":1}}],[\"并且不保证数据不丢失\",{\"1\":{\"53\":1}}],[\"并且不支持断点续传功能\",{\"1\":{\"46\":1}}],[\"并且磁头只需要返回到有磁道访问请求的位置即可\",{\"1\":{\"16\":1}}],[\"并且磁头返回时也需要返回到磁盘起点\",{\"1\":{\"16\":1}}],[\"并且为该进程创建一个对应的进程控制块\",{\"1\":{\"8\":1}}],[\"会指定其大小\",{\"1\":{\"416\":1}}],[\"会自旋\",{\"1\":{\"408\":1}}],[\"会自旋更多次\",{\"1\":{\"398\":1}}],[\"会自动先检查表中是否有唯一索引且不允许存在\",{\"1\":{\"128\":1}}],[\"会清理掉\",{\"1\":{\"383\":1}}],[\"会清空加载过的\",{\"1\":{\"147\":1}}],[\"会被清理掉\",{\"1\":{\"383\":1}}],[\"会被记录下来\",{\"1\":{\"184\":1}}],[\"会尝试获取对象的锁\",{\"1\":{\"372\":1}}],[\"会发出信号通知其他cpu将该变量的缓存行置为无效状态\",{\"1\":{\"362\":1}}],[\"会发生隐式转换\",{\"1\":{\"143\":1}}],[\"会把run\",{\"1\":{\"351\":1}}],[\"会释放对象锁\",{\"1\":{\"350\":1}}],[\"会实际调用实现invocationhandler接口类的invoke\",{\"1\":{\"323\":1}}],[\"会创建副本\",{\"1\":{\"311\":1}}],[\"会创建1个或者2个字符串对象\",{\"1\":{\"306\":1}}],[\"会在堆中在单独创建一个字符串对象\",{\"1\":{\"307\":1}}],[\"会直接复制原本类o的内部对象引用地址\",{\"1\":{\"297\":1}}],[\"会有压缩\",{\"1\":{\"246\":1}}],[\"会有三次握手来建立连接\",{\"1\":{\"53\":1}}],[\"会结合多个源\",{\"1\":{\"232\":1}}],[\"会话失效节点自动被删除\",{\"1\":{\"210\":1}}],[\"会话消失则节点消失\",{\"1\":{\"210\":1}}],[\"会判断\",{\"1\":{\"209\":1}}],[\"会不断地延长锁的过期时间\",{\"1\":{\"206\":1}}],[\"会导致oom\",{\"1\":{\"199\":1}}],[\"会导致多线程阻塞\",{\"1\":{\"21\":1}}],[\"会为\",{\"1\":{\"184\":1}}],[\"会为该进程分配一个唯一的进程\",{\"1\":{\"8\":1}}],[\"会根据初始化的长度决定使用哪种类型\",{\"1\":{\"184\":1}}],[\"会根据请求中使用的方法返回响应的实体\",{\"1\":{\"44\":1}}],[\"会锁定读取到的记录的同时\",{\"1\":{\"166\":1}}],[\"会使用该\",{\"1\":{\"161\":1}}],[\"会出现什么情况呢\",{\"1\":{\"152\":1}}],[\"会出现死锁\",{\"1\":{\"102\":1}}],[\"会记录redo\",{\"1\":{\"152\":1}}],[\"会丢失最近n个事务的binlog日志\",{\"1\":{\"151\":1}}],[\"会丢失\",{\"1\":{\"151\":1}}],[\"会执行记录的sql语句\",{\"1\":{\"150\":1}}],[\"会先将请求转发给父类加载器\",{\"1\":{\"497\":1}}],[\"会先将驱动表读出来放到\",{\"1\":{\"108\":1}}],[\"会先根据\",{\"1\":{\"184\":1}}],[\"会先查询缓存\",{\"1\":{\"91\":1,\"94\":1}}],[\"会对对象进行逃逸分析\",{\"1\":{\"279\":1}}],[\"会对\",{\"1\":{\"103\":1}}],[\"会去记录自己发送消息的状态比如消息是否发送了\",{\"1\":{\"53\":1}}],[\"会产生两个\",{\"1\":{\"40\":1}}],[\"会将对应的子节点删除\",{\"1\":{\"209\":1}}],[\"会将\",{\"1\":{\"40\":1}}],[\"会给\",{\"1\":{\"40\":1,\"368\":1}}],[\"会一直阻塞\",{\"1\":{\"21\":1}}],[\"会经历两个步骤\",{\"1\":{\"18\":1}}],[\"会向cpu发出响应的中断信号\",{\"1\":{\"3\":1}}],[\"before这个线程的每一个操作\",{\"1\":{\"359\":1}}],[\"before后面对这个变量的读操作\",{\"1\":{\"359\":1}}],[\"before加锁\",{\"1\":{\"359\":1}}],[\"before于书写在后面的操作\",{\"1\":{\"359\":1}}],[\"before\",{\"0\":{\"358\":1,\"359\":1},\"1\":{\"316\":1,\"359\":3}}],[\"behind\",{\"0\":{\"177\":1},\"1\":{\"177\":3}}],[\"break\",{\"1\":{\"260\":1}}],[\"bgsave\",{\"1\":{\"239\":1,\"246\":1}}],[\"bgp\",{\"1\":{\"39\":1}}],[\"bsd\",{\"1\":{\"170\":1}}],[\"bst\",{\"0\":{\"124\":1}}],[\"b字段是有序的\",{\"1\":{\"136\":1}}],[\"b字段的值是无序的\",{\"1\":{\"136\":2}}],[\"b=2\",{\"1\":{\"136\":5}}],[\"b树的检索过程相当于对范围内的每个结点的关键字做二分查找\",{\"1\":{\"127\":1}}],[\"b树的叶子节点都是独立的\",{\"1\":{\"127\":1}}],[\"b树的所有节点既存放键\",{\"1\":{\"127\":1}}],[\"b树和b+树中的b是balanced的意思\",{\"1\":{\"127\":1}}],[\"b树也称为b\",{\"1\":{\"127\":1}}],[\"b+树的叶子节点不是数据本身\",{\"1\":{\"132\":1}}],[\"b+树的叶子节点有一条引用链指向与他相邻的叶子节点\",{\"1\":{\"127\":1}}],[\"b+树叶节点的data域存放的是数据记录的地址\",{\"1\":{\"127\":1}}],[\"b+树是b树的变体\",{\"1\":{\"127\":1}}],[\"b+树\",{\"0\":{\"127\":1},\"1\":{\"142\":1}}],[\"b\",{\"0\":{\"127\":1},\"1\":{\"136\":4,\"289\":1,\"308\":3,\"359\":2}}],[\"buffer\",{\"1\":{\"108\":2,\"145\":1,\"146\":3,\"177\":1}}],[\"buffer等抽象\",{\"1\":{\"22\":1}}],[\"byte\",{\"1\":{\"228\":1,\"278\":1,\"280\":1,\"509\":1}}],[\"by\",{\"1\":{\"108\":2}}],[\"biginteger内部使用int\",{\"1\":{\"284\":1}}],[\"bitcount\",{\"1\":{\"189\":2,\"229\":1,\"230\":1}}],[\"bitop\",{\"1\":{\"189\":2,\"229\":1,\"230\":1}}],[\"bit\",{\"1\":{\"189\":1,\"228\":2}}],[\"bitmap只需要一个\",{\"1\":{\"189\":1}}],[\"bitmap\",{\"0\":{\"189\":1,\"228\":1},\"1\":{\"170\":1,\"179\":1,\"181\":1,\"189\":2,\"228\":3,\"229\":1}}],[\"binlog日志写期间发生了异常\",{\"1\":{\"152\":1}}],[\"binlog日志刷盘流程如下\",{\"1\":{\"151\":1}}],[\"binlog设置成一个比较大的值\",{\"1\":{\"151\":1}}],[\"binlog控制\",{\"1\":{\"151\":1}}],[\"binlog的写入时机也非常简单\",{\"1\":{\"151\":1}}],[\"binlog会记录所有涉及更新数据的逻辑操作\",{\"1\":{\"149\":1}}],[\"binlog\",{\"0\":{\"149\":1},\"1\":{\"91\":1,\"113\":5,\"150\":1,\"151\":2,\"152\":1,\"246\":1}}],[\"bio\",{\"0\":{\"21\":1},\"1\":{\"21\":1,\"197\":3}}],[\"backup\",{\"1\":{\"238\":1}}],[\"base64\",{\"1\":{\"182\":1,\"213\":1}}],[\"bad\",{\"1\":{\"44\":2}}],[\"barrier\",{\"1\":{\"7\":1}}],[\"bootstrap\",{\"1\":{\"496\":1}}],[\"bootstrapclassloader\",{\"1\":{\"490\":1,\"494\":4,\"495\":1}}],[\"boolean直接返回true或者是false\",{\"1\":{\"280\":1}}],[\"boolean\",{\"1\":{\"206\":1,\"278\":1,\"495\":1,\"497\":1}}],[\"body\",{\"1\":{\"40\":7}}],[\"border\",{\"1\":{\"39\":1}}],[\"blocked\",{\"1\":{\"344\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"388\":1}}],[\"blockingqueue阻塞的原因是其支持当队列没有元素时一直阻塞\",{\"1\":{\"261\":1,\"414\":1}}],[\"blockingqueue\",{\"0\":{\"261\":1,\"414\":1},\"1\":{\"261\":2,\"410\":1,\"413\":1,\"414\":2,\"415\":1}}],[\"blocking\",{\"0\":{\"21\":1,\"22\":1},\"1\":{\"22\":1}}],[\"block\",{\"1\":{\"8\":1,\"15\":1,\"108\":1,\"417\":1}}],[\"p操作\",{\"1\":{\"407\":1}}],[\"pms\",{\"1\":{\"396\":1}}],[\"peeklast\",{\"1\":{\"258\":1}}],[\"peekfirst\",{\"1\":{\"258\":1}}],[\"peek\",{\"1\":{\"258\":1}}],[\"pexpire\",{\"1\":{\"206\":1}}],[\"permgen\",{\"1\":{\"504\":1,\"509\":1}}],[\"permsize=n\",{\"1\":{\"504\":1}}],[\"permits\",{\"1\":{\"407\":2}}],[\"perfcounter\",{\"1\":{\"497\":3}}],[\"percentage\",{\"1\":{\"244\":1}}],[\"persistent\",{\"1\":{\"210\":3}}],[\"persist命令可以溢出一个键的过期时间\",{\"1\":{\"199\":1}}],[\"per\",{\"1\":{\"173\":1}}],[\"px\",{\"1\":{\"205\":1}}],[\"pfmerge\",{\"1\":{\"232\":1}}],[\"pfcount\",{\"1\":{\"190\":2,\"232\":1,\"233\":1}}],[\"pfadd\",{\"1\":{\"190\":2,\"232\":1,\"233\":1}}],[\"public\",{\"1\":{\"206\":2,\"285\":3,\"289\":3,\"304\":1,\"312\":2,\"316\":3,\"323\":3,\"324\":2,\"329\":2,\"330\":2,\"331\":2,\"332\":1,\"333\":2,\"362\":2,\"382\":2,\"477\":1,\"496\":1}}],[\"pub\",{\"1\":{\"179\":1}}],[\"putstatic\",{\"1\":{\"489\":1}}],[\"put\",{\"1\":{\"41\":2,\"417\":1}}],[\"put请求是http协议中的一种请求方法\",{\"1\":{\"41\":1}}],[\"put请求\",{\"1\":{\"41\":1}}],[\"put和post的区别\",{\"0\":{\"41\":1}}],[\"ptr\",{\"1\":{\"153\":1,\"160\":1,\"161\":1}}],[\"preparation\",{\"1\":{\"483\":1}}],[\"prepare\",{\"1\":{\"91\":1}}],[\"pretunuresizethreshold指定对象大小的阈值\",{\"1\":{\"469\":1}}],[\"prev\",{\"1\":{\"405\":1}}],[\"printtenuringdistribution\",{\"1\":{\"514\":1}}],[\"printsafepointstatisticscount=1\",{\"1\":{\"507\":1}}],[\"println\",{\"1\":{\"285\":2,\"289\":2,\"293\":5,\"307\":3,\"308\":1,\"310\":1,\"312\":2,\"316\":2}}],[\"priorityblockingqueue\",{\"0\":{\"417\":1},\"1\":{\"417\":1}}],[\"priorityqueue默认是小顶堆\",{\"1\":{\"260\":1}}],[\"priorityqueue是线程不安全的\",{\"1\":{\"260\":1}}],[\"priorityqueue使用堆实现了在o\",{\"1\":{\"260\":1}}],[\"priorityqueue使用变长数组存储元素\",{\"1\":{\"260\":1}}],[\"priorityqueue\",{\"0\":{\"260\":1},\"1\":{\"251\":1,\"260\":1,\"417\":1}}],[\"privatemethod\",{\"1\":{\"319\":4}}],[\"private\",{\"1\":{\"206\":1,\"285\":2,\"304\":1,\"314\":1,\"316\":1,\"329\":2,\"330\":2,\"331\":2,\"332\":2,\"333\":3,\"362\":2,\"496\":1}}],[\"primary\",{\"0\":{\"128\":1},\"1\":{\"108\":2}}],[\"promotion\",{\"1\":{\"447\":1}}],[\"proxy类中使用较多的方法是newproxyinstance\",{\"1\":{\"323\":1}}],[\"proxy\",{\"1\":{\"316\":1,\"323\":2,\"324\":2}}],[\"protected\",{\"1\":{\"206\":1,\"495\":2,\"496\":1,\"497\":1}}],[\"protocol\",{\"1\":{\"37\":5,\"38\":2,\"39\":7,\"56\":4,\"75\":2,\"79\":1}}],[\"process\",{\"1\":{\"8\":1}}],[\"parent\",{\"1\":{\"496\":3,\"497\":2}}],[\"parents\",{\"1\":{\"496\":1}}],[\"parallelgc\",{\"1\":{\"511\":1}}],[\"parallel\",{\"0\":{\"463\":1,\"465\":1},\"1\":{\"464\":1,\"465\":3}}],[\"parnew\",{\"0\":{\"462\":1},\"1\":{\"433\":1,\"462\":1}}],[\"parties\",{\"1\":{\"409\":1}}],[\"partial\",{\"1\":{\"46\":2,\"446\":1}}],[\"pattern\",{\"0\":{\"175\":1,\"176\":1,\"177\":1},\"1\":{\"175\":1,\"176\":7,\"177\":3}}],[\"path\",{\"1\":{\"39\":1,\"507\":1}}],[\"page\",{\"1\":{\"146\":2,\"151\":1,\"190\":2}}],[\"polllast\",{\"1\":{\"258\":1}}],[\"pollfirst\",{\"1\":{\"258\":1}}],[\"poll\",{\"1\":{\"258\":1}}],[\"pos\",{\"1\":{\"147\":5}}],[\"post请求\",{\"1\":{\"41\":1}}],[\"post\",{\"1\":{\"40\":10,\"41\":4}}],[\"pool\",{\"0\":{\"476\":1},\"1\":{\"148\":1,\"177\":1,\"476\":4}}],[\"pool刷盘的区别\",{\"1\":{\"148\":1}}],[\"pool里存在要更新的数据\",{\"1\":{\"145\":1}}],[\"pool中更新\",{\"1\":{\"145\":1}}],[\"pool中查找\",{\"1\":{\"145\":1}}],[\"pool中\",{\"1\":{\"145\":1}}],[\"pop3\",{\"1\":{\"37\":3,\"56\":3}}],[\"pid<pid>\",{\"1\":{\"508\":1}}],[\"pire\",{\"1\":{\"199\":1}}],[\"ping\",{\"1\":{\"39\":1}}],[\"pipes\",{\"1\":{\"9\":2}}],[\"psw\",{\"1\":{\"8\":1}}],[\"pcb\",{\"0\":{\"8\":1},\"1\":{\"8\":5,\"10\":1}}],[\"通知机制\",{\"1\":{\"377\":1}}],[\"通知或中断\",{\"1\":{\"344\":1}}],[\"通知获取锁失败的客户端\",{\"1\":{\"211\":1}}],[\"通用\",{\"1\":{\"214\":2}}],[\"通常表示为\",{\"1\":{\"494\":1}}],[\"通常情况\",{\"1\":{\"487\":1}}],[\"通常情况下被final修饰的static变量会成为常量\",{\"1\":{\"286\":1}}],[\"通常情况下\",{\"1\":{\"41\":1,\"179\":1}}],[\"通常在创建\",{\"1\":{\"416\":1}}],[\"通常会比\",{\"1\":{\"246\":1}}],[\"通常不建议这样实现分布式锁\",{\"1\":{\"215\":1}}],[\"通常是将\",{\"1\":{\"210\":1}}],[\"通常做法是加一个版本号或者时间戳字段\",{\"1\":{\"158\":1}}],[\"通常用于线程之间的通信\",{\"1\":{\"349\":1}}],[\"通常用于创建新的资源或提交数据到服务器进行处理\",{\"1\":{\"41\":1}}],[\"通常用于更新或者是替换服务器上的资源\",{\"1\":{\"41\":1}}],[\"通常基于\",{\"1\":{\"37\":1}}],[\"通过创建太多相同\",{\"1\":{\"509\":1}}],[\"通过创建唯一性索引\",{\"1\":{\"121\":1}}],[\"通过解析操作符号引用就能直接变成为目标方法在类中方法表的位置\",{\"1\":{\"488\":1}}],[\"通过数据流分析和控制流分析\",{\"1\":{\"486\":1}}],[\"通过数据行的\",{\"1\":{\"153\":1,\"160\":1}}],[\"通过全类名获取定义此类的二进制字节流\",{\"1\":{\"485\":1}}],[\"通过移动中间的指针\",{\"1\":{\"433\":1}}],[\"通过内置的\",{\"1\":{\"405\":1}}],[\"通过cas\",{\"1\":{\"401\":1}}],[\"通过class\",{\"1\":{\"318\":1}}],[\"通过threadpoolexecutor构造函数来创建\",{\"1\":{\"387\":1}}],[\"通过该\",{\"1\":{\"372\":1}}],[\"通过enhancer类来动态获取被代理类\",{\"1\":{\"324\":1}}],[\"通过proxy类的newinstance\",{\"1\":{\"323\":1}}],[\"通过类加载器获取class对象不会进行初始化\",{\"1\":{\"318\":1}}],[\"通过类加载器xxxclassloader\",{\"1\":{\"318\":1}}],[\"通过类名直接访问\",{\"1\":{\"288\":1}}],[\"通过实例对象的getclass\",{\"1\":{\"318\":1}}],[\"通过一个个方法的执行解决问题\",{\"1\":{\"292\":1}}],[\"通过biginteger存储\",{\"1\":{\"284\":1}}],[\"通过位运算实现取模\",{\"1\":{\"269\":1}}],[\"通过key的hashcode经过扰动函数之后获得hash值\",{\"1\":{\"267\":1}}],[\"通过使用一种叫做\",{\"1\":{\"245\":1}}],[\"通过appendonly参数开启\",{\"1\":{\"240\":1}}],[\"通过顺序节点解决顺序唤醒后续节点\",{\"1\":{\"210\":1}}],[\"通过过期时间来避免锁无法被释放导致死锁问题的\",{\"1\":{\"210\":1}}],[\"通过调用\",{\"1\":{\"206\":1}}],[\"通过在插入和删除节点时进行颜色变换和旋转操作\",{\"1\":{\"126\":1}}],[\"通过键可以快速取出对应的值\",{\"1\":{\"123\":1}}],[\"通过这些信息\",{\"1\":{\"108\":1}}],[\"通过mvcc和next\",{\"1\":{\"97\":1}}],[\"通过拥塞控制算法实现\",{\"1\":{\"66\":1}}],[\"通过\",{\"1\":{\"53\":1,\"179\":3,\"189\":1,\"197\":3,\"228\":1,\"234\":1,\"267\":1,\"377\":1,\"387\":1,\"503\":2}}],[\"通过加密和认证机制实现安全的访问和文件传输等业务\",{\"1\":{\"37\":1}}],[\"通过它只需要一个线程便可以管理多个客户端连接\",{\"1\":{\"22\":1}}],[\"通过减少无效的系统调用\",{\"1\":{\"22\":1}}],[\"通过轮训操作避免了一直阻塞\",{\"1\":{\"22\":1}}],[\"通过通知操作的方式来保持多线程同步\",{\"1\":{\"7\":1}}],[\"通信和安全等\",{\"1\":{\"2\":1}}],[\"world\",{\"1\":{\"461\":1,\"467\":1}}],[\"workqueue\",{\"1\":{\"388\":2}}],[\"while\",{\"1\":{\"260\":1}}],[\"where\",{\"1\":{\"86\":2,\"106\":1,\"108\":2,\"136\":8,\"143\":2,\"150\":1,\"152\":1}}],[\"window并进行重传\",{\"1\":{\"64\":1}}],[\"warning\",{\"1\":{\"496\":1}}],[\"watcher\",{\"1\":{\"209\":1}}],[\"watch\",{\"1\":{\"206\":6}}],[\"wan\",{\"1\":{\"39\":1}}],[\"waitstatus\",{\"1\":{\"405\":1}}],[\"waiting\",{\"1\":{\"344\":2}}],[\"wait状态\",{\"1\":{\"60\":1}}],[\"waitpid\",{\"1\":{\"10\":3}}],[\"wait\",{\"0\":{\"349\":1},\"1\":{\"7\":1,\"10\":3,\"60\":3,\"349\":4,\"350\":1}}],[\"webrtc\",{\"1\":{\"37\":1}}],[\"web\",{\"1\":{\"37\":2,\"56\":2}}],[\"write将数据写入到了系统内核缓冲区之后直接返回\",{\"1\":{\"241\":1}}],[\"write技术\",{\"1\":{\"239\":1}}],[\"write和fsync的时机\",{\"1\":{\"151\":1}}],[\"write是把日志写入page\",{\"1\":{\"151\":1}}],[\"write\",{\"0\":{\"176\":1,\"177\":1},\"1\":{\"7\":1,\"147\":5,\"176\":2,\"177\":5,\"241\":1,\"242\":3,\"362\":1}}],[\"是由jvm自动产生的\",{\"1\":{\"492\":1}}],[\"是由客户端自己负责把数据写入\",{\"1\":{\"176\":1}}],[\"是类加载的最后一步\",{\"1\":{\"489\":1}}],[\"是类还是接口\",{\"1\":{\"477\":1}}],[\"是有风险的\",{\"1\":{\"447\":1}}],[\"是各个线程共享的内存区域\",{\"1\":{\"428\":1}}],[\"是共享锁的一种实现\",{\"1\":{\"407\":1,\"408\":1}}],[\"是相对于使用操作系统互斥量来实现的传统锁而言的\",{\"1\":{\"401\":1}}],[\"是强引用\",{\"1\":{\"383\":1}}],[\"是随机或者按照其他优先级排序的\",{\"1\":{\"376\":1}}],[\"是让获得对象锁的线程等待\",{\"1\":{\"350\":1}}],[\"是线程安全的\",{\"1\":{\"303\":1}}],[\"是本地方法\",{\"1\":{\"300\":1}}],[\"是子类对父类方法的实现过程重新编写\",{\"1\":{\"289\":1}}],[\"是继承自\",{\"1\":{\"272\":1}}],[\"是在\",{\"1\":{\"259\":1,\"260\":1}}],[\"是安全的\",{\"1\":{\"213\":1}}],[\"是直接操作\",{\"1\":{\"208\":1}}],[\"是单线程模型\",{\"1\":{\"197\":1}}],[\"是基于可变长的数组和双指针来实现\",{\"1\":{\"259\":1}}],[\"是基于\",{\"1\":{\"184\":1}}],[\"是同步更新\",{\"1\":{\"177\":1}}],[\"是我们平时使用比较多的一个缓存读写模式\",{\"1\":{\"175\":1}}],[\"是多线程\",{\"1\":{\"172\":1}}],[\"是一款面向服务器的垃圾收集器\",{\"1\":{\"467\":1}}],[\"是一次性的\",{\"1\":{\"408\":1}}],[\"是一个支持优先级的无界阻塞队列\",{\"1\":{\"417\":1}}],[\"是一个虚拟的双向队列\",{\"1\":{\"405\":1}}],[\"是一个可重入且独占式的锁\",{\"1\":{\"375\":1}}],[\"是一个原子操作\",{\"1\":{\"366\":1}}],[\"是一个本地方法\",{\"1\":{\"307\":1}}],[\"是一个接口\",{\"1\":{\"261\":1,\"414\":1}}],[\"是一个\",{\"1\":{\"219\":1}}],[\"是一个开源的\",{\"1\":{\"206\":1}}],[\"是一个基于\",{\"1\":{\"170\":1}}],[\"是一种策略\",{\"1\":{\"508\":1}}],[\"是一种双向卡表\",{\"1\":{\"470\":1}}],[\"是一种有名的基数计数概率算法\",{\"1\":{\"231\":1}}],[\"是一种无序集合\",{\"1\":{\"187\":1}}],[\"是一种二进制安全的数据结构\",{\"1\":{\"182\":1,\"213\":1}}],[\"是一种不安全的协议\",{\"1\":{\"37\":1,\"56\":1}}],[\"是一种用于在计算机之间传输文件的协议\",{\"1\":{\"37\":1,\"56\":1}}],[\"是一种用于发送电子邮件的协议\",{\"1\":{\"37\":1,\"56\":1}}],[\"是一种用于传输超文本和多媒体内容的协议\",{\"1\":{\"37\":1,\"56\":1}}],[\"是指在一致性非锁定读\",{\"1\":{\"159\":1}}],[\"是指对数据库中表记录的操作\",{\"1\":{\"87\":1}}],[\"是行锁\",{\"1\":{\"156\":1}}],[\"是不可以防止幻读的\",{\"1\":{\"156\":1}}],[\"是当前要擦除的位置\",{\"1\":{\"147\":1}}],[\"是当前记录的位置\",{\"1\":{\"147\":1}}],[\"是当用户使用浏览器访问网址之后\",{\"1\":{\"49\":1}}],[\"是innodb引擎独有的\",{\"1\":{\"145\":1}}],[\"是目前搜索引擎数据库使用的一种技术\",{\"1\":{\"129\":1}}],[\"是目前较可靠\",{\"1\":{\"56\":1}}],[\"是因为二级索引的叶子节点存储的数据是主键\",{\"1\":{\"129\":1}}],[\"是对对象的每个字段单独存储\",{\"1\":{\"183\":1}}],[\"是对数据表行的拆分\",{\"1\":{\"116\":1}}],[\"是对数据表列的拆分\",{\"1\":{\"116\":1}}],[\"是对原文件起了一个别名\",{\"1\":{\"15\":1}}],[\"是除了\",{\"1\":{\"108\":1}}],[\"是查询中select的序号\",{\"1\":{\"108\":1}}],[\"是针对索引字段加锁\",{\"1\":{\"102\":1}}],[\"是数据的保存形式\",{\"1\":{\"212\":1}}],[\"是数据定义语言的缩写\",{\"1\":{\"87\":1}}],[\"是数据库操作语言\",{\"1\":{\"87\":1}}],[\"是开发人员日常使用最频繁的操作\",{\"1\":{\"87\":1}}],[\"是\",{\"1\":{\"84\":1,\"108\":1,\"182\":1,\"213\":1,\"370\":1,\"415\":1,\"430\":1,\"494\":1}}],[\"是的x0\",{\"1\":{\"84\":1}}],[\"是tcp\",{\"1\":{\"73\":1}}],[\"是面向报文的\",{\"1\":{\"53\":1}}],[\"是面向字节流的\",{\"1\":{\"53\":1}}],[\"是无状态服务\",{\"1\":{\"53\":1}}],[\"是无副作用的\",{\"1\":{\"40\":1}}],[\"是否为\",{\"1\":{\"477\":1}}],[\"是否能存储null\",{\"1\":{\"264\":1}}],[\"是否有正确的访问权限\",{\"1\":{\"486\":1}}],[\"是否有损坏或者丢失的数据\",{\"1\":{\"245\":1}}],[\"是否有状态\",{\"1\":{\"53\":1}}],[\"是否存在内存泄露\",{\"1\":{\"512\":1}}],[\"是否存在\",{\"1\":{\"214\":1}}],[\"是否支持mvcc\",{\"1\":{\"93\":1}}],[\"是否支持数据库异常崩溃后的安全恢复\",{\"1\":{\"93\":1}}],[\"是否支持外键\",{\"1\":{\"93\":1}}],[\"是否支持事务\",{\"1\":{\"93\":1}}],[\"是否支持行级锁\",{\"1\":{\"93\":1}}],[\"是否提供广播或多播服务\",{\"1\":{\"53\":1}}],[\"是否被接收了等等\",{\"1\":{\"53\":1}}],[\"是否可靠传输\",{\"1\":{\"53\":1}}],[\"是否是可靠传输\",{\"1\":{\"53\":1}}],[\"是否面向连接\",{\"1\":{\"53\":1}}],[\"是统一资源定位符\",{\"1\":{\"47\":1}}],[\"是统一资源标志符\",{\"1\":{\"47\":1}}],[\"是运行在\",{\"1\":{\"45\":1}}],[\"是幂等的\",{\"1\":{\"40\":1}}],[\"是操作系统中用来管理和跟踪进程的数据结构\",{\"1\":{\"8\":1}}],[\"是操作系统中拥有资源的基本单位\",{\"1\":{\"5\":1}}],[\"是什么\",{\"0\":{\"8\":1,\"370\":1,\"375\":1}}],[\"是这种机制\",{\"1\":{\"7\":1}}],[\"cmd\",{\"1\":{\"508\":3}}],[\"cmsinitiatingoccupancyfraction=percent\",{\"1\":{\"515\":1}}],[\"cms的老年代内存越大越好\",{\"1\":{\"515\":1}}],[\"cms采用的是增量更新\",{\"1\":{\"470\":1}}],[\"cms采用标记清除算法\",{\"1\":{\"468\":1}}],[\"cms和g1在根节点枚举上的区别就在于处理跨代引用上\",{\"1\":{\"470\":1}}],[\"cms和g1的stw的区别\",{\"0\":{\"470\":1}}],[\"cms和g1的异同\",{\"0\":{\"468\":1}}],[\"cms和g1都是响应时间优先的收集器\",{\"1\":{\"468\":1}}],[\"cms大致可以分为初始标记\",{\"1\":{\"468\":1}}],[\"cms收集器\",{\"0\":{\"466\":1}}],[\"cms垃圾收集器关注的是停顿时间\",{\"1\":{\"463\":1}}],[\"cms\",{\"1\":{\"433\":1,\"462\":1,\"464\":1,\"466\":3,\"467\":3,\"468\":1,\"506\":1,\"511\":1,\"518\":1}}],[\"cp\",{\"1\":{\"476\":1}}],[\"cpp\",{\"1\":{\"430\":1}}],[\"cpu调度的最小单位变成线程\",{\"1\":{\"5\":1}}],[\"cpu\",{\"1\":{\"3\":1,\"8\":1,\"246\":1,\"366\":1,\"368\":1,\"392\":1,\"465\":1,\"466\":1,\"467\":4}}],[\"cpu响应的时候切换到核心态\",{\"1\":{\"3\":1}}],[\"cglib是通过生成一个被代理类的子类来拦截代理类的方法调用\",{\"1\":{\"325\":1}}],[\"cglib则不需要\",{\"1\":{\"325\":1}}],[\"cglib动态代理中methodintercepter接口和enhancer类是核心\",{\"1\":{\"324\":1}}],[\"cglib动态代理\",{\"0\":{\"324\":1},\"1\":{\"322\":1}}],[\"c++实现\",{\"1\":{\"494\":1}}],[\"c++支持多继承\",{\"1\":{\"277\":1}}],[\"c++\",{\"0\":{\"277\":1},\"1\":{\"494\":2}}],[\"createmap\",{\"1\":{\"382\":1}}],[\"creator\",{\"1\":{\"162\":1}}],[\"crc64\",{\"1\":{\"245\":1}}],[\"catch\",{\"1\":{\"497\":1}}],[\"cas+重试\",{\"1\":{\"433\":1}}],[\"cas问题\",{\"0\":{\"368\":1}}],[\"cas\",{\"0\":{\"366\":1},\"1\":{\"271\":1,\"272\":1,\"364\":1,\"366\":4,\"368\":4,\"407\":2,\"408\":2,\"413\":2}}],[\"callable\",{\"0\":{\"395\":1},\"1\":{\"395\":3}}],[\"callerrunspolicy\",{\"1\":{\"389\":1}}],[\"callback\",{\"1\":{\"324\":1}}],[\"call\",{\"1\":{\"204\":2,\"206\":2,\"395\":1}}],[\"cachedthreadpool\",{\"1\":{\"387\":2,\"390\":2}}],[\"cache失效\",{\"1\":{\"362\":1}}],[\"cache中没有取到数据\",{\"1\":{\"175\":1}}],[\"cache里面的\",{\"1\":{\"151\":1}}],[\"cache写到binlog文件中\",{\"1\":{\"151\":1}}],[\"cache\",{\"0\":{\"175\":1},\"1\":{\"146\":2,\"151\":5,\"175\":5,\"176\":17,\"177\":5}}],[\"currentthread\",{\"1\":{\"382\":1}}],[\"current\",{\"1\":{\"159\":1}}],[\"change\",{\"1\":{\"312\":2}}],[\"charsets\",{\"1\":{\"494\":1}}],[\"charsequence\",{\"1\":{\"304\":1}}],[\"character创建了\",{\"1\":{\"280\":1}}],[\"char\",{\"1\":{\"278\":1,\"304\":1,\"509\":1}}],[\"checkcreateclassloader\",{\"1\":{\"496\":1}}],[\"checksum\",{\"1\":{\"245\":1}}],[\"checkpoint\",{\"1\":{\"147\":6}}],[\"chrome\",{\"1\":{\"40\":1}}],[\"c=1\",{\"1\":{\"152\":1}}],[\"c=2\",{\"1\":{\"136\":1}}],[\"c=3\",{\"1\":{\"136\":2}}],[\"c是目的\",{\"1\":{\"96\":1}}],[\"cwnd\",{\"1\":{\"66\":4}}],[\"clh锁的结构如下\",{\"1\":{\"405\":1}}],[\"clh\",{\"1\":{\"405\":3}}],[\"clazz\",{\"1\":{\"318\":3}}],[\"classnotfoundexception\",{\"1\":{\"497\":2}}],[\"classpath\",{\"1\":{\"494\":1}}],[\"classcastexception\",{\"1\":{\"417\":1}}],[\"class<\",{\"1\":{\"323\":1,\"495\":1,\"497\":1}}],[\"classloader抽象类\",{\"1\":{\"494\":1,\"495\":1}}],[\"classloader\",{\"1\":{\"318\":1,\"323\":1,\"455\":1,\"493\":1,\"494\":4,\"495\":3,\"496\":10,\"499\":2}}],[\"class\",{\"0\":{\"475\":1,\"478\":2},\"1\":{\"285\":1,\"289\":1,\"304\":1,\"316\":1,\"318\":5,\"321\":1,\"329\":1,\"330\":1,\"331\":1,\"332\":2,\"333\":2,\"362\":2,\"371\":2,\"382\":1,\"424\":1,\"455\":1,\"472\":1,\"474\":3,\"475\":3,\"477\":2,\"478\":2,\"479\":1,\"480\":2,\"481\":2,\"487\":1,\"495\":2,\"496\":2,\"497\":1}}],[\"class通过解释器和jit\",{\"1\":{\"276\":1}}],[\"class文件格式检查\",{\"1\":{\"486\":1}}],[\"class文件结构总结\",{\"0\":{\"473\":1}}],[\"class文件中除了有类的版本号\",{\"1\":{\"429\":1}}],[\"class文件\",{\"1\":{\"276\":1,\"475\":2,\"485\":1,\"492\":1}}],[\"cluster\",{\"1\":{\"170\":1,\"172\":1,\"206\":1}}],[\"closed\",{\"0\":{\"62\":1}}],[\"close\",{\"1\":{\"60\":2,\"197\":1}}],[\"client确认了\",{\"1\":{\"59\":2}}],[\"client什么都不能确认\",{\"1\":{\"59\":1}}],[\"c\",{\"1\":{\"16\":5,\"136\":1,\"170\":1,\"184\":8,\"213\":2,\"308\":2,\"359\":2,\"495\":1,\"497\":9}}],[\"circular\",{\"1\":{\"16\":1}}],[\"copying\",{\"1\":{\"458\":1}}],[\"copyonwritearraylist\",{\"0\":{\"411\":1,\"412\":1},\"1\":{\"410\":1,\"411\":1,\"412\":1}}],[\"corepoolsize\",{\"1\":{\"387\":1,\"388\":3}}],[\"collections\",{\"1\":{\"206\":1}}],[\"countdown\",{\"1\":{\"408\":4}}],[\"countdownlatch\",{\"0\":{\"408\":1},\"1\":{\"406\":1,\"408\":11}}],[\"counting\",{\"1\":{\"231\":1}}],[\"count\",{\"1\":{\"188\":2,\"223\":2,\"235\":1,\"408\":2,\"409\":3,\"476\":3,\"478\":2,\"479\":2,\"480\":3,\"481\":2}}],[\"com\",{\"1\":{\"318\":2}}],[\"completablefuture<skuinfoentity>\",{\"1\":{\"396\":4}}],[\"completablefuture\",{\"0\":{\"396\":1},\"1\":{\"396\":5}}],[\"completionstage<boolean>\",{\"1\":{\"206\":1}}],[\"comparator\",{\"1\":{\"417\":1}}],[\"comparable\",{\"1\":{\"417\":1}}],[\"comparable<string>\",{\"1\":{\"304\":1}}],[\"comparable对象\",{\"1\":{\"260\":1}}],[\"compareto\",{\"1\":{\"417\":1}}],[\"compare\",{\"1\":{\"364\":1,\"366\":1}}],[\"component就能声明一个bean\",{\"1\":{\"316\":1}}],[\"committed\",{\"1\":{\"97\":2,\"99\":1,\"156\":2,\"158\":1}}],[\"commit\",{\"1\":{\"91\":1,\"95\":1,\"146\":2}}],[\"come\",{\"1\":{\"16\":1}}],[\"concurrentskiplistmap\",{\"0\":{\"418\":1},\"1\":{\"410\":1}}],[\"concurrentlinkedqueue\",{\"0\":{\"413\":1},\"1\":{\"410\":1,\"413\":4}}],[\"concurrent\",{\"1\":{\"364\":1,\"403\":1,\"410\":1,\"466\":2}}],[\"concurrenthashmap\",{\"0\":{\"271\":1,\"272\":1},\"1\":{\"271\":4,\"410\":1}}],[\"condition\",{\"1\":{\"108\":1}}],[\"constant\",{\"0\":{\"476\":1},\"1\":{\"476\":4}}],[\"const\",{\"1\":{\"108\":4}}],[\"config\",{\"1\":{\"206\":1}}],[\"configuration\",{\"1\":{\"75\":1}}],[\"conflict\",{\"1\":{\"46\":1}}],[\"content\",{\"1\":{\"46\":2}}],[\"continue\",{\"1\":{\"46\":1}}],[\"control\",{\"1\":{\"8\":1,\"38\":1,\"39\":1,\"75\":1,\"78\":1}}],[\"cyclicbarrier\",{\"0\":{\"409\":1},\"1\":{\"7\":1,\"409\":1}}],[\"它尽可能优化字符串串联操作\",{\"1\":{\"509\":1}}],[\"它采用\",{\"1\":{\"509\":1}}],[\"它采用的是环形数组形式\",{\"1\":{\"147\":1}}],[\"它限制在抛出\",{\"1\":{\"508\":1}}],[\"它首先不会自己去尝试加载这个类\",{\"1\":{\"499\":1}}],[\"它首先不会尝试去加载这个类\",{\"1\":{\"497\":1}}],[\"它不面向任何特定的处理器\",{\"1\":{\"472\":1}}],[\"它不再坚持以固定大小以及固定数量的分代区域划分\",{\"1\":{\"467\":1}}],[\"它不能再次被使用\",{\"1\":{\"408\":1}}],[\"它使用的回收算法\",{\"1\":{\"466\":1}}],[\"它第一次实现了让垃圾收集线程与用户线程\",{\"1\":{\"466\":1}}],[\"它非常符合在注重用户体验的应用上使用\",{\"1\":{\"466\":1}}],[\"它主要有两大用途\",{\"1\":{\"464\":1}}],[\"它同样是一个单线程收集器\",{\"1\":{\"464\":1}}],[\"它可以将内存分为大小相同的两块\",{\"1\":{\"458\":1}}],[\"它里面的\",{\"1\":{\"446\":1}}],[\"它就是\",{\"1\":{\"417\":1}}],[\"它默认构造\",{\"1\":{\"407\":1,\"408\":1}}],[\"它保存着线程的引用\",{\"1\":{\"405\":1}}],[\"它名字中的\",{\"1\":{\"401\":1}}],[\"它将感兴趣的事件及类型注册到内核中并监听每个事件是否发生\",{\"1\":{\"194\":1}}],[\"它比较类似于\",{\"1\":{\"179\":1}}],[\"它支持三种策略\",{\"1\":{\"146\":1}}],[\"它对数据库中的数据改变是持久的\",{\"1\":{\"96\":1}}],[\"它和\",{\"1\":{\"87\":1}}],[\"它解决的是网络层地址和链路层地址之间的转换问题\",{\"1\":{\"79\":1}}],[\"它的整个生命周期可以简单概括为\",{\"1\":{\"483\":1}}],[\"它的唯一作用是确定这个文件是否为一个能被虚拟机接收的\",{\"1\":{\"474\":1}}],[\"它的插入操作\",{\"1\":{\"417\":1}}],[\"它的意思是这个锁会偏向于第一个获得它的线程\",{\"1\":{\"402\":1}}],[\"它的目的是消除数据在无竞争情况下的同步原语\",{\"1\":{\"402\":1}}],[\"它的本意是在没有多线程竞争的前提下\",{\"1\":{\"401\":1}}],[\"它的查找\",{\"1\":{\"125\":1}}],[\"它的\",{\"1\":{\"78\":1}}],[\"它会执行上图框住的逻辑\",{\"1\":{\"152\":1}}],[\"它会假定确认件指出的数据段丢失了\",{\"1\":{\"66\":1}}],[\"它会停止执行并等待其他线程到达屏障\",{\"1\":{\"7\":1}}],[\"它启动一个定时器\",{\"1\":{\"64\":1}}],[\"它发送一个\",{\"1\":{\"60\":1}}],[\"它起着代理的作用\",{\"1\":{\"50\":1}}],[\"它是\",{\"1\":{\"210\":1}}],[\"它是一种具体的\",{\"1\":{\"47\":1}}],[\"它是异步\",{\"1\":{\"23\":1}}],[\"它允许将私有\",{\"1\":{\"76\":1}}],[\"它允许只请求资源的某个部分\",{\"1\":{\"46\":1}}],[\"它允许同一时刻多个线程访问同一资源\",{\"1\":{\"7\":1}}],[\"它提供了端到端的实时传输数据的功能\",{\"1\":{\"37\":1}}],[\"它在功能和性能上都更加强大\",{\"1\":{\"37\":1,\"56\":1}}],[\"它包含了到原文件的路径信息\",{\"1\":{\"15\":1}}],[\"它们才会一起继续执行\",{\"1\":{\"7\":1}}],[\"用一个闭包结构去记录可达对象\",{\"1\":{\"466\":1}}],[\"用key搜索\",{\"1\":{\"250\":1}}],[\"用来表示哪部分的内存是空闲的\",{\"1\":{\"433\":1}}],[\"用来加载代理对象\",{\"1\":{\"323\":1}}],[\"用来生成一个代理对象\",{\"1\":{\"323\":1}}],[\"用来标识整个查询中select语句的顺序\",{\"1\":{\"108\":1}}],[\"用来关闭客户端到服务器的数据传送\",{\"1\":{\"60\":1}}],[\"用正则等工具从数据中获取\",{\"1\":{\"40\":1}}],[\"用\",{\"1\":{\"40\":1,\"469\":1}}],[\"用的都是同一个传输层协议\",{\"1\":{\"40\":1}}],[\"用套接字中的相关函数来完成通信过程\",{\"1\":{\"9\":1}}],[\"用于发出紧急命令\",{\"1\":{\"508\":1}}],[\"用于统计类加载器相关的信息\",{\"1\":{\"497\":1}}],[\"用于描述接口或类中声明的变量\",{\"1\":{\"479\":1}}],[\"用于展示当前临界资源的获锁情况\",{\"1\":{\"405\":1}}],[\"用于实现类加载过程中的第一步\",{\"1\":{\"492\":1}}],[\"用于实现乐观锁\",{\"1\":{\"366\":1}}],[\"用于实现不同类型的功能和选项\",{\"1\":{\"75\":1}}],[\"用于线程的暂停执行\",{\"1\":{\"349\":1}}],[\"用于存放方法执行过程中产生的中间计算结果\",{\"1\":{\"424\":1}}],[\"用于存放新创建的对象\",{\"1\":{\"343\":1}}],[\"用于存放局部变量表\",{\"1\":{\"342\":1}}],[\"用于调用原始方法\",{\"1\":{\"324\":1}}],[\"用于拦截增强被代理类的方法\",{\"1\":{\"324\":1}}],[\"用于对传输准确性要求特别高的场景\",{\"1\":{\"54\":1}}],[\"用于修改服务器上的数据\",{\"1\":{\"40\":1}}],[\"用于获取信息\",{\"1\":{\"40\":1}}],[\"用于解决域名和\",{\"1\":{\"37\":1}}],[\"用于通过一个终端登陆到其他服务器\",{\"1\":{\"37\":1,\"56\":1}}],[\"用于通知接收进程某个事件已经发生\",{\"1\":{\"9\":1}}],[\"用于多进程对共享数据的访问\",{\"1\":{\"9\":1}}],[\"用于具有亲缘关系的父子进程间或者兄弟进程之间的通信\",{\"1\":{\"9\":1}}],[\"用于等待多个线程到达某个点再一起继续执行\",{\"1\":{\"7\":1}}],[\"用户可通过覆写该方法\",{\"1\":{\"497\":1}}],[\"用户需要定义一个需要执行的主类\",{\"1\":{\"489\":1}}],[\"用户行为统计\",{\"1\":{\"230\":1}}],[\"用户签到情况\",{\"1\":{\"230\":1}}],[\"用户信息\",{\"1\":{\"221\":1}}],[\"用户单位时间的请求数\",{\"1\":{\"215\":1}}],[\"用户\",{\"1\":{\"185\":1}}],[\"用户访问的数据属于高频数据并且不会经常改变的话\",{\"1\":{\"173\":1}}],[\"用户只能看到该事务创建\",{\"1\":{\"153\":1,\"160\":1}}],[\"用户无法手动操作意向锁\",{\"1\":{\"105\":1}}],[\"用户变量\",{\"1\":{\"94\":1}}],[\"用户数据协议\",{\"1\":{\"38\":1}}],[\"用户再发起read调用\",{\"1\":{\"22\":1}}],[\"用户栈指针\",{\"1\":{\"8\":1}}],[\"用户态进程主动要求切换到内核态的一种方式\",{\"1\":{\"3\":1}}],[\"用户态切换到内核态的三种方式\",{\"1\":{\"3\":1}}],[\"用户态运行的进程可以直接读取用户程序的数据\",{\"1\":{\"3\":1}}],[\"用户态\",{\"1\":{\"3\":1}}],[\"用户的身份认证\",{\"1\":{\"2\":1}}],[\"屏障是一种同步原语\",{\"1\":{\"7\":1}}],[\"屏障\",{\"1\":{\"7\":1}}],[\"sweep\",{\"1\":{\"457\":2,\"466\":2}}],[\"swap\",{\"1\":{\"151\":1,\"364\":1,\"366\":1}}],[\"s0\",{\"1\":{\"445\":1}}],[\"skuitemvo\",{\"1\":{\"396\":1}}],[\"skuid\",{\"1\":{\"396\":1}}],[\"skuinfoentity\",{\"1\":{\"396\":1}}],[\"sku\",{\"1\":{\"396\":1}}],[\"sku基本信息的获取\",{\"1\":{\"396\":1}}],[\"skill\",{\"1\":{\"295\":1}}],[\"skiplist\",{\"1\":{\"212\":2}}],[\"sfence\",{\"1\":{\"362\":1}}],[\"sftp\",{\"1\":{\"37\":1,\"56\":1}}],[\"sleep方法是thread类的静态本地方法\",{\"1\":{\"349\":1}}],[\"sleep\",{\"0\":{\"349\":1},\"1\":{\"349\":3}}],[\"slaac\",{\"1\":{\"75\":1}}],[\"s4\",{\"1\":{\"307\":5}}],[\"s3\",{\"1\":{\"307\":4}}],[\"s2\",{\"1\":{\"307\":3}}],[\"s1\",{\"0\":{\"306\":1},\"1\":{\"307\":6,\"445\":1}}],[\"safepoint\",{\"1\":{\"507\":1}}],[\"save\",{\"1\":{\"239\":1}}],[\"sadd\",{\"1\":{\"188\":1,\"223\":1}}],[\"scheduledthreadpool\",{\"1\":{\"387\":2,\"390\":1}}],[\"score2\",{\"1\":{\"226\":1}}],[\"score1\",{\"1\":{\"226\":1}}],[\"score\",{\"1\":{\"225\":3,\"226\":5,\"235\":1}}],[\"scavenge\",{\"0\":{\"463\":1},\"1\":{\"464\":1,\"465\":2}}],[\"scard\",{\"1\":{\"223\":1,\"224\":1}}],[\"scan\",{\"1\":{\"16\":9}}],[\"sdiffstore\",{\"1\":{\"223\":1,\"224\":1}}],[\"sdiff\",{\"1\":{\"223\":1,\"224\":1}}],[\"sds\",{\"1\":{\"184\":9,\"212\":2,\"213\":3}}],[\"sun\",{\"1\":{\"497\":3}}],[\"sunionstore\",{\"1\":{\"223\":1,\"224\":1}}],[\"sunion\",{\"1\":{\"223\":1,\"224\":1}}],[\"super\",{\"0\":{\"478\":1},\"1\":{\"478\":1}}],[\"supplyasync\",{\"1\":{\"396\":3}}],[\"survivorratio=6\",{\"1\":{\"509\":1}}],[\"survivorratio\",{\"1\":{\"509\":1}}],[\"survivor空间或者老年代空间\",{\"1\":{\"467\":1}}],[\"survivor\",{\"1\":{\"445\":4,\"509\":2}}],[\"sum\",{\"1\":{\"226\":1,\"285\":2}}],[\"submit\",{\"1\":{\"395\":1}}],[\"sub\",{\"1\":{\"179\":1}}],[\"subquery\",{\"1\":{\"108\":3}}],[\"smembers\",{\"1\":{\"223\":1}}],[\"smtp\",{\"1\":{\"37\":2,\"56\":3}}],[\"springboot中使用\",{\"1\":{\"316\":1}}],[\"springboot\",{\"1\":{\"316\":1}}],[\"spring\",{\"1\":{\"316\":1}}],[\"spin\",{\"1\":{\"207\":1}}],[\"spop\",{\"1\":{\"188\":1,\"223\":1,\"224\":1}}],[\"sourcekey2\",{\"1\":{\"232\":1}}],[\"sourcekey1\",{\"1\":{\"232\":1}}],[\"sorted\",{\"0\":{\"225\":1},\"1\":{\"170\":1,\"179\":1,\"186\":1,\"225\":2,\"234\":1,\"235\":1}}],[\"sockets\",{\"1\":{\"9\":1}}],[\"stw\",{\"1\":{\"507\":1}}],[\"stop\",{\"1\":{\"461\":1,\"467\":1}}],[\"str4\",{\"1\":{\"308\":2}}],[\"str\",{\"1\":{\"306\":2,\"308\":2,\"310\":3}}],[\"str3\",{\"1\":{\"293\":3,\"308\":3}}],[\"str2\",{\"1\":{\"293\":4,\"308\":5}}],[\"str1\",{\"1\":{\"293\":6,\"308\":5}}],[\"strlen\",{\"1\":{\"214\":1}}],[\"stream\",{\"1\":{\"179\":3,\"218\":1}}],[\"stringtablesize\",{\"1\":{\"430\":2}}],[\"stringtable\",{\"1\":{\"430\":2}}],[\"string对象使用+进行拼接\",{\"1\":{\"305\":1}}],[\"string类本身也被final修饰导致不能被继承\",{\"1\":{\"304\":1}}],[\"string为何不可变\",{\"0\":{\"304\":1}}],[\"string是不可变的\",{\"1\":{\"303\":1}}],[\"stringbuilder没有添加同步锁\",{\"1\":{\"303\":1}}],[\"stringbuilder\",{\"0\":{\"303\":1,\"305\":1}}],[\"stringbuffer和stringbuilder是对对象本身进行操作\",{\"1\":{\"303\":1}}],[\"stringbuffer\",{\"0\":{\"303\":1}}],[\"string\",{\"0\":{\"182\":1,\"183\":1,\"184\":1,\"185\":1,\"213\":1,\"302\":1,\"303\":1,\"306\":2,\"307\":1},\"1\":{\"170\":1,\"181\":1,\"182\":3,\"183\":4,\"184\":2,\"212\":2,\"213\":3,\"219\":1,\"285\":1,\"289\":3,\"293\":4,\"304\":1,\"306\":4,\"307\":6,\"308\":9,\"310\":2,\"312\":1,\"430\":1,\"454\":1,\"495\":2,\"497\":1,\"509\":4}}],[\"static则子类不能重写方法\",{\"1\":{\"289\":1}}],[\"static\",{\"1\":{\"267\":1,\"296\":1,\"312\":2,\"314\":1,\"323\":1,\"329\":2,\"330\":3,\"331\":2,\"332\":2,\"333\":3,\"362\":1,\"371\":1,\"487\":1}}],[\"state>=0\",{\"1\":{\"407\":1}}],[\"state<0\",{\"1\":{\"407\":1}}],[\"state=state+1\",{\"1\":{\"407\":1}}],[\"state=state\",{\"1\":{\"407\":2}}],[\"state\",{\"1\":{\"405\":2,\"407\":5,\"408\":6}}],[\"statement\",{\"1\":{\"150\":1,\"512\":1}}],[\"stateless\",{\"1\":{\"75\":1}}],[\"start\",{\"1\":{\"95\":1,\"217\":2,\"226\":4,\"229\":2,\"351\":2}}],[\"snapshot\",{\"1\":{\"158\":1}}],[\"s\",{\"1\":{\"104\":1,\"105\":2,\"159\":1,\"310\":3}}],[\"sql定义了四个隔离级别\",{\"1\":{\"156\":1}}],[\"sql语句为update\",{\"1\":{\"152\":1}}],[\"sql语句会经过分析器\",{\"1\":{\"91\":1}}],[\"sql2\",{\"1\":{\"95\":1}}],[\"sql1\",{\"1\":{\"95\":1}}],[\"sql\",{\"1\":{\"95\":1,\"108\":2,\"113\":2,\"143\":1,\"156\":1}}],[\"srandmember\",{\"1\":{\"188\":1,\"223\":1,\"224\":1}}],[\"sr\",{\"0\":{\"70\":1}}],[\"ssl\",{\"1\":{\"45\":2,\"56\":1}}],[\"ssh\",{\"1\":{\"37\":2,\"56\":5}}],[\"sstf\",{\"1\":{\"16\":3}}],[\"sift\",{\"1\":{\"260\":3}}],[\"size>\",{\"1\":{\"502\":2,\"503\":1}}],[\"size\",{\"1\":{\"244\":1}}],[\"size参数控制单个线程\",{\"1\":{\"151\":1}}],[\"sismember\",{\"1\":{\"223\":1}}],[\"singlethreadscheduledexecutor\",{\"1\":{\"390\":1}}],[\"singlethreadexector\",{\"1\":{\"390\":1}}],[\"singlethreadexecutor\",{\"1\":{\"387\":2}}],[\"singleton=new\",{\"1\":{\"362\":1}}],[\"singleton==null\",{\"1\":{\"362\":2}}],[\"singletoninstance\",{\"1\":{\"333\":2}}],[\"singleton\",{\"1\":{\"329\":7,\"330\":8,\"331\":9,\"332\":11,\"333\":7,\"334\":2,\"362\":8}}],[\"singletonlist\",{\"1\":{\"206\":1}}],[\"sinterstore\",{\"1\":{\"223\":1,\"224\":1}}],[\"sinter\",{\"1\":{\"223\":1,\"224\":1}}],[\"since\",{\"1\":{\"46\":2}}],[\"simple\",{\"1\":{\"37\":1,\"56\":1,\"108\":1,\"184\":1,\"213\":1}}],[\"signal\",{\"1\":{\"9\":1}}],[\"shutdown\",{\"1\":{\"508\":1}}],[\"short\",{\"1\":{\"278\":1,\"280\":1}}],[\"shortest\",{\"1\":{\"16\":2,\"39\":1}}],[\"share\",{\"1\":{\"106\":1,\"158\":1,\"159\":2,\"166\":1}}],[\"shared\",{\"1\":{\"9\":1,\"105\":1}}],[\"shell\",{\"1\":{\"37\":1,\"56\":1}}],[\"segment\",{\"1\":{\"271\":1,\"272\":3}}],[\"segment的个数固定默认16\",{\"1\":{\"271\":1}}],[\"sequential\",{\"1\":{\"210\":2}}],[\"seq=y\",{\"1\":{\"58\":1,\"60\":1}}],[\"seq=x\",{\"1\":{\"58\":1,\"60\":2}}],[\"session\",{\"1\":{\"182\":1,\"210\":1,\"215\":1}}],[\"seconds\",{\"1\":{\"206\":1,\"214\":1}}],[\"second\",{\"1\":{\"173\":1}}],[\"secure\",{\"1\":{\"37\":1,\"56\":2}}],[\"sentinel\",{\"1\":{\"170\":1,\"206\":1}}],[\"send\",{\"1\":{\"58\":1}}],[\"setinfo\",{\"1\":{\"396\":1}}],[\"setifabsent\",{\"1\":{\"204\":1}}],[\"setaccessible\",{\"1\":{\"319\":1}}],[\"setlockwatchdogtimeout\",{\"1\":{\"206\":1}}],[\"setex\",{\"1\":{\"199\":2}}],[\"setbit\",{\"1\":{\"189\":3,\"229\":1,\"230\":1}}],[\"setnx\",{\"1\":{\"182\":1,\"204\":5,\"214\":1,\"215\":1}}],[\"set\",{\"0\":{\"187\":1,\"188\":1,\"222\":1,\"225\":1,\"250\":1,\"256\":1},\"1\":{\"150\":1,\"152\":1,\"170\":1,\"172\":1,\"179\":1,\"181\":1,\"186\":1,\"187\":2,\"188\":1,\"199\":1,\"204\":1,\"205\":2,\"212\":2,\"214\":1,\"215\":2,\"222\":3,\"225\":4,\"234\":1,\"235\":1,\"249\":1,\"250\":1,\"251\":1,\"257\":1,\"381\":1,\"382\":2,\"383\":1,\"412\":1,\"467\":1}}],[\"select标识符\",{\"1\":{\"108\":1}}],[\"select\",{\"1\":{\"104\":1,\"106\":4,\"108\":4,\"136\":2,\"158\":3,\"159\":4,\"166\":2,\"512\":1}}],[\"selector\",{\"1\":{\"22\":2}}],[\"serial\",{\"0\":{\"461\":1,\"464\":1},\"1\":{\"433\":1,\"461\":1,\"462\":3,\"464\":1}}],[\"serialversionuid用来给jvm识别的\",{\"1\":{\"314\":1}}],[\"serialversionuid的作用是版本控制\",{\"1\":{\"314\":1}}],[\"serialversionuid\",{\"0\":{\"314\":1},\"1\":{\"314\":1}}],[\"serializable\",{\"1\":{\"156\":2,\"304\":1}}],[\"serializable隔离级别是通过锁来实现的\",{\"1\":{\"99\":1}}],[\"server层\",{\"1\":{\"149\":1}}],[\"server\",{\"1\":{\"62\":1,\"91\":2,\"201\":5,\"509\":2}}],[\"server确认了\",{\"1\":{\"59\":2}}],[\"server确认了对方发送正常\",{\"1\":{\"59\":1}}],[\"served\",{\"1\":{\"16\":1}}],[\"service\",{\"1\":{\"16\":1}}],[\"seo\",{\"1\":{\"45\":2}}],[\"seek\",{\"1\":{\"16\":1}}],[\"semaphores\",{\"1\":{\"9\":1}}],[\"semaphore\",{\"0\":{\"407\":1},\"1\":{\"7\":1,\"403\":1,\"407\":9}}],[\"sychronized修饰方法\",{\"0\":{\"371\":1}}],[\"synchronousqueue等等皆是基于\",{\"1\":{\"403\":1}}],[\"synchronousqueue\",{\"1\":{\"390\":2}}],[\"synchronousqueue同步队列\",{\"1\":{\"387\":1}}],[\"synchronized锁优化\",{\"0\":{\"397\":1}}],[\"synchronized关键字与wait\",{\"1\":{\"377\":1}}],[\"synchronized底层原理\",{\"0\":{\"372\":1}}],[\"synchronized和各种lock来实现原子性\",{\"1\":{\"360\":1}}],[\"synchronized\",{\"0\":{\"369\":1,\"370\":1,\"373\":1,\"377\":1},\"1\":{\"7\":1,\"207\":1,\"271\":1,\"272\":2,\"331\":1,\"332\":1,\"360\":1,\"361\":1,\"362\":2,\"370\":1,\"371\":4,\"372\":5,\"373\":3,\"375\":1,\"377\":1,\"378\":1,\"407\":1,\"497\":1}}],[\"sync\",{\"1\":{\"375\":4}}],[\"syn+ack\",{\"1\":{\"58\":1}}],[\"syn\",{\"1\":{\"58\":3}}],[\"system\",{\"1\":{\"37\":1,\"49\":1,\"56\":1,\"108\":3,\"285\":2,\"289\":2,\"293\":5,\"307\":3,\"308\":1,\"310\":1,\"312\":2,\"316\":2,\"497\":2}}],[\"symlink\",{\"1\":{\"15\":1}}],[\"symbolic\",{\"1\":{\"15\":2}}],[\"但很有必要\",{\"1\":{\"486\":1}}],[\"但在这个阶段结束\",{\"1\":{\"466\":1}}],[\"但在该\",{\"1\":{\"39\":1}}],[\"但若有空闲线程可以复用\",{\"1\":{\"387\":1}}],[\"但可能会导致某些线程永远无法获取到锁\",{\"1\":{\"376\":1}}],[\"但不包括在方法内部声明的局部变量\",{\"1\":{\"479\":1}}],[\"但不包含资源预留存\",{\"1\":{\"37\":1}}],[\"但不能保证数据的原子性\",{\"1\":{\"361\":1,\"373\":1}}],[\"但会对机器的\",{\"1\":{\"246\":1}}],[\"但体积更小\",{\"1\":{\"246\":1}}],[\"但和\",{\"1\":{\"225\":1}}],[\"但实际还有一些后台线程用于执行一些比较耗时的操作\",{\"1\":{\"197\":1}}],[\"但通过io多路复用程序来监听多个套接字\",{\"1\":{\"193\":1}}],[\"但由于\",{\"1\":{\"165\":1}}],[\"但它们生成\",{\"1\":{\"164\":1}}],[\"但幻读仍有可能发生\",{\"1\":{\"156\":1}}],[\"但累积n个事务后才fsync\",{\"1\":{\"151\":1}}],[\"但还是不推荐这么做\",{\"1\":{\"143\":1}}],[\"但查询条件未遵守最左匹配原则\",{\"1\":{\"143\":1}}],[\"但加锁的开销也最大\",{\"1\":{\"102\":1}}],[\"但同时还要发送确认\",{\"1\":{\"68\":1}}],[\"但对称加密的密钥用服务器方的证书进行了非对称加密\",{\"1\":{\"45\":1}}],[\"但未满足条件\",{\"1\":{\"44\":1}}],[\"但\",{\"1\":{\"39\":1,\"79\":1,\"184\":1,\"259\":1,\"467\":1}}],[\"但后者已经被提议来取代前者\",{\"1\":{\"39\":1}}],[\"但也支持\",{\"1\":{\"37\":1}}],[\"但容易出现饥饿问题\",{\"1\":{\"16\":1}}],[\"但为其分配了\",{\"1\":{\"12\":1}}],[\"但无法被进一步使用\",{\"1\":{\"10\":1}}],[\"但是可以作为\",{\"1\":{\"496\":1}}],[\"但是可能会造成过多的key没有被删除\",{\"1\":{\"200\":1}}],[\"但是自定义的类加载器加载的类是可能被卸载的\",{\"1\":{\"490\":1}}],[\"但是低版本的jvm不会向上兼容高版本的\",{\"1\":{\"475\":1}}],[\"但是cms是追求最小的停顿时间为目标\",{\"1\":{\"468\":1}}],[\"但是微观上是在各个region之间标记复制\",{\"1\":{\"468\":1}}],[\"但是这个参数只支持serial和parnew\",{\"1\":{\"469\":1}}],[\"但是这个组合在g1出现后已经被废弃了\",{\"1\":{\"468\":1}}],[\"但是这种io模型仍然存在问题\",{\"1\":{\"22\":1}}],[\"但是还是保留了分代的概念\",{\"1\":{\"467\":1}}],[\"但是对象之间存在循环引用\",{\"1\":{\"449\":1}}],[\"但是出现溢出的概率比原来的永久代小很多\",{\"1\":{\"428\":1}}],[\"但是被检测到不可能存在共享数据竞争的锁进行消除\",{\"1\":{\"399\":1}}],[\"但是当前运行的线程数是小于最大线程数的\",{\"1\":{\"391\":1}}],[\"但是当并发数量增大的时候\",{\"1\":{\"21\":1}}],[\"但是小于最大线程数\",{\"1\":{\"391\":1}}],[\"但是需要借助于condition接口与newcondition\",{\"1\":{\"377\":1}}],[\"但是需要控制同一时刻访问此资源的最大线程数量\",{\"1\":{\"7\":1}}],[\"但是从\",{\"1\":{\"368\":1}}],[\"但是没义务保证多线程之间语义的一致\",{\"1\":{\"354\":1}}],[\"但是不称为引用传递\",{\"1\":{\"312\":1}}],[\"但是不代表它的应用场景少\",{\"1\":{\"177\":1}}],[\"但是线程不安全\",{\"1\":{\"303\":1}}],[\"但是父类中不存在的方法\",{\"1\":{\"295\":1}}],[\"但是会提供方法来操作属性\",{\"1\":{\"295\":1}}],[\"但是能implements多个接口\",{\"1\":{\"296\":1}}],[\"但是能重载\",{\"1\":{\"294\":1}}],[\"但是能通过事务id找到对应的binlog日志\",{\"1\":{\"152\":1}}],[\"但是方法内的代码不同\",{\"1\":{\"289\":1}}],[\"但是范围过大不可能直接放入内存中进行计算\",{\"1\":{\"269\":1}}],[\"但是范围查询字段的后面的字段无法使用到联合索引\",{\"1\":{\"136\":1}}],[\"但是作为null的key只能有一个\",{\"1\":{\"264\":1}}],[\"但是每一个英雄的技能各有不同\",{\"1\":{\"295\":1}}],[\"但是每次插入数据时均需要申请新的堆空间\",{\"1\":{\"259\":1}}],[\"但是每个线程都有自己的程序计数器\",{\"1\":{\"5\":1}}],[\"但是aof重写时会占用大量cpu和内存资源\",{\"1\":{\"246\":1}}],[\"但是体积更小\",{\"1\":{\"244\":1}}],[\"但是redis\",{\"1\":{\"196\":1}}],[\"但是给缓存加一个比较短的过期时间\",{\"1\":{\"175\":1}}],[\"但是使用\",{\"1\":{\"173\":1}}],[\"但是innodb\",{\"1\":{\"156\":1}}],[\"但是幻读或不可重复读仍有可能发生\",{\"1\":{\"156\":1}}],[\"但是侧重点不同\",{\"1\":{\"152\":1}}],[\"但是机器宕机\",{\"1\":{\"151\":1}}],[\"但是有个问题\",{\"1\":{\"150\":1}}],[\"但是维护索引的成本也是不小的\",{\"1\":{\"140\":1}}],[\"但是在\",{\"1\":{\"487\":1}}],[\"但是在多线程下还是会出现数据覆盖问题\",{\"1\":{\"270\":1}}],[\"但是在a=1的二级索引记录的范围里\",{\"1\":{\"136\":1}}],[\"但是在符合a>1条件的二级索引记录的范围里\",{\"1\":{\"136\":1}}],[\"但是在日常开发中不建议使用外键\",{\"1\":{\"93\":1}}],[\"但是如果查询条件是以下几种\",{\"1\":{\"136\":1}}],[\"但是允许数据为null\",{\"1\":{\"129\":1}}],[\"但是两者实现方式有所不同\",{\"1\":{\"127\":1}}],[\"但是两者实现方式不同\",{\"1\":{\"93\":1}}],[\"但是哈希算法有hash冲突问题\",{\"1\":{\"123\":1}}],[\"但是主库和从库的数据存在延时\",{\"1\":{\"111\":1}}],[\"但是缓存同时也带来了额外的开销\",{\"1\":{\"94\":1}}],[\"但是\",{\"1\":{\"16\":1,\"45\":1,\"84\":1,\"103\":1,\"159\":1,\"172\":2,\"173\":1,\"177\":1,\"373\":1,\"495\":1,\"499\":1,\"508\":1}}],[\"但是该进程仍在运行\",{\"1\":{\"10\":1}}],[\"但是其父进程仍在运行\",{\"1\":{\"10\":1}}],[\"但只有一个线程可以对共享资源进行写操作\",{\"1\":{\"7\":1}}],[\"关键点在于这二者都存在一个并发标记的步骤\",{\"1\":{\"470\":1}}],[\"关键字修饰的接口方法\",{\"1\":{\"489\":1}}],[\"关键字类似\",{\"1\":{\"375\":1}}],[\"关键字解决的是多个线程之间访问资源的同步性\",{\"1\":{\"373\":1}}],[\"关键字可以修饰方法以及代码块\",{\"1\":{\"373\":1}}],[\"关键字可以保证变量的可见性\",{\"1\":{\"361\":1}}],[\"关键字只能用于变量而\",{\"1\":{\"373\":1}}],[\"关键字是线程同步的轻量级实现\",{\"1\":{\"373\":1}}],[\"关键字加到实例方法上是给对象实例上锁\",{\"1\":{\"371\":1}}],[\"关键字加到\",{\"1\":{\"371\":1}}],[\"关键字的使用方式主要有下面\",{\"1\":{\"371\":1}}],[\"关键字两者都能保证\",{\"1\":{\"361\":1,\"373\":1}}],[\"关键字能保证数据的可见性\",{\"1\":{\"361\":1,\"373\":1}}],[\"关键词和各种\",{\"1\":{\"7\":1}}],[\"关系型数据库通常都是执行命令之前记录日志\",{\"1\":{\"243\":1}}],[\"关系型数据库都有acid特性\",{\"1\":{\"96\":1}}],[\"关系模型表明了数据库中所存储的数据之间的联系\",{\"1\":{\"89\":1}}],[\"关系中\",{\"1\":{\"84\":2}}],[\"关于我\",{\"0\":{\"0\":1}}],[\"中花费的\",{\"1\":{\"508\":1}}],[\"中是没有与之对应的类的\",{\"1\":{\"494\":1}}],[\"中更小的一个值\",{\"1\":{\"445\":1}}],[\"中每熬过一次\",{\"1\":{\"445\":1}}],[\"中就会出现\",{\"1\":{\"383\":1}}],[\"中使用的\",{\"1\":{\"383\":1}}],[\"中实现的\",{\"1\":{\"375\":1}}],[\"中synchronized和reentrantlock等独占锁就是悲观锁思想的实现\",{\"1\":{\"365\":1}}],[\"中java\",{\"1\":{\"364\":1}}],[\"中被引入的\",{\"1\":{\"260\":1}}],[\"中被称为\",{\"1\":{\"210\":1}}],[\"中存储的就是对象的句柄地址\",{\"1\":{\"440\":1}}],[\"中存储的直接就是对象的地址\",{\"1\":{\"439\":1}}],[\"中存储的地理位置信息的经纬度数据通过\",{\"1\":{\"235\":1}}],[\"中存在\",{\"1\":{\"176\":1}}],[\"中存在的队头阻塞问题\",{\"1\":{\"55\":1}}],[\"中储存的数字值减一\",{\"1\":{\"214\":1}}],[\"中储存的数字值增一\",{\"1\":{\"214\":1}}],[\"中数据的最小单元\",{\"1\":{\"210\":1}}],[\"中任意选择数据淘汰\",{\"1\":{\"201\":2}}],[\"中挑选最不经常使用的数据淘汰\",{\"1\":{\"201\":1}}],[\"中挑选最近最少使用的数据淘汰\",{\"1\":{\"201\":1}}],[\"中挑选将要过期的数据淘汰\",{\"1\":{\"201\":1}}],[\"中有一个叫做\",{\"1\":{\"186\":1}}],[\"中最简单同时也是最常用的一个数据结构\",{\"1\":{\"182\":1,\"213\":1}}],[\"中最小的事务\",{\"1\":{\"162\":1}}],[\"中增加的\",{\"1\":{\"179\":1}}],[\"中不存在对应的数据\",{\"1\":{\"176\":1}}],[\"中不存在\",{\"1\":{\"176\":1}}],[\"中服务端把\",{\"1\":{\"176\":1}}],[\"中读取数据\",{\"1\":{\"175\":1,\"176\":1}}],[\"中出现的子查询将被标记为\",{\"1\":{\"108\":1}}],[\"中主要使用\",{\"1\":{\"46\":1}}],[\"中新加入了大量的状态码\",{\"1\":{\"46\":1}}],[\"中间件\",{\"0\":{\"31\":1}}],[\"中引入了\",{\"1\":{\"23\":1}}],[\"中\",{\"0\":{\"20\":1},\"1\":{\"39\":1,\"40\":2,\"46\":1,\"84\":3,\"85\":1,\"108\":1,\"113\":1,\"153\":1,\"187\":1,\"190\":2,\"204\":1,\"223\":3,\"225\":1,\"226\":1,\"232\":2,\"235\":1,\"361\":1,\"445\":1,\"472\":1,\"493\":1}}],[\"中的永久代\",{\"1\":{\"454\":1}}],[\"中的共享资源\",{\"1\":{\"407\":1}}],[\"中的一个关键字\",{\"1\":{\"370\":1}}],[\"中的元素\",{\"1\":{\"235\":1}}],[\"中的分布式锁自带自动续期机制\",{\"1\":{\"206\":1}}],[\"中的数据\",{\"1\":{\"175\":1}}],[\"中的历史版本\",{\"1\":{\"153\":1,\"160\":1}}],[\"中的信息将数据回滚到修改之前的样子即可\",{\"1\":{\"153\":1}}],[\"中的信息会不断变化\",{\"1\":{\"8\":1}}],[\"中的内容写到文件系统缓存\",{\"1\":{\"146\":1}}],[\"中的\",{\"1\":{\"7\":2,\"75\":2,\"161\":1,\"175\":2,\"187\":1,\"204\":1,\"207\":1,\"216\":1,\"219\":1,\"222\":2}}],[\"中断\",{\"1\":{\"3\":1,\"375\":1}}],[\"因此称为类变量\",{\"1\":{\"487\":1}}],[\"因此除了\",{\"1\":{\"478\":1}}],[\"因此g1的记忆集是一个哈希表\",{\"1\":{\"470\":1}}],[\"因此会产生内存碎片\",{\"1\":{\"468\":1}}],[\"因此会有较大的计算开销\",{\"1\":{\"125\":1}}],[\"因此传统的锁机制就称为\",{\"1\":{\"401\":1}}],[\"因此创建n+n个核心线程\",{\"1\":{\"392\":1}}],[\"因此这种策略会降低对于新任务提交速度\",{\"1\":{\"389\":1}}],[\"因此当其他cpu需要读取这个变量时\",{\"1\":{\"362\":1}}],[\"因此不能代理声明final类型的类和方法\",{\"1\":{\"325\":1}}],[\"因此不能通过b=2来进一步减少需要扫描的记录数量\",{\"1\":{\"136\":1}}],[\"因此需要先通过取模运算\",{\"1\":{\"269\":1}}],[\"因此\",{\"1\":{\"152\":1,\"231\":1,\"245\":1,\"390\":1,\"472\":1}}],[\"因此innodb表数据文件本身就是索引\",{\"1\":{\"127\":1}}],[\"因此被称为平衡二叉树\",{\"1\":{\"125\":1}}],[\"因此哈希表可以快速检索数据\",{\"1\":{\"123\":1}}],[\"因此每发送完一个分组需要设置一个超时计时器\",{\"1\":{\"68\":1}}],[\"因此叫\",{\"1\":{\"16\":1}}],[\"因此线程之间的相互通信无需调用内核\",{\"1\":{\"6\":1}}],[\"因为g1的分区是按region分的\",{\"1\":{\"470\":1}}],[\"因为用户线程可能会不断的更新引用域\",{\"1\":{\"466\":1}}],[\"因为方法区的gc效率很低\",{\"1\":{\"430\":1}}],[\"因为它是无界队列\",{\"1\":{\"417\":1}}],[\"因为它在传输过程中不会对数据进行加密\",{\"1\":{\"37\":1,\"56\":1}}],[\"因为公平锁为了保证时间上的绝对顺序\",{\"1\":{\"376\":1}}],[\"因为sleep\",{\"1\":{\"350\":1}}],[\"因为锁的问题\",{\"1\":{\"264\":1}}],[\"因为数据完整性不如aof\",{\"1\":{\"246\":1}}],[\"因为数据在地址栏上不可见\",{\"1\":{\"40\":1}}],[\"因为时不时地创建一个\",{\"1\":{\"246\":1}}],[\"因为内存有限\",{\"1\":{\"199\":1}}],[\"因为缓存的写入速度是比数据库的写入速度快很多\",{\"1\":{\"175\":1}}],[\"因为会造成数据库和缓存的数据不一致问题\",{\"1\":{\"175\":1}}],[\"因为可以把缓存中的数据持久化到磁盘上\",{\"1\":{\"172\":1}}],[\"因为mysql根据redo\",{\"1\":{\"152\":1}}],[\"因为索引是需要占用磁盘空间的\",{\"1\":{\"142\":1}}],[\"因为对于联合索引\",{\"1\":{\"136\":1}}],[\"因为有查询优化器\",{\"1\":{\"136\":1}}],[\"因为二级索引的叶子节点存放的是主键\",{\"1\":{\"132\":1}}],[\"因为b+树是多路平衡树\",{\"1\":{\"131\":1}}],[\"因为b+树本身就是一棵多叉平衡树\",{\"1\":{\"131\":1}}],[\"因为红黑树在插入和删除节点时只需进行\",{\"1\":{\"126\":1}}],[\"因为红黑树的平衡性相对较弱\",{\"1\":{\"126\":1}}],[\"因为不会自动平衡\",{\"1\":{\"124\":1}}],[\"因为hash索引不支持顺序和范围查询\",{\"1\":{\"123\":1}}],[\"因为确定了学号或者是身份证就能确定姓名\",{\"1\":{\"84\":1}}],[\"因为现在还不知道网络的符合情况\",{\"1\":{\"66\":1}}],[\"因为服务器收到客户端断开连接的请求时\",{\"1\":{\"61\":1}}],[\"因为\",{\"1\":{\"40\":1,\"45\":1}}],[\"因为一个事务的binlog不能被拆开\",{\"1\":{\"151\":1}}],[\"因为一个数据也对应的位置可能在磁盘文件的随机位置\",{\"1\":{\"148\":1}}],[\"因为一个\",{\"1\":{\"39\":1,\"79\":1}}],[\"因为磁头移动方向上可能已经没有请求需要处理了\",{\"1\":{\"16\":1}}],[\"因为互斥对象只有一个\",{\"1\":{\"7\":1}}],[\"有三个步骤需要stw\",{\"1\":{\"470\":1}}],[\"有以下特点\",{\"1\":{\"467\":1}}],[\"有地方引用的时候就将计数器+1\",{\"1\":{\"449\":1}}],[\"有两种模式\",{\"1\":{\"407\":1}}],[\"有两个构造函数\",{\"1\":{\"395\":1}}],[\"有一个任务\",{\"1\":{\"394\":1}}],[\"有公平锁\",{\"1\":{\"375\":1}}],[\"有什么关系\",{\"0\":{\"395\":1}}],[\"有什么用\",{\"0\":{\"370\":1,\"381\":1}}],[\"有什么作用\",{\"0\":{\"314\":1}}],[\"有什么区别\",{\"0\":{\"75\":1,\"93\":1,\"102\":1,\"373\":1,\"377\":1}}],[\"有参构造和无参构造\",{\"1\":{\"294\":1}}],[\"有要求使用treeset\",{\"1\":{\"257\":1}}],[\"有序性\",{\"1\":{\"332\":1,\"360\":1}}],[\"有序\",{\"1\":{\"251\":1}}],[\"有序集合\",{\"0\":{\"225\":1},\"1\":{\"181\":1,\"212\":1}}],[\"有点像是\",{\"1\":{\"225\":1}}],[\"有点类似于\",{\"1\":{\"187\":1,\"222\":1}}],[\"有对应的\",{\"1\":{\"184\":1}}],[\"有主题和消费组的概念\",{\"1\":{\"179\":1}}],[\"有灾难恢复机制\",{\"1\":{\"172\":1}}],[\"有何不同\",{\"1\":{\"127\":1}}],[\"有可能是多个列的长度和\",{\"1\":{\"108\":1}}],[\"有可能丢失\",{\"1\":{\"62\":1}}],[\"有哪几类行锁\",{\"0\":{\"103\":1}}],[\"有哪些常见的\",{\"0\":{\"19\":1}}],[\"有\",{\"1\":{\"91\":1}}],[\"有了对集合中的元素根据键排序的能力\",{\"1\":{\"265\":1}}],[\"有了对集合内元素的搜索的能力\",{\"1\":{\"265\":1}}],[\"有了一些改进\",{\"1\":{\"75\":1}}],[\"有了序列号能够将接收到的数据根据序列号排序\",{\"1\":{\"64\":1}}],[\"有了进程为什么还需要线程\",{\"0\":{\"6\":1}}],[\"有确认\",{\"1\":{\"53\":1}}],[\"有些文章中提到\",{\"1\":{\"40\":1}}],[\"有副作用\",{\"1\":{\"40\":1}}],[\"有名管道以磁盘文件的方式存在\",{\"1\":{\"9\":1}}],[\"有名管道严格遵循\",{\"1\":{\"9\":1}}],[\"有名管道\",{\"1\":{\"9\":1}}],[\"有效利用cpu资源\",{\"1\":{\"6\":1}}],[\"jar等\",{\"1\":{\"494\":1}}],[\"jar\",{\"1\":{\"494\":5}}],[\"java对象最小是16字节\",{\"1\":{\"512\":1}}],[\"java文件\",{\"1\":{\"492\":1}}],[\"java文件经过javac编译之后变成\",{\"1\":{\"276\":1}}],[\"java为每一个类都准备了一张方法表来存放类中所有的方法\",{\"1\":{\"488\":1}}],[\"java语言规范\",{\"1\":{\"486\":1}}],[\"java虚拟机规范\",{\"1\":{\"486\":1}}],[\"java程序中通常有大量的字符串等待回收\",{\"1\":{\"430\":1}}],[\"java内存结构和运行时区域有关\",{\"1\":{\"357\":1}}],[\"java内存结构和java内存模型的区别\",{\"0\":{\"357\":1}}],[\"java内存模型\",{\"0\":{\"353\":1}}],[\"java变成\",{\"1\":{\"321\":1}}],[\"java反射\",{\"0\":{\"315\":1}}],[\"java序列化\",{\"0\":{\"313\":1}}],[\"java只有值传递\",{\"0\":{\"312\":1}}],[\"java值传递\",{\"0\":{\"309\":1}}],[\"java中动态代理中invocationhandler接口和proxy类是核心\",{\"1\":{\"323\":1}}],[\"java中通过实现serializable接口实现序列化功能\",{\"1\":{\"313\":1}}],[\"java中如果两个对象相同则hashcode\",{\"1\":{\"301\":1}}],[\"java中的wait\",{\"1\":{\"211\":1}}],[\"java中的nio有一个非常重要的选择器\",{\"1\":{\"22\":1}}],[\"java中的nio可以看做是i\",{\"1\":{\"22\":1}}],[\"java中的nio于java\",{\"1\":{\"22\":1}}],[\"java8可以用default关键字在接口中定义默认方法\",{\"1\":{\"296\":1}}],[\"java基础\",{\"0\":{\"335\":1}}],[\"java基础二\",{\"0\":{\"290\":1}}],[\"java基础一\",{\"0\":{\"274\":1}}],[\"java有8种基本数据类型\",{\"1\":{\"278\":1}}],[\"java有自动的垃圾回收机制\",{\"1\":{\"277\":1}}],[\"java的类是单继承的\",{\"1\":{\"277\":1}}],[\"java不支持通过指针来直接访问内存\",{\"1\":{\"277\":1}}],[\"java和c++都是面向对象的语言\",{\"1\":{\"277\":1}}],[\"java等\",{\"1\":{\"275\":1}}],[\"java集合二\",{\"0\":{\"262\":1}}],[\"java集合由两大接口派生而来\",{\"1\":{\"249\":1}}],[\"java集合一\",{\"0\":{\"248\":1}}],[\"java\",{\"0\":{\"20\":1,\"30\":1,\"277\":1},\"1\":{\"7\":2,\"23\":1,\"187\":1,\"204\":1,\"206\":1,\"207\":1,\"222\":1,\"225\":1,\"304\":1,\"307\":6,\"324\":1,\"361\":1,\"364\":1,\"365\":1,\"370\":2,\"396\":1,\"403\":1,\"410\":1,\"413\":1,\"425\":1,\"427\":2,\"430\":1,\"434\":1,\"440\":1,\"446\":1,\"455\":2,\"459\":1,\"467\":2,\"472\":4,\"476\":1,\"478\":6,\"481\":1,\"487\":1,\"489\":1,\"494\":3,\"495\":1,\"504\":2,\"508\":1,\"509\":3}}],[\"java菜鸟\",{\"1\":{\"0\":1}}],[\"juc常见并发容器\",{\"0\":{\"410\":1}}],[\"jmm确保所有线程看到这个变量的值是一致的\",{\"1\":{\"362\":1}}],[\"jmm和java的并发编程有关\",{\"1\":{\"357\":1}}],[\"jmm是java定义的并发编程相关的一组规范\",{\"1\":{\"355\":1}}],[\"jit完成一次编译之后\",{\"1\":{\"276\":1}}],[\"jre是java运行时环境\",{\"1\":{\"275\":1}}],[\"jre\",{\"0\":{\"275\":1},\"1\":{\"494\":1}}],[\"jvm重要参数\",{\"0\":{\"500\":1}}],[\"jvm检查两个java类是否相同的依据\",{\"1\":{\"497\":1}}],[\"jvm中内置了三个classloader\",{\"1\":{\"494\":1}}],[\"jvm中对象的创建\",{\"0\":{\"431\":1}}],[\"jvm垃圾回收\",{\"0\":{\"441\":1}}],[\"jvm内存结构\",{\"0\":{\"420\":1}}],[\"jvm可以对这两个操作进行重排序\",{\"1\":{\"359\":1}}],[\"jvm能理解的代码就是字节码\",{\"1\":{\"276\":1}}],[\"jvm是java虚拟机\",{\"1\":{\"275\":1}}],[\"jvm\",{\"0\":{\"275\":1,\"340\":1,\"520\":1},\"1\":{\"361\":1,\"372\":1,\"377\":1,\"428\":1,\"430\":1,\"453\":1,\"472\":1,\"489\":1,\"493\":1,\"494\":2,\"506\":1,\"508\":3,\"509\":3}}],[\"jdk8\",{\"1\":{\"489\":1}}],[\"jdk8中的源码\",{\"1\":{\"304\":1}}],[\"jdk代理需要实现接口的类才能作为目标对象\",{\"1\":{\"324\":1}}],[\"jdk动态代理的效率要更好\",{\"1\":{\"325\":1}}],[\"jdk动态代理需要目标类实现接口或直接代理接口\",{\"1\":{\"325\":1}}],[\"jdk动态代理和cglib动态代理的区别\",{\"0\":{\"325\":1}}],[\"jdk动态代理\",{\"0\":{\"323\":1},\"1\":{\"316\":1,\"322\":1}}],[\"jdk是功能齐全的sdk\",{\"1\":{\"275\":1}}],[\"jdk\",{\"0\":{\"272\":2,\"275\":1},\"1\":{\"272\":1,\"368\":1,\"410\":2,\"428\":2,\"487\":1,\"490\":1,\"494\":1,\"496\":1,\"504\":2}}],[\"jdk1\",{\"0\":{\"267\":1,\"268\":1},\"1\":{\"5\":1,\"219\":1,\"251\":4,\"253\":1,\"255\":1,\"259\":2,\"260\":1,\"264\":1,\"267\":2,\"268\":1,\"270\":2,\"271\":5,\"272\":5,\"382\":1,\"398\":1,\"430\":2,\"454\":3,\"463\":1,\"464\":1,\"504\":1}}],[\"j指向左右孩子中大的那个\",{\"1\":{\"260\":1}}],[\"j<=high\",{\"1\":{\"260\":1}}],[\"j\",{\"1\":{\"260\":10}}],[\"join操作\",{\"1\":{\"119\":1}}],[\"join\",{\"1\":{\"108\":3}}],[\"线程本地分配缓存\",{\"1\":{\"513\":1}}],[\"线程本地分配缓冲区\",{\"1\":{\"433\":1}}],[\"线程执行的\",{\"1\":{\"467\":1}}],[\"线程开始对未标记的区域做清扫\",{\"1\":{\"466\":1}}],[\"线程无法保证可达性分析的实时性\",{\"1\":{\"466\":1}}],[\"线程的消亡而消亡\",{\"1\":{\"423\":1}}],[\"线程的生命周期和状态\",{\"0\":{\"344\":1}}],[\"线程尝试释放许可证\",{\"1\":{\"407\":1}}],[\"线程尝试获取许可证\",{\"1\":{\"407\":1}}],[\"线程等待队列\",{\"1\":{\"405\":1}}],[\"线程工厂\",{\"1\":{\"388\":1}}],[\"线程池处理任务的流程了解吗\",{\"0\":{\"391\":1}}],[\"线程池中常用的阻塞队列有哪些\",{\"0\":{\"390\":1}}],[\"线程池中的线程数量大于\",{\"1\":{\"388\":1}}],[\"线程池中若有空闲线程\",{\"1\":{\"387\":1}}],[\"线程池的饱和策略有哪些\",{\"0\":{\"389\":1}}],[\"线程池的最大线程数\",{\"1\":{\"388\":1}}],[\"线程池的核心线程数量\",{\"1\":{\"388\":1}}],[\"线程池的主要参数\",{\"0\":{\"388\":1}}],[\"线程池的线程数量不确定\",{\"1\":{\"387\":1}}],[\"线程池是管理一系列线程的资源池\",{\"1\":{\"385\":1}}],[\"线程池\",{\"0\":{\"384\":1}}],[\"线程启动规则\",{\"1\":{\"359\":1}}],[\"线程会自动苏醒\",{\"1\":{\"349\":1}}],[\"线程不会自动苏醒\",{\"1\":{\"349\":1}}],[\"线程不安全法\",{\"1\":{\"328\":1}}],[\"线程不安全\",{\"1\":{\"254\":1}}],[\"线程调用了start\",{\"1\":{\"344\":1}}],[\"线程已经创建但是没有调用start\",{\"1\":{\"344\":1}}],[\"线程共有的\",{\"0\":{\"426\":1}}],[\"线程共有\",{\"1\":{\"339\":1}}],[\"线程是否安全\",{\"1\":{\"264\":1}}],[\"线程安全的\",{\"1\":{\"410\":2}}],[\"线程安全法\",{\"1\":{\"328\":1}}],[\"线程安全实现方式\",{\"1\":{\"272\":2}}],[\"线程安全\",{\"0\":{\"331\":1},\"1\":{\"254\":1,\"303\":1,\"328\":1,\"332\":1,\"333\":1}}],[\"线程上下文切换等问题\",{\"1\":{\"195\":1}}],[\"线程数\",{\"1\":{\"172\":1}}],[\"线程模式后面会详细介绍到\",{\"1\":{\"171\":1}}],[\"线程读取\",{\"1\":{\"113\":1}}],[\"线程将接收的\",{\"1\":{\"113\":1}}],[\"线程负责接收\",{\"1\":{\"113\":1}}],[\"线程来发送\",{\"1\":{\"113\":1}}],[\"线程向主库请求更新的\",{\"1\":{\"113\":1}}],[\"线程首先发起select调用\",{\"1\":{\"22\":1}}],[\"线程依然是阻塞的\",{\"1\":{\"22\":1}}],[\"线程间的同步的方式有哪些\",{\"0\":{\"7\":1}}],[\"线程更加轻量\",{\"1\":{\"6\":1}}],[\"线程私有的\",{\"0\":{\"422\":1}}],[\"线程私有\",{\"1\":{\"5\":1,\"279\":2,\"423\":1}}],[\"线程又称为轻量级进程\",{\"1\":{\"5\":1,\"339\":1}}],[\"线程\",{\"0\":{\"339\":1},\"1\":{\"5\":1}}],[\"当父类加载器无法加载时\",{\"1\":{\"497\":1}}],[\"当父类的加载器为空\",{\"1\":{\"497\":1}}],[\"当父类的加载器不为空\",{\"1\":{\"497\":1}}],[\"当遇到new\",{\"1\":{\"489\":1}}],[\"当需要调用一个类的方法的时候\",{\"1\":{\"488\":1}}],[\"当程序执行方法的时候\",{\"1\":{\"488\":1}}],[\"当这一块的内存使用完后\",{\"1\":{\"458\":1}}],[\"当垃圾回收器准备回收一个对象时\",{\"1\":{\"453\":1}}],[\"当累积的某个年龄大小超过了\",{\"1\":{\"445\":1}}],[\"当它的年龄增加到一定程度\",{\"1\":{\"445\":1}}],[\"当对象大于tlab剩余空内存或者tlab内存耗尽的时候\",{\"1\":{\"433\":1}}],[\"当常量池无法再申请到内存时会抛出\",{\"1\":{\"429\":1}}],[\"当队列容量满时\",{\"1\":{\"415\":1}}],[\"当count值为0则会将被阻塞的线程唤醒\",{\"1\":{\"409\":1}}],[\"当cpu写数据时\",{\"1\":{\"362\":1}}],[\"当调用\",{\"1\":{\"408\":1}}],[\"当获取锁失败的时候线程不会立马阻塞\",{\"1\":{\"398\":1}}],[\"当线程使用\",{\"1\":{\"408\":1}}],[\"当线程数大于核心线程数时\",{\"1\":{\"388\":1}}],[\"当线程切换回来的时候能够知道上次运行到哪里了\",{\"1\":{\"341\":1}}],[\"当有一个新的任务提交时\",{\"1\":{\"387\":1}}],[\"当有任务要处理时\",{\"1\":{\"385\":1}}],[\"当使用该方法时\",{\"1\":{\"331\":1}}],[\"当使用到联合索引时\",{\"1\":{\"108\":1}}],[\"当代理类调用方法的时候\",{\"1\":{\"324\":1}}],[\"当前活跃对象+需要晋升的对象\",{\"1\":{\"514\":1}}],[\"当前类\",{\"0\":{\"478\":1},\"1\":{\"478\":1}}],[\"当前虚拟机的垃圾收集都采用分代收集算法\",{\"1\":{\"459\":1}}],[\"当前节点在队列中的状态\",{\"1\":{\"405\":1}}],[\"当前可以同时运行的线程数量变为最大线程数\",{\"1\":{\"388\":1}}],[\"当前method方法的参数\",{\"1\":{\"323\":1}}],[\"当前读\",{\"1\":{\"106\":1,\"156\":1,\"159\":1}}],[\"当你使用代理对象调用方法的时候实际会调用到这个方法\",{\"1\":{\"323\":1}}],[\"当单个链表的长度大于8\",{\"1\":{\"268\":1}}],[\"当元素个数超过负载因子\",{\"1\":{\"264\":1}}],[\"当真正对数组进行添加元素操作时\",{\"1\":{\"253\":1}}],[\"当链表长度大于阈值\",{\"1\":{\"251\":1}}],[\"当子进程完成创建新\",{\"1\":{\"244\":1}}],[\"当aof变得太大时\",{\"1\":{\"244\":1}}],[\"当redis重启时\",{\"1\":{\"241\":1}}],[\"当redis实例故障之后\",{\"1\":{\"238\":1}}],[\"当该锁被释放之后\",{\"1\":{\"210\":1}}],[\"当内存不足以容纳新写入数据时\",{\"1\":{\"201\":2}}],[\"当执行当前读时\",{\"1\":{\"166\":1}}],[\"当读取记录时\",{\"1\":{\"163\":1}}],[\"当事务回滚时用于将数据恢复到修改前的样子\",{\"1\":{\"163\":1}}],[\"当用户再次启动数据库的时候\",{\"1\":{\"153\":1}}],[\"当操作涉及跨多个共享变量时\",{\"1\":{\"368\":1}}],[\"当操作符左右两边的数据类型不一致时\",{\"1\":{\"143\":1}}],[\"当操作系统创建一个新进程时\",{\"1\":{\"8\":1}}],[\"当操作系统接收到进程的系统调用请求时\",{\"1\":{\"3\":1}}],[\"当没有显示的指定表的主键时\",{\"1\":{\"128\":1}}],[\"当二叉查找树不平衡时\",{\"1\":{\"124\":1}}],[\"当二叉查找树是平衡的时候\",{\"1\":{\"124\":1}}],[\"当堆表中的数据进行增删改的时候\",{\"1\":{\"121\":1}}],[\"当查询条件使用了多个索引时\",{\"1\":{\"108\":1}}],[\"当连表查询时\",{\"1\":{\"108\":1}}],[\"当然是使用对象的操作而不是线程的操作\",{\"1\":{\"350\":1}}],[\"当然学号属性取值是唯一的\",{\"1\":{\"84\":1}}],[\"当然也可以不遵循这种约定\",{\"1\":{\"40\":1}}],[\"当一个接口中定义了\",{\"1\":{\"489\":1}}],[\"当一个对象到\",{\"1\":{\"450\":1}}],[\"当一个方法要调用其他方法\",{\"1\":{\"424\":1}}],[\"当一个线程对共享变量进行修改\",{\"1\":{\"360\":1}}],[\"当一个线程到达屏障时\",{\"1\":{\"7\":1}}],[\"当一个节点对应的客户端释放锁之后\",{\"1\":{\"211\":1}}],[\"当一台设备更换了网络\",{\"1\":{\"78\":1}}],[\"当网络设备发送ip数据包时\",{\"1\":{\"74\":1}}],[\"当网络拥塞时\",{\"1\":{\"64\":1}}],[\"当接收方来不及处理发送方的数据\",{\"1\":{\"64\":1}}],[\"当发送方发送数据之后\",{\"1\":{\"64\":1}}],[\"当主机发出\",{\"1\":{\"50\":1}}],[\"当301\",{\"1\":{\"44\":1}}],[\"当我们使用浏览器浏览网页的时候\",{\"1\":{\"37\":1,\"56\":1}}],[\"当后台处理完成\",{\"1\":{\"23\":1}}],[\"当客户端数据到了之后才会为其服务\",{\"1\":{\"22\":1}}],[\"当应用程序发起\",{\"1\":{\"18\":1}}],[\"当应用程序需要执行某些特权指令的时候就会发生系统调用\",{\"1\":{\"3\":1}}],[\"当采用固定比例比如\",{\"1\":{\"12\":1}}],[\"当进程执行时\",{\"1\":{\"8\":1}}],[\"当\",{\"1\":{\"3\":1,\"143\":2,\"184\":2,\"246\":1,\"408\":1,\"412\":1,\"443\":1}}],[\"当外围设备完成用户请求操作之后\",{\"1\":{\"3\":1}}],[\"内部的核心类库\",{\"1\":{\"494\":1}}],[\"内部通过链表\",{\"1\":{\"410\":1}}],[\"内部通过一个\",{\"1\":{\"409\":1}}],[\"内部采用的是\",{\"1\":{\"390\":1}}],[\"内部方法使用synchronized修饰\",{\"1\":{\"264\":1}}],[\"内部都是通过linkedhashmap实现\",{\"1\":{\"251\":1}}],[\"内部实现也差不多\",{\"1\":{\"219\":1}}],[\"内部内存碎片\",{\"1\":{\"12\":1}}],[\"内置了多种优化过后的数据结构实现\",{\"1\":{\"171\":1}}],[\"内置了多种数据类型实现\",{\"1\":{\"170\":1}}],[\"内容写入\",{\"1\":{\"146\":1}}],[\"内未收到确认消息\",{\"1\":{\"64\":1}}],[\"内\",{\"1\":{\"39\":1}}],[\"内核将数据从内核空间拷贝到用户空间\",{\"1\":{\"18\":1}}],[\"内核等待\",{\"1\":{\"18\":1}}],[\"内核态运行的进程集合可以访问计算机的任何资源\",{\"1\":{\"3\":1}}],[\"内核态\",{\"1\":{\"3\":1}}],[\"内存占用是非常高的\",{\"1\":{\"467\":1}}],[\"内存足够不会回收\",{\"1\":{\"453\":1}}],[\"内存分配和回收原则\",{\"0\":{\"442\":1}}],[\"内存分配完成后\",{\"1\":{\"434\":1}}],[\"内存对齐存放\",{\"1\":{\"437\":1}}],[\"内存屏障通常有三种\",{\"1\":{\"362\":1}}],[\"内存不足操作\",{\"1\":{\"172\":1}}],[\"内存的分配方式有\",{\"1\":{\"433\":1}}],[\"内存的分配和管理\",{\"1\":{\"2\":1}}],[\"内存的访问速度是磁盘的上千倍\",{\"1\":{\"171\":1}}],[\"内存数据库\",{\"1\":{\"170\":1}}],[\"内存管理\",{\"0\":{\"11\":1}}],[\"内存空间\",{\"1\":{\"8\":1}}],[\"以cms为例\",{\"1\":{\"515\":1}}],[\"以避免收缩\",{\"1\":{\"509\":1}}],[\"以后可以用来查找泄漏\",{\"1\":{\"508\":1}}],[\"以后由数组+链表\",{\"1\":{\"251\":1}}],[\"以便在内存不足的情况下执行\",{\"1\":{\"508\":1}}],[\"以便让应用程序自己决定如何去获取所需的类\",{\"1\":{\"494\":1}}],[\"以便它们可以跨网络传播并到达正确的目的地\",{\"1\":{\"39\":1,\"73\":1}}],[\"以保证其描述的信息符合\",{\"1\":{\"486\":1}}],[\"以用于描述某些场景专有的信息\",{\"1\":{\"481\":1}}],[\"以极高概率满足\",{\"1\":{\"467\":1}}],[\"以减少加锁和解锁的次数\",{\"1\":{\"400\":1}}],[\"以一种易于理解和解析的格式包含所有操作的日志\",{\"1\":{\"246\":1}}],[\"以一定频率刷入磁盘\",{\"1\":{\"148\":1}}],[\"以判断文件是否完整\",{\"1\":{\"245\":1}}],[\"以此减少查找时间\",{\"1\":{\"268\":1}}],[\"以此来完成\",{\"1\":{\"244\":1}}],[\"以此实现非锁定读\",{\"1\":{\"163\":1}}],[\"以及被\",{\"1\":{\"494\":1}}],[\"以及以前的版本中与\",{\"1\":{\"464\":1}}],[\"以及\",{\"1\":{\"179\":1,\"229\":1}}],[\"以及设备启动等功能\",{\"1\":{\"2\":1}}],[\"以update语句为例\",{\"1\":{\"152\":1}}],[\"以基本的事务为单位\",{\"1\":{\"152\":1}}],[\"以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果\",{\"1\":{\"143\":1}}],[\"以\",{\"1\":{\"143\":1,\"206\":1}}],[\"以下几种情况必须对类进行初始化\",{\"1\":{\"489\":1}}],[\"以下几种查询条件就能利用联合索引\",{\"1\":{\"136\":1}}],[\"以下字段适合创建索引\",{\"1\":{\"139\":1}}],[\"以太网地址等\",{\"1\":{\"78\":1}}],[\"以外\",{\"1\":{\"39\":1}}],[\"以至于不能满足任意进程所需要的内存分配请求\",{\"1\":{\"12\":1}}],[\"以防止非法用户对系统资源的访问和操作\",{\"1\":{\"2\":1}}],[\"以提供高效可靠的网络服务\",{\"1\":{\"2\":1}}],[\"网站\",{\"1\":{\"187\":1,\"224\":1}}],[\"网站用于记录学习笔记\",{\"1\":{\"0\":1}}],[\"网际协议\",{\"1\":{\"39\":1,\"73\":1}}],[\"网络设备根据目的\",{\"1\":{\"74\":1}}],[\"网络地址转换\",{\"1\":{\"39\":1,\"75\":1,\"76\":1}}],[\"网络地址转换协议\",{\"1\":{\"39\":1}}],[\"网络层\",{\"0\":{\"39\":1,\"72\":1}}],[\"网络是计算机系统中连接不同计算机的方式\",{\"1\":{\"2\":1}}],[\"网络管理\",{\"1\":{\"2\":1}}],[\"的参数\",{\"1\":{\"509\":1}}],[\"的同步策略\",{\"1\":{\"509\":1}}],[\"的实例来减少不必要的内存使用\",{\"1\":{\"509\":1}}],[\"的实现类\",{\"1\":{\"395\":1}}],[\"的实现为一个\",{\"1\":{\"216\":1}}],[\"的实现\",{\"0\":{\"160\":1},\"1\":{\"446\":1}}],[\"的实现依赖于\",{\"1\":{\"153\":1,\"160\":1}}],[\"的最大大小\",{\"1\":{\"504\":1}}],[\"的最大线程数是\",{\"1\":{\"390\":1}}],[\"的fgc阈值\",{\"1\":{\"504\":1}}],[\"的永久代\",{\"1\":{\"504\":1}}],[\"的大小\",{\"1\":{\"504\":1}}],[\"的大版本号\",{\"1\":{\"475\":1}}],[\"的全部要求\",{\"1\":{\"486\":1}}],[\"的全称为\",{\"1\":{\"403\":1}}],[\"的全称是\",{\"1\":{\"366\":1}}],[\"的访问标记\",{\"1\":{\"477\":1}}],[\"的常量值等\",{\"1\":{\"476\":1}}],[\"的常见应用场景如下\",{\"1\":{\"182\":1,\"187\":1}}],[\"的小版本号\",{\"1\":{\"475\":1}}],[\"的文件\",{\"1\":{\"472\":1}}],[\"的由来\",{\"1\":{\"467\":1}}],[\"的另一个大优势\",{\"1\":{\"467\":1}}],[\"的条件则相对苛刻许多\",{\"1\":{\"455\":1}}],[\"的对象\",{\"0\":{\"451\":1}}],[\"的对象作为起点\",{\"1\":{\"450\":1}}],[\"的映射关系\",{\"1\":{\"430\":1}}],[\"的映射表\",{\"1\":{\"219\":1}}],[\"的内置类加载器本身没有父类加载器\",{\"1\":{\"496\":1}}],[\"的内存\",{\"1\":{\"423\":1}}],[\"的内部元素并不是按照放入的时间排序\",{\"1\":{\"390\":1}}],[\"的线程安全版本\",{\"1\":{\"417\":1}}],[\"的特性\",{\"1\":{\"416\":1}}],[\"的初始值为\",{\"1\":{\"409\":1}}],[\"的操作来减少\",{\"1\":{\"408\":1}}],[\"的使用简单\",{\"1\":{\"407\":1}}],[\"的这些缺陷\",{\"1\":{\"396\":1}}],[\"的记录\",{\"1\":{\"383\":1}}],[\"的弱引用\",{\"1\":{\"383\":1}}],[\"的原子指令\",{\"1\":{\"366\":1}}],[\"的原生字符串\",{\"1\":{\"213\":1}}],[\"的思想很简单\",{\"1\":{\"366\":1}}],[\"的方法会执行线程的准备工作\",{\"1\":{\"351\":1}}],[\"的引用保存在字符串常量池中\",{\"1\":{\"307\":1}}],[\"的引用\",{\"1\":{\"306\":2}}],[\"的相应类型的缓存数据\",{\"1\":{\"280\":1}}],[\"的概念\",{\"1\":{\"271\":1}}],[\"的形式\",{\"1\":{\"271\":1}}],[\"的底层数据结构类似都是采用\",{\"1\":{\"271\":1}}],[\"的底层实现\",{\"0\":{\"266\":1}}],[\"的底层实现是什么\",{\"0\":{\"184\":1}}],[\"的幂次方\",{\"0\":{\"269\":1}}],[\"的幂次方进行内存分配时\",{\"1\":{\"12\":1}}],[\"的升序排序\",{\"1\":{\"265\":1}}],[\"的主体\",{\"1\":{\"251\":2,\"271\":1}}],[\"的数字来验证\",{\"1\":{\"245\":1}}],[\"的数据结构\",{\"1\":{\"390\":1}}],[\"的数据结构经常被用在各种排行榜的场景\",{\"1\":{\"186\":1}}],[\"的数据安全性不如\",{\"1\":{\"246\":1}}],[\"的数据是存在内存中的\",{\"1\":{\"170\":1}}],[\"的数据版本均可见\",{\"1\":{\"162\":1}}],[\"的数据版本均不可见\",{\"1\":{\"162\":1}}],[\"的数据传输服务\",{\"1\":{\"38\":2}}],[\"的计数场景\",{\"1\":{\"233\":1}}],[\"的计数结果并不是一个精确值\",{\"1\":{\"231\":1}}],[\"的空间大小更大\",{\"1\":{\"509\":1}}],[\"的空间\",{\"1\":{\"231\":1}}],[\"的空间就能存储接近2^64个不同元素\",{\"1\":{\"231\":1}}],[\"的存储结构做了优化\",{\"1\":{\"231\":1}}],[\"的存在\",{\"1\":{\"104\":1}}],[\"的场景\",{\"1\":{\"230\":1}}],[\"的范围来获取元素的列表\",{\"1\":{\"225\":1}}],[\"的元素个数\",{\"1\":{\"229\":1}}],[\"的元素\",{\"1\":{\"217\":1}}],[\"的分布式可重入锁\",{\"1\":{\"206\":1}}],[\"的分配和管理等\",{\"1\":{\"2\":1}}],[\"的值理解为许可证的数量\",{\"1\":{\"407\":1}}],[\"的值\",{\"1\":{\"204\":1,\"214\":5,\"407\":3}}],[\"的值确定的情况下\",{\"1\":{\"84\":1}}],[\"的多线程只是在网络数据的读写上使用\",{\"1\":{\"196\":1}}],[\"的唯一计数\",{\"1\":{\"190\":1,\"232\":1}}],[\"的长度为什么是\",{\"0\":{\"269\":1}}],[\"的长度获取直接读取\",{\"1\":{\"184\":1}}],[\"的长度限制\",{\"1\":{\"40\":1}}],[\"的一半\",{\"1\":{\"183\":1}}],[\"的一种特例\",{\"1\":{\"108\":1}}],[\"的缓存\",{\"1\":{\"182\":1}}],[\"的应用场景是什么\",{\"0\":{\"187\":1}}],[\"的应用场景有哪些\",{\"0\":{\"182\":1}}],[\"的应用层协议\",{\"1\":{\"40\":1}}],[\"的写性能非常高\",{\"1\":{\"177\":1}}],[\"的读写\",{\"1\":{\"177\":1}}],[\"的问题\",{\"1\":{\"176\":1}}],[\"的情况\",{\"1\":{\"173\":1}}],[\"的差异\",{\"0\":{\"164\":1}}],[\"的事务\",{\"1\":{\"162\":1}}],[\"的结合体\",{\"1\":{\"225\":1}}],[\"的结合\",{\"1\":{\"156\":1}}],[\"的隔离级别\",{\"1\":{\"156\":1}}],[\"的时间复杂度内插入和删除元素\",{\"1\":{\"260\":1}}],[\"的时间内收到了\",{\"1\":{\"62\":1}}],[\"的时机却不同\",{\"1\":{\"164\":1}}],[\"的时候\",{\"1\":{\"146\":3,\"271\":1,\"388\":1,\"504\":1}}],[\"的刷盘策略提供了\",{\"1\":{\"146\":1}}],[\"的前后条件中有一个列没有索引\",{\"1\":{\"143\":1}}],[\"的自增主键\",{\"1\":{\"128\":1}}],[\"的表中\",{\"1\":{\"128\":1}}],[\"的性能更高\",{\"1\":{\"102\":1}}],[\"的要求\",{\"1\":{\"85\":1}}],[\"的不同的属性子集\",{\"1\":{\"84\":1}}],[\"的优势还包括\",{\"1\":{\"75\":1}}],[\"的拥塞控制是怎么实现的\",{\"0\":{\"66\":1}}],[\"的接收端只允许发送端发送接收端缓冲区能接纳的数据\",{\"1\":{\"64\":1}}],[\"的话\",{\"1\":{\"62\":1,\"177\":1,\"407\":2,\"408\":1}}],[\"的缩写\",{\"1\":{\"56\":1,\"87\":1}}],[\"的协议有哪些\",{\"0\":{\"56\":2}}],[\"的传输效率要比\",{\"1\":{\"53\":1}}],[\"的作用是什么\",{\"0\":{\"49\":1}}],[\"的区别主要体现在实现线程安全的方式上不同\",{\"1\":{\"271\":1}}],[\"的区别在于元素出队顺序是与优先级相关的\",{\"1\":{\"260\":1}}],[\"的区别和共同点\",{\"0\":{\"172\":1}}],[\"的区别\",{\"0\":{\"47\":1,\"53\":1,\"259\":1,\"264\":1,\"271\":1,\"277\":1,\"303\":1,\"351\":1}}],[\"的路由选择协议\",{\"1\":{\"39\":1}}],[\"的\",{\"0\":{\"272\":1},\"1\":{\"38\":2,\"45\":2,\"55\":1,\"108\":1,\"128\":1,\"177\":1,\"184\":1,\"213\":2,\"216\":1,\"219\":1,\"235\":1,\"246\":1,\"271\":1,\"383\":1,\"390\":1,\"395\":1,\"403\":1,\"407\":1,\"408\":1,\"467\":1}}],[\"的非常安全的网络传输协议的主要原因\",{\"1\":{\"37\":1,\"56\":1}}],[\"的改进版\",{\"1\":{\"23\":1}}],[\"的执行是由操作系统的内核来完成的\",{\"1\":{\"18\":1}}],[\"的网络通信的基本操作单元\",{\"1\":{\"9\":1}}],[\"的请求或释放\",{\"1\":{\"2\":1}}],[\"写完之后\",{\"1\":{\"412\":1}}],[\"写屏障\",{\"1\":{\"362\":1}}],[\"写出rdb文件都比较耗时\",{\"1\":{\"238\":1}}],[\"写操作频繁的话会导致cache中数据频繁被删除\",{\"1\":{\"175\":1}}],[\"写入也不会阻塞读取操作\",{\"1\":{\"411\":1}}],[\"写入\",{\"1\":{\"175\":1}}],[\"写入binlog时发生异常也不会有影响\",{\"1\":{\"152\":1}}],[\"写入时机\",{\"0\":{\"151\":1}}],[\"写入到\",{\"1\":{\"113\":1,\"176\":1}}],[\"写到末尾又回到头循环写\",{\"1\":{\"147\":1}}],[\"写写互斥\",{\"1\":{\"104\":1}}],[\"写作x\",{\"1\":{\"84\":1}}],[\"写\",{\"1\":{\"2\":1,\"175\":1,\"176\":1}}],[\"唤醒等待线程\",{\"1\":{\"211\":1}}],[\"唤醒\",{\"1\":{\"2\":1}}],[\"阻塞状态\",{\"1\":{\"344\":1}}],[\"阻塞队列可以通过加锁来实现\",{\"1\":{\"413\":1}}],[\"阻塞队列\",{\"1\":{\"261\":1,\"414\":1}}],[\"阻塞等\",{\"1\":{\"8\":1}}],[\"阻塞\",{\"1\":{\"2\":1,\"148\":1}}],[\"撤销\",{\"1\":{\"2\":1}}],[\"希望能对学java的大家提供一点帮助\",{\"1\":{\"0\":1}}],[\"秋招信息\",{\"1\":{\"0\":1}}],[\"摄影爱好者\",{\"1\":{\"0\":1}}],[\"摸鱼王者\",{\"1\":{\"0\":1}}],[\"杭州某电计算机专业研二学生\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,xt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(ot(t,D[s],n)):e==="search"?self.postMessage(nt(t,D[s],n)):self.postMessage({suggestions:ot(t,D[s],n),results:nt(t,D[s],n)})};
//# sourceMappingURL=index.js.map
