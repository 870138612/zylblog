const d=(o,a)=>{const i=o.toLowerCase(),e=a.toLowerCase(),s=[];let n=0,l=0;const c=(t,p=!1)=>{let r="";l===0?r=t.length>20?`… ${t.slice(-20)}`:t:p?r=t.length+l>100?`${t.slice(0,100-l)}… `:t:r=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,r&&s.push(r),l+=r.length,p||(s.push(["strong",a]),l+=a.length,l>=100&&s.push(" …"))};let h=i.indexOf(e,n);if(h===-1)return null;for(;h>=0;){const t=h+e.length;if(c(o.slice(n,h)),n=t,l>100)break;h=i.indexOf(e,n)}return l<100&&c(o.slice(n),!0),s},g=Object.entries,y=Object.keys,f=o=>o.reduce((a,{type:i})=>a+(i==="title"?50:i==="heading"?20:i==="custom"?10:1),0),$=(o,a)=>{var i;const e={};for(const[s,n]of g(a)){const l=((i=a[s.replace(/\/[^\\]*$/,"")])==null?void 0:i.title)||"",c=`${l?`${l} > `:""}${n.title}`,h=d(n.title,o);h&&(e[c]=[...e[c]||[],{type:"title",path:s,display:h}]),n.customFields&&g(n.customFields).forEach(([t,p])=>{p.forEach(r=>{const u=d(r,o);u&&(e[c]=[...e[c]||[],{type:"custom",path:s,index:t,display:u}])})});for(const t of n.contents){const p=d(t.header,o);p&&(e[c]=[...e[c]||[],{type:"heading",path:s+(t.slug?`#${t.slug}`:""),display:p}]);for(const r of t.contents){const u=d(r,o);u&&(e[c]=[...e[c]||[],{type:"content",header:t.header,path:s+(t.slug?`#${t.slug}`:""),display:u}])}}}return y(e).sort((s,n)=>f(e[s])-f(e[n])).map(s=>({title:s,contents:e[s]}))},m=JSON.parse("{\"/\":{\"/intro.html\":{\"title\":\"关于我\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"杭州某电专计算机专业研二学生\",\"科研狗混子，摸鱼王者，摄影爱好者\",\"网站基于开源项目vuepress-theme-hope\",\"图片采用腾讯对象存储\"]}]},\"/database/\":{\"title\":\"数据库\",\"contents\":[]},\"/framework/\":{\"title\":\"框架\",\"contents\":[]},\"/home/\":{\"title\":\"欢迎\",\"contents\":[]},\"/java/\":{\"title\":\"Java\",\"contents\":[]},\"/middleware/\":{\"title\":\"中间件\",\"contents\":[]},\"/photo/99%E5%B9%B3%E6%BD%AD.html\":{\"title\":\"平潭四月\",\"contents\":[{\"header\":\"2023年四月\",\"slug\":\"_2023年四月\",\"contents\":[\" 去年八月去平潭看海，大太阳晒的掉皮，不过风景是真滴好看 对于特别喜欢看海的人不会放过每一次机会，于是今年四月我又来平潭了。\",\" ⭐猴研岛，68海里景区，大风下的猴研岛\",\" ⭐去北线的路上，照片裁成宽幅，挺有回忆的感觉，偶遇安徽老乡\",\" ⭐仙人井景区，后面的天气稍微好了一点，不过还是很大的风\",\" ⭐环岛路旁随便一拍都很好看\",\" ⭐长江澳风车田，看着大海就很爽\",\" ⭐北部湾生态长廊落日\",\" ⭐有新人在拍婚纱照\",\" ⭐晚霞映在海面上\",\"☀️下次还来！\"]}]},\"/photo/\":{\"title\":\"拍拍\",\"contents\":[]},\"/java/1java/1java.html\":{\"title\":\"Java基础面试题一\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"梦开始的地方\",\"一切就从这里开始吧\"]},{\"header\":\"JVM JRE JDK\",\"slug\":\"jvm-jre-jdk\",\"contents\":[\"JVM是java虚拟机，针对不同系统有不同的实现，常用的为HotSpot VM。\",\"JDK是功能齐全的SDK，包含JRE和一些其他的工具，例如javac，java等。\",\"JRE是Java运行时环境，仅包含Java应用程序运行时的必要环境。\"]},{\"header\":\"什么是字节码？采用字节码的好处？\",\"slug\":\"什么是字节码-采用字节码的好处\",\"contents\":[\"JVM能理解的代码就是字节码，字节码解决了传统解释语言运行效率低的问题，还具有很好的可移植性，一次编译，任何地方运行。\",\".java文件经过javac编译之后变成.class文件，.class通过解释器和JIT（运行时编译器）编译成机器可以理解的代码，JIT完成一次编译之后，就会将对应的机器码保存下来，之后复用，其中编译的是热点代码。所以Java也是编译与解释共存的语言。\"]},{\"header\":\"Java 和 C++ 的区别\",\"slug\":\"java-和-c-的区别\",\"contents\":[\"Java和C++都是面向对象的语言，都支持封装继承多态。\",\"Java不支持通过指针来直接访问内存，程序内存更加安全。\",\"Java的类是单继承的，C++支持多继承。\",\"Java有自动的垃圾回收机制，不需要手动释放内存。\"]},{\"header\":\"基本数据类型\",\"slug\":\"基本数据类型\",\"contents\":[\"Java有8种基本数据类型\",\"6种数字类型 \",\"4种整数类型：byte、short、int、long\",\"2种浮点数类型：float、double\",\"1种字符类型：char\",\"1种布尔类型：boolean\"]},{\"header\":\"基本类型和包装类型\",\"slug\":\"基本类型和包装类型\",\"contents\":[\"包装类型能用于泛型，而基本类型不可以。\",\"基本数据类型的局部变量存放在Java虚拟机栈中的局部变量表中（线程私有），基本数据类型的成员变量没有被static修饰的话放在堆中。而包装类型属于对象类型。\",\"包装类型占用的空间比基本类型要大。\",\"成员包装类型不赋值就是null，而基本类型有默认值并且不是null\",\"基本数据类型使用==进行比较，而包装类型通过equals()进行比较\",\"在HotSpot虚拟机中引入JIT优化之后，会对对象进行逃逸分析，如果对象的作用范围没有超过当前方法，则可能通过标量替换来实现栈（线程私有）上分配，避免堆上分配对象。\"]},{\"header\":\"包装类的缓存机制\",\"slug\":\"包装类的缓存机制\",\"contents\":[\"Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，8位补码的表示范围。\",\"Character创建了 [0，127] 范围的缓存数据，7位无符号数的表示范围，Boolean直接返回True或者是False。\"]},{\"header\":\"自动拆装箱\",\"slug\":\"自动拆装箱\",\"contents\":[\"装箱就是使用包装类的valueOf方法，拆箱就是使用xxValue方法。\",\"Integer i=10等价于Integer i = Integer.valueOf(10)\",\"int n = i 等价于int n = i.intValue()\"]},{\"header\":\"浮点数运算的时候会有精度丢失的风险？\",\"slug\":\"浮点数运算的时候会有精度丢失的风险\",\"contents\":[\"计算机组成原理第二章浮点加减法\"]},{\"header\":\"如何解决浮点数运算的时候精度丢失问题？\",\"slug\":\"如何解决浮点数运算的时候精度丢失问题\",\"contents\":[\"使用BigDecimal类进行浮点数运算，不会造成精度丢失问题\"]},{\"header\":\"超过long 64位补码的范围数字应该如何表示？\",\"slug\":\"超过long-64位补码的范围数字应该如何表示\",\"contents\":[\"通过BigInteger存储，BigInteger内部使用int[]存储任意大小的整型数据。\"]},{\"header\":\"变量\",\"slug\":\"变量\",\"contents\":[]},{\"header\":\"静态变量\",\"slug\":\"静态变量\",\"contents\":[\"静态变量就是被static修饰的变量，被static修饰的变量为类所共享的，无论创建了多少个类实例，这个变量都是共享的，只会分配一次内存，静态变量通过类名.进行访问。\",\"通常情况下被final修饰的static变量会成为常量。\"]},{\"header\":\"方法\",\"slug\":\"方法\",\"contents\":[]},{\"header\":\"静态方法为什么不能调用非静态成员？\",\"slug\":\"静态方法为什么不能调用非静态成员\",\"contents\":[\"静态方法属于类，在类加载的时候就会分配内存，通过类名直接访问，非静态方法属于实例对象，需要通过类的实例对象去调用。\",\"在类的非静态成员不存在的时候静态方法就已经存在，此时调用内存中不存在的非静态成员不合法。\"]},{\"header\":\"重载和重写\",\"slug\":\"重载和重写\",\"contents\":[\"重载就是对同一个方法根据输入的不同作出不同的方法处理。\",\"重写一般在子类继承父类，输入的数据一样，但是方法内的代码不同。\",\"重载\",\"重写\",\"重写发生在运行时，是子类对父类方法的实现过程重新编写\",\"方法名，参数列表必须相同，子类方法返回值类型比父类方法返回值类型更小或者是相等，子类抛出的异常应该小于或者等于父类，访问修饰符范围大于等于父类\",\"如果父类方法访问修饰符是private/final/static则子类不能重写方法，被static修饰的方法能被再次声明。\",\"构造方法无法被重写\",\"方法的重写要遵循“两同两小一大”\",\"“两同”即方法名相同、形参列表相同；\",\"“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；\",\"“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。\"]}]},\"/java/1java/2java.html\":{\"title\":\"Java基础面试题二\",\"contents\":[{\"header\":\"面向对象\",\"slug\":\"面向对象\",\"contents\":[]},{\"header\":\"面向对象和面向过程的区别\",\"slug\":\"面向对象和面向过程的区别\",\"contents\":[\"面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。\",\"面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。\",\"一个注重过程，一个注重内部属性。\"]},{\"header\":\"对象的相等和引用的相等\",\"slug\":\"对象的相等和引用的相等\",\"contents\":[\"对象的相等是是比较内存中存放的对象是否相等。\",\"引用相等是指向的内存地址是否相等。\",\"System.out.println(str1 == str2);//false详见后半部分String。\"]},{\"header\":\"如果没有声明构造方法，程序能正确执行吗？\",\"slug\":\"如果没有声明构造方法-程序能正确执行吗\",\"contents\":[\"如果类没有声明构造方法则会默认生成一个不带参数的构造方法。\",\"如果自己添加了构造方法无论是否有参数都不会再自动生成无参构造方法。\",\"构造方法不能被重写@Override，但是能重载（有参构造和无参构造）。\"]},{\"header\":\"面向对象的三个特征\",\"slug\":\"面向对象的三个特征\",\"contents\":[\"封装\",\"封装是将一个对象的状态信息隐藏在内部，不允许外部直接访问这些属性，但是会提供方法来操作属性。\",\"继承\",\"不同类型的对象可能会具有相似特点，例如游戏中的每一个英雄都有血量，移速等基础属性，但是每一个英雄的技能各有不同，则可以通过继承复用减少开发难度。\",\":::tags\",\"@tab:active HeroTemplate\",\"@tab Hero1\",\"@tab Hero2\",\":::\",\"子类拥有父类的所有属性和方法（包括私有属性和私有方法）。\",\"子类能对父类进行扩展。\",\"多态\",\"表示一个对象具有多种状态，上述代码中创建对象：\",\":::tags\",\"@tab:active HeroTemplate\",\"@tab Hero1\",\"@tab Hero2\",\":::\",\"对象类型和引用类型之间具有继承/实现关系；\",\"引用类型变量发出的方法调用到底是哪个类中的方法，在程序运行的时候才能确定；\",\"多态不能调用只在子类中存在，但是父类中不存在的方法，也就是hero能调用的方法是看父类Hero的，执行的结果看子类Hero1；\",\"如果子类重写了父类方法，则执行的是子类中的方法，如果没有重写则执行的是父类中的方法。\"]},{\"header\":\"接口和抽象类的共同点\",\"slug\":\"接口和抽象类的共同点\",\"contents\":[\"共同点\",\"都不能被实例化；\",\"都可以包含抽象方法；\",\"都可以有默认的实现方法（Java8可以用default关键字在接口中定义默认方法）。\",\"不同点\",\"接口强调行为的约束，实现某个接口就相当于有某个责任，必须实现对应的方法，继承则是强调复用，子类继承父类并不一定要重写父类方法；\",\"一个类只能extends一个类，但是能implements多个接口；\",\"接口中的成员变量只能是public static final类型，不能被修改而且必须有初始值，抽象类中的成员变量默认default，可以在子类中被重新定义，重新赋值。\"]},{\"header\":\"浅拷贝，深拷贝，引用拷贝\",\"slug\":\"浅拷贝-深拷贝-引用拷贝\",\"contents\":[\"浅拷贝\",\"在堆上创建一个新对象N，N对象中的内部对象是引用类型的话，会直接复制原本类O的内部对象引用地址；\",\"也就是新对象N内部对象和原来的对象O的内部对象是同一个。\",\"深拷贝\",\"不仅仅拷贝对象，将原本对象内部的所有属性都单独复制一份；\",\"新对象的内部引用对象不再是原来对象的内部引用对象。\",\"引用拷贝\",\"两个不同对象的引用指向同一个对象。\"]},{\"header\":\"Object\",\"slug\":\"object\",\"contents\":[]},{\"header\":\"==和equals区别\",\"slug\":\"和equals区别\",\"contents\":[\"对于基本类型来说==是比较值；\",\"对于引用类型来说==是比较地址。\",\"equals存在两种情况：\",\"类没有重写equals方法：则通过equals比较两个对象的时候等价于==；\",\"重写了equals方法：则是比较两个对象内部的属性是否相等。\",\"创建String类型的对象，虚拟机会在字符串常量池中查找有没有相同值的对象，如果有则直接返回这个对象的引用，如果没有就创建一个String对象。\"]},{\"header\":\"hashCode()作用\",\"slug\":\"hashcode-作用\",\"contents\":[\"hashCode()方法用来获哈希码，作用是确定在哈希表中的位置。\",\"hashCode()定义在Object类中，所以所有的对象都有这个方法。hashCode()是本地方法，也就是通过C或者是C++实现的。\",\"HashMap通过计算Hash值使得查找元素的时间复杂度为1，数据结构散列表。\"]},{\"header\":\"为什么重写 equals() 时必须重写 hashCode() 方法？\",\"slug\":\"为什么重写-equals-时必须重写-hashcode-方法\",\"contents\":[\"Java中如果两个对象相同则HashCode，必须相等；\",\"如果HashCode相同，则对象不一定相等；\",\"如果两个对象的HashCode不同则对象一定不同。\",\"重写equals()代表这个方法是用来比较两个对象是否相等，如果不重写HashCode()方法可能会导致判断是相等的两个对象但是HashCode不等。\"]},{\"header\":\"String\",\"slug\":\"string\",\"contents\":[]},{\"header\":\"String、StringBuffer、StringBuilder 的区别？\",\"slug\":\"string、stringbuffer、stringbuilder-的区别\",\"contents\":[\"String是不可变的，可以看成常量，线程安全。对内部方法加了同步锁，是线程安全的。StringBuilder没有添加同步锁，所以是线程不安全的。\",\"每次对String类型进行修改的时候，都会新生成一个String类型，然后将引用指向新的String对象。StringBuffer和StringBuilder是对对象本身进行操作，不会生成新的对象，相同情况下使用StringBuilder会带来一点性能提升，但是线程不安全。\",\"少量数据使用String，单线程下大量数据使用StringBuilder，多线程下使用StringBuffer。\"]},{\"header\":\"String为何不可变？\",\"slug\":\"string为何不可变\",\"contents\":[\"JDK8中的源码：\",\"保存字符串的数组是final修饰的，并且内部没有暴露能修改这个数组的方法；\",\"String类本身也被final修饰导致不能被继承，从而避免子类破坏String的不变性。\"]},{\"header\":\"字符串拼接用“+” 还是 StringBuilder?\",\"slug\":\"字符串拼接用-还是-stringbuilder\",\"contents\":[\"+和+=是Java中唯二为String重载过的运算符。\",\"String对象使用+进行拼接，实际就是通过StringBuilder调用append()方法，拼完之后调用toString()方法返回String对象。\",\"相关信息\",\"如果在循环内使用+进行拼接多个字符串，编译器不会复用StringBuilder，而是每次循环都创建一个StringBuilder。\",\"直接使用StringBuilder进行拼接就能解决这个问题。\"]},{\"header\":\"String s1 = new String(\\\"abc\\\");这句话创建了几个字符串对象？\",\"slug\":\"string-s1-new-string-abc-这句话创建了几个字符串对象\",\"contents\":[\"会创建1个或者2个字符串对象。、\",\"String str = new String(\\\"abc\\\");\",\"如果字符串常量池中不存在\\\"abc\\\"的引用，则会在堆中创建2个字符串对象\\\"abc\\\"。一个是在字符串常量池中创建的\\\"abc\\\"，另外是new在堆中创建的对象。\",\"如果字符串常量池中存在\\\"abc\\\"的引用，则会在堆中创建1个字符串对象\\\"abc\\\"。也就是new在堆中创建的对象。\",\"示意图：\"]},{\"header\":\"String#intern 方法有什么作用?\",\"slug\":\"string-intern-方法有什么作用\",\"contents\":[\"String.intern()是一个本地方法，作用是将指定的字符串对象保存到字符串常量池中。\",\"如果字符串常量池中保存了对应的字符串对象的引用，则返回引用。\",\"如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。\"]},{\"header\":\"编译器对字符串拼接的优化\",\"slug\":\"编译器对字符串拼接的优化\",\"contents\":[\"对于String str3 = \\\"a\\\" + \\\"b\\\"等价于String str3 = \\\"ab\\\"；对于在编译期间就能确定的字符串，编译器会在编译期间直接放入字符串常量池中。\",\"String str4 = str1 + str2;则不会在编译期间确定结果，不会产生优化。\",\"使用final修饰则看成常量，在编译期间就会优化放入字符串常量池中。\"]}]},\"/java/1java/\":{\"title\":\"Java基础\",\"contents\":[]}}}");self.onmessage=({data:o})=>{self.postMessage($(o.query,m[o.routeLocale]))};
//# sourceMappingURL=original.js.map
