const ut="ENTRIES",W="KEYS",$="VALUES",p="";class O{constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=z(this._path);if(z(s)===p)return{done:!1,value:this.result()};const n=t.get(z(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=z(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>z(t)).filter(t=>t!==p).join("")}value(){return z(this._path).node.get(p)}result(){switch(this._type){case $:return this.value();case W:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const z=e=>e[e.length-1],it=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===p){const a=o[h-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let l=0;l<c.length;++l,++a){const m=c[l],f=i*a,g=f-i;let d=o[f];const F=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let _=F;_<y;++_){const I=m!==t[_],x=o[g+_]+ +I,A=o[g+_+1]+1,k=o[f+_]+1,T=o[f+_+1]=Math.min(x,A,k);T<d&&(d=T)}if(d>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{constructor(t=new Map,s=""){this._size=void 0,this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=v(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=S(n);for(const i of o.keys())if(i!==p&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,rt(this._tree,t)}entries(){return new O(this,ut)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return it(this._tree,t,s)}get(t){const s=M(this._tree,t);return s!==void 0?s.get(p):void 0}has(t){const s=M(this._tree,t);return s!==void 0&&s.has(p)}keys(){return new O(this,W)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,B(this._tree,t).set(p,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=B(this._tree,t);return n.set(p,s(n.get(p))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=B(this._tree,t);let o=n.get(p);return o===void 0&&n.set(p,o=s()),o}values(){return new O(this,$)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const v=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==p&&t.startsWith(n))return s.push([e,n]),v(e.get(n),t.slice(n.length),s);return s.push([e,t]),v(void 0,"",s)},M=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==p&&t.startsWith(s))return M(e.get(s),t.slice(s.length))},B=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==p&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},rt=(e,t)=>{const[s,n]=v(e,t);if(s!==void 0){if(s.delete(p),s.size===0)q(n);else if(s.size===1){const[o,u]=s.entries().next().value;P(n,o,u)}}},q=e=>{if(e.length===0)return;const[t,s]=S(e);if(t.delete(s),t.size===0)q(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==p&&P(e.slice(0,-1),n,o)}},P=(e,t,s)=>{if(e.length===0)return;const[n,o]=S(e);n.set(o+t,s),n.delete(o)},S=e=>e[e.length-1],ct=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,j="or",N="and",lt="and_not",ht=(e,t)=>{e.includes(t)||e.push(t)},G=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},J=({score:e},{score:t})=>t-e,at=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},U=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[j]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),G(n.terms,u)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);G(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[lt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},ft=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},gt=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},Ft={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(ct),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},H={combineWith:j,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:Ft},pt={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K};class At{constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...H,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const Ct=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},X=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},zt=(e,t,s,n)=>{if(!e._index.has(n)){X(e,s,t,n);return}const o=e._index.fetch(n,at),u=o.get(t);u==null||u.get(s)==null?X(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},Y=(e,t=j)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},L=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const a=u[c],l=e._fieldIds[c],m=o.get(l);if(m==null)continue;let f=m.size;const g=e._avgFieldLength[l];for(const d of m.keys()){if(!e._documentIds.has(d)){zt(e,l,d,s),f-=1;continue}const F=i?i(e._documentIds.get(d),s,e._storedFields.get(d)):1;if(!F)continue;const y=m.get(d),_=e._fieldLength.get(d)[l],I=ft(y,f,e._documentCount,_,g,r),x=n*a*F*I,A=h.get(d);if(A){A.score+=x,ht(A.terms,t);const k=U(A.match,s);k?k.push(c):A.match[s]=[c]}else h.set(d,{score:x,terms:[t],match:{[s]:[c]}})}}return h},Et=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((d,F)=>({...d,[F]:U(n.boost,F)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:a}={...H.weights,...i},l=e._index.get(t.term),m=L(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,F=d<1?Math.min(r,Math.round(t.term.length*d)):d;F&&(g=e._index.fuzzyGet(t.term,F))}if(f)for(const[d,F]of f){const y=d.length-t.term.length;if(!y)continue;g==null||g.delete(d);const _=a*d.length/(d.length+.3*y);L(e,t.term,d,_,F,o,u,h,m)}if(g)for(const d of g.keys()){const[F,y]=g.get(d);if(!y)continue;const _=c*d.length/(d.length+y);L(e,t.term,d,_,F,o,u,h,m)}return m},Q=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},l=t.queries.map(m=>Q(e,m,a));return Y(l,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(a=>h(a)).filter(a=>!!a).map(gt(i)).map(a=>Et(e,a,i));return Y(c,i.combineWith)},Z=(e,t,s={})=>{const n=Q(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(J),o},wt=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Z(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(J),o},xt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new At(a);l._documentCount=t,l._nextId=s,l._documentIds=b(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=b(u),l._avgFieldLength=i,l._storedFields=b(r),l._dirtCount=h||0,l._index=new C;for(const[m,f]of l._documentIds)l._idToShortId.set(f,m);for(const[m,f]of e){const g=new Map;for(const d of Object.keys(f)){let F=f[d];c===1&&(F=F.ds),g.set(parseInt(d,10),b(F))}l._index.set(m,g)}return l},tt=Object.entries,kt=Object.fromEntries,E=100,w=20,V=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let l="";i===0?l=c.length>w?`… ${c.slice(-w)}`:c:a?l=c.length+i>E?`${c.slice(0,E-i)}… `:c:l=c.length>w?`${c.slice(0,w)} … ${c.slice(-w)}`:c,l&&o.push(l),i+=l.length,a||(o.push(["mark",t]),i+=t.length,i>=E&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>E)break;h=s.indexOf(n,u)}return i<E&&r(e.slice(u),!0),o},et=/[\u4e00-\u9fa5]/g,st=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(et)||[],n=t.replace(et,"").toLowerCase();return n?[n,...s]:[...s]},...e}),nt=(e,t,s={})=>{const n={};return Z(t,e,st({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[a,l]=u.split(/[#@]/),{contents:m}=n[a]??={title:"",contents:[]};if(h)m.push([{type:"customField",key:a,index:l,display:i.map(f=>o.c.map(g=>V(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>V(o.h,g)).filter(g=>g!==null);if(f.length&&m.push([{type:c?"heading":"title",key:a,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const d=i.map(F=>V(g,F)).filter(F=>F!==null);d.length&&m.push([{type:"text",key:a,...c&&{anchor:l},display:d},r])}}}),tt(n).sort(([,o],[,u])=>u.contents.reduce((i,[,r])=>i+r,0)-o.contents.reduce((i,[,r])=>i+r,0)).map(([o,{title:u,contents:i}])=>{if(!u){const r=Ct(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},ot=(e,t,s={})=>wt(t,e,st(s)).map(({suggestion:n})=>n),D=kt(tt(JSON.parse("{\"/\":{\"documentCount\":738,\"nextId\":738,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-287418c4\",\"2\":\"v-287418c4#操作系统的功能\",\"3\":\"v-287418c4#什么是用户态和内核态\",\"4\":\"v-287418c4#进程和线程\",\"5\":\"v-287418c4#什么是进程和线程\",\"6\":\"v-287418c4#有了进程为什么还需要线程\",\"7\":\"v-287418c4#线程间的同步的方式有哪些\",\"8\":\"v-287418c4#pcb-是什么-包含哪些信息\",\"9\":\"v-287418c4#进程间的通信方式有哪些\",\"10\":\"v-287418c4#什么是僵尸进程和孤儿进程\",\"11\":\"v-287418c4#内存管理\",\"12\":\"v-287418c4#什么是内存碎片\",\"13\":\"v-287418c4#分段分页\",\"14\":\"v-287418c4#文件系统\",\"15\":\"v-287418c4#硬链接和软链接有什么区别\",\"16\":\"v-287418c4#常见的磁盘调度算法有哪些\",\"17\":\"v-0f6e5a7b\",\"18\":\"v-0f6e5a7b#何为io\",\"19\":\"v-0f6e5a7b#有哪些常见的-io-模型\",\"20\":\"v-0f6e5a7b#java-中-3-种常见-io-模型\",\"21\":\"v-0f6e5a7b#bio-blocking-i-o\",\"22\":\"v-0f6e5a7b#nio-non-blocking-new-i-o\",\"23\":\"v-0f6e5a7b#aio-asynchronous-i-o\",\"24\":\"v-0f6e5a7b#比较\",\"25\":\"v-a94a8cca\",\"26\":\"v-2e25198a\",\"27\":\"v-7d72c4ac\",\"28\":\"v-ab0c34e0\",\"29\":\"v-ab0c34e0#和-的区别是什么\",\"30\":\"v-ab0c34e0#dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗\",\"31\":\"v-ab0c34e0#mybatis的xml映射文件中-不同的xml映射文件-id是否可以重复\",\"32\":\"v-ab0c34e0#mybatis的xml映射文件和mybatis内部数据结构的映射关系\",\"33\":\"v-ab0c34e0#属性名和字段名不一致如何解决\",\"34\":\"v-ab0c34e0#mybatis中的分页\",\"35\":\"v-ab0c34e0#mybatis中的执行器有哪些\",\"36\":\"v-14b0a7d7\",\"37\":\"v-14b0a7d7#java\",\"38\":\"v-14b0a7d7#计算机基础\",\"39\":\"v-14b0a7d7#数据库\",\"40\":\"v-14b0a7d7#中间件云原生\",\"41\":\"v-14b0a7d7#框架\",\"42\":\"v-14b0a7d7#笔记\",\"43\":\"v-14b0a7d7#面经\",\"44\":\"v-14b0a7d7#拍拍\",\"45\":\"v-14b0a7d7#关于\",\"46\":\"v-14c69af4\",\"47\":\"v-7273d1ac\",\"48\":\"v-7273d1ac#静态web配置\",\"49\":\"v-7273d1ac#反向代理和header\",\"50\":\"v-7273d1ac#正向代理与反向代理\",\"51\":\"v-7273d1ac#配置反向代理\",\"52\":\"v-7273d1ac#设置代理请求headers\",\"53\":\"v-7273d1ac#动静分离\",\"54\":\"v-7273d1ac#修饰符\",\"55\":\"v-7273d1ac#动静分离的好处\",\"56\":\"v-7273d1ac#缓冲与缓存\",\"57\":\"v-7273d1ac#缓冲-buffer\",\"58\":\"v-7273d1ac#缓存-cache\",\"59\":\"v-7273d1ac#负载均衡\",\"60\":\"v-7273d1ac#负载均衡策略\",\"61\":\"v-7273d1ac#健康检查\",\"62\":\"v-7273d1ac#https配置\",\"63\":\"v-7273d1ac#tcp反向代理\",\"64\":\"v-7273d1ac#重写\",\"65\":\"v-7273d1ac#重写-return\",\"66\":\"v-7273d1ac#重写-rewrite\",\"67\":\"v-35959987\",\"68\":\"v-35959987#消息队列有什么用\",\"69\":\"v-35959987#通过异步处理提高系统性能-减少响应所需时间\",\"70\":\"v-35959987#削峰-限流\",\"71\":\"v-35959987#降低系统耦合性\",\"72\":\"v-35959987#实现分布式事务\",\"73\":\"v-35959987#使用消息队列会带来哪些问题\",\"74\":\"v-35959987#amqp是什么\",\"75\":\"v-35959987#rpc和消息队列的区别\",\"76\":\"v-35959987#常见的消息队列\",\"77\":\"v-35959987#kafka\",\"78\":\"v-35959987#rabbitmq\",\"79\":\"v-35959987#rabbitmq和kafka区别\",\"80\":\"v-35959987#介绍下rabbitmq\",\"81\":\"v-35959987#rabbitmq特点\",\"82\":\"v-35959987#rabbitmq组成\",\"83\":\"v-35959987#producer-生产者-和consumer-消费者\",\"84\":\"v-35959987#exchange-交换器\",\"85\":\"v-35959987#queue-消息队列\",\"86\":\"v-35959987#broker-消息中间件的服务节点\",\"87\":\"v-35959987#exchange-types-交换器类型\",\"88\":\"v-35959987#_1、fanout-广播\",\"89\":\"v-35959987#_2、direct-精确匹配\",\"90\":\"v-35959987#_3、topic\",\"91\":\"v-35959987#_4、headers-不推荐\",\"92\":\"v-35959987#说说broker服务节点、queue队列、exchange交换器\",\"93\":\"v-35959987#什么是死信路由-如何产生的\",\"94\":\"v-35959987#什么是延迟队列-rabbitmq-怎么实现延迟队列\",\"95\":\"v-35959987#消息的ttl\",\"96\":\"v-35959987#模拟订单过期解锁库存\",\"97\":\"v-35959987#rabbitmq-消息怎么传输\",\"98\":\"v-35959987#如何保证消息的可靠性-防止消息丢失\",\"99\":\"v-35959987#confirmcallback\",\"100\":\"v-35959987#returncallback\",\"101\":\"v-35959987#ack\",\"102\":\"v-35959987#如何保证-rabbitmq-消息的顺序性\",\"103\":\"v-35959987#rabbitmq消息积压如何处理\",\"104\":\"v-e176da2c\",\"105\":\"v-e176da2c#打包、分发、部署\",\"106\":\"v-e176da2c#docker部署的优势\",\"107\":\"v-e176da2c#镜像、容器\",\"108\":\"v-e176da2c#docker挂载目录\",\"109\":\"v-e176da2c#docker-compose\",\"110\":\"v-14642a24\",\"111\":\"v-14642a24#分布式基础理论\",\"112\":\"v-14642a24#cap\",\"113\":\"v-14642a24#c-consistency-一致性\",\"114\":\"v-14642a24#a-availability可用性\",\"115\":\"v-14642a24#p-partition-tolerance分区容错性\",\"116\":\"v-14642a24#cap组合方式\",\"117\":\"v-14642a24#ap\",\"118\":\"v-14642a24#cp\",\"119\":\"v-14642a24#ca\",\"120\":\"v-14642a24#base理论\",\"121\":\"v-14642a24#分布式事务解决方案\",\"122\":\"v-14642a24#_2pc\",\"123\":\"v-14642a24#tcc\",\"124\":\"v-14642a24#tcc和2pc的区别\",\"125\":\"v-14642a24#可靠消息最终一致性\",\"126\":\"v-14642a24#_1-本地事务与消息发送的原子性\",\"127\":\"v-14642a24#_2-事务参与方接收消息的可靠性\",\"128\":\"v-14642a24#_3-消息重复消费问题\",\"129\":\"v-14642a24#rocketmq事务消息方案\",\"130\":\"v-14642a24#总结\",\"131\":\"v-14642a24#最大努力通知\",\"132\":\"v-14642a24#最大努力通知和可靠消息一致性的区别\",\"133\":\"v-14642a24#最大努力通知解决方案\",\"134\":\"v-4d194044\",\"135\":\"v-ed2e0e84\",\"136\":\"v-ed2e0e84#谷粒商城\",\"137\":\"v-ed2e0e84#介绍下项目的技术选型\",\"138\":\"v-ed2e0e84#商城页面由nginx代理实现动静分离-请求负载均衡\",\"139\":\"v-ed2e0e84#nginx反向代理在计算机网络的第几层\",\"140\":\"v-ed2e0e84#nginx的负载均衡算法有哪些\",\"141\":\"v-ed2e0e84#nginx动静分离\",\"142\":\"v-ed2e0e84#nginx反向代理怎么配置的-反向代理跟正向代理的区别是什么-nginx可以配置正向代理吗\",\"143\":\"v-ed2e0e84#拆分为网关-订单-秒杀等微服务\",\"144\":\"v-ed2e0e84#分微服务的原则是什么\",\"145\":\"v-ed2e0e84#实现单点登录\",\"146\":\"v-ed2e0e84#单点登录怎么实现的\",\"147\":\"v-ed2e0e84#分布式下的用户登录状态保持\",\"148\":\"v-ed2e0e84#项目中用到了哪些springsecurity过滤器\",\"149\":\"v-ed2e0e84#如果想要用户仅仅在一段时间内免登录怎么办\",\"150\":\"v-ed2e0e84#jwt-token-如何生成的\",\"151\":\"v-ed2e0e84#商品缓存快速查询\",\"152\":\"v-ed2e0e84#数据更新之后对缓存如何操作-缓存一致性解决办法\",\"153\":\"v-ed2e0e84#缓存穿透-缓存雪崩-缓存击穿问题\",\"154\":\"v-ed2e0e84#订单创建幂等性\",\"155\":\"v-ed2e0e84#订单创建的幂等性如何实现\",\"156\":\"v-ed2e0e84#延时关单如何实现的\",\"157\":\"v-ed2e0e84#秒杀遵从服务单一职责-独立部署-定时上架\",\"158\":\"v-ed2e0e84#秒杀的流程是啥样的\",\"159\":\"v-ed2e0e84#服务单一职责-独立部署-定时上架\",\"160\":\"v-ed2e0e84#库存预热快速扣减-秒杀连接加密-恶意请求拦截\",\"161\":\"v-ed2e0e84#库存预热快速扣减如何实现\",\"162\":\"v-ed2e0e84#秒杀连接加密-恶意请求拦截如何实现\",\"163\":\"v-ed2e0e84#流量错峰-后端限流-队列削峰。\",\"164\":\"v-ed2e0e84#流量错峰-队列削峰如何实现\",\"165\":\"v-ed2e0e84#限流熔断降级如何实现\",\"166\":\"v-15054f24\",\"167\":\"v-7ce4aeb6\",\"168\":\"v-7ce4aeb6#_2023-4平潭-世间浪漫海占一半\",\"169\":\"v-e2acc714\",\"170\":\"v-7acb0465\",\"171\":\"v-7acb0465#常见的网络协议\",\"172\":\"v-7acb0465#应用层\",\"173\":\"v-7acb0465#传输层\",\"174\":\"v-7acb0465#网络层\",\"175\":\"v-7acb0465#get和post的区别\",\"176\":\"v-7acb0465#put和post的区别\",\"177\":\"v-7acb0465#http\",\"178\":\"v-7acb0465#从输入-url-到页面展示到底发生了什么\",\"179\":\"v-7acb0465#http状态码\",\"180\":\"v-7acb0465#https与http的区别\",\"181\":\"v-7acb0465#http-1-0-和-http-1-1-区别\",\"182\":\"v-7acb0465#uri-和-url-的区别\",\"183\":\"v-7acb0465#dns\",\"184\":\"v-7acb0465#dns-的作用是什么\",\"185\":\"v-7acb0465#dns-服务器有哪些\",\"186\":\"v-0f0f7366\",\"187\":\"v-0f0f7366#tcp-与-udp\",\"188\":\"v-0f0f7366#tcp-与-udp-的区别\",\"189\":\"v-0f0f7366#什么时候选择-tcp-什么时候选-udp\",\"190\":\"v-0f0f7366#http-基于-tcp-还是-udp\",\"191\":\"v-0f0f7366#使用-tcp-的协议有哪些-使用-udp-的协议有哪些\",\"192\":\"v-0f0f7366#tcp-三次握手和四次挥手-传输层\",\"193\":\"v-0f0f7366#建立连接-tcp三次握手\",\"194\":\"v-0f0f7366#为什么要三次握手\",\"195\":\"v-0f0f7366#断开连接-tcp-四次挥手\",\"196\":\"v-0f0f7366#为什么不能把服务器发送的-ack-和-fin-合并起来-变成三次挥手\",\"197\":\"v-0f0f7366#为什么第四次挥手客户端需要等待-2-msl-报文段最长寿命-时间后才进入-closed-状态\",\"198\":\"v-0f0f7366#tcp-传输可靠性保障-传输层\",\"199\":\"v-0f0f7366#tcp-如何保证传输的可靠性\",\"200\":\"v-0f0f7366#tcp-如何实现流量控制\",\"201\":\"v-0f0f7366#tcp-的拥塞控制是怎么实现的\",\"202\":\"v-0f0f7366#arq协议\",\"203\":\"v-0f0f7366#停止等待协议\",\"204\":\"v-0f0f7366#后退n帧协议-gbn\",\"205\":\"v-0f0f7366#选择重传协议-sr\",\"206\":\"v-b9583b32\",\"207\":\"v-b9583b32#ip-网络层\",\"208\":\"v-b9583b32#ip协议的作用是什么\",\"209\":\"v-b9583b32#什么是ip地址-ip寻址如何工作\",\"210\":\"v-b9583b32#ipv4-和-ipv6-有什么区别\",\"211\":\"v-b9583b32#nat作用是什么\",\"212\":\"v-b9583b32#arp\",\"213\":\"v-b9583b32#什么是-mac-地址\",\"214\":\"v-b9583b32#arp-协议解决了什么问题\",\"215\":\"v-18d61928\",\"216\":\"v-6f176f1e\",\"217\":\"v-6f176f1e#数据库的三大范式\",\"218\":\"v-6f176f1e#_1nf\",\"219\":\"v-6f176f1e#_2nf\",\"220\":\"v-6f176f1e#_3nf\",\"221\":\"v-6f176f1e#drop、delete-与-truncate-区别\",\"222\":\"v-6f176f1e#dml-语句和-ddl-语句区别\",\"223\":\"v-5d9788e5\",\"224\":\"v-5d9788e5#什么是关系型数据库\",\"225\":\"v-5d9788e5#mysql有什么优点\",\"226\":\"v-5d9788e5#mysql基础架构\",\"227\":\"v-5d9788e5#mysql存储引擎\",\"228\":\"v-5d9788e5#myisam-和-innodb-有什么区别\",\"229\":\"v-5d9788e5#mysql查询缓存\",\"230\":\"v-5d9788e5#mysql-事务\",\"231\":\"v-5d9788e5#acid特性\",\"232\":\"v-5d9788e5#并发事务带来了哪些问题\",\"233\":\"v-5d9788e5#并发事务的控制方式有哪些\",\"234\":\"v-5d9788e5#mysql的隔离级别是基于锁实现的吗\",\"235\":\"v-5d9788e5#mysql的默认隔离级别是什么\",\"236\":\"v-5d9788e5#mysql-锁\",\"237\":\"v-5d9788e5#表级锁和行级锁了解吗-有什么区别\",\"238\":\"v-5d9788e5#innodb-有哪几类行锁\",\"239\":\"v-5d9788e5#共享锁和排他锁区别\",\"240\":\"v-5d9788e5#意向锁有什么作用\",\"241\":\"v-5d9788e5#快照读和当前读的区别\",\"242\":\"v-5d9788e5#mysql如何存储ip地址\",\"243\":\"v-5d9788e5#执行计划\",\"244\":\"v-5d9788e5#读写分离和分库分表\",\"245\":\"v-5d9788e5#读写分离\",\"246\":\"v-5d9788e5#读写分离会带来什么问题\",\"247\":\"v-5d9788e5#如何实现读写分离\",\"248\":\"v-5d9788e5#主从复制的原理是什么\",\"249\":\"v-5d9788e5#分库分表\",\"250\":\"v-5d9788e5#什么是分库\",\"251\":\"v-5d9788e5#什么是分表\",\"252\":\"v-5d9788e5#什么情况下需要分库分表\",\"253\":\"v-5d9788e5#常见的分片算法有哪些\",\"254\":\"v-5d9788e5#分库分表会带来什么问题呢\",\"255\":\"v-86a8eecc\",\"256\":\"v-86a8eecc#索引\",\"257\":\"v-86a8eecc#索引底层数据结构\",\"258\":\"v-86a8eecc#hash表\",\"259\":\"v-86a8eecc#二叉查找树-bst\",\"260\":\"v-86a8eecc#avl树\",\"261\":\"v-86a8eecc#红黑树\",\"262\":\"v-86a8eecc#b-树-b-树\",\"263\":\"v-86a8eecc#主键索引-primary-key\",\"264\":\"v-86a8eecc#二级索引\",\"265\":\"v-86a8eecc#聚簇索引与非聚簇索引\",\"266\":\"v-86a8eecc#聚簇索引-聚集索引\",\"267\":\"v-86a8eecc#非聚簇索引-非聚集索引\",\"268\":\"v-86a8eecc#覆盖索引和联合索引\",\"269\":\"v-86a8eecc#覆盖索引\",\"270\":\"v-86a8eecc#联合索引\",\"271\":\"v-86a8eecc#最左匹配原则\",\"272\":\"v-86a8eecc#索引下推\",\"273\":\"v-86a8eecc#使用索引的建议\",\"274\":\"v-86a8eecc#选择合适的字段创建索引\",\"275\":\"v-86a8eecc#被频繁更新的字段应该慎重建立索引\",\"276\":\"v-86a8eecc#限制每张表上的索引数量\",\"277\":\"v-86a8eecc#尽可能的考虑建立联合索引而不是单列索引\",\"278\":\"v-86a8eecc#避免索引失效\",\"279\":\"v-aba67072\",\"280\":\"v-6e5a4948\",\"281\":\"v-3754f902\",\"282\":\"v-3754f902#事务隔离级别\",\"283\":\"v-3754f902#一致性非锁定读和锁定读\",\"284\":\"v-3754f902#一致性非锁定读\",\"285\":\"v-3754f902#锁定读\",\"286\":\"v-3754f902#innodb-对-mvcc-的实现\",\"287\":\"v-3754f902#隐藏字段\",\"288\":\"v-3754f902#readview\",\"289\":\"v-3754f902#undo-log\",\"290\":\"v-3754f902#rc-和-rr-隔离级别下-mvcc-的差异\",\"291\":\"v-3754f902#mvcc下解决不可重复读问题\",\"292\":\"v-3754f902#mvcc-next-key-lock防止幻读\",\"293\":\"v-3e30edc0\",\"294\":\"v-c91da0ba\",\"295\":\"v-32a15a63\",\"296\":\"v-32a15a63#基础\",\"297\":\"v-32a15a63#什么是-redis\",\"298\":\"v-32a15a63#redis-为什么这么快\",\"299\":\"v-32a15a63#说一下-redis-和-memcached-的区别和共同点\",\"300\":\"v-32a15a63#为什么要用-redis-为什么要用缓存\",\"301\":\"v-32a15a63#常见的缓存读写策略\",\"302\":\"v-32a15a63#cache-aside-pattern-旁路缓存模式\",\"303\":\"v-32a15a63#read-write-through-pattern-读写穿透\",\"304\":\"v-32a15a63#write-behind-pattern-异步缓存写入\",\"305\":\"v-32a15a63#redis-应用\",\"306\":\"v-32a15a63#redis-除了做缓存-还能做什么\",\"307\":\"v-32a15a63#redis-数据结构\",\"308\":\"v-32a15a63#redis-常用的数据结构有哪些\",\"309\":\"v-32a15a63#string-的应用场景有哪些\",\"310\":\"v-32a15a63#string-还是-hash-存储对象数据更好呢\",\"311\":\"v-32a15a63#string-的底层实现是什么\",\"312\":\"v-32a15a63#购物车信息用-string-还是-hash-存储更好呢\",\"313\":\"v-32a15a63#使用-redis-实现一个排行榜怎么做\",\"314\":\"v-32a15a63#set-的应用场景是什么\",\"315\":\"v-32a15a63#使用-set-实现抽奖系统怎么做\",\"316\":\"v-32a15a63#使用-bitmap-统计活跃用户怎么做\",\"317\":\"v-32a15a63#使用-hyperloglog-统计页面-uv-怎么做\",\"318\":\"v-32a15a63#redis持久化\",\"319\":\"v-32a15a63#redis线程模型\",\"320\":\"v-32a15a63#redis单线程了解吗\",\"321\":\"v-32a15a63#单线程如何监听大量的客户端连接\",\"322\":\"v-32a15a63#redis-6-0之前为什么不使用多线程\",\"323\":\"v-32a15a63#redis-6-0之后为何引入了多线程\",\"324\":\"v-32a15a63#redis后台线程了解吗\",\"325\":\"v-32a15a63#redis内存管理\",\"326\":\"v-32a15a63#redis给缓存数据设置过期时间有啥用\",\"327\":\"v-32a15a63#过期数据的删除策略\",\"328\":\"v-32a15a63#redis内存淘汰机制\",\"329\":\"v-70f3e5b8\",\"330\":\"v-70f3e5b8#redis性能优化\",\"331\":\"v-70f3e5b8#使用批量操作减少网络传输\",\"332\":\"v-70f3e5b8#原生批量操作\",\"333\":\"v-70f3e5b8#pipeline\",\"334\":\"v-70f3e5b8#lua脚本\",\"335\":\"v-70f3e5b8#大量key集中过期问题\",\"336\":\"v-70f3e5b8#redis-bigkey\",\"337\":\"v-70f3e5b8#有什么危害\",\"338\":\"v-70f3e5b8#如何发现\",\"339\":\"v-70f3e5b8#如何处理\",\"340\":\"v-70f3e5b8#redis-hotkey-热-key\",\"341\":\"v-70f3e5b8#有什么危害-1\",\"342\":\"v-70f3e5b8#如何发现-1\",\"343\":\"v-70f3e5b8#如何解决\",\"344\":\"v-70f3e5b8#慢查询命令\",\"345\":\"v-70f3e5b8#原因\",\"346\":\"v-70f3e5b8#如何找到慢查询命令\",\"347\":\"v-70f3e5b8#redis内存碎片\",\"348\":\"v-70f3e5b8#为何会出现\",\"349\":\"v-70f3e5b8#如何查看redis内存碎片的信息\",\"350\":\"v-70f3e5b8#如何清理redis内存碎片\",\"351\":\"v-70f3e5b8#缓存穿透-雪崩-击穿\",\"352\":\"v-70f3e5b8#缓存穿透-请求数据不存在\",\"353\":\"v-70f3e5b8#解决办法\",\"354\":\"v-70f3e5b8#缓存雪崩-大量key同时失效\",\"355\":\"v-70f3e5b8#解决办法-1\",\"356\":\"v-70f3e5b8#缓存击穿-热点key失效\",\"357\":\"v-70f3e5b8#解决办法-2\",\"358\":\"v-70f3e5b8#缓存穿透和缓存击穿的区别\",\"359\":\"v-70f3e5b8#缓存雪崩和缓存击穿有什么区别\",\"360\":\"v-70f3e5b8#如何保证缓存和数据库数据的一致性\",\"361\":\"v-70f3e5b8#redis阻塞的常见原因\",\"362\":\"v-70f3e5b8#o-n-命令\",\"363\":\"v-70f3e5b8#save-创建-rdb-快照\",\"364\":\"v-70f3e5b8#aof\",\"365\":\"v-70f3e5b8#大key\",\"366\":\"v-70f3e5b8#清空数据库\",\"367\":\"v-70f3e5b8#集群扩容\",\"368\":\"v-70f3e5b8#swap-内存交换\",\"369\":\"v-70f3e5b8#cpu竞争\",\"370\":\"v-70f3e5b8#网络问题\",\"371\":\"v-70f3e5b8#redis集群\",\"372\":\"v-41f5be07\",\"373\":\"v-41f5be07#基于-redis-实现分布式锁\",\"374\":\"v-41f5be07#如何基于-redis-实现一个最简易的分布式锁如何基于-redis-实现一个最简易的分布式锁\",\"375\":\"v-41f5be07#如何防止释放锁逻辑失效导致的锁无法释放\",\"376\":\"v-41f5be07#如何实现锁的优雅续期\",\"377\":\"v-41f5be07#如何实现可重入锁\",\"378\":\"v-41f5be07#redis-如何解决集群情况下分布式锁的可靠性\",\"379\":\"v-41f5be07#基于-zookeeper-实现分布式锁\",\"380\":\"v-41f5be07#为什么要用临时顺序节点\",\"381\":\"v-41f5be07#为什么要设置对前一个节点的监听\",\"382\":\"v-4644acc8\",\"383\":\"v-4644acc8#string-字符串\",\"384\":\"v-4644acc8#常用命令\",\"385\":\"v-4644acc8#应用场景\",\"386\":\"v-4644acc8#list-列表\",\"387\":\"v-4644acc8#常用命令-1\",\"388\":\"v-4644acc8#应用场景-1\",\"389\":\"v-4644acc8#hash-哈希\",\"390\":\"v-4644acc8#常用命令-2\",\"391\":\"v-4644acc8#应用场景-2\",\"392\":\"v-4644acc8#set-集合\",\"393\":\"v-4644acc8#常用命令-3\",\"394\":\"v-4644acc8#应用场景-3\",\"395\":\"v-4644acc8#sorted-set-有序集合\",\"396\":\"v-4644acc8#常用命令-4\",\"397\":\"v-4644acc8#应用场景-4\",\"398\":\"v-4644acc8#bitmap\",\"399\":\"v-4644acc8#常用命令-5\",\"400\":\"v-4644acc8#应用场景-5\",\"401\":\"v-4644acc8#hyperloglog\",\"402\":\"v-4644acc8#常用命令-6\",\"403\":\"v-4644acc8#应用场景-6\",\"404\":\"v-4644acc8#geospatial-index\",\"405\":\"v-4644acc8#常用命令-7\",\"406\":\"v-4644acc8#应用场景-7\",\"407\":\"v-7251bf68\",\"408\":\"v-7251bf68#rdb持久化\",\"409\":\"v-7251bf68#rdb创建快照的时候会阻塞主线程吗\",\"410\":\"v-7251bf68#aof持久化\",\"411\":\"v-7251bf68#aof工作基本流程\",\"412\":\"v-7251bf68#aof持久化方式有哪些\",\"413\":\"v-7251bf68#aof为什么是在执行完命令之后记录日志\",\"414\":\"v-7251bf68#aof重写了解吗\",\"415\":\"v-7251bf68#aof-校验机制了解吗\",\"416\":\"v-7251bf68#如何选择-rdb-和-aof\",\"417\":\"v-2f51bcf0\",\"418\":\"v-2f51bcf0#主从集群\",\"419\":\"v-2f51bcf0#数据同步原理\",\"420\":\"v-2f51bcf0#全量同步\",\"421\":\"v-2f51bcf0#增量同步\",\"422\":\"v-2f51bcf0#优化主从集群\",\"423\":\"v-2f51bcf0#redis哨兵sentinel\",\"424\":\"v-2f51bcf0#作用\",\"425\":\"v-2f51bcf0#心跳机制\",\"426\":\"v-2f51bcf0#选举新的master\",\"427\":\"v-2f51bcf0#如何实现故障转移\",\"428\":\"v-2f51bcf0#redis分片集群\",\"429\":\"v-2f51bcf0#使用分片集群\",\"430\":\"v-2f51bcf0#散列插槽\",\"431\":\"v-2f51bcf0#故障转移\",\"432\":\"v-50823daa\",\"433\":\"v-42365a57\",\"434\":\"v-42365a57#spring是什么\",\"435\":\"v-42365a57#单例bean是单例设计模式吗\",\"436\":\"v-42365a57#什么是单例池-作用是什么\",\"437\":\"v-42365a57#spring中的设计模式\",\"438\":\"v-42365a57#spring中bean创建的生命周期\",\"439\":\"v-42365a57#bean初始化和实例化的区别是什么\",\"440\":\"v-42365a57#初始化后是什么\",\"441\":\"v-42365a57#bean对象和普通对象之间的区别是什么\",\"442\":\"v-42365a57#postconstruct是如何工作的\",\"443\":\"v-42365a57#构造方法推断\",\"444\":\"v-42365a57#先bytype再byname\",\"445\":\"v-42365a57#spring事务\",\"446\":\"v-42365a57#事务实现原理\",\"447\":\"v-42365a57#spring事务传播机制\",\"448\":\"v-42365a57#spring事务失效的原因\",\"449\":\"v-42365a57#springaop怎么工作的\",\"450\":\"v-42365a57#spring为什么要使用三级缓存来解决循环依赖\",\"451\":\"v-42365a57#spring框架中的bean是线程安全的吗\",\"452\":\"v-42365a57#applicationcontext和beanfactory有什么区别\",\"453\":\"v-42365a57#spring容器的启动流程\",\"454\":\"v-49e7ffb6\",\"455\":\"v-49e7ffb6#springmvc\",\"456\":\"v-49e7ffb6#springmvc处理请求的底层原理\",\"457\":\"v-49e7ffb6#springmvc的核心组件有哪些\",\"458\":\"v-49e7ffb6#springmvc零配置\",\"459\":\"v-49e7ffb6#统一异常处理\",\"460\":\"v-49e7ffb6#springboot\",\"461\":\"v-49e7ffb6#springbootapplication注解的作用\",\"462\":\"v-49e7ffb6#springboot中的spring-factories文件有什么作用\",\"463\":\"v-49e7ffb6#springboot的启动流程\",\"464\":\"v-182fabca\",\"465\":\"v-e26068d4\",\"466\":\"v-e26068d4#jvm-jre-jdk\",\"467\":\"v-e26068d4#什么是字节码-采用字节码的好处\",\"468\":\"v-e26068d4#java-和-c-的区别\",\"469\":\"v-e26068d4#基本数据类型\",\"470\":\"v-e26068d4#基本类型和包装类型\",\"471\":\"v-e26068d4#包装类的缓存机制\",\"472\":\"v-e26068d4#自动拆装箱\",\"473\":\"v-e26068d4#浮点数运算的时候会有精度丢失的风险\",\"474\":\"v-e26068d4#如何解决浮点数运算的时候精度丢失问题\",\"475\":\"v-e26068d4#超过long-64位补码的范围数字应该如何表示\",\"476\":\"v-e26068d4#变量\",\"477\":\"v-e26068d4#静态变量\",\"478\":\"v-e26068d4#方法\",\"479\":\"v-e26068d4#静态方法为什么不能调用非静态成员\",\"480\":\"v-e26068d4#重载和重写\",\"481\":\"v-f9cd8696\",\"482\":\"v-f9cd8696#面向对象\",\"483\":\"v-f9cd8696#面向对象和面向过程的区别\",\"484\":\"v-f9cd8696#对象的相等和引用的相等\",\"485\":\"v-f9cd8696#如果没有声明构造方法-程序能正确执行吗\",\"486\":\"v-f9cd8696#面向对象的三个特征\",\"487\":\"v-f9cd8696#接口和抽象类的共同点\",\"488\":\"v-f9cd8696#浅拷贝-深拷贝-引用拷贝\",\"489\":\"v-f9cd8696#object\",\"490\":\"v-f9cd8696#和equals区别\",\"491\":\"v-f9cd8696#hashcode-作用\",\"492\":\"v-f9cd8696#为什么重写-equals-时必须重写-hashcode-方法\",\"493\":\"v-f9cd8696#string\",\"494\":\"v-f9cd8696#string、stringbuffer、stringbuilder-的区别\",\"495\":\"v-f9cd8696#string为何不可变\",\"496\":\"v-f9cd8696#字符串拼接用-还是-stringbuilder\",\"497\":\"v-f9cd8696#string-s1-new-string-abc-这句话创建了几个字符串对象\",\"498\":\"v-f9cd8696#string-intern-方法有什么作用\",\"499\":\"v-f9cd8696#编译器对字符串拼接的优化\",\"500\":\"v-f9cd8696#java值传递\",\"501\":\"v-f9cd8696#形参和实参\",\"502\":\"v-f9cd8696#值传递-引用传递\",\"503\":\"v-f9cd8696#java只有值传递\",\"504\":\"v-f9cd8696#java序列化\",\"505\":\"v-f9cd8696#serialversionuid-有什么作用\",\"506\":\"v-49079e4a\",\"507\":\"v-49079e4a#反射的应用场景\",\"508\":\"v-49079e4a#反射的优缺点\",\"509\":\"v-49079e4a#反射获取class对象\",\"510\":\"v-49079e4a#获取方法并执行\",\"511\":\"v-63b48971\",\"512\":\"v-63b48971#静态代理\",\"513\":\"v-63b48971#动态代理\",\"514\":\"v-63b48971#jdk动态代理\",\"515\":\"v-63b48971#cglib动态代理\",\"516\":\"v-63b48971#jdk动态代理和cglib动态代理的区别\",\"517\":\"v-63b48971#静态代理和动态代理的区别\",\"518\":\"v-a94b071a\",\"519\":\"v-a94b071a#单例模式实现方式\",\"520\":\"v-a94b071a#饿汉式-静态常量\",\"521\":\"v-a94b071a#饿汉式-静态代码块\",\"522\":\"v-a94b071a#懒汉式-线程安全-同步方法\",\"523\":\"v-a94b071a#双重检查-重要\",\"524\":\"v-a94b071a#静态内部类-重要\",\"525\":\"v-a94b071a#枚举\",\"526\":\"v-2cfca4b0\",\"527\":\"v-32f3b57d\",\"528\":\"v-32f3b57d#集合\",\"529\":\"v-32f3b57d#说说-list-set-queue-map-四者的区别\",\"530\":\"v-32f3b57d#集合框架底层数据结构\",\"531\":\"v-32f3b57d#list\",\"532\":\"v-32f3b57d#说说arraylist\",\"533\":\"v-32f3b57d#arrylist和vector区别\",\"534\":\"v-32f3b57d#arraylist-与-linkedlist-区别\",\"535\":\"v-32f3b57d#set\",\"536\":\"v-32f3b57d#比较-hashset、linkedhashset-和-treeset-三者的异同\",\"537\":\"v-32f3b57d#queue\",\"538\":\"v-32f3b57d#arraydeque-与-linkedlist-的区别\",\"539\":\"v-32f3b57d#priorityqueue\",\"540\":\"v-32f3b57d#blockingqueue\",\"541\":\"v-1485935c\",\"542\":\"v-1485935c#map\",\"543\":\"v-1485935c#hashmap-和-hashtable-的区别\",\"544\":\"v-1485935c#hashmap-和-treemap-区别\",\"545\":\"v-1485935c#hashmap-的底层实现\",\"546\":\"v-1485935c#jdk1-8-之前\",\"547\":\"v-1485935c#jdk1-8-之后\",\"548\":\"v-1485935c#hashmap-的长度为什么是-2-的幂次方\",\"549\":\"v-1485935c#hashmap-多线程操作导致死链问题\",\"550\":\"v-1485935c#concurrenthashmap-和-hashtable-的区别\",\"551\":\"v-1485935c#jdk-1-7-和-jdk-1-8-的-concurrenthashmap-实现有什么不同\",\"552\":\"v-31c43ed3\",\"553\":\"v-53d0b748\",\"554\":\"v-53d0b748#进程和线程\",\"555\":\"v-53d0b748#进程\",\"556\":\"v-53d0b748#线程\",\"557\":\"v-53d0b748#从-jvm-角度说进程和线程之间的关系\",\"558\":\"v-53d0b748#程序计数器为什么是线程私有\",\"559\":\"v-53d0b748#虚拟机栈和本地方法栈为什么是私有的\",\"560\":\"v-53d0b748#堆和方法区\",\"561\":\"v-53d0b748#线程的生命周期和状态\",\"562\":\"v-53d0b748#什么是死锁-如何避免\",\"563\":\"v-53d0b748#死锁\",\"564\":\"v-53d0b748#如何预防死锁\",\"565\":\"v-53d0b748#如何避免死锁\",\"566\":\"v-53d0b748#sleep-方法和-wait-方法对比\",\"567\":\"v-53d0b748#为什么wait-方法不定义在thread中\",\"568\":\"v-53d0b748#直接调用run-和start-的区别\",\"569\":\"v-6a5c135d\",\"570\":\"v-6a5c135d#java内存模型\",\"571\":\"v-6a5c135d#指令重排序\",\"572\":\"v-6a5c135d#什么是java内存模型-为什么需要java内存模型\",\"573\":\"v-6a5c135d#什么是主内存-什么是本地内存\",\"574\":\"v-6a5c135d#java内存结构和java内存模型的区别\",\"575\":\"v-6a5c135d#happens-before\",\"576\":\"v-6a5c135d#happens-before-常见规则\",\"577\":\"v-6a5c135d#并发编程的三个特性\",\"578\":\"v-6a5c135d#volatile关键字\",\"579\":\"v-6a5c135d#volatile如何禁止指令重排序\",\"580\":\"v-6a5c135d#乐观锁和悲观锁\",\"581\":\"v-6a5c135d#什么是乐观锁\",\"582\":\"v-6a5c135d#什么是悲观锁\",\"583\":\"v-6a5c135d#cas-算法\",\"584\":\"v-6a5c135d#aba问题\",\"585\":\"v-6a5c135d#cas问题\",\"586\":\"v-6a5c135d#synchronized\",\"587\":\"v-6a5c135d#synchronized-是什么-有什么用\",\"588\":\"v-6a5c135d#sychronized修饰方法\",\"589\":\"v-6a5c135d#synchronized底层原理\",\"590\":\"v-6a5c135d#synchronized-和-volatile-有什么区别\",\"591\":\"v-6a5c135d#reentrantlock\",\"592\":\"v-6a5c135d#reentrantlock-是什么\",\"593\":\"v-6a5c135d#公平锁和非公平锁有什么区别\",\"594\":\"v-6a5c135d#synchronized-和-reentrantlock-有什么区别\",\"595\":\"v-6a5c135d#可中断锁和不可中断锁有什么区别\",\"596\":\"v-02befb44\",\"597\":\"v-02befb44#threadlocal\",\"598\":\"v-02befb44#threadlocal-有什么用\",\"599\":\"v-02befb44#threadlocal原理\",\"600\":\"v-02befb44#threadlocal内存泄露\",\"601\":\"v-02befb44#线程池\",\"602\":\"v-02befb44#什么是线程池\",\"603\":\"v-02befb44#为什么要用线程池\",\"604\":\"v-02befb44#如何创建线程池\",\"605\":\"v-02befb44#线程池的主要参数\",\"606\":\"v-02befb44#线程池的饱和策略有哪些\",\"607\":\"v-02befb44#线程池中常用的阻塞队列有哪些\",\"608\":\"v-02befb44#线程池处理任务的流程了解吗\",\"609\":\"v-02befb44#如何设定线程池的大小\",\"610\":\"v-02befb44#future\",\"611\":\"v-02befb44#future类有什么用\",\"612\":\"v-02befb44#callable-和-future-有什么关系\",\"613\":\"v-02befb44#completablefuture-类有什么用\",\"614\":\"v-d0bf4a88\",\"615\":\"v-d0bf4a88#自旋锁与自适应自旋\",\"616\":\"v-d0bf4a88#锁消除\",\"617\":\"v-d0bf4a88#锁粗化\",\"618\":\"v-d0bf4a88#轻量级锁\",\"619\":\"v-d0bf4a88#偏向锁\",\"620\":\"v-70192d16\",\"621\":\"v-70192d16#aqs原理\",\"622\":\"v-70192d16#aqs核心思想\",\"623\":\"v-70192d16#aqs资源共享方式\",\"624\":\"v-70192d16#semaphore-信号量\",\"625\":\"v-70192d16#countdownlatch-倒计时器\",\"626\":\"v-70192d16#cyclicbarrier-循环栅栏\",\"627\":\"v-169e4648\",\"628\":\"v-169e4648#copyonwritearraylist\",\"629\":\"v-169e4648#copyonwritearraylist-原理\",\"630\":\"v-169e4648#concurrentlinkedqueue\",\"631\":\"v-169e4648#blockingqueue\",\"632\":\"v-169e4648#arrayblockingqueue\",\"633\":\"v-169e4648#linkedblockingqueue\",\"634\":\"v-169e4648#priorityblockingqueue\",\"635\":\"v-169e4648#concurrentskiplistmap\",\"636\":\"v-64a8bef6\",\"637\":\"v-616d4a15\",\"638\":\"v-616d4a15#运行时数据区域\",\"639\":\"v-616d4a15#线程私有的\",\"640\":\"v-616d4a15#程序计数器\",\"641\":\"v-616d4a15#虚拟机栈\",\"642\":\"v-616d4a15#本地方法栈\",\"643\":\"v-616d4a15#线程共有的\",\"644\":\"v-616d4a15#堆\",\"645\":\"v-616d4a15#方法区\",\"646\":\"v-616d4a15#运行时常量池-方法区内部\",\"647\":\"v-616d4a15#字符串常量池\",\"648\":\"v-616d4a15#jvm中对象的创建\",\"649\":\"v-616d4a15#_1-类加载检查\",\"650\":\"v-616d4a15#_2-分配内存\",\"651\":\"v-616d4a15#_3-初始化零值\",\"652\":\"v-616d4a15#_4-设置对象头\",\"653\":\"v-616d4a15#_5-执行-init-方法\",\"654\":\"v-616d4a15#对象的内存布局\",\"655\":\"v-616d4a15#对象的访问定位\",\"656\":\"v-616d4a15#直接指针\",\"657\":\"v-616d4a15#句柄\",\"658\":\"v-654da30e\",\"659\":\"v-654da30e#内存分配和回收原则\",\"660\":\"v-654da30e#对象优先在eden中分配\",\"661\":\"v-654da30e#大对象直接进入老年代\",\"662\":\"v-654da30e#长期存活的对象将进入老年代\",\"663\":\"v-654da30e#gc区域\",\"664\":\"v-654da30e#空间分配担保\",\"665\":\"v-654da30e#死亡对象的判断方法\",\"666\":\"v-654da30e#引用计数法\",\"667\":\"v-654da30e#可达性分析\",\"668\":\"v-654da30e#可以作为gc-roots的对象\",\"669\":\"v-654da30e#对象可以被回收-就代表一定会被回收吗\",\"670\":\"v-654da30e#引用类型总结\",\"671\":\"v-654da30e#如何判断一个常量是废弃常量\",\"672\":\"v-654da30e#如何判断一个类是无用的类\",\"673\":\"v-654da30e#垃圾收集算法\",\"674\":\"v-654da30e#标记-清除算法\",\"675\":\"v-654da30e#复制算法\",\"676\":\"v-654da30e#分代收集算法-hotspot为什么要分代\",\"677\":\"v-654da30e#垃圾回收器\",\"678\":\"v-654da30e#serial-收集器\",\"679\":\"v-654da30e#parnew-收集器\",\"680\":\"v-654da30e#parallel-scavenge-收集器\",\"681\":\"v-654da30e#serial-old收集器\",\"682\":\"v-654da30e#parallel-old-收集器\",\"683\":\"v-654da30e#cms收集器\",\"684\":\"v-654da30e#g1-收集器\",\"685\":\"v-654da30e#cms和g1的异同\",\"686\":\"v-654da30e#到底多大的对象会被直接扔到老年代\",\"687\":\"v-654da30e#cms和g1的stw的区别\",\"688\":\"v-f43459d6\",\"689\":\"v-f43459d6#字节码\",\"690\":\"v-f43459d6#class文件结构总结\",\"691\":\"v-f43459d6#魔数-magic-number\",\"692\":\"v-f43459d6#class-文件版本号-minor-major-version\",\"693\":\"v-f43459d6#常量池-constant-pool\",\"694\":\"v-f43459d6#访问标志-access-flags\",\"695\":\"v-f43459d6#当前类-this-class-、父类-super-class-、接口-interfaces-索引集合\",\"696\":\"v-f43459d6#字段表集合-fields\",\"697\":\"v-f43459d6#方法表集合-methods\",\"698\":\"v-f43459d6#属性表集合-attributes\",\"699\":\"v-5d9b8262\",\"700\":\"v-5d9b8262#类的生命周期\",\"701\":\"v-5d9b8262#类加载过程\",\"702\":\"v-5d9b8262#加载\",\"703\":\"v-5d9b8262#验证\",\"704\":\"v-5d9b8262#准备\",\"705\":\"v-5d9b8262#解析\",\"706\":\"v-5d9b8262#初始化\",\"707\":\"v-5d9b8262#类卸载\",\"708\":\"v-494f04b5\",\"709\":\"v-494f04b5#类加载器\",\"710\":\"v-494f04b5#类加载器的加载规则\",\"711\":\"v-494f04b5#类加载器总结\",\"712\":\"v-494f04b5#自定义类加载器\",\"713\":\"v-494f04b5#双亲委派\",\"714\":\"v-494f04b5#双亲委派模型的执行流程\",\"715\":\"v-494f04b5#双亲委派的好处\",\"716\":\"v-494f04b5#打破双亲委派模型方法\",\"717\":\"v-6cd0e214\",\"718\":\"v-6cd0e214#堆内存相关\",\"719\":\"v-6cd0e214#指定堆内存-xms和-xmx\",\"720\":\"v-6cd0e214#指定新生代内存-young-generation\",\"721\":\"v-6cd0e214#指定永久代-元空间大小\",\"722\":\"v-6cd0e214#垃圾收集器相关\",\"723\":\"v-6cd0e214#垃圾回收器\",\"724\":\"v-6cd0e214#gc-日志记录\",\"725\":\"v-6cd0e214#处理-oom\",\"726\":\"v-6cd0e214#其他\",\"727\":\"v-3c93d317\",\"728\":\"v-3c93d317#确定目标\",\"729\":\"v-3c93d317#最快的gc是不发生gc\",\"730\":\"v-3c93d317#新生代gc调优\",\"731\":\"v-3c93d317#幸存区\",\"732\":\"v-3c93d317#老年代调优\",\"733\":\"v-3c93d317#案例\",\"734\":\"v-3c93d317#案例1\",\"735\":\"v-3c93d317#案例2\",\"736\":\"v-3c93d317#案例3\",\"737\":\"v-64b6db6e\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,14],\"1\":[1],\"2\":[1,33],\"3\":[2,33],\"4\":[1],\"5\":[2,16],\"6\":[2,10],\"7\":[2,39],\"8\":[4,49],\"9\":[2,73],\"10\":[2,33],\"11\":[1],\"12\":[2,35],\"13\":[1,1],\"14\":[1],\"15\":[2,38],\"16\":[2,75],\"17\":[2],\"18\":[2,25],\"19\":[4,14],\"20\":[6],\"21\":[5,14],\"22\":[7,48],\"23\":[5,17],\"24\":[1],\"25\":[1],\"26\":[1],\"27\":[1],\"28\":[1],\"29\":[4,43],\"30\":[6,83],\"31\":[4,16],\"32\":[2,33],\"33\":[2,22],\"34\":[1,38],\"35\":[2,11],\"36\":[1],\"37\":[1],\"38\":[1],\"39\":[1],\"40\":[1],\"41\":[1],\"42\":[1],\"43\":[1],\"44\":[1],\"45\":[1],\"46\":[1],\"47\":[1],\"48\":[1,32],\"49\":[1],\"50\":[1,5],\"51\":[1,14],\"52\":[1,51],\"53\":[1,29],\"54\":[1,32],\"55\":[1,9],\"56\":[1],\"57\":[3,63],\"58\":[3,26],\"59\":[1,23],\"60\":[1,61],\"61\":[1,21],\"62\":[1,54],\"63\":[1,22],\"64\":[1],\"65\":[2,15],\"66\":[2,39],\"67\":[1,9],\"68\":[2],\"69\":[3,5],\"70\":[2,6],\"71\":[1,8],\"72\":[1,2],\"73\":[2,11],\"74\":[2,22],\"75\":[1,20],\"76\":[1],\"77\":[1,18],\"78\":[1,51],\"79\":[1,21],\"80\":[1,28],\"81\":[1,40],\"82\":[1,7],\"83\":[5,30],\"84\":[3,36],\"85\":[3,32],\"86\":[3,13],\"87\":[4],\"88\":[4,6],\"89\":[4,4],\"90\":[2,31],\"91\":[4,3],\"92\":[4,16],\"93\":[3,26],\"94\":[4,8],\"95\":[1,9],\"96\":[1,10],\"97\":[3,57],\"98\":[3,13],\"99\":[1,15],\"100\":[1,35],\"101\":[1,28],\"102\":[4,12],\"103\":[2,29],\"104\":[1,8],\"105\":[3,13],\"106\":[1,3],\"107\":[2,21],\"108\":[1,28],\"109\":[2,29],\"110\":[1,4],\"111\":[1],\"112\":[1,14],\"113\":[3,17],\"114\":[2,17],\"115\":[3,18],\"116\":[1],\"117\":[1,9],\"118\":[1,6],\"119\":[1,8],\"120\":[1,25],\"121\":[1],\"122\":[1,12],\"123\":[1,34],\"124\":[1,9],\"125\":[1,6],\"126\":[2,8],\"127\":[2,5],\"128\":[2,3],\"129\":[1,27],\"130\":[1,9],\"131\":[1,13],\"132\":[2,21],\"133\":[1,13],\"134\":[1],\"135\":[1,10],\"136\":[1,57],\"137\":[1,28],\"138\":[2],\"139\":[2,57],\"140\":[2,9],\"141\":[1,9],\"142\":[4,32],\"143\":[3],\"144\":[2,24],\"145\":[1],\"146\":[2,109],\"147\":[1,21],\"148\":[2,3],\"149\":[2,9],\"150\":[4,36],\"151\":[1,4],\"152\":[3,40],\"153\":[3,30],\"154\":[1],\"155\":[2,81],\"156\":[2,7],\"157\":[3],\"158\":[2,64],\"159\":[3,11],\"160\":[3],\"161\":[2,3],\"162\":[3,11],\"163\":[4],\"164\":[3,8],\"165\":[2,39],\"166\":[1],\"167\":[1],\"168\":[3,9],\"169\":[1],\"170\":[1],\"171\":[1],\"172\":[1,89],\"173\":[1,19],\"174\":[1,102],\"175\":[1,108],\"176\":[1,37],\"177\":[1],\"178\":[4,11],\"179\":[1,40],\"180\":[1,44],\"181\":[5,68],\"182\":[4,17],\"183\":[1],\"184\":[3,17],\"185\":[3,41],\"186\":[1],\"187\":[3],\"188\":[4,66],\"189\":[5,15],\"190\":[6,36],\"191\":[5,88],\"192\":[4],\"193\":[2,26],\"194\":[2,16],\"195\":[3,44],\"196\":[7,9],\"197\":[8,20],\"198\":[4],\"199\":[3,42],\"200\":[3,5],\"201\":[3,32],\"202\":[1,6],\"203\":[1,16],\"204\":[3,20],\"205\":[3,9],\"206\":[1],\"207\":[3],\"208\":[2,9],\"209\":[3,12],\"210\":[5,57],\"211\":[2,22],\"212\":[1],\"213\":[4,44],\"214\":[3,39],\"215\":[1],\"216\":[1],\"217\":[1],\"218\":[1,8],\"219\":[1,68],\"220\":[1,21],\"221\":[6,25],\"222\":[4,29],\"223\":[1],\"224\":[2,6],\"225\":[2,12],\"226\":[1,26],\"227\":[1,7],\"228\":[5,45],\"229\":[1,21],\"230\":[2,15],\"231\":[1,28],\"232\":[2,16],\"233\":[2,5],\"234\":[2,10],\"235\":[2,7],\"236\":[2],\"237\":[3,40],\"238\":[3,35],\"239\":[1,30],\"240\":[2,33],\"241\":[1,34],\"242\":[2,19],\"243\":[1,162],\"244\":[1],\"245\":[1,7],\"246\":[2,4],\"247\":[2,8],\"248\":[2,23],\"249\":[1],\"250\":[1,12],\"251\":[1,12],\"252\":[2,6],\"253\":[2,14],\"254\":[2,10],\"255\":[1],\"256\":[1,15],\"257\":[1],\"258\":[1,8],\"259\":[3,16],\"260\":[1,13],\"261\":[1,40],\"262\":[3,51],\"263\":[4,20],\"264\":[1,22],\"265\":[1],\"266\":[3,25],\"267\":[3,24],\"268\":[1],\"269\":[1,9],\"270\":[1,6],\"271\":[1,64],\"272\":[1,8],\"273\":[1],\"274\":[1,7],\"275\":[1,6],\"276\":[1,6],\"277\":[1,10],\"278\":[1,42],\"279\":[1],\"280\":[1],\"281\":[1],\"282\":[1,66],\"283\":[1],\"284\":[1,48],\"285\":[1,66],\"286\":[4,25],\"287\":[1,33],\"288\":[1,38],\"289\":[2,12],\"290\":[6,25],\"291\":[1,22],\"292\":[3,59],\"293\":[1],\"294\":[1],\"295\":[1],\"296\":[1],\"297\":[3,33],\"298\":[3,13],\"299\":[6,65],\"300\":[4,45],\"301\":[1],\"302\":[5,69],\"303\":[6,49],\"304\":[5,40],\"305\":[2],\"306\":[4,71],\"307\":[2,2],\"308\":[3,21],\"309\":[3,30],\"310\":[5,18],\"311\":[3,77],\"312\":[6,13],\"313\":[4,18],\"314\":[3,34],\"315\":[4,17],\"316\":[4,39],\"317\":[6,27],\"318\":[1,2],\"319\":[1,11],\"320\":[2,15],\"321\":[2,18],\"322\":[4,12],\"323\":[4,9],\"324\":[2,23],\"325\":[1],\"326\":[2,40],\"327\":[1,9],\"328\":[1,41],\"329\":[1],\"330\":[1],\"331\":[1,12],\"332\":[1,16],\"333\":[1,18],\"334\":[1,38],\"335\":[1,18],\"336\":[2,6],\"337\":[2,3],\"338\":[2,20],\"339\":[2,22],\"340\":[5,5],\"341\":[2,8],\"342\":[2,27],\"343\":[2,12],\"344\":[1,8],\"345\":[1,59],\"346\":[2,27],\"347\":[1,2],\"348\":[2,3],\"349\":[2,3],\"350\":[2,43],\"351\":[3],\"352\":[3,6],\"353\":[1,28],\"354\":[3,3],\"355\":[1,11],\"356\":[3,8],\"357\":[1,10],\"358\":[2,8],\"359\":[2,3],\"360\":[2,39],\"361\":[1],\"362\":[3,76],\"363\":[4,22],\"364\":[1,5],\"365\":[1,2],\"366\":[1,10],\"367\":[1,5],\"368\":[3,4],\"369\":[1,11],\"370\":[1,6],\"371\":[1,1],\"372\":[1,14],\"373\":[3],\"374\":[6,69],\"375\":[2,37],\"376\":[2,111],\"377\":[2,31],\"378\":[3,40],\"379\":[3,48],\"380\":[2,63],\"381\":[2,9],\"382\":[1,35],\"383\":[3,33],\"384\":[1,38],\"385\":[1,28],\"386\":[3,11],\"387\":[1,32],\"388\":[1,23],\"389\":[3,24],\"390\":[1,40],\"391\":[1,16],\"392\":[3,19],\"393\":[1,35],\"394\":[1,41],\"395\":[4,19],\"396\":[1,48],\"397\":[1,17],\"398\":[1,18],\"399\":[1,32],\"400\":[1,16],\"401\":[1,38],\"402\":[1,23],\"403\":[1,17],\"404\":[2,14],\"405\":[1,50],\"406\":[1,8],\"407\":[1],\"408\":[1,16],\"409\":[2,22],\"410\":[1,16],\"411\":[2,28],\"412\":[2,15],\"413\":[2,12],\"414\":[2,48],\"415\":[3,29],\"416\":[5,122],\"417\":[1],\"418\":[1,11],\"419\":[1],\"420\":[1,31],\"421\":[1,10],\"422\":[1,42],\"423\":[1],\"424\":[1,11],\"425\":[1,7],\"426\":[1,24],\"427\":[2,15],\"428\":[1,6],\"429\":[1,23],\"430\":[1,51],\"431\":[1,31],\"432\":[1],\"433\":[1],\"434\":[1,13],\"435\":[2,13],\"436\":[3,32],\"437\":[1,34],\"438\":[1,12],\"439\":[2,34],\"440\":[2,4],\"441\":[1,3],\"442\":[2,44],\"443\":[1,9],\"444\":[1,31],\"445\":[1],\"446\":[1,23],\"447\":[1,20],\"448\":[1,51],\"449\":[2,19],\"450\":[2,62],\"451\":[2,28],\"452\":[2,11],\"453\":[1,18],\"454\":[2],\"455\":[1],\"456\":[1,40],\"457\":[2,24],\"458\":[1,33],\"459\":[1,29],\"460\":[1],\"461\":[2,25],\"462\":[3,16],\"463\":[1,53],\"464\":[1],\"465\":[1,5],\"466\":[3,11],\"467\":[3,16],\"468\":[4,9],\"469\":[1,14],\"470\":[1,19],\"471\":[1,17],\"472\":[1,13],\"473\":[2,2],\"474\":[2,3],\"475\":[3,4],\"476\":[1,26],\"477\":[1,9],\"478\":[1],\"479\":[2,8],\"480\":[1,42],\"481\":[1],\"482\":[1],\"483\":[1,7],\"484\":[1,18],\"485\":[3,7],\"486\":[1,37],\"487\":[1,21],\"488\":[3,12],\"489\":[1],\"490\":[1,12],\"491\":[2,10],\"492\":[6,10],\"493\":[1],\"494\":[5,18],\"495\":[2,19],\"496\":[5,12],\"497\":[7,16],\"498\":[4,31],\"499\":[1,33],\"500\":[1],\"501\":[1,13],\"502\":[2,8],\"503\":[1,29],\"504\":[1,8],\"505\":[3,15],\"506\":[1,3],\"507\":[1,41],\"508\":[1,7],\"509\":[1,25],\"510\":[1,11],\"511\":[1,6],\"512\":[1,11],\"513\":[1,10],\"514\":[1,43],\"515\":[1,47],\"516\":[1,7],\"517\":[1,11],\"518\":[1,4],\"519\":[1,15],\"520\":[3,16],\"521\":[3,16],\"522\":[4,18],\"523\":[3,22],\"524\":[3,19],\"525\":[1,7],\"526\":[1],\"527\":[1],\"528\":[1,7],\"529\":[7,20],\"530\":[1,52],\"531\":[1],\"532\":[1,27],\"533\":[2,8],\"534\":[5,14],\"535\":[1],\"536\":[6,19],\"537\":[1,36],\"538\":[4,27],\"539\":[1,50],\"540\":[1,14],\"541\":[1],\"542\":[1],\"543\":[4,26],\"544\":[4,15],\"545\":[2],\"546\":[3,33],\"547\":[3,9],\"548\":[5,18],\"549\":[2,14],\"550\":[4,47],\"551\":[9,29],\"552\":[1],\"553\":[1],\"554\":[1],\"555\":[1,4],\"556\":[1,11],\"557\":[3,8],\"558\":[2,6],\"559\":[2,11],\"560\":[1,8],\"561\":[1,22],\"562\":[2],\"563\":[1,7],\"564\":[2,9],\"565\":[2,3],\"566\":[4,22],\"567\":[3,11],\"568\":[3,18],\"569\":[1],\"570\":[1],\"571\":[1,11],\"572\":[3,6],\"573\":[3,9],\"574\":[1,8],\"575\":[2,20],\"576\":[3,26],\"577\":[1,16],\"578\":[1,15],\"579\":[2,56],\"580\":[1],\"581\":[2,23],\"582\":[2,15],\"583\":[2,26],\"584\":[1,7],\"585\":[1,19],\"586\":[1],\"587\":[4,14],\"588\":[1,13],\"589\":[1,39],\"590\":[5,15],\"591\":[1],\"592\":[3,29],\"593\":[2,12],\"594\":[5,32],\"595\":[2,12],\"596\":[1],\"597\":[1],\"598\":[3,12],\"599\":[1,47],\"600\":[1,34],\"601\":[1],\"602\":[2,6],\"603\":[2,7],\"604\":[2,59],\"605\":[1,44],\"606\":[2,23],\"607\":[2,49],\"608\":[2,16],\"609\":[2,14],\"610\":[1],\"611\":[2,16],\"612\":[5,29],\"613\":[3,45],\"614\":[1,10],\"615\":[1,16],\"616\":[1,10],\"617\":[1,10],\"618\":[1,22],\"619\":[1,17],\"620\":[1,20],\"621\":[1],\"622\":[1,43],\"623\":[1,12],\"624\":[3,92],\"625\":[3,64],\"626\":[3,24],\"627\":[1,32],\"628\":[1,7],\"629\":[2,16],\"630\":[1,21],\"631\":[1,14],\"632\":[1,16],\"633\":[1,21],\"634\":[1,30],\"635\":[1,14],\"636\":[1],\"637\":[1],\"638\":[1],\"639\":[2],\"640\":[1,12],\"641\":[1,26],\"642\":[1,11],\"643\":[2],\"644\":[1,14],\"645\":[1,17],\"646\":[3,20],\"647\":[1,38],\"648\":[1],\"649\":[2,6],\"650\":[2,30],\"651\":[2,8],\"652\":[2,14],\"653\":[4,8],\"654\":[1,22],\"655\":[1,3],\"656\":[1,4],\"657\":[1,8],\"658\":[1],\"659\":[1],\"660\":[1,10],\"661\":[1,6],\"662\":[1,56],\"663\":[1,28],\"664\":[1,29],\"665\":[1],\"666\":[1,11],\"667\":[1,11],\"668\":[4,6],\"669\":[3,16],\"670\":[1,42],\"671\":[2,29],\"672\":[2,28],\"673\":[1],\"674\":[2,15],\"675\":[1,22],\"676\":[2,21],\"677\":[1],\"678\":[2,16],\"679\":[2,26],\"680\":[3,12],\"681\":[2,15],\"682\":[3,15],\"683\":[1,55],\"684\":[2,121],\"685\":[1,33],\"686\":[1,11],\"687\":[1,38],\"688\":[1],\"689\":[1,20],\"690\":[1],\"691\":[4,13],\"692\":[6,24],\"693\":[4,44],\"694\":[4,20],\"695\":[8,38],\"696\":[3,13],\"697\":[3,18],\"698\":[3,24],\"699\":[1],\"700\":[1,30],\"701\":[1],\"702\":[1,9],\"703\":[1,46],\"704\":[1,38],\"705\":[1,28],\"706\":[1,38],\"707\":[1,17],\"708\":[1],\"709\":[1,13],\"710\":[1,17],\"711\":[1,69],\"712\":[1,42],\"713\":[1,40],\"714\":[1,87],\"715\":[1,14],\"716\":[1,19],\"717\":[1],\"718\":[1],\"719\":[4,9],\"720\":[4,22],\"721\":[2,48],\"722\":[1],\"723\":[1,16],\"724\":[2,53],\"725\":[2,61],\"726\":[1,84],\"727\":[1],\"728\":[1,6],\"729\":[1,30],\"730\":[1,21],\"731\":[1,8],\"732\":[1,10],\"733\":[1],\"734\":[1,7],\"735\":[1,15],\"736\":[1,8],\"737\":[1]},\"averageFieldLength\":[1.9119241192411922,24.803225402657564],\"storedFields\":{\"0\":{\"h\":\"关于\",\"t\":[\"杭州某电计算机专业研二学生，java菜鸟，摸鱼王者，摄影爱好者。\",\"网站用于收集Java知识点，记录学习笔记，秋招面经。\",\"希望能对学Java的同学提供一点帮助。\",\"笔记来源：JavaGuide和bilibili等网课，有删改。\",\"终将美好，我们的春夏秋冬。\"]},\"1\":{\"h\":\"操作系统\"},\"2\":{\"h\":\"操作系统的功能\",\"t\":[\"进程和线程的管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等。\",\"存储管理：内存的分配和管理、外存（磁盘等）的分配和管理等。\",\"文件管理：文件的读、写、创建及删除等。\",\"设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。\",\"网络管理：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。\",\"安全管理：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。\"]},\"3\":{\"h\":\"什么是用户态和内核态？\",\"t\":[\"用户态：又称为目态，用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些特权指令的时候就会发生系统调用，让用户态变成内核态。\",\"内核态：又称为管态，内核态运行的进程集合可以访问计算机的任何资源，拥有非常高的权限，当操作系统接收到进程的系统调用请求时，就会从用户态切换为内核态，执行响应的系统调用，并将结果返回给进程，最后再从内核态切换为用户态。\",\"用户态切换到内核态的三种方式：\",\"系统调用：用户态进程主动要求切换到内核态的一种方式；\",\"中断：当外围设备完成用户请求操作之后，会向CPU发出响应的中断信号，CPU响应的时候切换到核心态。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。\",\"异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。\"]},\"4\":{\"h\":\"进程和线程\"},\"5\":{\"h\":\"什么是进程和线程？\",\"t\":[\"进程：值得是计算机中正在运行的程序实例，是操作系统中拥有资源的基本单位。\",\"线程：引入线程之后，CPU调度的最小单位变成线程，线程又称为轻量级进程。\",\"对于Java来说，一个进程能拥有很多个线程，多个线程共享进程的堆和方法区（JDK1.8之后的元空间），但是每个线程都有自己的程序计数器，虚拟机栈和本地方法栈（线程私有）。\"]},\"6\":{\"h\":\"有了进程为什么还需要线程?\",\"t\":[\"进程切换的成本大于线程切换。\",\"线程更加轻量，一个进程能创建多个线程。\",\"多个线程能并发处理不同的任务，有效利用CPU资源。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞就会挂起直到结果返回。\",\"同一个进程的线程共享内存和文件，因此线程之间的相互通信无需调用内核。\"]},\"7\":{\"h\":\"线程间的同步的方式有哪些？\",\"t\":[\"互斥锁(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。\",\"读写锁（Read-Write Lock）：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。\",\"信号量(Semaphore)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。\",\"屏障（Barrier）：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 CyclicBarrier 是这种机制。\",\"事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。\"]},\"8\":{\"h\":\"PCB 是什么？包含哪些信息？\",\"t\":[\"PCB（Process Control Block） 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。你可以将 PCB 视为进程的大脑。\",\"当操作系统创建一个新进程时，会为该进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块。当进程执行时，PCB 中的信息会不断变化，操作系统会根据这些信息来管理和调度进程。\",\"PCB 主要包含下面几部分的内容：\",\"进程的描述信息，包括进程的名称、标识符等等；\",\"进程的调度信息，包括进程阻塞原因、进程状态（就绪、运行、阻塞等）、进程优先级（标识进程的重要程度）等等；\",\"进程对资源的需求情况，包括 CPU 时间、内存空间、I/O 设备等等。\",\"进程打开的文件信息，包括文件描述符、文件类型、打开模式等等。\",\"处理机的状态信息（由处理机的各种寄存器中的内容组成的），包括通用寄存器、指令计数器、程序状态字 PSW、用户栈指针。\"]},\"9\":{\"h\":\"进程间的通信方式有哪些？\",\"t\":[\"管道/匿名管道(Pipes)：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。\",\"有名管道(Named Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循 先进先出(First In First Out) 。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。\",\"信号(Signal)：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\",\"消息队列(Message Queuing)：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。\",\"信号量(Semaphores)：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。\",\"共享内存(Shared memory)：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\",\"套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\"]},\"10\":{\"h\":\"什么是僵尸进程和孤儿进程？\",\"t\":[\"僵尸进程：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。\",\"孤儿进程：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。\"]},\"11\":{\"h\":\"内存管理\"},\"12\":{\"h\":\"什么是内存碎片？\",\"t\":[\"内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（2^7） 大小的内存，那 63 字节的内存就成为了内部内存碎片。（固定分区分配）\",\"外部内存碎片(External Memory Fragmentation，简称为外部碎片)：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并为分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。没有分配的内存多出的碎片。（动态分区分配）\"]},\"13\":{\"h\":\"分段分页\",\"t\":[\"...\"]},\"14\":{\"h\":\"文件系统\"},\"15\":{\"h\":\"硬链接和软链接有什么区别？\",\"t\":[\"1、硬链接（Hard Link）\",\"是对原文件起了一个别名。\",\"（1）文件有相同的 inode 及 data block；\",\"（2）只能对已存在的文件进行创建；\",\"（3）不能交叉文件系统进行硬链接的创建；\",\"（4）不能对目录进行创建，只可对文件创建；\",\"（5）删除一个硬链接文件并不影响其他有相同inode 号的文件。\",\"2、软链接（Symbolic Link 或 Symlink）\",\"又被叫为符号链接（symbolic Link），它包含了到原文件的路径信息。\",\"文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。（快捷方式）\",\"本质区别\",\"硬链接：本质是同一个文件\",\"软链接：本质不是同一个文件\"]},\"16\":{\"h\":\"常见的磁盘调度算法有哪些？\",\"t\":[\"先来先服务算法（First-Come First-Served，FCFS）：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。\",\"最短寻道时间优先算法（Shortest Seek Time First，SSTF）：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF 算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。\",\"扫描算法（SCAN）：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。\",\"循环扫描算法（Circular Scan，C-SCAN）：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。\",\"边扫描边观察算法（LOOK）：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。\",\"均衡循环扫描算法（C-LOOK）：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。\"]},\"17\":{\"h\":\"I/O\"},\"18\":{\"h\":\"何为IO？\",\"t\":[\"I/O（Input/Outpu） 即输入／输出 。\",\"从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。\",\"当应用程序发起 I/O 调用后，会经历两个步骤：\",\"内核等待 I/O 设备准备好数据\",\"内核将数据从内核空间拷贝到用户空间。\"]},\"19\":{\"h\":\"有哪些常见的 IO 模型?\",\"t\":[\"UNIX 系统下， IO 模型一共有 5 种：同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。\"]},\"20\":{\"h\":\"Java 中 3 种常见 IO 模型\"},\"21\":{\"h\":\"BIO (Blocking I/O)\",\"t\":[\"BIO 属于同步阻塞 IO 模型 。\",\"同步阻塞IO模型中，应用程序发起read调用后，会一直阻塞，知道内核把数据拷贝到用户空间。\",\"在客户端连接数量不高的情况下是没有问题的，但是当并发数量增大的时候，传统的BIO模型是无能为力的，会导致多线程阻塞，响应不了其他请求。\"]},\"22\":{\"h\":\"NIO (Non-blocking/New I/O)\",\"t\":[\"Java中的NIO于Java 1.4中引入，对应Java.nio包，提供了Channel,Selector,Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。支持面向缓冲，基于通道的I/O操作方法。对于高负载、高并发的应用，应使用NIO。\",\"Java中的NIO可以看做是I/O多路复用模型。\",\"在同步非阻塞IO模型中，应用程序会一直发起read调用，等待数据从内核空间拷贝到用户空间的这段时间，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。相比于同步阻塞IO模型，同步非阻塞IO模型确实有很大的改进，通过轮训操作避免了一直阻塞。但是这种IO模型仍然存在问题：应用程序不断进行I/O系统调用论文数据是否已经准备好的过程是很消耗CPU资源的。\",\"IO多路复用模型中，线程首先发起select调用，查询内核数据是否准备就绪，等内核把数据准备好了，用户再发起read调用。read调用的过程（数据从内核空间->用户空间）还是阻塞的。\",\"IO多路复用模型，通过减少无效的系统调用，减少了对CPU资源的消耗。\",\"Java中的NIO有一个非常重要的选择器（Selector）概念，称为多路复用器。通过它只需要一个线程便可以管理多个客户端连接，当客户端数据到了之后才会为其服务。\"]},\"23\":{\"h\":\"AIO (Asynchronous I/O)\",\"t\":[\"AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2，它是异步 IO 模型。\",\"异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\"]},\"24\":{\"h\":\"比较\"},\"25\":{\"h\":\"计算机基础\"},\"26\":{\"h\":\"数据库\"},\"27\":{\"h\":\"框架\"},\"28\":{\"h\":\"MyBatis\"},\"29\":{\"h\":\"#{} 和 ${} 的区别是什么？\",\"t\":[\"${}是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc. Driver。\",\"#{}是 sql 的参数占位符，MyBatis 会将 sql 中的#{}替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，#{item.name} 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName()。可以有效防止sql注入问题。\"]},\"30\":{\"h\":\"Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？\",\"t\":[\"通常一个 xml 映射文件，都会写一个 Dao 接口与之对应。Dao 接口就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 MappedStatement 的 id 值，接口方法内的参数，就是传递给 sql 的参数。\",\"在 MyBatis 中，每一个 <select>、 <insert>、 <update>、 <delete> 标签，都会被解析为一个 MappedStatement 对象。\",\"Dao 接口里的方法可以重载（多个同名方法，但是参数不同），但是 MyBatis 的 xml 里面的 id 不允许重复。\",\"<select id=\\\"getAllStu\\\" resultType=\\\"com.pojo.Student\\\"> select * from student <where> <if test=\\\"id != null\\\"> id = #{id} </if> </where> </select> \",\"Dao接口方法名对应 MappedStatement 的 id；\",\"Dao接口参数对应 #{id}；\",\"Dao接口返回值类型对应 MappedStatement 的resultType。\",\"Dao接口的全路径名对应xml文件中的namespace。\",\"MyBatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。\",\"Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 MappedStatement 所代表的 sql，然后将 sql 执行结果返回。如果有多个sql则不知道执行哪个了。\"]},\"31\":{\"h\":\"MyBatis的xml映射文件中，不同的xml映射文件，id是否可以重复？\",\"t\":[\"不同的xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复。\",\"namespace+id是作为 Map<String,MappedStatement>的key使用的，如果没有namespace，就剩下id，id重复就会导致数据覆盖，有了namespace，并且不同，则可以使用相同的id，因为key不再重复。\"]},\"32\":{\"h\":\"MyBatis的xml映射文件和MyBatis内部数据结构的映射关系？\",\"t\":[\"MyBatis 将所有 xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 xml 映射文件中， <parameterMap> 标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。 <resultMap> 标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个 <select>、<insert>、<update>、<delete> 标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。\"]},\"33\":{\"h\":\"属性名和字段名不一致如何解决？\",\"t\":[\"查询的SQL语句使用别名处理。\",\"通过resultMap来设置字段和属性的映射关系。以下列举将表中level_id字段映射为属性名levelId。\",\"<resultMap type=\\\"com.member.entity.MemberEntity\\\" id=\\\"memberMap\\\"> <result property=\\\"id\\\" column=\\\"id\\\"/> <result property=\\\"levelId\\\" column=\\\"level_id\\\"/> </resultMap> \"]},\"34\":{\"h\":\"MyBatis中的分页\",\"t\":[\"分页分为逻辑分页和物理分页两种。\",\"逻辑分页：在服务器返回给客户端的时候进行分页，实际查询的仍然是所有的数据。\",\"物理分页：从数据查询的时候就进行分页，查询的数据不是全部。\",\"MyBatis 使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页；\",\"可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。\",\"物理分页就是对SQL进行改造：\",\"select * from xxx --> select t.* from (select * from xxx) t limit 0,10 \",\"通过添加插件的方式进行分页：\",\"@Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } \"]},\"35\":{\"h\":\"MyBatis中的执行器有哪些？\",\"t\":[\"SimpleExecutor：简单的执行器，每次执行操作都会开启一个新的Statement对象，用完就会立即关闭。\",\"ReuseExecutor：复用的执行器，实现了对Statement对象的复用。\",\"BatchExecutor：可执行批处理任务的执行器。\",\"每一个执行器都是在SqlSession执行的生命周期内拿到的。\"]},\"36\":{\"h\":\"欢迎\"},\"37\":{\"h\":\"Java\"},\"38\":{\"h\":\"计算机基础\"},\"39\":{\"h\":\"数据库\"},\"40\":{\"h\":\"中间件云原生\"},\"41\":{\"h\":\"框架\"},\"42\":{\"h\":\"笔记\"},\"43\":{\"h\":\"面经\"},\"44\":{\"h\":\"拍拍\"},\"45\":{\"h\":\"关于\"},\"46\":{\"h\":\"Java\"},\"47\":{\"h\":\"Nginx\"},\"48\":{\"h\":\"静态Web配置\",\"t\":[\"server{ listen 80; server_name localhost; location /abc { root /html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location / } \",\"listen\",\"监听可以配置成IP或端口或IP+端口。\",\"listen 127.0.0.1:8080、listen 8080、listen *:8080。\",\"server_name\",\"主要用于区分，可以随便起，可以使用$hostname配置成主机名。\",\"location\",\"location /abc{ root /html; index index.html index.htm; } \",\"表示访问/目录会去子目录html中寻找页面或资源。也就是说访问/abc就会被追加到root目录之后，成为/html/abc。\"]},\"49\":{\"h\":\"反向代理和Header\"},\"50\":{\"h\":\"正向代理与反向代理\",\"t\":[\"在客户端代理转发请求称为正向代理。例如VPN。\",\"在服务端代理转发请求称为反向代理。例如Nginx。\"]},\"51\":{\"h\":\"配置反向代理\",\"t\":[\"server{ listen 80; Server_name localhost; location / { proxy_pass http://localhost:8080/ } } \",\"访问80端口会被路由到本机的8080端口，但是在路由的时候会丢失Header。\"]},\"52\":{\"h\":\"设置代理请求headers\",\"t\":[\"用户可以重新定义或追加header信息传递给后端服务器。\",\"proxy_set_header Host $proxy_host; proxy_set_header Connection close; \",\"由于使用反向代理之后，后端无法获取用户的真实IP，所以一般反向代理都会设置以下header信息。\",\"location /{ proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:8080/ } \",\"常用的变量值：\",\"$host：nginx主机IP；\",\"$http_host：nginx主机IP和端口；\",\"$proxy_host：localhost:8080，proxy_pass里面配置的主机名和端口；\",\"$remote_addr：用户的真实IP，也就是客户端IP。\",\"proxy_pass说明\",\"如果proxy_pass的地址只配置到/，不包括URI，location将被追加到转发地址中。\",\"location /some/ { proxy_pass http://localhost:8080/; } \",\"访问http://localhost/some/page.html会被代理到http://localhost:8080/some/page.html。\",\"如果proxy_pass的地址包括URI，那么location将不会被追加到转发地址中。\",\"location /some/ { proxy_pass http://localhost:8080/zh-cn/; } \",\"访问http://localhost/some/page.html会被代理到http://localhost:8080/zh-cn/page.html。\"]},\"53\":{\"h\":\"动静分离\",\"t\":[\"server { listen 81; server_name localhost; location ~ \\\\.(css|js|png|jpg|gif|ico) { root /home/static; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } \",\"将静态资源放入nginx服务器的static目录中，则所有以(css|js|png|jpg|gif|ico)结尾的文件都会在这个文件夹中寻找。\"]},\"54\":{\"h\":\"修饰符\",\"t\":[\"location可以使用正则表达式。包括：\",\"=：等于，严格匹配，优先级最高；\",\"^~：前缀匹配，表示普通匹配字符，如果匹配成功，不再匹配其他location，优先级第二；\",\"~：正则匹配，区分大小写，优先级第三；\",\"~*：正则匹配，不区分大小写，优先级第三。\",\"不写修饰符：优先级最低。\",\"location ^~ /img/ { root /host/static; } \",\"例如请求/img/a.jpg会请求/host/static/img/a.jpg，资源都是在root后拼接路径，不同于proxy_pass。\"]},\"55\":{\"h\":\"动静分离的好处\",\"t\":[\"Tomcat主要用来处理servlet请求。处理像css、js、图片这些静态文件的IO性能不好，因此将静态文件交给nginx处理，可以提高系统访问速度，减少Tomcat的请求次数，有效减少后端压力。\"]},\"56\":{\"h\":\"缓冲与缓存\"},\"57\":{\"h\":\"缓冲（buffer）\",\"t\":[\"缓冲一般放在内存中，如果不适合放入内存（超过了指定大小），则会将响应临时写入磁盘中。\",\"启用缓冲之后，nginx先将后端的请求响应（response）放入缓冲区中，等到整个响应完成再返回给客户端。\",\"客户端往往是用户网络，情况复杂，可能出现网络不稳定，速度很慢的情况。\",\"而nginx和后端server一般处于同一个机房或者区域，网速稳定且快。\",\"如果禁用了缓冲，则在客户端从代理服务器接收响应时，响应将同步发送给客户端，对于需要尽快开始接收响应的快速交互式客户端是可取的。但是如果客户端网速很慢，导致nginx只能以较慢的速度将响应传给客户端，进而导致后端server也只能以同样较慢的速度传递响应给nginx，造成一次请求连接耗时较长。\",\"在高并发的情况下，后端server可能会出现大量的连接积压，最终拖垮server端。\",\"开启代理缓冲之后，nginx以尽可能快的速度将响应读入缓冲区中，同时根据客户端网络质量以合适的网速将响应传递给客户端。\",\"这样既解决了server端连接过多的问题，也能保证持续稳定的向客户端传递响应。\",\"通过proxy_buffering启用和禁用缓冲区，默认为on。\",\"proxy_buffering on; \",\"proxy_buffers设置每个连接读取响应的缓冲区的数量和大小。\",\"来自后端服务器响应的第一部分存储在单独的缓冲区中，大小通过proxy_buffer_size进行设置，此部分通常是相对较小的headers，通常设置成小于默认值。\",\"location / { proxy_buffers 16 4K; proxy_buffer_size 2K; proxy_pass http://localhost:8080; } \",\"如果整个响应不适合放入内存中，则将其中的一部分保存至磁盘的临时文件中。\",\"proxy_max_temp_file_size设置临时文件的最大值。\",\"proxy_temp_file_write_size设置一次写入临时文件的大小。\"]},\"58\":{\"h\":\"缓存（cache）\",\"t\":[\"启用缓存后，nginx将响应保存在磁盘中，返回给客户端的数据首先在缓存中取，这样相同的请求不用每次都发送给后端服务器，减少到后端请求的数量。\",\"通过proxy_cache_path指定缓存路径名称和大小。\",\"缓存区可以被多个server共享，使用proxy_cache指定缓存区。\",\"http { proxy_cache_path /data/nginx/cache keys_zone=mycache:10m; server { proxy_cache mycache; location / { proxy_pass http://localhost:8000; } } } \"]},\"59\":{\"h\":\"负载均衡\",\"t\":[\"跨多个应用程序实例的负载均衡是一种常用的技术，用于优化资源利用率，最大化吞吐量，减少延时，容灾。nginx将流量分配到多个服务器，可以提升服务器性能，提高扩展性和可靠性。\",\"通过配置upstream实现多个服务器的负载均衡。\",\"upstream apps { server http://localhost:8080; server http://localhost:8081; } server { listen 80; server_name localhost; location / { proxy_pass http://apps; } } \"]},\"60\":{\"h\":\"负载均衡策略\",\"t\":[\"负载均衡策略有：轮训，最小连接，ip_hash，hash，权重，随机。\",\"轮训机制（round-robin）：默认的负载均衡策略，以轮训方式分发请求。\",\"最小连接（least-connected）：将下一个请求分配给最小连接的服务器（较为空闲的服务器）。\",\"upstream apps { least-conn; server http://localhost:8080; server http://localhost:8081; } \",\"注意\",\"使用轮训或者最小连接会让每一个客户端的请求分发到不同的服务器上，不能保证同一个客户端将始终定位到同一个服务器，因此不能会话保持。\",\"ip_hash：客户端的IP地址将计算哈希键，来自同一个ip的请求会分发到同一台服务器。\",\"upstream apps { ip_hash; server http://localhost:8080; server http://localhost:8081; } \",\"如果某个时刻对应的服务器宕机，还是会导致同一个ip请求转发到其他的服务器，引发缓存失效，路由失效等连锁反应。\",\"因此有了一致性hash算法。\",\"一致性hash算法：通用hash，允许用户自定义hash，key可以是配对的源ip地址和端口，也可以是URI。\",\"upstream apps { hash $request_uri consistent; server http://localhost:8080; server http://localhost:8081; } \",\"consistent参数启用ketama一致哈希算法，如果在上游服务器组中添加或者删除服务器，只会重新映射部分键，最大限度减少缓存失效。\",\"权重方式：在server服务器后面添加参数weight参数指定权重，权重越大，分得请求的概率越大，不写默认为1。\",\"server http://localhost:8080 weight=3; \",\"随机方式：随机挑选N个服务器，在N个服务器中选择一台发送请求，默认是连接数最小的机器。\",\"upstream apps { random two least_conn; server http://localhost:8080; server http://localhost:8081; server http://localhost:8082; } \"]},\"61\":{\"h\":\"健康检查\",\"t\":[\"如果后端服务器在某个周期内响应失败的次数超过规定值，nginx将会标记服务器为失败，后续的周期不再分发请求给这个服务器。\",\"通过fail_timeout来设置检查周期，默认为10秒。\",\"通过max_fails来设置失败次数，默认是1次。\",\"upstream apps { server http://localhost:8080; server http://localhost:8081 max_fails=3 fail_timeout=30s; } \"]},\"62\":{\"h\":\"Https配置\",\"t\":[\"server { listen 443 ssl; #表示监听443端口即https server_name ylzhong.top; #域名 ssl_certificate ./ylzhong.top_nginx/ylzhong.top_bundle.crt; #证书文件路径 ssl_certificate_key ./ylzhong.top_nginx/ylzhong.top.key; #证书私钥文件路径 ssl_session_timeout 5m; #5分钟session会话保持 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { root /usr/share/nginx/html/dist; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } \"]},\"63\":{\"h\":\"TCP反向代理\",\"t\":[\"http反向代理使用http模块，TCP反向代理使用stream模块。可以用来负载均衡连接MySQL，Redis等。\",\"http { ... } stream { upstream backend-mysql { server localhost:3306; #定义连接池空闲连接的数量，可以避免打开频繁的打开和关闭连接，相当于线程池里的核心线程数 keepalive 8; } server { listen 13306; proxy_pass backend-mysql; } } \"]},\"64\":{\"h\":\"重写\"},\"65\":{\"h\":\"重写-return\",\"t\":[\"转发是服务端行为，重定向是客户端行为。\",\"server { ... return 301 https://localhost:8000; ... } \",\"重定向的地址如果写成localhost会造成重定向错误，会在本机中进行地址映射也就是IP地址127.0.0.1，而不是服务器中。301表示永久重定向。\"]},\"66\":{\"h\":\"重写-rewrite\",\"t\":[\"server { rewrite ^(/download/.*)/media/(/w+)\\\\.?.*$ $1/mp3/$2.mp3 last; rewrite ^(/download/.*)/audio/(/w+)\\\\.?.*$ $1/mp3/$2.ra last; } \",\"^表示正则开始，$表示结束。\",\".*中.表示匹配任何字符，*表示前面的正则出现0或者多次。\",\"/w+匹配出现1次或者多次任意字母或者数字。\",\"\\\\.是.的转义。?表示前面的转义出现0或者1次。\",\"$1、$2是截取前面括号中匹配的内容。\",\"例如访问/download/cnd-west/media/file1就会变成/download/cdn-west/mp3/file1.mp3。如果文件有扩展名也会被删除，\\\\.?.*就是匹配. 开头的字符串或者是空串。\",\"last与break\",\"last：rewrite之后停止后续正则匹配处理，使用重写后的路径，重新搜索location。\",\"break：rewrite之后停止后续正则匹配处理，使用重写后的路径，执行余下的块内指令。\"]},\"67\":{\"h\":\"RabbitMQ\",\"t\":[\"消息队列是一种用于在应用程序之间传递消息的通信方式，消息队列允许应用程序异步的发送和接收消息，并且不需要直接连接到对方。\",\"可以把消息队列看作是一个存放消息的容器，需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于队列Queue是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。\"]},\"68\":{\"h\":\"消息队列有什么用？\"},\"69\":{\"h\":\"通过异步处理提高系统性能（减少响应所需时间）\",\"t\":[\"项目中订单取消之后的解锁库存操作可以通过消息队列实现，订单取消之后发送一个库存释放任务到消息队列中，由库存模块中的监听器完成库存解锁和释放，订单模块不需要等待库存释放完成才返回。\"]},\"70\":{\"h\":\"削峰/限流\",\"t\":[\"秒杀场景中，开始秒杀时创建秒杀订单具有很大的峰值，通过消息队列减少同时创建订单的任务数，创建订单任务先放入消息队列中，再由数据库创建订单。\"]},\"71\":{\"h\":\"降低系统耦合性\",\"t\":[\"订单模块负责订单取消，库存模块负责库存解锁释放，两者通过消息队列实现通信，降低耦合度。如果有新的消费者上线，只需要将消费者关联到这个消息队列中，原有系统不会改变。\"]},\"72\":{\"h\":\"实现分布式事务\",\"t\":[\"分布式事务的解决办法之一就是MQ事务。\",\"☀️详见分布式事务\"]},\"73\":{\"h\":\"使用消息队列会带来哪些问题？\",\"t\":[\"系统可用性降低：需要额外考虑消息队列服务出错的处理办法。\",\"系统复杂度提高：加入消息队列之后，需要考虑消息重复消费，消息丢失，保证消息传递顺序等问题。\",\"一致性问题：如果消息没有被正确的消费，就会带来一致性问题。\"]},\"74\":{\"h\":\"AMQP是什么？\",\"t\":[\"AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 高级消息队列协议（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容JMS（JAVA Message Service，java 消息服务）。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。AMQP天然具有跨平台、跨语言特性。\"]},\"75\":{\"h\":\"RPC和消息队列的区别\",\"t\":[\"RPC和消息队列都是分布式系统中重要的组件之一。\",\"从用途来看：RPC主要解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过RPC可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。消息队列主要用来降低系统耦合性、实现任务异步、有效地进行流量削峰。\",\"从通信方式来看：RPC是双向直接网络通讯，消息队列是单向引入中间载体的网络通讯。\",\"从架构上来看：消息队列需要把消息存储起来，RPC则没有这个要求，因为前面也说了RPC是双向直接网络通讯。\",\"从请求处理的时效性来看：通过RPC发出的调用一般会立即被处理，存放在消息队列中的消息并不一定会立即被处理。\"]},\"76\":{\"h\":\"常见的消息队列\"},\"77\":{\"h\":\"Kafka\",\"t\":[\"项目中使用的消息队列是 RabbitMQ，Kafka仅做介绍。\",\"Kafka是LinkedIn开源的一个分布式流式处理平台，已经成为Apache顶级项目，早期被用来用于处理海量的日志，后面才慢慢发展成了一款功能全面的高性能消息队列。\",\"具有三个关键功能：\",\"消息队列：发布和订阅消息流，功能类似消息队列。\",\"容错的持久方式存储记录消息流：Kafka会把消息持久化到磁盘，有效避免了消息丢失的风险。\",\"流式处理平台：在消息发布的时候进行处理，Kafka提供了一个完整的流式处理类库。\"]},\"78\":{\"h\":\"RabbitMQ\",\"t\":[\"RabbitMQ是采用Erlang语言实现AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。\",\"可靠性：RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。\",\"灵活的路由：在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。\",\"扩展性：多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。\",\"高可用性：队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。\",\"支持多种协议：RabbitMQ除了原生支持AMQP协议，还支持 STOMP、MQTT等多种消息中间件协议。\",\"多语言客户端：RabbitMQ几乎支持所有常用语言，比如Java、Python、Ruby、PHP、C#、JavaScript 等。\",\"易用的管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。\",\"插件机制：RabbitMQ提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。\"]},\"79\":{\"h\":\"RabbitMQ和Kafka区别\",\"t\":[\"RabbitMQ在吞吐量方面虽然稍逊于Kafka，但是由于它基于Erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。\",\"Kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时Kafka最好是支撑较少的topic 数量即可，保证其超高吞吐量。Kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略，这个特性天然适合大数据实时计算以及日志收集。\"]},\"80\":{\"h\":\"介绍下RabbitMQ\",\"t\":[\"RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。\",\"RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。\"]},\"81\":{\"h\":\"RabbitMQ特点\",\"t\":[\"可靠性：RabbitMQ使用一些机制保证可靠性，例如持久化、传输确认以及发布确认。\",\"灵活的路由：在消息进入队列之前，通过交换器来路由消息。\",\"扩展性：多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。\",\"高可用性：队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。\",\"多种协议：RabbitMQ除了原生支持AMQP协议，还支持STOMP，MQTT等多种消息 中间件协议。\",\"跨语言：RabbitMQ几乎支持所有常用语言，比如Java、Python、Ruby、PHP、C#、JavaScript 等。\",\"管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。\",\"插件机制：RabbitMQ提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。\"]},\"82\":{\"h\":\"RabbitMQ组成\",\"t\":[\"RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。从计算机术语层面来说，RabbitMQ 模型更像是一种交换器模型。\"]},\"83\":{\"h\":\"Producer（生产者）和Consumer（消费者）\",\"t\":[\"Producer(生产者) :生产消息的一方;\",\"Consumer(消费者) :消费消息的一方。\",\"消息一般由 2 部分组成：消息头和 消息体。消息体也可以称为 payLoad，消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。\"]},\"84\":{\"h\":\"Exchange（交换器）\",\"t\":[\"在 RabbitMQ 中，消息并不是直接投递到Queue（消息队列）中，中间还必须经过Exchange（交换器），交换器会根据路由键和路由方式将消息发送给对应的Queue中。\",\"Exchange用来接收生产者发送的消息并将这些消息路由给服务器中的队列，如果路由不到则会返回给Producer（生产者）或者直接丢失。\",\"RabbitMQ的Exchange有4种类型，不同的类型对应着不同的路由策略：direct（默认），fanout，topic和headers。\",\"生产者将消息发给交换器的时候需要指定一个RoutingKey（路由键），用来指定这个消息的路由规则，而这个RoutingKey需要与交换器类型和绑定键BindingKey联合使用才能生效。\",\"RabbitMQ 中通过Binding（绑定）将Exchange与Queue关联起来，在绑定的时候一般会指定一个BindingKey（绑定键），这样 RabbitMQ 就知道如何正确将消息路由到队列了，如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange和Queue的绑定可以是多对多的关系。\",\"Bindkey就像路由表中的一个表项，指明了响应的RoutingKey应该投递到哪个队列。\"]},\"85\":{\"h\":\"Queue（消息队列）\",\"t\":[\"Queue（消息队列）用来保存消息直到发送给消费者。是消息的容器也是终点，一个消息可以投入一个或者多个队列中。\",\"RabbitMQ中消息只能存储在队列中，这一点和Kafka相反。Kafka将消息存储在topic(主题)这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。\",\"事件被组织并持久地存储在Topic中，Topic类似于文件系统中的文件夹，事件就是该文件夹中的文件。Kafka中的Topic始终是多生产者和多订阅者：一个Topic可以有零个、一个或多个生产者向其写入事件，也可以有零个、一个或多个消费者订阅这些事件。Topic中的事件可以根据需要随时读取，与传统的消息中间件不同，事件在使用后不会被删除，相反，可以通过配置来定义Kafka中每个Topic应该保留事件的时间，超过该事件后旧事件将被丢弃。Kafka的性能在数据大小方面实际上是恒定的，因此长时间存储数据是非常好的。\",\"多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样可以避免重复消费。\"]},\"86\":{\"h\":\"Broker（消息中间件的服务节点）\",\"t\":[\"对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作一个RabbitMQ服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。\",\"下图展示了生产者将消息存入RabbitMQ Broker，以及消费者从Broker中消费数据的整个流程。\",\"由于RabbitMQ是以byte[]为单位进行传输的，因此消息需要序列化和反序列化。\"]},\"87\":{\"h\":\"Exchange Types（交换器类型）\"},\"88\":{\"h\":\"1、fanout（广播）\",\"t\":[\"fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以fanout类型是所有的交换器类型里面速度最快的。fanout类型常用来广播消息。\"]},\"89\":{\"h\":\"2、direct（精确匹配）\",\"t\":[\"direct类型的Exchange路由规则也很简单，它会把消息路由到那些Bindingkey与RoutingKey完全匹配的Queue中。\",\"可能匹配的队列有多个。\"]},\"90\":{\"h\":\"3、topic\",\"t\":[\"topic类型的交换器在匹配规则上进行了扩展，它与direct类型的交换器相似，也是将消息路由到BindingKey和RoutingKey相匹配的队列中，但这里的匹配规则有些不同，它约定：\",\"RoutingKey为一个点号.分隔的字符串（被点号.分隔开的每一段独立的字符串称为一个单词），如 com.rabbitmq.client、java.util.concurrent、com.hidden.client;\",\"BindingKey和RoutingKey一样也是点号.分隔的字符串；\",\"BindingKey中可以存在两种特殊字符串*和#，用于做模糊匹配，其中*用于匹配一个单词，#用于匹配零个或者多个单词。\",\"例如BindKey为#.com，则所有以com结尾的路由键消息都会匹配，*.*.com，则路由键必须有三个单词，且最后一个单词是com才会匹配，例如yl.zhong.com。\"]},\"91\":{\"h\":\"4、headers(不推荐)\",\"t\":[\"headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。\"]},\"92\":{\"h\":\"说说Broker服务节点、Queue队列、Exchange交换器？\",\"t\":[\"Broker：可以看做RabbitMQ的服务节点。一般情况下一个Broker可以看做一个RabbitMQ服务器。\",\"Queue：RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。\",\"Exchange：生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。\"]},\"93\":{\"h\":\"什么是死信路由，如何产生的？\",\"t\":[\"DLX，全称为 Dead-Letter-Exchange，死信交换器，死信邮箱。当消息在一个队列中变成死信 (dead message) 之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX，绑定DLX的队列就称之为死信队列。\",\"导致的死信的几种原因：\",\"消息被拒（Basic.Reject /Basic.Nack）且requeue = false。\",\"消息TTL过期。\",\"队列满了，无法再添加。\"]},\"94\":{\"h\":\"什么是延迟队列？RabbitMQ 怎么实现延迟队列？\",\"t\":[\"延时队列指的是存储对应的延时消息，消息被发送给队列之后，并不会立刻让消费者得到消息，而是等待一段时间之后才会消费消息。\",\"RabbitMQ本身没有延时队列，可以通过本身的队列特性，需要使用死信交换机和消息存活的TTL。\"]},\"95\":{\"h\":\"消息的TTL\",\"t\":[\"TTL就是消息的存活时间，RabbitMQ可以对队列和消息分别设置TTL。\",\"对队列设置TTL，也可以为每一个消息单独设置TTL，如果两个都设置了会选择较小值。通过expiration或者x-message-ttl属性来设置过期时间。\"]},\"96\":{\"h\":\"模拟订单过期解锁库存\",\"t\":[\"订单创建的时候在延时队列中添加库存解锁信息，信息过期的时候表明订单也就过期了，进入死信路由DLX，接着转发到解锁库存的队列中，在解锁前还需要检查订单是否支付（支付宝中采用最大努力交付，用户还可通过接口主动查询支付结果），没有支付则释放库存和取消订单（取消订单可以通过信息发送给相应的订单解锁队列）。\"]},\"97\":{\"h\":\"RabbitMQ 消息怎么传输？\",\"t\":[\"由于TCP链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以RabbitMQ 使用信道的方式来传输数据。\",\"信道（Channel）是生产者、消费者与RabbitMQ通信的渠道，信道是建立在 TCP 链接上的虚拟链接，且每条TCP链接上的信道数量没有限制。就是说RabbitMQ在一条TCP链接上建立成百上千个信道来达到多个线程处理，这个TCP被多个线程共享，每个信道在RabbitMQ都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。\",\"Broker：中间件本身。接收和分发消息的应用，这里指的就是RabbitMQ Server。\",\"Virtual host：虚拟主机。出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange／queue等。\",\"Connection：连接。publisher／consumer和Broker之间的TCP连接。断开连接的操作只会在client端进行，Broker不会断开连接，除非出现网络故障或Broker服务出现问题。\",\"Channel：渠道。如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP 。\",\"Connection的开销会比较大且效率也较低。Channel是在Connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的Channel进行通讯，AMQP method包含了Channel Id帮助客户端和Message Broker识别Channel，所以Channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP Connection的开销。\"]},\"98\":{\"h\":\"如何保证消息的可靠性，防止消息丢失？\",\"t\":[\"生产者到RabbitMQ：事务的Confirm机制，事务和confirm机制不能同时存在。\",\"RabbitMQ自身：持久化、集群、普通模式、镜像模式。\",\"RabbitMQ到消费者：basicACK机制、死信队列、消息补偿机制。\"]},\"99\":{\"h\":\"confirmCallback\",\"t\":[\"消息从producer——>exchange，会回调confirmCallback，重写confirm方法有3个参数：\",\"correlationData：相关配置信息；\",\"ack：exchange交换机是否成功收到信息，true成功，false失败；\",\"cause：失败原因；\",\"producer端发送消息需要添加异常处理，防止发送途中MQ宕机。\"]},\"100\":{\"h\":\"returnCallback\",\"t\":[\"消息从exchange——>queue，当交换机到队列路由失败时才会执行returnCallback 。\",\"rabbitTemplate.setMandatory(true);//设置交换机处理失败消息的模式，如果不设置，默认会丢失消息，设置为true，则会执行returnMessage方法，将消息返回给生产者。 rabbitTemplage.setReturnCallback(new RabbitTemplate.ReturnCallback(){ @Override public void returnMessage(Message message, int replyCode, String replyText, String exchange, String routingKey){ System.out.println(\\\"return 执行了\\\"); } }); \"]},\"101\":{\"h\":\"ack\",\"t\":[\"ack指Acknowledge，确认，表示消费者收到消息后的确认方式。\",\"有3种确认方式：\",\"自动确认：acknowledge=\\\"none\\\"；\",\"手动确认：acknowledge=\\\"manual\\\"；\",\"根据异常情况确认：acknowledge=\\\"auto\\\"。\",\"其中自动确认是指一旦消息被consumer收到，则自动确认收到，并将相应的message从RabbitMQ缓存中移除，但在实际业务处理中，很可能消息接收到但是业务处理出现异常，那么该消息就会丢失。\",\"如果设置了手动确认模式，则在业务处理成功后，调用channel.basicAck()手动签收，如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息。\"]},\"102\":{\"h\":\"如何保证 RabbitMQ 消息的顺序性？\",\"t\":[\"一个 queue (消息队列)是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。\"]},\"103\":{\"h\":\"RabbitMQ消息积压如何处理？\",\"t\":[\"消息生产太快，消费不过来，导致队列堆积很长，把服务器内存耗尽，这时RabbitMQ的处理能力很低下。 总结起来解决方案大体包括：\",\"增加消费者的处理能力，或减少发布频率，增加消费端实例。说白了就是增加机器。\",\"如果申请机器行不通，毕竟公司的机器是有限的，此时可以增加消费端的消费能力。在MQ的配置中配置\\\"最大消费者数量\\\"与\\\"每次从队列中获取的消息数量\\\"。\",\"考虑使用队列最大长度限制，RabbitMQ 3.1支持。\",\"给消息设置年龄，超时就丢弃。\",\"发送者发送流量太大上线更多的消费者，紧急上线专门用于记录消息的队列，将消息先批量取出来，记录数据库，离线慢慢处理。\"]},\"104\":{\"h\":\"Docker\",\"t\":[\"Docker是一个应用打包、分发、部署的工具。\",\"可以把它理解为一个轻量级的虚拟机，它只虚拟软件需要运行的环境，多余的不要，而普通的虚拟机则是一个完整而庞大的系统。\"]},\"105\":{\"h\":\"打包、分发、部署\",\"t\":[\"打包：把软件运行需要的依赖、第三方库、软件打包在一起成为一个安装包。\",\"分发：可以把打包好的文件上传到一个镜像仓库，其他用户可以轻松获取。\",\"部署：使用安装包就能通过一个命令运行应用，不管是在Win/Mac/Linux环境中。\"]},\"106\":{\"h\":\"Docker部署的优势\",\"t\":[\"确保了应用能在不同的机器上使用相同的环境运行，不会出现从开发到部署环境不兼容的问题。\"]},\"107\":{\"h\":\"镜像、容器\",\"t\":[\"镜像：可以理解为软件安装包，方便传播和安装。\",\"容器：软件安装之后的状态，每个软件在docker中的运行环境都是独立的、隔离的，称之为容器。\",\"docker run -d -p 6379:6379 --name redis redis:latest; \",\"运行上述命令会先去下载镜像redis:latest，之后在6379端口运行，本机的6379端口映射到docker中的6379端口，容器的名称为redis。\"]},\"108\":{\"h\":\"Docker挂载目录\",\"t\":[\"docker run -p 80:80 --name nginx \\\\ -v /mydata/nginx/html:/usr/share/nginx/html \\\\ -v /mydata/nginx/logs:/var/log/nginx \\\\ -v /mydata/nginx/conf:/etc/nginx \\\\ -d nginx:latest \",\"nginx:latest拉去最新的nginx镜像，-p映射本机端口80到容器中。-v表示挂载目录，将目录 /mydata/nginx/html映射到/usr/share/nginx/html，这样在目录 /mydata/nginx/html中添加文件，nginx容器就能直接读取，其他同理。\"]},\"109\":{\"h\":\"Docker-Compose\",\"t\":[\"如果每个虚拟机中需要创建很多的容器，一个一个运行命令很麻烦。\",\"可以使用docker-compose把项目的多个服务集合到一起，一键运行。\",\"创建docker-compose.yml文件，写入：\",\"services: redis: image: redis:latest volumes: - redis: /data environment: - TZ=Asia/Shanghai \",\"在docker-compose.yml文件所在目录，执行docker-compose up就能运行安装。\",\"关于查看运行状态，停止，重启docker-compose命令和docker命令结构是相同的。\",\"docker-compose stop \"]},\"110\":{\"h\":\"分布式事务\",\"t\":[\"订单微服务中，下单的同时请求库存微服务减少库存，整个过程就是一个分布式事务。\"]},\"111\":{\"h\":\"分布式基础理论\"},\"112\":{\"h\":\"CAP\",\"t\":[\"CAP是Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性，可用性，分区容错性。\",\"商品信息管理案例\",\"采用读写分离的数据库集群模式。\",\"整体执行过程：\",\"商品服务请求主数据库写入商品信息。\",\"主数据库向商品服务响应写入成功。\",\"商品服务请求从数据库读取商品信息。\"]},\"113\":{\"h\":\"C-Consistency 一致性\",\"t\":[\"写操作之后读操作能获得最新的数据。\",\"商品信息要满足一致性需要：\",\"写主数据库成功，则向从数据库查询新数据也成功。\",\"写主数据库失败，则向从数据库查询新数据也失败。\",\"如何实现一致性？\",\"写入主数据库后要将数据同步到从数据库。\",\"写入完成之后的数据同步时，需要将从数据库锁定，防止请求查询到旧数据。\",\"分布式系统一致性的特点：\",\"由于数据同步的过程，写操作的响应有一定的延时。\",\"为了保证数据一致性会对资源进行锁定，待数据同步完成再释放资源。\"]},\"114\":{\"h\":\"A-Availability可用性\",\"t\":[\"任何事务操作都可以得到响应结果，且不会出现响应超时或者错误。\",\"商品信息满足可用性需要：\",\"从数据库接收到数据查询的请求则能立即响应数据查询结果。\",\"从数据库不允许出现响应超时或者错误。\",\"如何实现可用性？\",\"写入主数据库后数据同步到从数据库。\",\"由于要保证数据库的可用性，不能将数据库进行锁定。\",\"即使数据库没有同步完成，从数据库也要返回结果，即使结果是旧数据，但不能响应错误或者超时。\",\"分布式系统可用性特点：\",\"所有请求都有响应，并且不会出现响应错误或者响应超时。\"]},\"115\":{\"h\":\"P-Partition tolerance分区容错性\",\"t\":[\"分布式系统部署在不同的子网，不可避免出现由于网络问题而导致的节点之间通信失败，对此仍然可以对外提供服务，称为分区容错性。\",\"商品信息满足分区容错性需要：\",\"主数据库向从数据库同步失败不影响读写操作。\",\"其一个节点挂掉不影响另外一个节点对外服务。\",\"如何实现分区容错性？\",\"尽量使用异步取代同步，例如使用异步将主数据库的数据同步到从数据库。\",\"添加数据库节点，其中一个挂掉，另外一个仍然能工作。\",\"分布式系统分区容错性的特点：\",\"分区容错性是分布式系统最基本的能力。\",\"在所有分布式事务场景中不会同时具备CAP三个特性，满足P的前提下C和A是不能共存的。\"]},\"116\":{\"h\":\"CAP组合方式\"},\"117\":{\"h\":\"AP\",\"t\":[\"放弃一致性，追求分区容错性和可用性，这是多数分布式系统设计时的选择。\",\"通常实现AP都会保证最终一致性，BASE理论就是根据AP扩展来，例如订单退款，不要求立即到账，只要最终会退款即可。\"]},\"118\":{\"h\":\"CP\",\"t\":[\"放弃可用性，追求分区容错性和一致性，Zookeeper其实就是追求强一致性。例如跨行转账，需要等待双方银行系统都完成整个事务才算完成。\"]},\"119\":{\"h\":\"CA\",\"t\":[\"放弃分区容错性，追求一致性和可用性，不考虑网络挂掉的情况，那么系统就不是一个分布式系统。\",\"上述商品系统管理如果要实现CA，则可以使用一个数据库，这样就不存在分布式系统。\"]},\"120\":{\"h\":\"BASE理论\",\"t\":[\"BASE是Basically Available(基本可用)、Soft State(软状态)和Eventually Consistent(最终一致性)三个短语的缩写。是AP组合模式的拓展，允许数据库在一段时间内不一致，但最终达到一致状态，称为”柔性事务“。\",\"基本可用：分布式系统出现故障时，允许损失部分可用功能，保证其余功能可用。\",\"软状态：由于不要求强一致性，BASE理论允许系统出现中间状态（软状态），这个状态不影响系统可用性。\",\"最终一直：经过一段时间之后，所有节点的数据都会达到一致性。\"]},\"121\":{\"h\":\"分布式事务解决方案\"},\"122\":{\"h\":\"2PC\",\"t\":[\"两阶段提交，将事物变成两个阶段，准备阶段（prepare phase）和提交阶段（commit phase）。\",\"整个事务过程由事务管理器管理。\",\"实现方案：XA、Seata。\"]},\"123\":{\"h\":\"TCC\",\"t\":[\"TCC是Try、Confirm、Cancel三个词语的缩写，TCC要求每个分支事务实现三个操作：预处理Try、确认Confirm、撤销Cancel。\",\"TCC分为三个阶段︰\",\"Try阶段是做业务检查(一致性)及资源预留(隔离)，此阶段仅是一个初步操作，它和后续的Confirm一起才能真正构成一个完整的业务逻辑。\",\"Confirm阶段是做确认提交，Try阶段所有分支事务执行成功后开始执行Confirm。通常情况下，采用 TCC则认为Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引入重试机制或人工处理。\",\"Cancel阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用ICC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。\",\"TM事务管理器\",\"TM事务管理器可以实现为独立的服务，也可以让全局事务发起方充当TM的角色，TM独立出来是为了成为公用组件，是为了考虑系统结构和软件复用。\"]},\"124\":{\"h\":\"TCC和2PC的区别\",\"t\":[\"2PC通常都是在跨库的DB层面，而TCC则是在应用层面处理，需要通过业务逻辑实现，这种分布式事务的实现方式可以让应用自己定义数据操作的粒度、降低锁冲突、提高吞吐量。\",\"不足在于TCC对应用的侵入很大，实现难度也大。\"]},\"125\":{\"h\":\"可靠消息最终一致性\",\"t\":[\"可靠消息最终一致性指的是事务发起方执行完本地事务之后发出一条消息，事务参与方一定能接受消息并处理事务成功，此方案强调的是只要消息发给事务参与放最终事务要达到一致，通过消息队列中间件完成。\",\"为了实现可靠消息最终一致性需要解决以下几个问题：\"]},\"126\":{\"h\":\"1.本地事务与消息发送的原子性\",\"t\":[\"本地事务与消息发送的原子性问题即事务发起方在本地事务执行成功后消息必须发出去，否则就丢弃消息。即实现本地事务和消息发送的原子性，要么都成功，要么都失败。本地事务与消息发送的原子性问题是实现可靠消息最终—致性方案的关键问题。\"]},\"127\":{\"h\":\"2.事务参与方接收消息的可靠性\",\"t\":[\"消费者方（事务参与方）需要正确接收到消息，如果接收失败可以重复接收消息。\"]},\"128\":{\"h\":\"3.消息重复消费问题\",\"t\":[\"对于接收到重复的消息应该只能有一个执行结果，需要完成事务参与方的方法幂等性。\"]},\"129\":{\"h\":\"RocketMQ事务消息方案\",\"t\":[\"RocketMQ是来自阿里巴巴的分布式消息中间件，事务消息设计主要是为了解决Producer端发送消息与本地事务执行的原子性问题，其中的broker与producer端的双向通信能力使得broker天生可以作为一个事务的协调者存在，RocketMQ本身也为事务消息提供了持久化能力。\",\"在MQ发送方将消息成功发送给MQ Server时，消息还是处于不能消费的状态，如果收到MQ Server的确认，则会去调用本地事务，本地事务成功后通知MQ Server将消息Commit，此时订阅方可消费。\",\"如果本地事务出现问题，则会向MQ Server发送Rollback，将消息删除，这样就能保证本地事务和消息发送的原子性。\",\"第5步骤的回查事务状态，如果发现发送方有事务已经提交，则MQ Server会主动修改消息状态，即使没有收到MQ发送方发送的Commit。\",\"从MQ Server到MQ订阅方部分采用ACK确认机制，只要MQ订阅方没有返回ACK则会一直给他消费。\",\"☀️详见RabbitMQ\"]},\"130\":{\"h\":\"总结\",\"t\":[\"RocketMQ主要解决了分布式事务中的两个问题：\",\"本地事务与消息发送的原子性问题。\",\"事务参与方接收消息的可靠性问题。\",\"可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景，引入消息机制后，同步的事物变成了基于消息执行的异步事务，避免了分布式事务中的同步阻塞操作的影响，并实现了服务的解耦。\"]},\"131\":{\"h\":\"最大努力通知\",\"t\":[\"发起通知方通过一定机制最大努力将业务处理结果通知到接收方。\",\"具体包括：\",\"有一定的消息重复通知机制。\",\"消息的校对机制。\",\"例如支付宝支付成功之后会向对应的接口发送异步通知，如果不对接口返回确认，则过一段时间之后支付宝会再次发送通知，称为消息重复机制。\",\"发送次数变多仍然没有收到确认之后，支付宝就会将时间间隔变大进行异步通知，此外服务器可以通过支付宝给的接口主动去查询支付结果，称为消息的校对机制。\"]},\"132\":{\"h\":\"最大努力通知和可靠消息一致性的区别？\",\"t\":[\"解决思想不同\",\"可靠消息一致性，发起通知方需要保证将消息发送出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。\",\"最大努力通知，发起通知方尽最大努力将业务处理结果通知接收通知方，但是消息可能接收不到，此时需要通过接口查询业务处理结果，通知的可靠性关键在接收通知方。\",\"两者的业务场景不同\",\"可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易。\",\"最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去。\",\"技术解决方向不同\",\"可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。\",\"最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。\"]},\"133\":{\"h\":\"最大努力通知解决方案\",\"t\":[\"以支付宝支付系统为例。\",\"业务执行触发可以看成支付事务，支付结果通过发起通知方发送到消息队列中，并通过单独的通知程序定期通知给调用方。发起通知方，MQ，通知程序，可以看成支付宝管理的部分，接收方则可以看成我们自己。\",\"此方案主要用于外部应用之间的通知，例如支付宝，微信支付结果通知。\"]},\"134\":{\"h\":\"中间件云原生\"},\"135\":{\"h\":\"简历项目详解\",\"t\":[\"八股经历大约两个月终于是啃（抄）完了，得上点硬菜了，以下针对我简历上的三个项目进行复习。\",\"包含谷粒商城，黑马点评，三更博客。（点击跳转B站网课）\"]},\"136\":{\"h\":\"谷粒商城\",\"t\":[\"项目整体较为复杂，项目中可能会涉及到的疑问点参考诚哥的博客文章秋招笔记整理。\",\"首先是简历部分：\",\"恐龙商城 2022.3-2022.8 springcloud，springsecurity，springboot，mybatis，redis，rabbitmq，sentinel，nginx, docker 商城页面由Nginx代理实现动静分离，请求负载均衡，拆分为网关，订单，购物车，秒杀等微服务。 实现单点登录，商品缓存快速查询，订单创建幂等性。秒杀遵从服务单一职责，独立部署，定时上架，库存预热快速扣减，秒杀连接加密，恶意请求拦截，流量错峰，后端限流，队列削峰。 ● 网关微服务实现集群状态下的负载均衡，使得来自同一个主域名的不同请求分发到对应的微服务。 ● Redis存储Token，SpringSecurity完成多微服务下的用户登录验证和状态刷新。 ● SpringSchedule定时任务上架秒杀商品。 ● 前端限流，后端验证登录，Sentinel框架熔断降级的流量错峰保证在秒杀高流量的情况下项目稳定。 ● Redis验证秒杀中的一人一单，信号量Semaphore实现库存的快速扣减，解决并发安全问题。 ● RabbitMq完成秒杀订单创建，实现队列削峰，减少数据库压力，采用手动ack确保订单创建成功。 ● RabbitMq延时队列模拟订单过期，过期订单的解锁订单和解锁库存流程通过RabbitMq消息队列实现。 \",\"为什么叫做恐龙商城？因为诚哥写的就是恐龙商城，哥们照抄的✨。\",\"下面逐句进行分析。\"]},\"137\":{\"h\":\"介绍下项目的技术选型\",\"t\":[\"项目中使用到的技术栈为springcloud，springboot，mybatis，redis，rabbitmq，sentinel，nginx，docker，使用springcloud（Nacos作为注册中心和配置中心，简化多服务器的管理，并将项目拆分为多个微服务（模块），微服务之间使用openFeign调用，mybatis作为数据库框架，redis作为缓存，分布式锁，rabbitmq用来队列削峰，sentinel用来熔断降级限流，主要用在秒杀部分，nginx用来动静分离，负载均衡，docker容器化部署，zipkin用作链路追踪，分析请求到每个模块的运行耗时，另外还用到了jmeter进行压力测试，visualVM查看堆内存情况。\"]},\"138\":{\"h\":\"商城页面由Nginx代理实现动静分离，请求负载均衡\"},\"139\":{\"h\":\"Nginx反向代理在计算机网络的第几层？\",\"t\":[\"Nginx反向代理包含7层反向代理（应用层）和4层反向代理（传输层）两种。\",\"7层代理是写在http模块中的，而4层代理是写在stream模块中，与http模块并列。\",\"4层代理是基于ip和端口转发的，基于TCP/UDP协议。\",\"7层代理可以 基于url和ip以及cookie和请求头进行分流。\",\"七层代理写法：\",\"http { # 写在http模块中基于内容和协议的交换 nginx代理服务器其实建立了两次TCP连接 upstream web { server 192.168.1.100:80; server 192.168.1.101:80; } server { listen 80; location / { proxy_pass http://web; root html; index index.html index.htm; } } } \",\"四层代理写法：\",\"stream { # 写在stream中 基于ip和端口进行转发 实际上是修改了请求头中的目标ip和端口 server { listen 30028; proxy_pass appserver; } upstream appserver { server 10.0.0.12:8080; server 10.0.0.13:8080; } } \",\"4层代理设备将client发送报文中的目标地址（原来为4层代理的ip地址）修改为目标内部服务器的地址，这样client就可以和server建立TCP连接并发送数据。 在stream中，server一定要配置port，proxy_pass配置行直接加集群名，**不能加http:// **。\",\"在本项目中，upstream使用的是七层代理的配置方法。\"]},\"140\":{\"h\":\"Nginx的负载均衡算法有哪些？\",\"t\":[\"详见☀️Nginx负载均衡\",\"负载均衡策略有：轮训，最小连接，ip_hash，hash，权重，随机。\"]},\"141\":{\"h\":\"Nginx动静分离\",\"t\":[\"项目编译完成之后会产生一些不会发生变化的静态文件，放入到nginx的html目录下，通过nginx配置进行获取这些静态文件，后端tomcat服务器应该用来处理请求而不是返回这些静态数据。开启nginx缓冲（buffer）之后还能解决高并发下的连接积压问题（server端到nginx端的连接）。\"]},\"142\":{\"h\":\"Nginx反向代理怎么配置的？反向代理跟正向代理的区别是什么？nginx可以配置正向代理吗？\",\"t\":[\"详见☀️正向代理和反向代理\",\"反向代理通过在location里添加proxy_pass进行请求代理\",\"http { # 写在http模块中基于内容和协议的交换 nginx代理服务器其实建立了两次TCP连接 upstream web { server 192.168.1.100:80; server 192.168.1.101:80; } server { listen 80; location / { proxy_pass http://web; root html; index index.html index.htm; } } } \",\"正向代理通过客户端代理转发请求，例如VPN。反向代理通过服务端代理转发请求例如Nginx反向代理。\",\"Nginx可以配置正向代理，例如A能访问外网，BCD不能访问外网但是能访问A，则可以通过正向代理将请求代理转发给A进行外网访问。（类似VPN代理模式）\"]},\"143\":{\"h\":\"拆分为网关，订单，秒杀等微服务\"},\"144\":{\"h\":\"分微服务的原则是什么？\",\"t\":[\"单一职责原则：每个微服务应该只负责一个特定的业务功能。例如网关微服务只用来做请求转发，秒杀微服务只做秒杀，即使因为高流量导致秒杀微服务宕机也不会影响到正常的订单微服务。\",\"业务领域驱动划分：根据应用程序的业务需求和领域知识来对服务进行划分。同上，每一个微服务需要做的业务清晰明了。\",\"最小可行服务：在进行微服务划分时，应该尽量保持服务的粒度足够小，以降低系统复杂性和提高灵活性。拆分成微服务之后，各个微服务之间的调用变得更加灵活。\",\"高内聚低耦合：微服务划分应该追求高内聚低耦合的原则。各个微服务之间的耦合度应该尽可能的小。\",\"数据自治原则：每个微服务应该对其所使用的数据有完全的控制权。每一个微服务都对自己所属的数据库架构有完全控制权。\",\"技术多样性：微服务架构允许使用不同的技术栈来实现不同的服务。\"]},\"145\":{\"h\":\"实现单点登录\"},\"146\":{\"h\":\"单点登录怎么实现的？\",\"t\":[\"使用SpringSecurity框架实现。\",\"首先需要考虑用户的数据应该存储在哪。\",\"如果使用session保存用户数据则会导致其他的服务器无法获取用户数据。\",\"如果使用cookie存储用户数据，由于cookie存储在客户端，容易篡改，不安全。\",\"采用nginx的hash一致性负载均衡算法，让所有来源相同的请求定位到同一个服务器，但是如果服务器宕机，则数据会丢失，不可行。\",\"本项目使用Redis进行用户数据统一存储。添加依赖之后将session存储方式改为redis。\",\"项目课程中使用SpringSession进行登录数据存储，后续改为SpringSecurity框架实现认证授权功能。\",\"在配置类中添加了jwtAuthenticationTokenFilter(OncePerRequestFilter的实现类，每次请求都会拦截)，和UsernamePasswordAuthenticationFilter.class。\",\"其中登录的密码查询是需要自己去实现接口UserDetailsService，并重写方法。\",\"@Service public class UserDetailServiceImpl implements UserDetailsService { @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { //根据用户名查询用户信息 LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>(); wrapper.eq(User::getUserName, username); User user = userMapper.selectOne(wrapper); //判断是否查到用户 如果没有查到则抛出异常 if (Objects.isNull(user)) { throw new RuntimeException(\\\"用户不存在\\\"); } //TODO 查询权限信息封装 return new LoginUser(user); } } \",\"返回值为实现接口UserDetails的LoginUser类。\",\"UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken);//通过UserDetails实现类查询用户账号和密码，并进行认证 \",\"密码编码器：\",\" @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } \",\"认证整体流程：\",\"用户提交用户名、密码被SecurityFilterChain中的 UsernamePasswordAuthenticationFilter过滤器获取到， 封装为Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。\",\"然后过滤器将Authentication提交至认证管理器（AuthenticationManager<<interface>>，实现类为ProviderManager，内部包含DaoAuthenticationProvider用来查找用户数据并认证）进行认证authenticationManager.authenticate(authenticationToken)，通过UserDetailsService实现类获取包含用户账号密码的UserDetails实现类 ，密码加密解密通过PasswordEncoder实现类BCryptPasswordEncoder完成，认证成功则返回Authentication，否则返回空。通过.getPrincipal从Authentication中获取用户数据（UserDetails的实现类）。\",\"认证成功之后通过userId生成JWT返回给前端，封装用户部分数据保存到Redis中，Redis数据的key是\\\"LOGIN:\\\"+userId。\",\"SecurityContextHolder 安全上下文容器将第2步填充了信息的 Authentication ，通过 SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。\",\"SecurityContextHolder可以看成一个ThreadLocal用来在一次会话中共享数据。\",\"上述流程在分布式下有时候不能保持登录状态，可以将用户数据保存至Redis中。\"]},\"147\":{\"h\":\"分布式下的用户登录状态保持\",\"t\":[\"第二次会话时开启新的线程就会导致不能获取之前的用户数据，不能保持登录状态。\",\"可将Redis作为分布式下用户数据的存储介质。\",\"在第二步认证成功之后通过userId生成JWT返回给前端，封装用户部分数据保存到Redis中，Redis数据的key是\\\"LOGIN:\\\"+userId。\",\"添加OncePerRequestFilter过滤器，需要重写doFilterInternal方法，每次请求都会被拦截。如果请求中没有携带token则表示是不需要登录的请求，直接放行，携带了token通过JWT工具类进行解密获得userId，如果解密为有效的userId，则可以作为key（\\\"LOGIN:\\\"+userId）去Redis中找到用户数据，并添加到SecurityContextHolder中，这样只要客户端保存正确的token就能保持登录状态。\",\"登录状态续期可以通过给Redis添加新的过期时间进行续期。\"]},\"148\":{\"h\":\"项目中用到了哪些SpringSecurity过滤器？\",\"t\":[\"UsernamePasswordAuthenticationFilter用来做用户认证，OncePerRequestFilter用来做请求拦截并根据情况做业务处理之后放行。\"]},\"149\":{\"h\":\"如果想要用户仅仅在一段时间内免登录怎么办？\",\"t\":[\"在OncePerRequestFilter过滤器添加Redis数据的时候加上过期时间，在通过key（\\\"LOGIN:\\\"+userId）获取Redis数据失败的时候则认为是用户的免登录时间已经过期。（用户数据在Redis中过期，则需要重新登录并将用户数据保存至Redis，返回新的Token）\"]},\"150\":{\"h\":\"JWT（Token）如何生成的？\",\"t\":[\"详见☀️15分钟学会JWT的使用\",\"使用JJWT生成JWT。\",\"JWT由三个部分构成，用.拼接：\",\"Header，包含类型和加密算法，此部分通过BASE64加密之后得到第一个部分（需要一个Key作为秘钥）。\",\"{ \\\"typ\\\":\\\"jwt, \\\"alg\\\":\\\"HS256\\\" } \",\"Payload，载荷，用于存放主要信息，通过BASE64加密之后得到TOKEN的第二个部分。\",\"{ \\\"sub\\\":\\\"123456\\\", \\\"name\\\":\\\"zyl\\\", } \",\"Signature，通过对Header和Payload进行再次加密得到的数据再通过HS256加盐得到最终的Signature。\",\"String encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload); String signature = HMACSHA256(encodedString, secret); \",\"​ 最后HS256加盐算法中的秘钥secret也可以通过BASE64加密获得。\"]},\"151\":{\"h\":\"商品缓存快速查询\",\"t\":[\"项目中使用SpringCache作为缓存框架。使用@Cacheable快速添加返回结果到缓存。\"]},\"152\":{\"h\":\"数据更新之后对缓存如何操作？缓存一致性解决办法？\",\"t\":[\"缓存一致性的解决方案有 双写模式 和 失效模式。\",\"双写模式：对数据库进行数据修改之后，会接着把新数据写入Redis。\",\"失效模式：对数据库进行数据修改之后，会让旧的缓存数据失效，SpringCache中的@CacheEvict执行缓存失效。\",\"双写模式下如果有两个数据同时写数据库，执行流程：1修改数据库，2修改数据库，2更新缓存，1更新缓存，这样会导致现在的缓存数据是1修改的数据，并不是后执行的2修改的数据，存在暂时脏数据问题，需要等到缓存失效之后才能得到最新的正确数据。\",\"失效模式下如果有三个进程，1修改数据库，1删除缓存，3查询缓存没有，3读数据库，2修改数据库，2删除缓存，3更新缓存，此时缓存中为旧数据，同样存在脏数据问题。\",\"两种方式都会存在脏数据问题，只能通过添加过期时间缓解，对于经常变化的数据就应该直接查询数据库，放入缓存的数据应该是变化度不高的数据。\",\"如果硬要解决缓存一致性问题，可以在并发读写，写写下加锁，读读不需要添加锁。（不建议）\",\"不要过度设计\",\"缓存只要保证最终一致性不需要强一致性，为了强一致性牺牲可用性不划算。\"]},\"153\":{\"h\":\"缓存穿透，缓存雪崩，缓存击穿问题\",\"t\":[\"详见☀️缓存穿透，缓存雪崩，缓存击穿\",\"缓存穿透：查询空数据，解决：缓存空数据并添加过期时间、布隆过滤器。\",\"缓存雪崩：大量的key失效，解决：添加随机过期时间。\",\"缓存击穿：热点key失效，解决：使用同步锁控制只能有一个线程去数据库中查询数据并更新缓存，秒杀场景下商品的过期时间应该在秒杀场结束之后。\",\"@Cacheable(value = {\\\"category\\\"}, key = \\\"#root.method.name\\\",sync = true) //默认是没有加锁的 所以没有解决缓存击穿问题 使用sync=true 进行加锁 本地锁 \",\"常规数据使用SpringCache可以满足大部分要求。\"]},\"154\":{\"h\":\"订单创建幂等性\"},\"155\":{\"h\":\"订单创建的幂等性如何实现？\",\"t\":[\"当用户点击多次提交订单的时候应该保证只会产生一个唯一的订单，也就是接口的幂等性。\",\"实现方式为从购物车页面点击确认订单的时候会在后端生成一个防重令牌，令牌的Key和memberId有关，值为随机生成的UUID，并将令牌放入Redis中，返回令牌到前端。\",\"此时前端提交订单的时候就会将令牌进行提交，后端从数据库中获取对应的令牌，如果比对成功则创建订单并将令牌删除，否则不会创建订单。这样就保证了在确认页面只有第一次点击订单能创建成功。\",\"多线程下验证令牌和删除令牌的过程应该是原子性的，所以使用Lua脚本实现。\",\"String script = \\\"if redis.call('get', KEY[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\\\"; String orderToken = vo.getOrderToken(); Long execute = template.execute(new DefaultRedisScript<Long>(script, Long.class), Arrays.asList(OrderConstant.USER_ORDER_TOKEN_PREFIX + memberResponseVo.getId()), orderToken); \",\"execute方法传入三个参数，分别是 Lua脚本，KEYS，ARGV。\",\"验证成功之后再次验证价格，保存订单数据（商品信息，价格），锁定库存（库存模块完成，发生异常则能本地回滚），如果库存锁定成功则发送订单消息给队列创建订单（订单号，商品编号，价格，收货人，订单状态等）。\",\"为了防止库存锁定之后订单服务出现问题，应该设置库存释放的死信队列，存活时间大于订单的释放时间，超时之后检查订单是否是取消状态，取消状态进行库存释放。需要注意一个订单只会释放一次库存，因此库存工作单中需要添加字段保证只会释放一次库存，项目中库存的释放统一由一个队列完成，因此不会存在并发问题。由于库存工作单存在状态标识，重复的库存释放消息只会执行一次。\",\"如果订单支付成功，则支付宝会进行异步回调，此时可以发送订单已支付消息到队列中修改订单状态。\"]},\"156\":{\"h\":\"延时关单如何实现的？\",\"t\":[\"使用RabbitMQ的死信队列实现，将队列添加x-message-ttl属性，让消息在一定时间之后成为死信交给死信交换机，后续可进行库存释放操作。\"]},\"157\":{\"h\":\"秒杀遵从服务单一职责，独立部署，定时上架\"},\"158\":{\"h\":\"秒杀的流程是啥样的？\",\"t\":[\"秒杀开始前通过@Scheduled进行定时上架商品，查询近期的秒杀场次，保存至Redis用于后续秒杀的时间和场次合法性校验，查询SKU信息保存至Redis加速查询，同时通过UUID生成随机码保存到SKU详情数据。\",\"秒杀商品的信号量key为SKU_STOCK_SEMAPHORE + token，token是生成的SKU随机码，通过semaphore.trySetPermits(seckillSkuVo.getSeckillCount())设置对应SKU信号量的许可证数量（秒杀库存数量）。\",\"秒杀开始判断用户是否登录，登录的话进行合法性校验，包含当前所处时间是否处于秒杀时间，检验随机码是否正确（在秒杀开始时返回到前端的随机码，用于防止恶意请求），验证购买数量是否超额。\",\"合法性校验通过之后进行占位（防止一个用户并发秒杀），使用SETNX进行占位（原子操作），key为userId+'_'+skuId，同时还需要添加过期时间，过期时间为场次结束时间-当前时间，让一个用户只能对同一个商品秒杀一次。遵从请求的幂等性。\",\"boolean b = semaphore.tryAcquire(num, 100, TimeUnit.MILLISECONDS)如果获取信号量成功则表示秒杀成功，将OrderSn，UserId，SkuId，SeckillSkuPrice，Num，PromotionSessionId封装发送到RabbitMQ的order-event-exchange交换机，路由键为order.seckill.order，返回OrderSn到前端，前端可以使用一个页面让用户选择收货地址。\",\"SETNX占位成功表示这个用户没有买过商品，通过Redssion的Semaphore。\",\"等待一段时间之后如果没有出现差错则订单已经创建在数据库中了，为未消费状态。\",\"详见☀️RabbitMQ\"]},\"159\":{\"h\":\"服务单一职责，独立部署，定时上架\",\"t\":[\"服务单一职责：秒杀项目是一个独立的微服务即使发生宕机也不会影响订单微服务。\",\"定时上架使用@Scheduled(cron = \\\"0 */1 * * * ?\\\")完成，参数为Cron表达式。\"]},\"160\":{\"h\":\"库存预热快速扣减，秒杀连接加密，恶意请求拦截\"},\"161\":{\"h\":\"库存预热快速扣减如何实现？\",\"t\":[\"预热通过定时上架商品为Redis信号量完成，快速扣减使用Semaphore完成。\"]},\"162\":{\"h\":\"秒杀连接加密，恶意请求拦截如何实现？\",\"t\":[\"秒杀在快开始的时候才会将随机的UUID设置到SKU详情中，请求携带这个UUID才是正确的请求参数，同时秒杀商品信号量的Semaphore的key也是SkuId生成的UUID组合起来的，而不是SkuId，如果是SkuId则很容易被人猜到。\",\"恶意请求拦截体现在对请求的合法性校验上，包含时间段校验，随机码校验，SkuId和秒杀场次的对应正确性校验，一人一单的秒杀幂等性问题。\"]},\"163\":{\"h\":\"流量错峰，后端限流，队列削峰。\"},\"164\":{\"h\":\"流量错峰，队列削峰如何实现？\",\"t\":[\"其实这两个是差不多的意思，在秒杀项目中为了防止数据库同时创建多个订单导致压力剧增，可以使用队列进行削峰填谷。而流量错峰可以使用验证码机制或者是添加购物车让大量请求不在同一个时间点到达。\",\"同时在创建秒杀单时可以通过分布式锁对秒杀单的创建流程上锁，防止大量请求同时到达数据库（使用分布式锁可以解决缓存击穿问题）。\"]},\"165\":{\"h\":\"限流熔断降级如何实现？\",\"t\":[\"后端限流在本项目中使用Sentinel框架实现限流熔断降级。\",\"熔断：A调用B，如果因为某些原因B宕机，则可以将B直接断路，不再调用B的服务。这样B的问题就不会影响到A的运作。@FeignClient(value = \\\"gulimall-seckill\\\",fallback = SeckillFallbackService.class)，调用失败之后回调方法。Sentinel中设置RT（每秒的并发数），异常比例，异常数进行服务熔断。\",\"降级：服务器压力剧增时，可以进行降级，就是将服务器停止服务，直接返回降级数据（前方拥堵，请稍后再试）。以上两者都是为了集群的大部分可用，防止整体崩溃，牺牲自己，用户最终的体验都是部分服务不可用。熔断是服务故障触发系统主动规则，降级是全局考虑，停止正常的服务，释放资源。\",\"限流：对请求的QPS进行限制，使得请求不会超过服务器能接受的最大压力。\",\"​\"]},\"166\":{\"h\":\"笔记\"},\"167\":{\"h\":\"平潭四月\"},\"168\":{\"h\":\"2023.4平潭-世间浪漫海占一半\",\"t\":[\" 今年四月又来看海了\",\"⭐猴研岛，68海里景区\",\" ⭐去北线的路上\",\"⭐环岛路旁\",\"⭐长江澳风车田\",\"⭐北部湾生态长廊\",\"⭐龙凤头浪花\"]},\"169\":{\"h\":\"拍拍\"},\"170\":{\"h\":\"计算机网络一\"},\"171\":{\"h\":\"常见的网络协议\"},\"172\":{\"h\":\"应用层\",\"t\":[\"HTTP（Hypertext Transfer Protocol，超文本传输协议）：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。\",\"SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。\",\"POP3/IMAP（邮件接收协议）：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。\",\"FTP（File Transfer Protocol，文件传输协议） : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。\",\"Telnet（远程登陆协议）：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。\",\"SSH（Secure Shell Protocol，安全的网络传输协议）：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务\",\"RTP（Real-time Transport Protocol，实时传输协议）：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。\",\"DNS（Domain Name System，域名管理系统）: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。\"]},\"173\":{\"h\":\"传输层\",\"t\":[\"TCP（Transmission Control Protocol，传输控制协议 ）：提供 面向连接 的，可靠 的数据传输服务。\",\"UDP（User Datagram Protocol，用户数据协议）：提供 无连接 的，尽最大努力 的数据传输服务（不保证数据传输的可靠性），简单高效。\"]},\"174\":{\"h\":\"网络层\",\"t\":[\"IP（Internet Protocol，网际协议）：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。\",\"ARP（Address Resolution Protocol，地址解析协议）：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。\",\"ICMP（Internet Control Message Protocol，互联网控制报文协议）：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。\",\"NAT（Network Address Translation，网络地址转换协议）：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。\",\"OSPF（Open Shortest Path First，开放式最短路径优先） ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。\",\"RIP(Routing Information Protocol，路由信息协议）：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。\",\"BGP（Border Gateway Protocol，边界网关协议）：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。\"]},\"175\":{\"h\":\"Get和POST的区别\",\"t\":[\"GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。\",\"不带参数时，这俩请求的报文只有在HTTP请求行的 method字段不一样，其他都一样。带参数时，我们通常约定GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中。当然也可以不遵循这种约定，只要在服务端做好支持就好了。\",\"GET 用于获取信息，是无副作用的，是幂等的，且可缓存\",\"POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存\",\"GET 方法参数写法是固定的吗？\",\"在约定中，我们的参数是写在 ? 后面，用 & 分割。我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行。\",\"POST 方法比 GET 方法安全？\",\"按照网上大部分文章的解释，POST 比 GET 安全，因为数据在地址栏上不可见。然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。要想安全传输，就只有加密，也就是 HTTPS。\",\"GET 方法的长度限制是怎么回事？\",\"首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。\",\"POST 方法会产生两个 TCP 数据包？\",\"有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。\"]},\"176\":{\"h\":\"PUT和POST的区别\",\"t\":[\"PUT请求\",\"PUT请求是HTTP协议中的一种请求方法，通常用于更新或者是替换服务器上的资源。使用PUT请求时，客户端需要将整个资源的新版本发送到服务器，如果服务器有这个资源，则用客户端提交的新版本替换原有的资源，如果资源不存在则会创建一个新的资源。\",\"可以更新整个资源。\",\"客户端需要发送完整的资源内容。\",\"如果服务器上不存在该资源，则会创建一个新的资源。\",\"PUT 请求具有幂等性，即执行多次 PUT 请求的结果应该相同。\",\"POST请求\",\"POST 请求是 HTTP 协议中的一种请求方法，通常用于创建新的资源或提交数据到服务器进行处理。使用 POST 请求时，客户端将数据提交到服务器，服务器根据数据进行处理，并返回响应。通常情况下，POST 请求会在服务器上创建新的资源，并返回该资源的 URI。\",\"可以创建新的资源或提交数据到服务器进行处理。\",\"客户端可以只发送部分资源内容。\",\"如果请求成功，服务器会返回一个表示新资源的 URI。\",\"POST 请求不具有幂等性。\"]},\"177\":{\"h\":\"HTTP\"},\"178\":{\"h\":\"从输入 URL 到页面展示到底发生了什么？\",\"t\":[\"DNS 解析\",\"TCP 连接\",\"发送 HTTP 请求\",\"服务器处理请求并返回 HTTP 报文\",\"浏览器解析渲染页面\",\"连接结束\"]},\"179\":{\"h\":\"HTTP状态码\",\"t\":[\"1开头的表示临时响应，比如100表示客户端可以继续发送剩余请求。\",\"2开头的表示客户端的请求成功被接收、理解、接受了。200表示请求成功，会根据请求中使用的方法返回响应的实体。\",\"3开头的表示重定向。就是说用户代理需要采取进一步措施才能满足要求。首部Location字段标示重定向的URL。301表示永久性的重定向，302表示临时性的重定向，304表示客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件(if-Match, if-Range)。当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。\",\"4开头的表示客户端错误。400 Bad Request代表客户端的请求服务器理解不了，401未授权、403服务器拒绝执行该请求，授权了也没用、404Not Found请求路径不存在。\",\"5开头的表示服务端错误。500服务端内部出现错误 ;502 Bad Gateway 504 Gateway timeout有可能是服务器断网了。\"]},\"180\":{\"h\":\"HTTPS与HTTP的区别\",\"t\":[\"端口号：HTTP 默认是 80，HTTPS 默认是 443。\",\"URL 前缀：HTTP 的 URL 前缀是 http://，HTTPS 的 URL 前缀是 https://。\",\"安全性和资源消耗：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。**所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。**所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。\",\"SEO（搜索引擎优化）：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。\"]},\"181\":{\"h\":\"HTTP/1.0 和 HTTP/1.1 区别\",\"t\":[\"连接方式 : HTTP/1.0 为短连接，HTTP/1.1 支持长连接。\",\"状态响应码 : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，100 (Continue)——在请求大资源前的预热请求，206 (Partial Content)——范围请求的标识码，409 (Conflict)——请求与当前资源的规定冲突，410 (Gone)——资源已被永久转移，而且没有任何已知的转发地址。\",\"缓存机制 : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。\",\"带宽：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\",\"Host 头（Host Header）处理 :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。\"]},\"182\":{\"h\":\"URI 和 URL 的区别\",\"t\":[\"URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。\",\"URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。\"]},\"183\":{\"h\":\"DNS\"},\"184\":{\"h\":\"DNS 的作用是什么？\",\"t\":[\"DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是域名和 IP 地址的映射问题。\",\"如果访问的网址在hosts文件中有对应的映射表目，则直接进行解析，否则需要使用DNS系统，DNS是应用层协议，基于UDP协议之上，端口为53。\"]},\"185\":{\"h\":\"DNS 服务器有哪些？\",\"t\":[\"根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。\",\"顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如com、org、net和edu等。国家也有自己的顶级域，如uk、fr和ca。TLD 服务器提供了权威 DNS 服务器的 IP 地址。\",\"权限 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。\",\"本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构。\",\"解析方式分为迭代查询和递归查询。\"]},\"186\":{\"h\":\"计算机网络二\"},\"187\":{\"h\":\"TCP 与 UDP\"},\"188\":{\"h\":\"TCP 与 UDP 的区别\",\"t\":[\"是否面向连接：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。\",\"是否是可靠传输：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。\",\"是否有状态：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。\",\"传输效率：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。\",\"传输形式：TCP 是面向字节流的，UDP 是面向报文的。\",\"首部开销：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。\",\"是否提供广播或多播服务：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；\"]},\"189\":{\"h\":\"什么时候选择 TCP，什么时候选 UDP?\",\"t\":[\"UDP 一般用于即时通信，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。\",\"TCP 用于对传输准确性要求特别高的场景，比如文件传输、发送和接收邮件、远程登录等等。\"]},\"190\":{\"h\":\"HTTP 基于 TCP 还是 UDP？\",\"t\":[\"HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 。此变化解决了 HTTP/2 中存在的队头阻塞问题。由于 HTTP/2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。另外，HTTP/2.0 需要经过经典的 TCP 三次握手过程（一般是 3 个 RTT）。由于 QUIC 协议的特性，HTTP/3.0 可以避免 TCP 三次握手的延迟，允许在第一次连接时发送数据（0 个 RTT ，零往返时间）。\"]},\"191\":{\"h\":\"使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?\",\"t\":[\"运行于 TCP 协议之上的协议：\",\"HTTP 协议：超文本传输协议（HTTP，HyperText Transfer Protocol)是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。\",\"HTTPS 协议：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议\",\"FTP 协议：文件传输协议 FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。\",\"SMTP 协议：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。\",\"POP3/IMAP 协议：两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。\",\"Telnet 协议：用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。\",\"SSH 协议 : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。\",\"运行于 UDP 协议之上的协议：\",\"**DHCP **：动态主机配置协议，动态配置 IP 地址。\",\"DNS：域名系统（DNS，Domain Name System）。\"]},\"192\":{\"h\":\"TCP 三次握手和四次挥手（传输层）\"},\"193\":{\"h\":\"建立连接-TCP三次握手\",\"t\":[\"一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 SYN_SEND 状态，等待服务器的确认；\",\"二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 SYN_RECV 状态\",\"三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务器端都进入ESTABLISHED 状态，完成 TCP 三次握手。\"]},\"194\":{\"h\":\"为什么要三次握手？\",\"t\":[\"三次握手的目的是建立可靠的通信信道。\",\"第一次握手：Client什么都不能确认，Server确认了对方发送正常，自己接收正常。\",\"第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：对方发送正常，自己接收正常。\",\"第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送、接收正常。\",\"三次握手就能确认双方收发功能都正常，缺一不可。\"]},\"195\":{\"h\":\"断开连接-TCP 四次挥手\",\"t\":[\"第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 FIN-WAIT-1 状态。\",\"第二次挥手：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后，此时服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。\",\"第三次挥手：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包->客户端请求关闭连接，然后，服务端进入 LAST-ACK 状态。\",\"第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包->服务端并且进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。\",\"只要四次挥手没有结束，客户端和服务端就可以继续传输数据\"]},\"196\":{\"h\":\"为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？\",\"t\":[\"因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。\"]},\"197\":{\"h\":\"为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？\",\"t\":[\"第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。\"]},\"198\":{\"h\":\"TCP 传输可靠性保障（传输层）\"},\"199\":{\"h\":\"TCP 如何保证传输的可靠性？\",\"t\":[\"基于数据块传输：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。\",\"对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。\",\"校验和 : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。\",\"超时重传 : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失open in new window并进行重传。\",\"流量控制 : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。\",\"拥塞控制 : 当网络拥塞时，减少数据的发送。\"]},\"200\":{\"h\":\"TCP 如何实现流量控制？\",\"t\":[\"TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。\"]},\"201\":{\"h\":\"TCP 的拥塞控制是怎么实现的？\",\"t\":[\"通过拥塞控制算法实现。\",\"慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。\",\"拥塞避免： 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.\",\"快重传与快恢复： 快重传：**如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。**快恢复：在网络发生拥塞之后，不会将拥塞窗口设置为1，而是直接设置为ssthresh阈值的一半。\"]},\"202\":{\"h\":\"ARQ协议\",\"t\":[\"ARQ称为自动重传请求（Automatic Repeat-reQuest，ARQ）；\"]},\"203\":{\"h\":\"停止等待协议\",\"t\":[\"发送窗口=接收窗口=1；\",\"停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。\",\"详见《计算机网络》（谢希仁）。\"]},\"204\":{\"h\":\"后退N帧协议（GBN）\",\"t\":[\"发送窗口>1 ,接收窗口=1；\",\"连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\",\"发送方能将发送窗口内的所有序号发送，接收窗口每收到一个序号就会发送一个确认帧，并将接收窗口向前移动。如果发送方超时没有收到确认帧，则将此确认帧还有之后已经发送的序号全部重发。\",\"如果收到了序号n的确认，则认为前面需要的数据在接收端都受到了，这种确认叫做累计确认机制。\"]},\"205\":{\"h\":\"选择重传协议（SR）\",\"t\":[\"发送窗口>1 ,接收窗口>1；\",\"选择重传协议不再具有累计确认机制，凡是接收窗口中的序号都接收并返回确认帧，如果发生超时，就重传超时的帧，而不是GBN中的当前帧和后续的所有帧。\",\"相关信息\",\"本章的所有知识都属于计算机统考408计算机学科专业基础中的知识点\"]},\"206\":{\"h\":\"计算机网络三\"},\"207\":{\"h\":\"IP（网络层）\"},\"208\":{\"h\":\"IP协议的作用是什么？\",\"t\":[\"IP（网际协议）是TCP/IP协议中最重要的协议之一，属于网络层的协议，主作用是定义数据包的格式，对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。\"]},\"209\":{\"h\":\"什么是IP地址？IP寻址如何工作？\",\"t\":[\"每个连入互联网的设备或域都被分配一个IP地址，作为唯一标识符。\",\"当网络设备发送IP数据包时，数据包包含了源IP地址和目的IP地址。源IP地址用于标识数据包的发送来源，目的IP地址用来表示数据包的接收方设备地址。\",\"网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。\"]},\"210\":{\"h\":\"IPv4 和 IPv6 有什么区别？\",\"t\":[\"为了解决 IP 地址耗尽的问题，IPV6采用128位的地址，除了更大的地址空间之外，IPv6 的优势还包括：\",\"无状态地址自动配置（Stateless Address Autoconfiguration，简称 SLAAC）：主机可以直接通过根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP（Dynamic Host Configuration Protocol）服务器，简化了网络配置和管理。\",\"NAT（Network Address Translation，网络地址转换） 成为可选项：IPv6 地址资源充足，可以给全球每个设备一个独立的地址。\",\"对标头结构进行了改进：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。\",\"可选的扩展头：允许在 IPv6 标头中添加不同的扩展头（Extension Headers），用于实现不同类型的功能和选项。\",\"ICMPv6（Internet Control Message Protocol for IPv6）：IPv6 中的 ICMPv6 相较于 IPv4 中的 ICMP 有了一些改进，如邻居发现、路径 MTU 发现等功能的改进，从而提升了网络的可靠性和性能。\"]},\"211\":{\"h\":\"NAT作用是什么？\",\"t\":[\"NAT（Network Address Translation，网络地址转换） 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。\",\"NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。\"]},\"212\":{\"h\":\"ARP\"},\"213\":{\"h\":\"什么是 MAC 地址？\",\"t\":[\"MAC 地址的全称是 媒体访问控制地址（Media Access Control Address）。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。\",\"可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。\",\"MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。\",\"MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。\"]},\"214\":{\"h\":\"ARP 协议解决了什么问题？\",\"t\":[\"ARP 协议，全称 地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议用来IP地址转MAC地址。\",\"在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 <IP, MAC, TTL> 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。\"]},\"215\":{\"h\":\"计算机网络\"},\"216\":{\"h\":\"数据库基础\"},\"217\":{\"h\":\"数据库的三大范式\"},\"218\":{\"h\":\"1NF\",\"t\":[\"属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了，1NF是所有关系型数据库的最基本要求，也就是说关系型数据库中创建的表一定满足第一范式。\"]},\"219\":{\"h\":\"2NF\",\"t\":[\"2NF在1NF的基础上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。\",\"一些概念：\",\"函数依赖：若在一张表中，在属性X（或属性组）的值确定的情况下，必定能确定属性Y的值，那么可以说Y函数依赖于X，写作X->Y。\",\"部分函数依赖：如果X->Y，并且存在X的一个真子集X0，是的X0->Y，则Y对X部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号），因为确定了学号或者是身份证就能确定姓名。\",\"完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；\",\"传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖于 X。传递函数依赖会导致数据冗余和异常。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。\"]},\"220\":{\"h\":\"3NF\",\"t\":[\"3NF在2NF的基础上，消除了非主属性对于码的传递函数依赖。符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。\"]},\"221\":{\"h\":\"drop、delete 与 truncate 区别？\",\"t\":[\"drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。\",\"truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。\",\"delete（删除数据） : delete from 表名 where 列名=值，删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。\"]},\"222\":{\"h\":\"DML 语句和 DDL 语句区别\",\"t\":[\"DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。\",\"DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。\"]},\"223\":{\"h\":\"MySQL基础\"},\"224\":{\"h\":\"什么是关系型数据库？\",\"t\":[\"一种建立在关系模型基础上的数据库，关系模型表明了数据库中所存储的数据之间的联系（一对一，一对多，多对多）。\"]},\"225\":{\"h\":\"MySQL有什么优点？\",\"t\":[\"成熟稳定，功能完善。\",\"开源免费。\",\"文档丰富。\",\"兼容性好。\",\"社区活跃，生态完善。\",\"事务支持优秀。\",\"支持分库分表、读写分离、高可用。\"]},\"226\":{\"h\":\"MySQL基础架构\",\"t\":[\"MySQL主要由下面几个部分构成：\",\"连接器：身份认证和权限相关。\",\"查询缓存：执行查询语句的时候，会先查询缓存（MySQL 8.0版本后移除）。\",\"分析器：没有命中缓存的话，SQL语句会经过分析器，分析SQL语句操作，检查语法是否正确。\",\"优化器：按照MySQL认为最优的方案去执行。\",\"执行器：执行语句，然后从存储引擎返回数据。\",\"插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持InnoDB，MyISAM，Memory等多种存储引擎。\"]},\"227\":{\"h\":\"MySQL存储引擎\",\"t\":[\"MySQL 5.5.5之前，MyISAM是MySQL的默认存储引擎。之后，InnoDB是MySQL的默认存储引擎。\"]},\"228\":{\"h\":\"MyISAM 和 InnoDB 有什么区别？\",\"t\":[\"是否支持行级锁\",\"MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。MyISAM一锁就是整张表，并发度不及InnoDB。\",\"是否支持事务\",\"MyISAM不提供事务。\",\"InnoDB提供事务支持，实现了SQL标准定义的四个隔离级别，具有提交和回滚事务的能力，并且InnoDB默认使用REPEAETABLE-READ（可重复读）隔离级别是可以解决幻读问题的（基于MVCC和Next-Key Lock）。\",\"是否支持外键\",\"MyISAM不支持，而InnoDB支持。外键对于维护数据的一致性非常有帮助，但是在日常开发中不建议使用外键，请通过关系表实现。\",\"是否支持数据库异常崩溃后的安全恢复\",\"MyISAM不支持，而InnoDB支持。\",\"使用InnoDB的数据库在异常崩溃之后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，这个恢复过程依赖于redo log。\",\"是否支持MVCC\",\"MyISAM不支持，InnoDB支持。\",\"索引实现不同\",\"MyISAM引擎InnoDB引擎都是使用B+Tree作为索引结构，但是两者实现方式不同。\",\"InnoDB引擎中，其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree阻止的一个索引结构，树的叶节点data域保存了完整的数据记录。\",\"性能\",\"InnoDb的性能比MyISAM性能更好，InnoDb读写支持并发，MyISAM不支持并发。\"]},\"229\":{\"h\":\"MySQL查询缓存\",\"t\":[\"执行查询语句的时候，会先查询缓存，不过在8.0版本之后缓存被移除。\",\"查询不命中的情况：\",\"任何两个查询在任何字符上的不同都会导致缓存不命中。\",\"如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。\",\"缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的没一张表，如果这些表发生变化，那么和这张表的所有缓存数据都失效。\",\"缓存虽然能提升数据库的查询能力，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。\"]},\"230\":{\"h\":\"MySQL 事务\",\"t\":[\"事务是逻辑上的一组操作，要么都执行，要么都不执行。\",\"MySQL中开启事务：\",\"# 开启一个事务 START TRANSACTION; # 多条 SQL 语句 SQL1,SQL2... ## 提交事务 COMMIT; \"]},\"231\":{\"h\":\"ACID特性\",\"t\":[\"关系型数据库都有ACID特性。\",\"原子性Atomicity：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么都完成，要么都不完成。\",\"一致性Consistency：执行事物的前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的。\",\"隔离性Isolation：并发访问数据库时，一个用户的事物不被其他事务所干扰，各并发事务之间的数据库是独立的。\",\"持久性Durability：一个事务被提交之后。它对数据库中的数据改变是持久的，即使数据库发生故障也不应该对其有任何影响。\",\"ACID\",\"只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是AID是手段，C是目的。\"]},\"232\":{\"h\":\"并发事务带来了哪些问题?\",\"t\":[\"脏读：读到了没有提交的数据。\",\"READ-UNCOMMITTED\",\"不可重复读：在一个事务内开启多次读，读取条件相同的情况下得到的结果却是不一样的。\",\"READ-UNCOMMITTED、READ-COMMITTED\",\"幻读：读取到了一个原本没有的数据（新插入的数据）。\",\"READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ（通过MVCC和Next-Key Lock可解决幻读）\"]},\"233\":{\"h\":\"并发事务的控制方式有哪些？\",\"t\":[\"MySQL中并发事务的控制方式有两种：锁和MVCC。锁可以看做是悲观控制的模式，多版本并发控制是勒段控制的模式。\"]},\"234\":{\"h\":\"MySQL的隔离级别是基于锁实现的吗？\",\"t\":[\"MySQL的隔离级别基于锁和MVCC机制共同实现的。\",\"SERIALIZABLE隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。\"]},\"235\":{\"h\":\"MySQL的默认隔离级别是什么？\",\"t\":[\"MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。\"]},\"236\":{\"h\":\"MySQL 锁\"},\"237\":{\"h\":\"表级锁和行级锁了解吗？有什么区别？\",\"t\":[\"MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。\",\"行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。\",\"表级锁和行级锁对比：\",\"表级锁：MySQL中锁定粒度最大的锁，对当前操作的整张表加锁，实现简单，资源消耗快，不会出现死锁。并发度低，与存储引擎无关，MyISAM和InnoDB都支持表级锁。\",\"行级锁：MySQL中锁定粒度最小的一种锁，是针对索引字段加锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突。加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，InnoDB支持MyISAM不支持。\"]},\"238\":{\"h\":\"InnoDB 有哪几类行锁？\",\"t\":[\"InnoDB支持三种行锁定方式：\",\"记录锁（Record Lock）：也被称为记录锁，属于单个行记录上的锁。\",\"间隙锁（Gap Lock）：锁定一个范围，不包括记录本身。\",\"临键锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。\",\"相关信息\",\"在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。\"]},\"239\":{\"h\":\"共享锁和排他锁区别\",\"t\":[\"两者都是行级锁。\",\"共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。读写互斥，写写互斥，其他不互斥。\",\"排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。操作都互斥。\",\"由于 MVCC 的存在，对于一般的 SELECT 语句，InnoDB 不会加任何锁。\"]},\"240\":{\"h\":\"意向锁有什么作用？\",\"t\":[\"如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差，所以需要意向锁来快速判断是否可以对某个表使用表锁。\",\"意向锁是表级锁，共有两种：\",\"意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。\",\"意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。\",\"注意\",\"意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InnoDB会先获取该行数据所在数据表对应的意向锁。\",\"意向锁之间是相互兼容的。\",\"除了意向共享锁（IS）和共享锁兼容（S），其余的意向锁和共享或者排他锁都互斥。\"]},\"241\":{\"h\":\"快照读和当前读的区别\",\"t\":[\"快照读（一致性非锁定读）就是单纯的 SELECT 语句。\",\"SELECT ... FOR UPDATE SELECT ... LOCK IN SHARE MODE \",\"快照即记录的历史版本，每行记录可能存在多个历史版本。\",\"快照读的情况下，如果读取的记录正在执行UPDATE/DELETE操作，读取操作不会因此去等待记录上X锁的释放，而是会去读取行的一个快照。\",\"只有在事务隔离级别RC和RR下，InnoDB才会使用快照读。\",\"在RC级别下，对于快照数据，快照读总是读取被锁定行的最新一份快照数据。\",\"在RR级别下，对于快照数据，快照读总是读取本事务开始时的行数据版本。\",\"当前读（一致性锁定读）就是给行记录加X锁或者S锁。\",\"# 对读的记录加一个X锁 SELECT...FOR UPDATE # 对读的记录加一个S锁 SELECT...LOCK IN SHARE MODE # 对修改的记录加一个X锁 INSERT... UPDATE... DELETE... \"]},\"242\":{\"h\":\"MySQL如何存储IP地址？\",\"t\":[\"可以将IP地址转换成整形数据存储，性能更好，占用空间更小。\",\"MySQL提供了两个方法来处理ip地址：\",\"INET_ATON()：把ip转化为无符号整数。\",\"INET_NTOA() :把整型的 ip 转为地址。\",\"插入数据前，先用 INET_ATON() 把 ip 地址转为整型，显示数据时，使用 INET_NTOA() 把整型的 ip 地址转为地址显示即可。\"]},\"243\":{\"h\":\"执行计划\",\"t\":[\"可以使用 EXPLAIN 命令来分析 SQL 的 执行计划 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。\",\"EXPLAIN 并不会真的去执行相关的语句，而是通过 查询优化器 对语句进行分析，找出最优的查询方案，并显示对应的信息。\",\"分析EXPLAIN结果\",\"id：SELECT标识符，是查询中SELECT的序号，用来标识整个查询中SELECT语句的顺序。id如果相同，从上往下一次执行。\",\"select_type：查询的类型，主要用于区分普通查询、联合查询、子查询等复杂查询。\",\"SIMPLE：简单查询，不包含 UNION 或者子查询。\",\"PRIMARY：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。\",\"SUBQUERY：子查询中的第一个 SELECT。\",\"UNION：在 UNION 语句中，UNION 之后出现的 SELECT。\",\"DERIVED：在 FROM 中出现的子查询将被标记为 DERIVED。\",\"UNION RESULT：UNION 查询的结果\",\"table：表名。\",\"type（重要）：查询执行的类型，所有值的顺序从最优到最差排序为system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL。\",\"system：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。\",\"const：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。\",\"eq_ref：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。\",\"ref：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。\",\"index_merge：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。\",\"range：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。\",\"index：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。\",\"ALL：全表扫描。\",\"key（重要）：key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。\",\"key_len：key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。\",\"rows：rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。\",\"Extra（重要）：这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：\",\"Using filesort：在排序时使用了外部的索引排序，没有用到表内索引进行排序。\",\"Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。\",\"Using index：表明查询使用了覆盖索引，不用回表，查询效率非常高。\",\"Using index condition：表示查询优化器选择使用了索引条件下推这个特性。\",\"Using where：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。\",\"Using join buffer (Block Nested Loop)：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。\"]},\"244\":{\"h\":\"读写分离和分库分表\"},\"245\":{\"h\":\"读写分离\",\"t\":[\"读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点（主节点写，从节点读）上，这样能小幅度提升写性能，大幅度提升读性能。\"]},\"246\":{\"h\":\"读写分离会带来什么问题？\",\"t\":[\"读写分离对提升数据库的并发非常有效，但是主库和从库的数据存在延时（主从同步延迟 ）。\"]},\"247\":{\"h\":\"如何实现读写分离？\",\"t\":[\"部署多台数据库，选择其中一台作为主数据库，其他的一台或者多台作为从数据库。\",\"保证主数据库和从数据库之间的数据是实时同步的，这个过程称为主从复制。\",\"系统将写请求交给主数据库处理，读请求交给从数据库处理。\"]},\"248\":{\"h\":\"主从复制的原理是什么？\",\"t\":[\"主库将数据库中数据的变化写入到 binlog；\",\"从库连接主库；\",\"从库会创建一个 I/O 线程向主库请求更新的 binlog；\",\"主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收；\",\"从库的 I/O 线程将接收的 binlog 写入到 relay log 中；\",\"从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。\"]},\"249\":{\"h\":\"分库分表\"},\"250\":{\"h\":\"什么是分库\",\"t\":[\"分库就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。\",\"垂直分库就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。\",\"水平分库是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的数据库上，实现了水平扩展，解决了单表的存储和性能瓶颈的问题。例如将10万条数据分成两个5万条数据。\"]},\"251\":{\"h\":\"什么是分表\",\"t\":[\"分表：就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。\",\"垂直分表：是对数据表列的拆分，把一张列比较多的表拆分成多张表。\",\"水平分表：是对数据表行的拆分，吧一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。\"]},\"252\":{\"h\":\"什么情况下需要分库分表？\",\"t\":[\"单表的数据达到千万级别以上，数据库读写速度比较缓慢。\",\"数据库的数据占用的空间越来越大，备份时间越来越长。\",\"应用的并发量太大。\"]},\"253\":{\"h\":\"常见的分片算法有哪些？\",\"t\":[\"分片算法主要解决了数据被水平分片之后，数据应该放在哪个表的问题。\",\"哈希分片：求指定key的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常使用范围查询的场景。\",\"范围分片：按照特性的范围区间来分配数据。\",\"地理位置分片：很多NewSQL数据库都支持地理位置分片算法。\",\"融合算法：灵活组合多种分片算法。\"]},\"254\":{\"h\":\"分库分表会带来什么问题呢？\",\"t\":[\"join操作：同一个数据库中的表分布在不同的数据库中，导致无法使用join操作。\",\"事务问题：同一个数据库中的表分布在不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事物就无法满足要求。\",\"分布式id分库之后，数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成唯一主键。\"]},\"255\":{\"h\":\"MySQL索引\"},\"256\":{\"h\":\"索引\",\"t\":[\"索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\",\"优点：\",\"使用索引可以大大加快数据的检索速度，这也是创建索引的主要原因。\",\"通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\",\"缺点：\",\"创建索引和维护索引需要耗费许多时间，当堆表中的数据进行增删改的时候，如果数据有索引，那么索引也需要改动，降低SQL执行效率。\",\"索引需要占用一定的物理空间。\"]},\"257\":{\"h\":\"索引底层数据结构\"},\"258\":{\"h\":\"Hash表\",\"t\":[\"哈希表示键值对的集合，通过键可以快速取出对应的值，因此哈希表可以快速检索数据。\",\"但是哈希算法有Hash冲突问题，不同的key最后会得到相同的index。\",\"因为Hash索引不支持顺序和范围查询，所以MySQL没有使用其作为索引的数据结构。\"]},\"259\":{\"h\":\"二叉查找树（BST）\",\"t\":[\"二叉查找树是一种基于二叉树的数据结构，具有以下特点：\",\"左子树的所有节点值均小于根节点。\",\"右子树所有节点的值均大于根节点的值。\",\"左右子树也符合上述规则。\",\"当二叉查找树是平衡的时候，任何节点的左右子树高度差的绝对值不超过1即为平衡，查询的时间复杂度是O(log2(N))。当二叉查找树不平衡时，最坏情况下退化为线性链表，查找的时间复杂度是O(N)。\",\"因为不会自动平衡，不适合作为MySQL底层索引的数据结构。\"]},\"260\":{\"h\":\"AVL树\",\"t\":[\"AVL树是自平衡的二叉查找树。保证任何节点的左右子树高度差的绝对值不超过1，因此被称为平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。\",\"AVL树需要频繁的进行旋转来保持平衡，因此会有较大的计算开销。并且使用AVL树，每个树节点仅存储一个数据，每次磁盘IO只能读取一个节点的数据。\"]},\"261\":{\"h\":\"红黑树\",\"t\":[\"红黑树是一种自平衡的二叉查找树，通过在插入和删除节点时金星颜色变换和旋转操作，使得树始终平衡，具有以下特点：\",\"每个节点不是红色就是黑色。\",\"根节点总是黑色。\",\"每个叶子节点都是黑色的空节点。\",\"如果节点是红色的，则它的子节点必须是黑色（反之不一定）。\",\"从根节点到叶节点或空子节点的每一条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。\",\"和 AVL 树不同的是，红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。也正因如此，红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。\"]},\"262\":{\"h\":\"B 树& B+树\",\"t\":[\"B树也称为B-树，全称多路平衡查找树，B+树是B树的编题，B树和B+树中的B是Balanced的意思。\",\"有何不同？\",\"B树的所有节点既存放键（key）也存放数据（data），而B+树只有叶子节点存放key和data，其他节点只存放key，起到索引作用。\",\"B树的叶子节点都是独立的，B+树的叶子节点有一条引用链指向与他相邻的叶子节点。\",\"B树的检索过程相当于对范围内的每个结点的关键字做二分查找，可能还没有到达叶子节点，索引就结束了。而B+树任何查找都是根节点到叶子节点的过程，只有叶子节点存储data。\",\"在B树中进行范围查询时，首先要找到查找的下限，然后对B树进行中序遍历，直到找到查找的上限；而B+树的范围查询，只需要拍对链表进行遍历即可。\",\"实现方式\",\"MyISAM引擎和InnoDB引擎都是使用B+树作为索引结构，但是两者实现方式有所不同：\",\"MyISAM引擎中，B+树叶节点的data域存放的是数据记录的地址，搜索的时候如果找道对应的节点，则会将节点的data值拿出，再通过data值作为地址读取相应的数据，这被称为非聚簇索引（非聚集索引）。\",\"InnoDB中，数据文件本身就是索引文件，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是索引，这被称为聚簇索引（聚集索引），而其余的索引都成为辅助索引，辅助索引的data域存储响应记录主键的值而不是地址。根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。\"]},\"263\":{\"h\":\"主键索引（Primary Key）\",\"t\":[\"数据表的主键列使用的就是主键索引。\",\"一张表只能有一个主键，并且不能为null，不能重复。\",\"在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。\"]},\"264\":{\"h\":\"二级索引\",\"t\":[\"二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键，也就是通过辅助索引能定位主键的位置。\",\"唯一索引：唯一索引是一种约束。唯一索引的属性页不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。建立唯一索引的目的大部分都是为了属性列的数据唯一性，而不是为了查询效率。\",\"普通索引：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。\",\"前缀索引：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小。\",\"全文索引：全文索引主要为了检索大文本数据中的关键字信息，是目前搜索引擎数据库使用的一种技术。\"]},\"265\":{\"h\":\"聚簇索引与非聚簇索引\"},\"266\":{\"h\":\"聚簇索引（聚集索引）\",\"t\":[\"聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB中的主键索引就属于聚簇索引。\",\"优点：\",\"查询速度非常快：库粗索引的查询速度很快，因为B+树本身就是一棵多叉平衡树，叶子节点也都是有序的，定位到索引的节点，相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的IO操作。\",\"对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度很快。\",\"缺点：\",\"依赖于有序的数据：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序。\",\"更新代价大：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改的代价很大。\"]},\"267\":{\"h\":\"非聚簇索引（非聚集索引）\",\"t\":[\"非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型，二级索引（辅助索引）就属于非聚簇索引。MySQL的MyISAM引擎不管是主键还是非主键，使用的都是非聚簇索引。（B+树的叶子节点不是数据本身，而是数据对应的地址）\",\"非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点存放的是主键，根据主键再回表查询数据。\",\"优点：\",\"更新代价比聚簇索引小。非聚簇索引的叶子节点不是存放数据，更新代价比聚簇索引小。\",\"缺点：\",\"依赖于有序的数据：跟聚簇索引一样，非聚簇索引也依赖于有序的数据。\",\"可能会二次查询（回表）：由于非聚簇索引的叶子节点存放的是主键，还需要根据主键去聚簇索引中去查找对应行的数据。\"]},\"268\":{\"h\":\"覆盖索引和联合索引\"},\"269\":{\"h\":\"覆盖索引\",\"t\":[\"如果一个索引包含所有需要查询字段的值，则称为覆盖索引。在InnoDB引擎中，如果不是主键索引，叶子节点存储的是主键+列值，最终需要会表查询。而覆盖搜因就是要查询出的列和索引是对应的，不会回表。\"]},\"270\":{\"h\":\"联合索引\",\"t\":[\"使用表中的多个字段创建索引，就是联合索引，也叫作组合索引或复合索引。\",\"使用表中的多个字段创建搜因，就是联合索引，也叫作组合索引或者复合索引。\"]},\"271\":{\"h\":\"最左匹配原则\",\"t\":[\"使用联合索引时存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。\",\"在使用联合索引进行查询的时候，如果不遵循最左匹配原则，联合索引会失效。\",\"例如如果创建了一个（a，b，c）联合索引，以下几种查询条件就能利用联合索引：\",\"where a=1; where a=1 and b=2 and c=3; where a=1 and b=2; \",\"因为有查询优化器，所以a字段在where中的顺序并不重要，但是如果查询条件是以下几种，就不符合最左匹配原则，联合索引就会失效：\",\"where b=2; where c=2; where b=2 and c=3; \",\"联合索引的最左匹配原则会一直向右匹配知道遇到范围查询就会停止匹配。也就是范围查询的字段可以用到联合索引，但是范围查询字段的后面的字段无法使用到联合索引。\",\"例子一\",\"select *from t_table where a>1 and b=2,联合索引（a，b）哪一个字段用到了联合索引？ \",\"由于联合索引是先按照a字段的值排序的，所以符合a>1条件的二级索引记录是肯定相邻的，于是在进行索引扫描的时候，可以定位到符合a>1条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合a>1条件位置。索引a字段可以在联合索引的B+树中进行索引查询。\",\"但是在符合a>1条件的二级索引记录的范围里，b字段的值是无序的。\",\"因此不能通过b=2来进一步减少需要扫描的记录数量\",\"所以在执行查询的时候，对应的扫描区间是[2,+ ∞)，形成这个扫描区间的条件是a>1，与b=2无关。\",\"例子二\",\" select * from t_table where a >= 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引？ \",\"跟例子1很像，不过条件变成了a>=1；\",\"符合a>=1条件的二级索引记录的范围里，b字段的值是无序的，但是在a=1的二级索引记录的范围里，b字段是有序的（因为对于联合索引，先是按照a字段的值排序，然后在a字段相同的情况下，再按照b字段值进行排序）。所以对于这个查询ab都用到了联合索引进行查询。\"]},\"272\":{\"h\":\"索引下推\",\"t\":[\"索引下推是MySQL 5.6版本中提供的索引优化功能，可以在非聚簇索引遍历啊过程中，对索引中包含的字段做判断，过滤掉不符合条件的记录，减少回表次数。\"]},\"273\":{\"h\":\"使用索引的建议\"},\"274\":{\"h\":\"选择合适的字段创建索引\",\"t\":[\"以下字段适合创建索引：\",\"不为NULL的字段；\",\"被频繁查询的字段；\",\"被作为条件查询的字段；\",\"频繁需要排序的字段；\",\"被经常频繁用于连接的字段。\"]},\"275\":{\"h\":\"被频繁更新的字段应该慎重建立索引\",\"t\":[\"虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。\"]},\"276\":{\"h\":\"限制每张表上的索引数量\",\"t\":[\"索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。\"]},\"277\":{\"h\":\"尽可能的考虑建立联合索引而不是单列索引\",\"t\":[\"因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。\"]},\"278\":{\"h\":\"避免索引失效\",\"t\":[\"索引失效是慢查询的主要原因之一，常见的导致索引失效的情况：\",\"创建了组合索引，但查询条件未遵守最左匹配原则；\",\"在索引列上进行计算、函数、类型转换等操作；\",\"以 % 开头的 LIKE 查询比如 like '%abc'；\",\"查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到；\",\"发生隐式转换\",\"隐式转换\",\"当操作符左右两边的数据类型不一致时，会发生隐式转换。\",\"当 where 查询操作符左边为数值类型时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。\",\"当 where 查询操作符左边为字符类型时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。\",\"字符串转换为数值类型时，非数字开头的字符串会转化为0，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。\",\"我们在写 SQL 时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描。\"]},\"279\":{\"h\":\"MySQL日志\"},\"280\":{\"h\":\"MySQL事务隔离级别\"},\"281\":{\"h\":\"事务隔离级别和MVCC\"},\"282\":{\"h\":\"事务隔离级别\",\"t\":[\"SQL定义了四个隔离级别：\",\"READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。\",\"READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\",\"REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\",\"SERIALIZABLE(可串行化)：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\",\"隔离级别\",\"脏读\",\"不可重复读\",\"幻读\",\"READ-UNCOMMITTED\",\"√\",\"√\",\"√\",\"READ-COMMITTED\",\"×\",\"√\",\"√\",\"REPEATABLE-READ\",\"×\",\"×\",\"√\",\"SERIALIZABLE\",\"×\",\"×\",\"×\",\"MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。\",\"标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的，但是InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：\",\"快照读：由 MVCC 机制来保证不出现幻读。\",\"当前读：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁\"]},\"283\":{\"h\":\"一致性非锁定读和锁定读\"},\"284\":{\"h\":\"一致性非锁定读\",\"t\":[\"对于一致性非锁定读的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见。\",\"在 InnoDB 存储引擎中，多版本并发控制就是对非锁定读的实现。如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，叫它快照读 (snapshot read)\",\"在 Repeatable Read 和 Read Committed 两个隔离级别下，如果是执行普通的 select 语句（不包括 select ... lock in share mode ,select ... for update）则会使用 一致性非锁定读（MVCC）。并且在 Repeatable Read 下 MVCC 实现了可重复读和防止部分幻读。\"]},\"285\":{\"h\":\"锁定读\",\"t\":[\"如果执行的是下列语句，就是锁定读\",\"select ... lock in share mode\",\"select ... for update\",\"insert、update、delete 操作\",\"在锁定读下，读取的是数据的最新版本，这种读也被称为 当前读（current read）。锁定读会对读取到的记录加锁：\",\"select ... lock in share mode：对记录加 S 锁，其它事务也可以加S（共享锁）锁，如果加 x 锁则会被阻塞。\",\"select ... for update、insert、update、delete：对记录加 X（排它锁） 锁，且其它事务不能加任何锁。\",\"在一致性非锁定读下，即使读取的记录已被其它事务加上 X 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 Repeatable Read 下 MVCC 防止了部分幻读，这边的 “部分” 是指在一致性非锁定读 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， InnoDB 在实现Repeatable Read 时，如果执行的是当前读，则会对读取的记录使用 Next-key Lock ，来防止其它事务在间隙间插入数据。\"]},\"286\":{\"h\":\"InnoDB 对 MVCC 的实现\",\"t\":[\"MVCC 的实现依赖于：隐藏字段、Read View、undo log。\",\"在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改\"]},\"287\":{\"h\":\"隐藏字段\",\"t\":[\"在内部，InnoDB 存储引擎为每行数据添加了三个隐藏字段：\",\"DB_TRX_ID（6字节）：表示最后一次插入或更新该行的事务 id。此外，delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除；\",\"DB_ROLL_PTR（7字节） 回滚指针，指向该行的 undo log 。如果该行未被更新，则为空；\",\"DB_ROW_ID（6字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引。\"]},\"288\":{\"h\":\"ReadView\",\"t\":[\"主要有以下字段：\",\"m_low_limit_id：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见\",\"m_up_limit_id：活跃事务列表 m_ids 中最小的事务 ID，如果 m_ids 为空，则 m_up_limit_id 为 m_low_limit_id。小于这个 ID 的数据版本均可见\",\"m_ids：Read View 创建时其他未提交的活跃事务 ID 列表。创建 Read View时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。m_ids 不包括当前事务自己和已提交的事务（正在内存中）\",\"m_creator_trx_id：创建该 Read View 的事务 ID。\"]},\"289\":{\"h\":\"undo log\",\"t\":[\"undo log 主要有两个作用：\",\"当事务回滚时用于将数据恢复到修改前的样子；\",\"另一个作用是 MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 undo log 读取之前的版本数据，以此实现非锁定读。\"]},\"290\":{\"h\":\"RC 和 RR 隔离级别下 MVCC 的差异\",\"t\":[\"在事务隔离级别 RC 和 RR （InnoDB 存储引擎的默认事务隔离级别）下，InnoDB 存储引擎使用 MVCC（非锁定一致性读），但它们生成 Read View 的时机却不同。\",\"在 RC 隔离级别下的 每次select 查询前都生成一个Read View (m_ids 列表)；\",\"在 RR 隔离级别下只在事务开始后 第一次select 数据前生成一个Read View（m_ids 列表）。\"]},\"291\":{\"h\":\"MVCC下解决不可重复读问题\",\"t\":[\"虽然 RC 和 RR 都通过 MVCC 来读取快照数据，但由于 生成 Read View 时机不同，从而在 RR 级别下实现可重复读。\",\"在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读。\",\"在RR隔离级别下，事务在第一次查询开始的时候会生成一个Read View 后续复用这个Read View。\"]},\"292\":{\"h\":\"MVCC+Next-key Lock防止幻读\",\"t\":[\"InnoDB存储引擎在RR隔离级别下通过MVCC和Next-key Lock来解决幻读问题。\",\"1、执行普通 select，此时会以 MVCC 快照读的方式读取数据\",\"在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 Read View ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。\",\"2、执行 select...for update/lock in share mode、insert、update、delete 等当前读\",\"在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。\",\"☀️详见MySQL锁\",\"临键锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。\"]},\"293\":{\"h\":\"MVCC\"},\"294\":{\"h\":\"Mysql\"},\"295\":{\"h\":\"Redis基础一\"},\"296\":{\"h\":\"基础\"},\"297\":{\"h\":\"什么是 Redis？\",\"t\":[\"Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。\",\"为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。\"]},\"298\":{\"h\":\"Redis 为什么这么快？\",\"t\":[\"Redis 基于内存，内存的访问速度是磁盘的上千倍；\",\"Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；\",\"Redis 内置了多种优化过后的数据结构实现，性能非常高。\"]},\"299\":{\"h\":\"说一下 Redis 和 Memcached 的区别和共同点？\",\"t\":[\"共同点：\",\"都是基于内存的数据库，一般都用来当做缓存使用。\",\"都有过期策略。\",\"两者的性能都非常高。\",\"区别：\",\"支持的数据类型：Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。\",\"持久化：Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。\",\"容灾恢复：Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。\",\"内存不足操作：Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。\",\"集群支持：Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。\",\"线程数：Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。（Redis 6.0 针对网络数据的读写引入了多线程）\",\"高级功能：Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。\",\"过期数据删除：Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。\"]},\"300\":{\"h\":\"为什么要用 Redis/为什么要用缓存？\",\"t\":[\"1、高性能\",\"假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。\",\"这样有什么好处呢？ 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。\",\"2、高并发\",\"一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。\",\"QPS（Query Per Second）：服务器每秒可以执行的查询次数；\",\"由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。\"]},\"301\":{\"h\":\"常见的缓存读写策略\"},\"302\":{\"h\":\"Cache Aside Pattern（旁路缓存模式）\",\"t\":[\"Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。\",\"服务端同时维护db和cache，并且是以db的结果为准。\",\"写（缓存失效）：\",\"先更新db\",\"然后直接删除cache\",\"读：\",\"从cache中读取数据，读到直接返回；\",\"cache中没有取到数据，就从db中读取数据返回；\",\"再把数据放到cache中。\",\"相关信息\",\"在写数据的过程中，可以先删除 cache ，后更新 db 么？\",\"不行，因为会造成数据库和缓存的数据不一致问题。\",\"请求 1 先把 cache 中的 A 数据删除 -> 请求 2 从 db 中读取数据->请求 1 再把 db 中的 A 数据更新\",\"在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？\",\"理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。\",\"请求 1 从 db 读数据 A-> 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -> 请求 1 将数据 A 写入 cache（发生在请求2更新数据之前则会出现数据不一致）\",\"优缺点：\",\"缺点1：首次请求的数据一定不在cache中。\",\"解决办法：将热点数据提前放入cache中。\",\"缺点2：写操作频繁的话会导致cache中数据频繁被删除，影响命中率。\",\"解决办法：\",\"数据库和缓存数据强一致性场景：更新db的时候同时更新cache，不过需要添加一个锁来保证更新cache的时候不存在线程安全问题。\",\"可以短暂地允许数据库和缓存数据不一致的场景：更新db的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样就能保证即使数据不一致影响也比较小。\"]},\"303\":{\"h\":\"Read/Write Through Pattern（读写穿透）\",\"t\":[\"Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。\",\"写（Write Through）：\",\"先查 cache，cache 中不存在，直接更新 db。\",\"cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（同步更新 cache 和 db）\",\"读(Read Through)：\",\"从 cache 中读取数据，读取到就直接返回 。\",\"读取不到的话，先从 db 加载，写入到 cache 后返回响应。\",\"Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。\",\"和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。\"]},\"304\":{\"h\":\"Write Behind Pattern（异步缓存写入）\",\"t\":[\"Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。\",\"但是，两个又有很大的不同：Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。\",\"很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。\",\"这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。\",\"Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。\"]},\"305\":{\"h\":\"Redis 应用\"},\"306\":{\"h\":\"Redis 除了做缓存，还能做什么？\",\"t\":[\"分布式锁：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。（秒杀下更新数据库时使用分布式锁）\",\"☀️详见：分布式锁\",\"限流：一般是通过 Redis + Lua 脚本的方式来实现限流。（秒杀下一人一单占位使用Lua脚本）\",\"消息队列：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。（快速创建秒杀单之后写回数据库使用消息队列）\",\"Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现，List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。\",\"Redis 2.0 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有广播机制的问题。Redis 5.0 新增加的一个数据结构 Stream 来做消息队列。\",\"Stream 支持：\",\"发布 / 订阅模式\",\"按照消费者组进行消费\",\"消息持久化（ RDB 和 AOF）\",\"复杂业务场景：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。\"]},\"307\":{\"h\":\"Redis 数据结构\",\"t\":[\"☀️详见：Redis数据结构\"]},\"308\":{\"h\":\"Redis 常用的数据结构有哪些？\",\"t\":[\"5 种基础数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。\",\"3 种特殊数据结构：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。\"]},\"309\":{\"h\":\"String 的应用场景有哪些？\",\"t\":[\"String 是 Redis 中最简单同时也是最常用的一个数据结构。String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。\",\"String 的常见应用场景如下：\",\"常规数据（比如 session、token、序列化后的对象、图片的路径）的缓存；\",\"计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；\",\"分布式锁(利用 SETNX key value 命令可以实现一个最简易的分布式锁)。\"]},\"310\":{\"h\":\"String 还是 Hash 存储对象数据更好呢？\",\"t\":[\"String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。\",\"String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。\"]},\"311\":{\"h\":\"String 的底层实现是什么？\",\"t\":[\"Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 \\\\0 结尾的字符数组），而是自己编写了 SDS（Simple Dynamic String，简单动态字符串） 来作为底层实现。\",\"Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。\",\"SDS 相比于 C 语言中的字符串有如下提升：\",\"可以避免缓冲区溢出：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。\",\"获取字符串长度的复杂度较低：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。\",\"减少内存分配次数：为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。\",\"二进制安全：C 语言中的字符串以空字符 \\\\0 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。\"]},\"312\":{\"h\":\"购物车信息用 String 还是 Hash 存储更好呢?\",\"t\":[\"由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：\",\"用户 id 为 key；\",\"商品 id 为 field，商品数量为 value。\"]},\"313\":{\"h\":\"使用 Redis 实现一个排行榜怎么做？\",\"t\":[\"Redis 中有一个叫做 sorted set 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、游戏中的段位排行榜、话题热度排行榜等等。\",\"相关的一些 Redis 命令: ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。\"]},\"314\":{\"h\":\"Set 的应用场景是什么？\",\"t\":[\"Redis 中 Set 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。\",\"Set 的常见应用场景如下：\",\"存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等等。\",\"需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。\",\"需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。\"]},\"315\":{\"h\":\"使用 Set 实现抽奖系统怎么做？\",\"t\":[\"如果想要使用 Set 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：\",\"SADD key member1 member2 ...：向指定集合添加一个或多个元素。\",\"SPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\",\"SRANDMEMBER key count : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。\"]},\"316\":{\"h\":\"使用 Bitmap 统计活跃用户怎么做？\",\"t\":[\"Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。\",\"如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。\",\"初始化数据：\",\"> SETBIT 20210308 1 1 (integer) 0 > SETBIT 20210308 2 1 (integer) 0 > SETBIT 20210309 1 1 (integer) 0 \",\"统计 20210308~20210309 总活跃用户数:\",\"> BITOP and desk1 20210308 20210309 (integer) 1 > BITCOUNT desk1 (integer) 1 \",\"统计 20210308~20210309 在线活跃用户数:\",\"> BITOP or desk2 20210308 20210309 (integer) 1 > BITCOUNT desk2 (integer) 2 \"]},\"317\":{\"h\":\"使用 HyperLogLog 统计页面 UV 怎么做？\",\"t\":[\"使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：\",\"PFADD key element1 element2 ...：添加一个或多个元素到 HyperLogLog 中。\",\"PFCOUNT key1 key2：获取一个或者多个 HyperLogLog 的唯一计数。\",\"1、将访问指定页面的每个用户 ID 添加到 HyperLogLog 中。\",\"PFADD PAGE_1:UV USER1 USER2 ...... USERn \",\"2、统计指定页面的 UV。\",\"PFCOUNT PAGE_1:UV \"]},\"318\":{\"h\":\"Redis持久化\",\"t\":[\"☀️详见：Redis持久化\"]},\"319\":{\"h\":\"Redis线程模型\",\"t\":[\"Redis读写单线程\",\"对于读写来说，Redis一直是单线程模型。不过在Redis 4.0版本之后引入了多线程来执行一些大键值对的异步删除操作，Redis 6.0之后引入了多线程来处理网络请求（提高网络IO读写性能）。\"]},\"320\":{\"h\":\"Redis单线程了解吗？\",\"t\":[\"Redis基于Reactor模式设计开发了一套高效的事件处理模型（Netty的线程模型也是基于Reactor模式），这套时间处理模型对应的是Redis中的文件事件处理器，由于文件事件处理器是单线程方式运行的，所以一般说Redis是单线程模型。\",\"Redis IO多路复用\",\"文件事件处理器使用IO多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。\",\"虽然文件事件处理器以单线程方式运行，但通过IO多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对阶，这保持列Redis内部单线程设计的简单性。\"]},\"321\":{\"h\":\"单线程如何监听大量的客户端连接？\",\"t\":[\"Redis通过IO多路复用程序来监听来自客户端的大量连接（或者说是监听多个socket），它将感兴趣的事件及类型注册到内核中并监听每个事件是否发生。\",\"IO多路复用技术的使用让Redis不需要额外创建多余的线程来监听客户端的大量连接，降低了资源消耗，（和NIO中的Selector组件很像）。\",\"文件事件处理器包含四个部分：\",\"多个socket（客户端连接）；\",\"IO多路复用程序（支持多个客户端连接的关键）；\",\"文件事件派发器（将socket关联到相应的事件处理器）；\",\"事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。\"]},\"322\":{\"h\":\"Redis 6.0之前为什么不使用多线程？\",\"t\":[\"在Redis 4.0之后的版本中就已经加入了对多线程的支持。不过多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来异步处理。\",\"单线程变成容易并且易于维护；\",\"Redis的性能瓶颈不再CPU，主要在于内存和网络；\",\"多线程就会存在死锁、线程上下文切换等问题，可能会影响性能。\"]},\"323\":{\"h\":\"Redis 6.0之后为何引入了多线程？\",\"t\":[\"Redis 6.0引入多线程主要是为了提高网络IO读写性能，这是Redis中的一个性能瓶颈。\",\"虽然引入了多线程，但是Redis 的多线程只是在网络数据的读写上使用，执行命令仍然是单线程顺序执行。\"]},\"324\":{\"h\":\"Redis后台线程了解吗？\",\"t\":[\"虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：\",\"通过 bio_close_file 后台线程来释放 AOF / RDB 等过程中产生的临时文件资源。\",\"通过 bio_aof_fsync 后台线程调用 fsync 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。\",\"通过 bio_lazy_free后台线程释放大对象（已删除）占用的内存空间.\"]},\"325\":{\"h\":\"Redis内存管理\"},\"326\":{\"h\":\"Redis给缓存数据设置过期时间有啥用？\",\"t\":[\"因为内存有限，不设置过期时间，会导致OOM。\",\"Redis 自带了给缓存数据设置过期时间的功能，比如：\",\"127.0.0.1:6379> expire key 60 # 数据在 60s 后过期 (integer) 1 127.0.0.1:6379> setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire) OK 127.0.0.1:6379> ttl key # 查看数据还有多久过期 (integer) 56 \",\"Redis中除了字符串类型有自己独有设置过期时间的命令setex外，其他方法都需要依靠expire命令来设置过期时间。persist命令可以溢出一个键的过期时间。\",\"Redis是如何判断数据是否过期的？\",\"Redis通过过期字典（可以看做是hash表）来保存数据过期的时间，过期字典的键指向Redis数据库中的某个key，过期字典的值是一个long long 类型的整数，这个整数保存了key所指向的数据库键的过期时间。\"]},\"327\":{\"h\":\"过期数据的删除策略\",\"t\":[\"常用的过期数据的删除策略就两个：\",\"惰性删除：只会在取出key的时候才对数据进行过期检查，这样对CPU友好，但是可能会造成过多的key没有被删除。\",\"定期删除：每隔一段时间抽取一批key执行删除过期key操作。并且Redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。\"]},\"328\":{\"h\":\"Redis内存淘汰机制\",\"t\":[\"Redis 提供 6 种数据淘汰策略：\",\"volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。\",\"volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。\",\"volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。\",\"allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。\",\"allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。\",\"no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！\",\"4.0 版本后增加以下两种：\",\"volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。\",\"allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。\"]},\"329\":{\"h\":\"Redis基础二\"},\"330\":{\"h\":\"Redis性能优化\"},\"331\":{\"h\":\"使用批量操作减少网络传输\",\"t\":[\"一个Redis命令的执行可以简化为以下4步：\",\"发送命令\",\"命令排队\",\"命令执行\",\"返回结果\",\"其中，1和4耗费时间称为RTT，也就是数据在网络上传输的时间。\",\"使用批量操作可以减少网络传输次数，从而有效减少网络开销，大幅减少RTT。\"]},\"332\":{\"h\":\"原生批量操作\",\"t\":[\"MGET(获取一个或多个指定 key 的值)、MSET(设置一个或多个指定 key 的值)、\",\"HMGET(获取指定哈希表中一个或者多个指定字段的值)、HMSET(同时将一个或多个 field-value 对设置到指定哈希表中)、\",\"SADD（向指定集合添加一个或多个元素）\"]},\"333\":{\"h\":\"pipeline\",\"t\":[\"对于不支持批量操作的命令，可以利用pipeline（流水线）将一批Redis命令封装成一组，这些Redis命令会被一次性提交到服务器，只需要一次网络传输。集群模式下不能保证所有的key都在同一个hash slot（哈希槽）上。\",\"原生批量操作和pipeline的区别：\",\"原生批量操作是原子操作，pipeline是非原子操作。\",\"pipeline可以打包不同的命令，原生批量操作不可以。\",\"原生批量操作命令是Redis服务器支持实现的，而pipeline需要服务端和客户端共同实现。\"]},\"334\":{\"h\":\"Lua脚本\",\"t\":[\"Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 原子操作 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。\",\"并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。\",\"不过， Lua 脚本依然存在下面这些缺陷：\",\"如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。\",\"Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 hash slot（哈希槽）上。\"]},\"335\":{\"h\":\"大量key集中过期问题\",\"t\":[\"对于过期key，Redis采用的是定期删除+惰性删除策略。\",\"对于遇到大量key过期（缓存雪崩），解决办法：\",\"给key设置随机过期时间。\",\"开启lazy-free（惰性删除/延时释放）。lazy-free特性是Redis 4.0引入的，让Redis采用异步方式延时释放key使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。\"]},\"336\":{\"h\":\"Redis bigkey\",\"t\":[\"如果一个key对应的value所占用的内存比较大，这个key就能看做是bigkey。\",\"大致标准：String类型的value超过10kb，复合类型的value包含的元素超过5000个。\"]},\"337\":{\"h\":\"有什么危害？\",\"t\":[\"除了会消耗很多的内存和带宽，还会对性能造成很大的影响。\"]},\"338\":{\"h\":\"如何发现？\",\"t\":[\"使用Redis自带的--bigkeys查找，为了降低对Redis的影响，需要指定-i参数控制扫描的频率，redis-cli -p 6379 --bigkeys -i 3 表示扫描过程中每次扫描后休息的时间间隔为 3 秒。\",\"这个命令会扫描Redis中的所有key，对Redis的性能有一点影响，这种方式只能找到每种数据结构top 1 bigkey。\"]},\"339\":{\"h\":\"如何处理？\",\"t\":[\"分割bigkey：将一个bigkey分割为多个小key，这种方式需要修改业务层代码，不推荐；\",\"手动清理：Redis 4.0+可以使用UNLINK命令来异步删除一个或者多个指定的key，Redis 4.0以下可以考虑使用SCAN命令结合DEL命令来分批次删除。\",\"采用合适的数据结构：比如使用HyperLogLog统计页面的UV。\",\"开启lazy-free（惰性删除/延时释放）：lazy-free特性是Redis 4.0开始引入的，让Redis采用异步方式延时释放key使用的内训，将该操作交给单独的子线程处理，避免阻塞主线程。\"]},\"340\":{\"h\":\"Redis hotkey（热 Key）\",\"t\":[\"如果一个key的访问次数明显多余其他key，则这个key就可以看做是hotkey。\",\"hotkey出现的原因是某个热点数据的访问量保证，如参与秒杀的商品。\"]},\"341\":{\"h\":\"有什么危害？\",\"t\":[\"处理hotkey会占用大量的CPU和带宽，可能会影响Redis处理其他请求。如果暴增的请求超出了Redis的处理能力，可能会导致Redis宕机，或者产生缓存击穿，大量请求落入数据库，从而导致数据库崩溃。\"]},\"342\":{\"h\":\"如何发现？\",\"t\":[\"使用Redis自带的--hotkeys参数来查找。\",\"​ Redis 4.0.3新增了hotkeys参数，能返回所有key被访问的次数。\",\"​ 使用前提是Redis Server的maxmemory-policy参数设置为LFU算法（最近最少使用）。\",\"Redis中有两种LFU算法：\",\"volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。\",\"allkeys-flu：当内存不足以容纳新写入的数据时，在键空间中，溢出最不经常使用的key。\",\"使用MONITOR命令。\",\"MONITOR命令是Redis提供的一种实时查看Redis的所有操作的方式，可以用于临时监控Redis实例的操作情况，包括读写、删除操作。\"]},\"343\":{\"h\":\"如何解决？\",\"t\":[\"读写分离：主节点处理写请求，从节点处理读请求。\",\"使用Redis Cluster：将热点数据分散存储在多个Redis节点上。\",\"二级缓存：hotkey采用二级缓存的方式进行处理，将hotkey存放一份到JVM本地内存中（可以使用 Caffeine）。\"]},\"344\":{\"h\":\"慢查询命令\",\"t\":[\"Redis命令的执行简化为以下四步：\",\"发送命令\",\"命令排队\",\"命令执行\",\"返回结果\",\"Redis慢查询统计的是命令执行这一步的耗时，慢查询命令也就是执行时间长的命令。\"]},\"345\":{\"h\":\"原因\",\"t\":[\"Redis中的大部分命令都是**O(1)时间复杂度，但是有少部分O(n)**时间复杂度的命令，如：\",\"KEYS *：会返回所有符合规则的 key。\",\"HGETALL：会返回一个 Hash 中所有的键值对。\",\"LRANGE：会返回 List 中指定范围内的元素。\",\"SMEMBERS：返回 Set 中的所有元素。\",\"SINTER/SUNION/SDIFF：计算多个 Set 的交集/并集/差集。\",\"除了这些时间复杂度为O(n)的命令，还有部分在O(n)以上的命令，例如：\",\"ZRANGE/ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。\",\"ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。\"]},\"346\":{\"h\":\"如何找到慢查询命令？\",\"t\":[\"在 redis.conf 文件中，可以使用 slowlog-log-slower-than 参数设置耗时命令的阈值，并使用 slowlog-max-len 参数设置耗时命令的最大记录条数。\",\"当 Redis 服务器检测到执行时间超过 slowlog-log-slower-than阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。\"]},\"347\":{\"h\":\"Redis内存碎片\",\"t\":[\"和操作系统的内部碎片外部碎片相同意思。\"]},\"348\":{\"h\":\"为何会出现？\",\"t\":[\"Redis存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。\",\"频繁修改Redis中的数据也会产生内存碎片。\"]},\"349\":{\"h\":\"如何查看Redis内存碎片的信息？\",\"t\":[\"使用info memory命令可查看Redis内存相关的信息。\"]},\"350\":{\"h\":\"如何清理Redis内存碎片？\",\"t\":[\"Redis 4.0-RC3版本之后自带了内存整理，可以避免内存碎片率过大的问题。\",\"通过config set命令将activedefrag设置为yes即可。\",\"config set activedefrag yes \",\"具体什么时候清理需要通过下面两个参数控制：\",\"# 内存碎片占用空间达到 500mb 的时候开始清理 config set active-defrag-ignore-bytes 500mb # 内存碎片率大于 1.5 的时候开始清理，内存碎片率=操作系统分配的内存/数据结构实际使用的内存 config set active-defrag-threshold-lower 50 \",\"通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，可以通过下面两个参数来减少对 Redis 性能的影响：\",\"# 内存碎片清理所占用 CPU 时间的比例不低于 20% config set active-defrag-cycle-min 20 # 内存碎片清理所占用 CPU 时间的比例不高于 50% config set active-defrag-cycle-max 50 \",\"另外，重启节点可以做到内存碎片重新整理。\"]},\"351\":{\"h\":\"缓存穿透，雪崩，击穿\"},\"352\":{\"h\":\"缓存穿透（请求数据不存在）\",\"t\":[\"大量请求的key是不合法的，并不存在于Redis和数据库中，就会导致每次的请求都会请求数据库，没有经过缓存层，对数据库造成很大的压力。\"]},\"353\":{\"h\":\"解决办法\",\"t\":[\"缓存无效key（缓存空对象）\",\"如果缓存和数据库都差不到某个key的数据就写一个到Redis中并设置过期时间，如果遇到构建不同请求的key就会导致Redis缓存大量的无效key，\",\"布隆过滤器\",\"布隆过滤器可以判断一个数据在Redis中是否存在。\",\"布隆过滤器判断不存在的数据则一定不存在。反之则不行，布隆过滤器判断一个数据存在，则有可能不存在于Redis中。\",\"将过滤器添加到查询缓存之前，就能过滤掉部分恶意请求。\",\"布隆过滤器\",\"将一个元素放入布隆过滤器中：\",\"使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值；\",\"根据得到的hash值，在位数组中把对应下标的值置为1。\",\"判断一个元素是否存在于布隆过滤器中：\",\"对给定的元素进行相同的哈希计算；\",\"得到的哈希值判断位数组中的每一个元素是否都为1，如果都为1则表示这个值在布隆过滤器中（可能误判），如果有一个值不为1，则元素肯定不在布隆过滤器中。\",\"造成误判的原因：不同的字符串可能哈希出的位置相同（地址冲突）。\"]},\"354\":{\"h\":\"缓存雪崩（大量key同时失效）\",\"t\":[\"同一个时间段内大量的key同时失效或者Redis服务器宕机，导致大量的请求到达数据库。\"]},\"355\":{\"h\":\"解决办法\",\"t\":[\"针对Redis服务不可用的情况：\",\"采用Redis集群，避免单击出现问题导致的整个服务都没办法使用。\",\"限流，避免同时处理大量的请求。\",\"针对热点缓存失效的情况：\",\"对不同的key设置不同的随机失效时间避免同时失效。\",\"缓存永远不会失效（不推荐）。\",\"设置二级缓存。\"]},\"356\":{\"h\":\"缓存击穿（热点key失效）\",\"t\":[\"请求的key是热点数据，如果热点key失效，就会导致大量的请求落入数据库，造成数据库宕机。\",\"秒杀商品就属于热点key，在秒杀项目中采用提前预热，并且在秒杀结束之前key不会过期来防止缓存击穿。\"]},\"357\":{\"h\":\"解决办法\",\"t\":[\"设置热点数据永远不过期或者过期时间比较长。\",\"针对热点数据提前预热，将其存入缓存中并设置合理的过期时间，例如在秒杀场景下，秒杀没有结束前key不会过期。\",\"请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求落到数据库上，减轻数据库的压力。\"]},\"358\":{\"h\":\"缓存穿透和缓存击穿的区别？\",\"t\":[\"缓存穿透中，请求的key不存在于Redis也不存在于数据库中。\",\"缓存击穿中，请求的key对应的是热点数据，该数据存在于数据库中，但不存在于缓存中（通常是因为缓存的数据已经过期）。\"]},\"359\":{\"h\":\"缓存雪崩和缓存击穿有什么区别？\",\"t\":[\"缓存雪崩导致的原因是缓存中的大量数据失效，缓存击穿导致的原因是某个热点数据不存在于缓存中。\"]},\"360\":{\"h\":\"如何保证缓存和数据库数据的一致性？\",\"t\":[\"Cache Aside Pattern（旁路缓存模式）是最常用的一致性方案，读数据时先查找缓存，命中直接返回，如果没有命中则去查找数据库并将数据写入缓存，返回数据。\",\"Cache Aside Pattern遇到数据更新时，先更新DB，然后直接删除cache。\",\"如果数据更新成功，而删除缓存失败的话，有以下解决办法：\",\"缓存失效时间变短（不推荐），让缓存数据的过期时间变短，则就算删除缓存失败，也会很快失效，会造成短时间的不一致性。这种解决办法对于先操作缓存后操作数据库的场景不适用。\",\"增加cache更新重试机制（常用），如果cache服务当前不可用导致缓存删除失败，则隔一段时间进行重试，如果重试还是失败则可以把当前更新失败的key存储队列中，等缓存服务可用之后，再将缓存中对应的key删除。\",\"消息队列删除缓存\",\"消息队列保证可靠性：写到队列中的消息，成功消费之前不会丢失。\",\"消息队列保证消息的成功投递：下游从队列拉去消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合重试场景）\"]},\"361\":{\"h\":\"Redis阻塞的常见原因\"},\"362\":{\"h\":\"O(n) 命令\",\"t\":[\"Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：\",\"KEYS *：会返回所有符合规则的 key。\",\"HGETALL：会返回一个 Hash 中所有的键值对。\",\"LRANGE：会返回 List 中指定范围内的元素。\",\"SMEMBERS：返回 Set 中的所有元素。\",\"SINTER/SUNION/SDIFF：计算多个 Set 的交集/并集/差集。\",\"由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长，从而导致客户端阻塞。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 HSCAN、SSCAN、ZSCAN 代替。\",\"除了这些 O(n)时间复杂度的命令可能会导致阻塞之外， 还有一些时间复杂度可能在 O(n) 以上的命令，例如：\",\"ZRANGE/ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。\",\"ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。\"]},\"363\":{\"h\":\"SAVE 创建 RDB 快照\",\"t\":[\"Redis 提供了两个命令来生成 RDB 快照文件：\",\"save : 同步保存操作，会阻塞 Redis 主线程；\",\"bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。\",\"默认情况下，Redis 默认配置会使用 bgsave 命令。如果手动使用 save 命令生成 RDB 快照文件的话，就会阻塞主线程。\"]},\"364\":{\"h\":\"AOF\",\"t\":[\"AOF 日志记录阻塞。\",\"AOF 刷盘阻塞。\",\"AOF 重写阻塞。\"]},\"365\":{\"h\":\"大Key\",\"t\":[\"查找大key。\",\"删除大Key\"]},\"366\":{\"h\":\"清空数据库\",\"t\":[\"清空数据库和上面 bigkey 删除也是同样道理，flushdb、flushall 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。\"]},\"367\":{\"h\":\"集群扩容\",\"t\":[\"扩容时候需要进行数据迁移，会导致阻塞，对于小key时间基本可以忽略不计，对于大key严重的时候会触发集群内的故障转移。\"]},\"368\":{\"h\":\"Swap（内存交换）\",\"t\":[\"内存不够的时候会将部分数据写入外存，类似虚拟内存（中级调度）。\"]},\"369\":{\"h\":\"CPU竞争\",\"t\":[\"Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。\"]},\"370\":{\"h\":\"网络问题\",\"t\":[\"连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。\"]},\"371\":{\"h\":\"Redis集群\",\"t\":[\"☀️详见Redis集群\"]},\"372\":{\"h\":\"分布式锁\",\"t\":[\"一个最基本的分布式锁需要满足：\",\"互斥：任意一个时刻，锁只能被一个线程持有；\",\"高可用：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。\",\"可重入：一个节点获取了锁之后，还可以再次获取锁。\"]},\"373\":{\"h\":\"基于 Redis 实现分布式锁\"},\"374\":{\"h\":\"如何基于-redis-实现一个最简易的分布式锁如何基于 Redis 实现一个最简易的分布式锁？\",\"t\":[\"在 Redis 中， SETNX 命令是可以帮助我们实现互斥。SETNX 即 SET if Not eXists (对应 Java 中的 setIfAbsent 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， SETNX 啥也不做。\",\"> SETNX lockKey uniqueValue (integer) 1 > SETNX lockKey uniqueValue (integer) 0 \",\"释放锁的话，直接通过 DEL 命令删除对应的 key 即可。\",\"> DEL lockKey (integer) 1 \",\"为了防止误删到其他的锁，建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。\",\"选用 Lua 脚本是为了保证解锁操作的原子性。\",\"// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放 if redis.call(\\\"get\\\",KEYS[1]) == ARGV[1] then return redis.call(\\\"del\\\",KEYS[1]) else return 0 end \",\"+这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。例如引用程序释放锁的逻辑挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。\"]},\"375\":{\"h\":\"如何防止释放锁逻辑失效导致的锁无法释放？\",\"t\":[\"为了避免锁无法被释放，可以给锁添加一个过期时间。\",\"127.0.0.1:6379> SET lockKey uniqueValue EX 3 NX OK \",\"lockKey：加锁的锁名；\",\"uniqueValue：能够唯一标示锁的随机字符串；\",\"NX：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；\",\"EX：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。\",\"一定要保证设置指定key的值和过期时间是一个原子操作，否则依然可能会出现锁无法被释放的问题。\",\"如果操作共享资源的时间大于过期时间，则会导致锁提前释放，分布锁直接失效。设置时间过长，解锁逻辑挂了又会影响性能。\"]},\"376\":{\"h\":\"如何实现锁的优雅续期？\",\"t\":[\"Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。\",\"Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 Watch Dog（ 看门狗），如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。\",\"看门狗名字的由来于 getLockWatchdogTimeout() 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒。\",\"//默认 30秒，支持修改 private long lockWatchdogTimeout = 30 * 1000; public Config setLockWatchdogTimeout(long lockWatchdogTimeout) { this.lockWatchdogTimeout = lockWatchdogTimeout; return this; } public long getLockWatchdogTimeout() { return lockWatchdogTimeout; } \",\"默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。\",\"Watch Dog 通过调用 renewExpirationAsync() 方法实现锁的异步续期\",\"protected CompletionStage<Boolean> renewExpirationAsync(long threadId) { return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, // 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认） \\\"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \\\" + \\\"redis.call('pexpire', KEYS[1], ARGV[1]); \\\" + \\\"return 1; \\\" + \\\"end; \\\" + \\\"return 0;\\\", Collections.singletonList(getRawName()), internalLockLeaseTime, getLockName(threadId)); } \",\"以 Redisson 的分布式可重入锁 RLock 为例来说明如何使用 Redisson 实现分布式锁：\",\"// 1.获取指定的分布式锁对象 RLock lock = redisson.getLock(\\\"lock\\\"); // 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制 lock.lock(); // 3.执行业务 ... // 4.释放锁 lock.unlock(); \",\"只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。\",\"// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制 lock.lock(10, TimeUnit.SECONDS); \"]},\"377\":{\"h\":\"如何实现可重入锁？\",\"t\":[\"所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 synchronized 和 ReentrantLock 都属于可重入锁。\",\"不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。\",\"我们不需要自己手动实现，推荐使用我们上面提到的 Redisson ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。\"]},\"378\":{\"h\":\"Redis 如何解决集群情况下分布式锁的可靠性？\",\"t\":[\"为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。\",\"Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。\",\"针对这个问题，Redis 之父 antirez 设计了Redlock 算法来解决。\",\"Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，就认为客户端成功地获得分布式锁，否则加锁失败。即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。\",\"Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。\"]},\"379\":{\"h\":\"基于 ZooKeeper 实现分布式锁\",\"t\":[\"Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。\",\"ZooKeeper 分布式锁是基于 临时顺序节点 和 Watcher（事件监听器） 实现的。\",\"类似AQS的实现方式。\",\"获取锁：\",\"首先我们要有一个持久节点/locks，客户端获取锁就是在locks下创建临时顺序节点。\",\"假设客户端 1 创建了/locks/lock1节点，创建成功之后，会判断 lock1是否是 /locks 下最小的子节点。\",\"如果 lock1是最小的子节点，则获取锁成功。否则，获取锁失败。\",\"如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如/locks/lock0上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。\",\"释放锁：\",\"成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。\",\"成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。\",\"前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。\"]},\"380\":{\"h\":\"为什么要用临时顺序节点？\",\"t\":[\"每个数据节点在 ZooKeeper 中被称为 znode，它是 ZooKeeper 中数据的最小单元。\",\"通常是将 znode 分为 4 大类：\",\"持久（PERSISTENT）节点：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。\",\"临时（EPHEMERAL）节点：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点只能做叶子节点 ，不能创建子节点。\",\"持久顺序（PERSISTENT_SEQUENTIAL）节点：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001、/node1/app0000000002 。\",\"临时顺序（EPHEMERAL_SEQUENTIAL）节点：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。\",\"可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。\",\"使用 Redis 实现分布式锁的时候，通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。\",\"假设不使用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。\",\"ZooKeeper通过临时节点解决释放锁逻辑失效问题，通过顺序节点解决顺序唤醒后续节点（避免竞争锁）。\"]},\"381\":{\"h\":\"为什么要设置对前一个节点的监听？\",\"t\":[\"当一个节点对应的客户端释放锁之后（也就是前一个节点被删除，监听的是删除事件），通知获取锁失败的客户端（唤醒等待线程，Java中的wait/notify），让它去获取锁。\"]},\"382\":{\"h\":\"Redis数据结构\",\"t\":[\"Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。\",\"这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。\",\"Redis 基本数据结构的底层数据结构实现如下：\",\"String\",\"List\",\"Hash\",\"Set\",\"Zset\",\"SDS\",\"LinkedList/ZipList/QuickList\",\"Hash Table、ZipList\",\"ZipList、Intset\",\"ZipList、SkipList\"]},\"383\":{\"h\":\"String（字符串）\",\"t\":[\"String 是 Redis 中最简单同时也是最常用的一个数据结构。\",\"String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。\",\"Redis自己构建了一种 简单动态字符串（Simple Dynamic String，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。\"]},\"384\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"SET key value\",\"设置指定 key 的值\",\"SETNX key value\",\"只有在 key 不存在时设置 key 的值\",\"GET key\",\"获取指定 key 的值\",\"MSET key1 value1 key2 value2 …\",\"设置一个或多个指定 key 的值\",\"MGET key1 key2 ...\",\"获取一个或多个指定 key 的值\",\"STRLEN key\",\"返回 key 所储存的字符串值的长度\",\"INCR key\",\"将 key 中储存的数字值增一\",\"DECR key\",\"将 key 中储存的数字值减一\",\"EXISTS key\",\"判断指定 key 是否存在\",\"DEL key（通用）\",\"删除指定的 key\",\"EXPIRE key seconds（通用）\",\"给指定 key 设置过期时间\"]},\"385\":{\"h\":\"应用场景\",\"t\":[\"需要存储常规数据的场景\",\"举例：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。\",\"相关命令：SET、GET。\",\"需要计数的场景\",\"举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。\",\"相关命令：SET、GET、 INCR、DECR 。\",\"分布式锁\",\"利用 SETNX key value 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。\"]},\"386\":{\"h\":\"List（列表）\",\"t\":[\"Redis 中的 List 其实就是链表数据结构的实现，Redis 的 List 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。\"]},\"387\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"RPUSH key value1 value2 ...\",\"在指定列表的尾部（右边）添加一个或多个元素\",\"LPUSH key value1 value2 ...\",\"在指定列表的头部（左边）添加一个或多个元素\",\"LSET key index value\",\"将指定列表索引 index 位置的值设置为 value\",\"LPOP key\",\"移除并获取指定列表的第一个元素(最左边)\",\"RPOP key\",\"移除并获取指定列表的最后一个元素(最右边)\",\"LLEN key\",\"获取列表元素数量\",\"LRANGE key start end\",\"获取列表 start 和 end 之间 的元素\"]},\"388\":{\"h\":\"应用场景\",\"t\":[\"信息流展示\",\"举例：最新文章、最新动态。\",\"相关命令：LPUSH、LRANGE。\",\"消息队列\",\"Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。\",\"相对来说，Redis 5.0 新增加的一个数据结构 Stream 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。\"]},\"389\":{\"h\":\"Hash（哈希）\",\"t\":[\"Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象。\",\"Hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。\"]},\"390\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"HSET key field value\",\"设置指定哈希表中指定字段的值\",\"HSETNX key field value\",\"只有指定字段不存在时设置指定字段的值\",\"HMSET key field1 value1 field2 value2 ...\",\"同时将一个或多个 field-value (域-值)对设置到指定哈希表中\",\"HGET key field\",\"获取指定哈希表中指定字段的值\",\"HMGET key field1 field2 ...\",\"获取指定哈希表中一个或者多个指定字段的值\",\"HGETALL key\",\"获取指定哈希表中所有的键值对\",\"HEXISTS key field\",\"查看指定哈希表中指定的字段是否存在\",\"HDEL key field1 field2 ...\",\"删除一个或多个哈希表字段\",\"HLEN key\",\"获取指定哈希表中字段的数量\",\"HINCRBY key field increment\",\"对指定哈希中的指定字段做运算操作（正数为加，负数为减）\",\"Hash数据结构添加需要三个参数，分别是hash的key、键、值，而String类型是两个参数。\"]},\"391\":{\"h\":\"应用场景\",\"t\":[\"对象数据存储场景\",\"举例：用户信息、商品信息、文章信息、购物车信息。\",\"相关命令：HSET （设置单个字段的值）、HMSET（设置多个字段的值）、HGET（获取单个字段的值）、HMGET（获取多个字段的值）。\"]},\"392\":{\"h\":\"Set（集合）\",\"t\":[\"Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。基于 Set 能轻易实现交集、并集、差集的操作，比如可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。\"]},\"393\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"SADD key member1 member2 ...\",\"向指定集合添加一个或多个元素\",\"SMEMBERS key\",\"获取指定集合中的所有元素\",\"SCARD key\",\"获取指定集合的元素数量\",\"SISMEMBER key member\",\"判断指定元素是否在指定集合中\",\"SINTER key1 key2 ...\",\"获取给定所有集合的交集\",\"SINTERSTORE destination key1 key2 ...\",\"将给定所有集合的交集存储在 destination 中\",\"SUNION key1 key2 ...\",\"获取给定所有集合的并集\",\"SUNIONSTORE destination key1 key2 ...\",\"将给定所有集合的并集存储在 destination 中\",\"SDIFF key1 key2 ...\",\"获取给定所有集合的差集\",\"SDIFFSTORE destination key1 key2 ...\",\"将给定所有集合的差集存储在 destination 中\",\"SPOP key count\",\"随机移除并获取指定集合中一个或多个元素\",\"SRANDMEMBER key count\",\"随机获取指定集合中指定数量的元素\"]},\"394\":{\"h\":\"应用场景\",\"t\":[\"需要存放的数据不能重复的场景\",\"举例：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等场景。\",\"相关命令：SCARD（获取集合数量） 。\",\"需要获取多个数据源交集、并集和差集的场景\",\"举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。\",\"相关命令：SINTER（交集）、SINTERSTORE （交集）、SUNION （并集）、SUNIONSTORE（并集）、SDIFF（差集）、SDIFFSTORE （差集）。\",\"需要随机获取数据源中的元素的场景\",\"举例：抽奖系统、随机点名等场景。\",\"相关命令：SPOP（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、SRANDMEMBER（随机获取集合中的元素，适合允许重复中奖的场景）。\"]},\"395\":{\"h\":\"Sorted Set（有序集合）\",\"t\":[\"Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。\"]},\"396\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"ZADD key score1 member1 score2 member2 ...\",\"向指定有序集合添加一个或多个元素\",\"ZCARD KEY\",\"获取指定有序集合的元素数量\",\"ZSCORE key member\",\"获取指定有序集合中指定元素的 score 值\",\"ZINTERSTORE destination numkeys key1 key2 ...\",\"将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量\",\"ZUNIONSTORE destination numkeys key1 key2 ...\",\"求并集，其它和 ZINTERSTORE 类似\",\"ZDIFFSTORE destination numkeys key1 key2 ...\",\"求差集，其它和 ZINTERSTORE 类似\",\"ZRANGE key start end\",\"获取指定有序集合 start 和 end 之间的元素（score 从低到高）\",\"ZREVRANGE key start end\",\"获取指定有序集合 start 和 end 之间的元素（score 从高到底）\",\"ZREVRANK key member\",\"获取指定有序集合中指定元素的排名(score 从大到小排序)\"]},\"397\":{\"h\":\"应用场景\",\"t\":[\"需要随机获取数据源中的元素根据某个权重进行排序的场景\",\"举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、游戏中的段位排行榜、话题热度排行榜等等。\",\"相关命令：ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。\",\"需要存储的数据有优先级或者重要程度的场景 比如优先级任务队列。\",\"举例：优先级任务队列。\",\"相关命令：ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。\"]},\"398\":{\"h\":\"Bitmap\",\"t\":[\"Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。\"]},\"399\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"SETBIT key offset value\",\"设置指定 offset 位置的值\",\"GETBIT key offset\",\"获取指定 offset 位置的值\",\"BITCOUNT key start end\",\"获取 start 和 end 之前值为 1 的元素个数\",\"BITOP operation destkey key1 key2 ...\",\"对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT\"]},\"400\":{\"h\":\"应用场景\",\"t\":[\"需要保存状态信息（0/1 即可表示）的场景\",\"举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。\",\"相关命令：SETBIT、GETBIT、BITCOUNT、BITOP。\"]},\"401\":{\"h\":\"HyperLogLog\",\"t\":[\"HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。\",\"Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近2^64个不同元素。并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：\",\"稀疏矩阵：计数较少的时候，占用空间很小。\",\"稠密矩阵：计数达到某个阈值的时候，占用 12k 的空间。\",\"基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 0.81% ）。\"]},\"402\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"PFADD key element1 element2 ...\",\"添加一个或多个元素到 HyperLogLog 中\",\"PFCOUNT key1 key2\",\"获取一个或者多个 HyperLogLog 的唯一计数。\",\"PFMERGE destkey sourcekey1 sourcekey2 ...\",\"将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。\"]},\"403\":{\"h\":\"应用场景\",\"t\":[\"数量量巨大（百万、千万级别以上）的计数场景\",\"举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、\",\"相关命令：PFADD、PFCOUNT 。\"]},\"404\":{\"h\":\"Geospatial index\",\"t\":[\"Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。\",\"通过 GEO 可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。\"]},\"405\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"GEOADD key longitude1 latitude1 member1 ...\",\"添加一个或多个元素对应的经纬度信息到 GEO 中\",\"GEOPOS key member1 member2 ...\",\"返回给定元素的经纬度信息\",\"GEODIST key member1 member2 M/KM/FT/MI\",\"返回两个给定元素之间的距离\",\"GEORADIUS key longitude latitude radius distance\",\"获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数\",\"GEORADIUSBYMEMBER key member radius distance\",\"类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素\",\"GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。\"]},\"406\":{\"h\":\"应用场景\",\"t\":[\"需要管理使用地理空间数据的场景\",\"举例：查找附近商铺。\",\"相关命令: GEOADD、GEORADIUS、GEORADIUSBYMEMBER 。\"]},\"407\":{\"h\":\"Redis持久化\"},\"408\":{\"h\":\"RDB持久化\",\"t\":[\"Redis Database Backup file 把内存中的所有数据都记录到磁盘中，当Redis实例故障之后，从磁盘中读取快照文件。\",\"快照持久化是Redis默认采用的持久化方式。\",\"Redis停机时会自动执行一次RDB。\",\"缺点 \",\"执行间隔很长，可能存在数据丢失的风险。\",\"fork子进程，压缩，写出RDB文件都比较耗时。\"]},\"409\":{\"h\":\"RDB创建快照的时候会阻塞主线程吗？\",\"t\":[\"Redis提供了两个命令来生成RDB快照文件：\",\"save：由主进程执行save，其他命令都会被阻塞；\",\"bgsave：fork出一个子进程，子进程执行，不会阻塞Redis主进程，默认选项。 \",\"子进程是fork主进程得到的，此时会阻塞主进程；\",\"子进程共享主进程的物理内存区域，加快fork速度；\",\"fork采用copy on write技术； \",\"主进程进行读的时候，访问共享内存；\",\"主进程执行写的时候，则会拷贝一份数据，执行写操作。\"]},\"410\":{\"h\":\"AOF持久化\",\"t\":[\"Append Only File 追加文件，redis处理的每一个命令都会记录在AOF文件中，可以看做是命令日志文件。\",\"与快照持久化相比，AOF持久化的实时性更好。默认情况下Redis没有开启AOF方式的持久化，通过appendonly参数开启。\",\"开启AOF持久化后没执行一条会更改Redis中的数据的命令，Redis就会将命令写入到AOF缓冲区中，最后再根据持久化方式的配置来决定何时将系统内核缓存区的数据同步到磁盘中。\",\"只有同步到磁盘中才算持久化保存，否则还是会存在数据丢失的风险。\"]},\"411\":{\"h\":\"AOF工作基本流程？\",\"t\":[\"AOF持久化功能的实现可以简单分为5步：\",\"命令追加（append）：所有的写命令会追加到AOF缓冲区中。\",\"文件写入（write）：将AOF缓冲区的数据写入到AOF文件中，这一步需要调用write函数，write将数据写入到了系统内核缓冲区之后直接返回。此时并没有同步到磁盘。\",\"文件同步（fsync）：AOF缓冲区根据对应的持久化方式向磁盘做同步操作，这一步需要调用fsync函数，fsync针对单个文件操作，对其进行强制磁盘同步，fsync将阻塞直到写入磁盘完成之后返回，保证数据的持久化。\",\"文件重写（rewrite）：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩目的。\",\"重启加载（load）：当Redis重启时，可以加载AOF文件进行数据恢复。\"]},\"412\":{\"h\":\"AOF持久化方式有哪些？\",\"t\":[\"appendonly开启，保存文件的频率有三种：\",\"appendfsync always ：主线程调用 write 执行写操作后，后台线程调用fsync保存aof文件到磁盘，严重影响性能。\",\"appendfsync everysec ：主线程调用 write 执行写操作后，后台线程每秒调用fsync保存aof文件。\",\"appendfsync no： 主线程调用 write 执行写操作后将数据写入AOF缓冲区，由操作系统决定什么时候写回磁盘。\"]},\"413\":{\"h\":\"AOF为什么是在执行完命令之后记录日志？\",\"t\":[\"关系型数据库通常都是执行命令之前记录日志，而Redis AOF持久化机制是在执行完命令之后再记录日志。\",\"为什么？\",\"避免额外的检查开销，AOF记录日志不会对命令进行语法检查；\",\"在命令执行完之后再记录，不会阻塞当前的命令执行。\",\"同时也带来了风险：\",\"如果刚执行完命令Redis宕机了就会导致对应的修改记录丢失；\",\"可能会阻塞后续其他命令的执行。\"]},\"414\":{\"h\":\"AOF重写了解吗？\",\"t\":[\"当AOF变得太大时，Redis能在后台自动重写AOF产生一个新的AOF文件，新的AOF文件和原有AOF文件所保存的数据库状态一直，但是体积更小。\",\"由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。\",\"AOF 文件重写期间，Redis 还会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。\",\"使用BGREWRITEAOF可以手动让AOF文件执行重写功能。\",\"也可以通过以下配置，让程序自动决定触发时机：\",\"auto-aof-rewrite-percentage 100：这次的文件大小比上次增长超过100%则重写，默认值100，设置为0表示禁用自动重写。\",\"auto-aof-rewrite-min-size 64mb：文件体积大于多少时执行重写，默认值64MB。\"]},\"415\":{\"h\":\"AOF 校验机制了解吗？\",\"t\":[\"AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。通过使用一种叫做 **校验和（checksum）**的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。\",\"因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。\"]},\"416\":{\"h\":\"如何选择 RDB 和 AOF？\",\"t\":[\"RDB 比 AOF 优秀的地方：\",\"RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。\",\"使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。\",\"AOF 比 RDB 优秀的地方：\",\"RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。\",\"RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。\",\"AOF 以一种易于理解和解析的格式包含所有操作的日志。可以轻松地导出 AOF 文件进行分析，也可以直接操作 AOF 文件来解决一些问题。比如，如果执行FLUSHALL命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。\",\"综上：\",\"Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。\",\"不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。\",\"如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。\",\"RDB\",\"AOF\",\"持久化方式\",\"定时对整个内存创建快照\",\"记录每一次执行的命令\",\"数据完整性\",\"不完整，两次备份之间的操作会丢失\",\"相对完整，取决于刷盘策略\",\"文件大小\",\"会有压缩，文件体积小\",\"记录命令，文件体积很大\",\"宕机恢复速度\",\"很快\",\"慢\",\"数据恢复优先级\",\"低，因为数据完整性不如AOF\",\"高，数据完整性更高\",\"系统占用资源\",\"高，大量CPU和内存消耗（创建快照时）\",\"低，主要是磁盘IO资源，但是AOF重写时会占用大量CPU和内存资源\",\"使用场景\",\"可以容忍数据部分不完整，追求更快的启动速度的场景\",\"对数据完整性安全性要求较高的场景\"]},\"417\":{\"h\":\"Redis集群\"},\"418\":{\"h\":\"主从集群\",\"t\":[\"多个Redis节点实现主从集群，主节点master用来写，从节点用来读。\",\"开启主从：通过在redis.conf中添加\",\"slaveof <master ip><masterport> //关联从节点 \"]},\"419\":{\"h\":\"数据同步原理\"},\"420\":{\"h\":\"全量同步\",\"t\":[\"由于第一次同步需要生成RDB文件，之后将RDB文件发送给从节点，因此叫做全量同步，较为消耗性能。\",\"记录RDB期间生成的新命令都会写入内存缓冲区repl_baklog中，最后再发送给从节点。\",\"如何判断是不是第一次主从同步？\",\"Replication Id：简称replid，是数据集的标记，id一致表示是同一个数据集。每一个master都有唯一的replid，slave则会继承master节点的replid。\",\"offset：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大，slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。类似于版本号。\",\"因此slave做数据同步，必须向master声明自己的Replication Id和offset，master才能判断需要更新哪些数据。\",\"Replication Id不同则表示是第一次主从同步，offset落后于master则表示需要更新。\"]},\"421\":{\"h\":\"增量同步\",\"t\":[\"增量同步用的命令来自repl_baklog，存储有上限，如果没有空间记录命令，则会覆盖之前的数据，因此slave断开太久就会导致没有备份的数据被覆盖，则无法基于repl_baklog做增量同步，只能再次全量同步。\"]},\"422\":{\"h\":\"优化主从集群\",\"t\":[\"在master中配置repl-diskless-sync yes 启用无磁盘复制，避免全量更新时的磁盘IO。（直接将数据发送给slave，不再写入磁盘）\",\"Redis单节点的内存占用不要太大，可以减少RDB导致的过多IO。\",\"适当提高repl_baklog大小，发现slave宕机之后尽快实现故障恢复，尽可能避免全量同步。\",\"限制一个master节点上的slave节点，如果实在太多，可以采用主-从-从链式结构，减少master压力。\",\"总结\",\"全量同步和增量同步的区别？\",\"全量同步：master将完整的内存数据生成RDB，发送给slave。后续命令保存至repl_baklog，逐个发送给slave。\",\"增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave。\",\"什么时候执行全量同步？\",\"slave节点第一次连接时。\",\"slave节点断开太久，导致repl_baklog中的offset已经被覆盖。\",\"什么时候执行增量同步？\",\"slave节点断开又恢复，并且在repl_baklog中能找到offset时。\"]},\"423\":{\"h\":\"Redis哨兵Sentinel\"},\"424\":{\"h\":\"作用\",\"t\":[\"监控：不断监控slave和master是否正常工作。\",\"自动故障恢复：如果master故障，sentinel会将一个slaver提升为master，当故障实例恢复之后也是以新的master为主节点。\",\"通知：充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新的消息发送给Redis客户端。\"]},\"425\":{\"h\":\"心跳机制\",\"t\":[\"每秒向集群内的每一个实例发送ping命令。\",\"如果未在规定时间内响应，则认为实例下线。\",\"超过一半的sentinel都认为这个实例主观下线，则该实例客观下线。quorum值最好超过sentinel实例数量的一半。\"]},\"426\":{\"h\":\"选举新的master\",\"t\":[\"一旦发现master故障，就需要选举新的slave作为master，依据：\",\"首先判断slave节点与master断开的时间长短，如果超过指定值（down-after-milliseconds*10)则会排除该slave节点。\",\"然后判断slave节点的slave-priority值，越小优先级越高，0表示永远不会参加选举。\",\"如果slave-priority相同，则判断slave节点的offset，越大说明数据越新，优先级越高。\",\"最后判断slave节点运行id的大小，越小则优先级越高（id越小说明越先被创建，存活时间越长）。\"]},\"427\":{\"h\":\"如何实现故障转移？\",\"t\":[\"选举了新的slave节点之后，故障转移步骤如下：\",\"sentinel给备选slave1节点发送slaveof no one命令，表示不再做从节点，成为master节点。\",\"sentinel给所有其他slave发送配置从节点命令slaveof <master ip><masterport>，让其余节点变成这个节点的从节点，开始从新的master节点上同步数据。\",\"最后sentinel将故障节点标记为slave，故障恢复之后此节点成为slave1的从节点。\"]},\"428\":{\"h\":\"Redis分片集群\",\"t\":[\"主从解决了高并发读，高可用的问题，但是存在：海量数据存储问题，高并发写问题。\"]},\"429\":{\"h\":\"使用分片集群\",\"t\":[\"使用分片集群解决海量存储问题和高并发写问题：\",\"集群中有多个master，每一个master保存不同的数据。\",\"每一个master都可以有多个slave节点。\",\"master之间通过ping检测彼此健康状况。\",\"客户端请求可以访问集群任意节点，最终都会被转发到正确的节点上。\",\"创建命令\",\"redis-cli --cluster create --cluster-replicas 1 <ip：端口> <ip：端口> <ip：端口> <ip：端口> \",\"--cluster-replicas 1表示集群中每个master的副本个数为1，例如写1，则表示一个master对应一个slave，则4个实例中有2个是master，2个是slave。其中写在前面的2个实例是master。\"]},\"430\":{\"h\":\"散列插槽\",\"t\":[\"redis会把每一个master节点映射到0~16383 的插槽上。\",\"数据key不是与节点绑定而是与插槽绑定，redis会根据key的有效部分计算插槽。\",\"固定数据保存在同一个节点。\",\"将商品类型key 加上大括号，就是标识有效部分，这个部分会计算hash值转化为插槽，同类的商品就能对应到同一个节点上。\",\"为什么是 16384 个插槽?\",\"2^14^=16384、2^16^=65536。\",\"如果槽位是65536个，发送心跳信息的消息头是65536/8/1024 = 8k。\",\"如果槽位是16384个，发送心跳信息的消息头是16384/8/1024 = 2k。\",\"因为Redis每秒都会发送一定数量的心跳包，如果消息头是8k，未免有些太大了，浪费网络资源。\",\"Redis的集群主节点数量一般不会超过1000个。集群中节点越多，心跳包的消息体内的数据就越多，如果节点过多，也会造成网络拥堵。对于节点数在1000个以内的Redis Cluster，16384个槽位完全够用。\",\"Redis主节点的哈希槽信息是通过bitmap存储的，在传输过程中，会对bitmap进行压缩，bitmap的填充率越低，压缩率越高。\",\"bitmap 填充率 = slots / N (N表示节点数)。\",\"也就是说slots越小，填充率就会越小，压缩率就会越高，传输效率就会越高。\"]},\"431\":{\"h\":\"故障转移\",\"t\":[\"Redis分片集群具备自动的主从切换，不需要使用哨兵。\",\"手动故障转移，数据迁移\",\"利用cluster failover命令让集群中的某个master宕机，切换到执行cluster failover的slave节点，实现无感知的数据迁移。\",\"支持三种模式：\",\"缺省：默认流程，slave节点拒绝任何客户端请求，再进行主从同步，标记自己为master，广播转移结果。\",\"force：省略了对offset一致性校验，省略步骤2、3。\",\"takeover：忽略数据一致性，忽略其余master意见，直接标记自己为master并广播结果，直接从5开始执行。\",\"操作步骤：\",\"利用redis-cli连接需要变成master的节点；\",\"执行cluster failover命令。\"]},\"432\":{\"h\":\"Redis\"},\"433\":{\"h\":\"Spring\"},\"434\":{\"h\":\"Spring是什么\",\"t\":[\"Spring是一个轻量级的控制反转（Ioc）和面向切面（AOP）的容器框架。\",\"从大小和开销两方面而言Spring是轻量级的。\",\"通过控制反转的技术达到松耦合。\",\"提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发。\",\"包含和管理应用对象的配置和声明周期，通过容器实现。\",\"将简单的配置组件组合成复杂的应用。\"]},\"435\":{\"h\":\"单例Bean是单例设计模式吗？\",\"t\":[\"单例模式指的是在JVM中一个类只能构造出一个实例对象，有很多单例模式的实现方法例如双检查法（懒汉式），静态代码块（饿汉式）。\",\"而Spring中的单例Bean也是一种单例模式，只不过范围比较小，范围是beanName，一个beanName对应同一个Bean对象，不同的beanName对应不同的Bean对象。\",\"也就是说同一个类可以创建多个实例，但是名称必须是不同的。\"]},\"436\":{\"h\":\"什么是单例池？作用是什么？\",\"t\":[\"单例Bean通过多次getBean方法都会获得同一个实例。\",\"@ComponentScan(\\\"com.zyl\\\") public class AppConfig { } @Component public class UserService { } public class Test { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); Object userService1 = applicationContext.getBean(\\\"userService\\\"); Object userService2 = applicationContext.getBean(\\\"userService\\\"); System.out.println(userService1); System.out.println(userService2); } } \",\"创建容器之后获取userService得到的是同一个实例。而这个实例就是放入单例池中，单例池可以看成是一个Map，保证Bean是单例。\"]},\"437\":{\"h\":\"Spring中的设计模式\",\"t\":[\"工厂设计模式：Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。\",\"代理设计模式：Spring AOP 功能的实现。\",\"单例设计模式：Spring 中的 Bean 默认都是单例的。\",\"模板方法模式：Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。\",\"观察者模式：各种监听器就是使用观察者模式。\",\"适配器模式：Spring AOP 的增强或通知（Advice）使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配Controller。\",\"包装器设计模式：构造数据库查询条件的Wrapper就是包装器模式。\",\"。。。\"]},\"438\":{\"h\":\"Spring中Bean创建的生命周期\",\"t\":[\"Spring中一个Bean的创建大概分为以下几个步骤：\",\"推断构造方法\",\"实例化\",\"依赖注入\",\"初始化前，处理@PostConstruct注解\",\"初始化，处理Initializing接口\",\"初始化后，进行AOP\",\"放入单例池\"]},\"439\":{\"h\":\"Bean初始化和实例化的区别是什么？\",\"t\":[\"Bean的实例化就是步骤UserService类-->无参构造方法-->对象，而初始化就是调用afterPropertiesSet()（类需要实现InitializingBean接口）。\",\"初始化过程其实就是对应afterPropertiesSet()方法，通过判断\",\"boolean isInitializingBean = (bean instanceof InitializingBean); \",\"bean实现了InitializingBean则调用afterPropertiesSet()。\",\"@Component public class UserService implements InitializingBean { //想加入一个特定的User对象到UserService private User admin; @Override public void afterPropertiesSet() throws Exception { //mysql ->管理员的信息->User对象->admin } } \"]},\"440\":{\"h\":\"初始化后是什么？\",\"t\":[\"初始化后做的事情就是执行AOP，生成代理对象，并将代理对象放入单例池中。\"]},\"441\":{\"h\":\"Bean对象和普通对象之间的区别是什么\",\"t\":[\"Bean对象本身就是普通对象，不过可能会经过初始化前和初始化后的增强。\"]},\"442\":{\"h\":\"@PostConstruct是如何工作的\",\"t\":[\"创建Bean的过程：UserService类-->无参构造方法-->对象-->依赖注入-->初始化前（@PostConstruct）-->初始化（InitializingBean）-->初始化后（AOP）-->放入Map单例池-->Bean对象。\",\"@Component public class UserService { //想加入一个特定的User对象到UserService private User admin; @PostConstruct public void a(){ //mysql ->管理员的信息->User对象->admin } } \",\"通过@PostConstruct，让Bean在初始化前进行增强。对应于创建Bean过程中的初始化前（调用@PostConstruct修饰的方法），再通过反射去调用方法。\",\"for (Method method : userService1.getClass().getDeclaredMethods()) { if (method.isAnnotationPresent(PostConstruct.class)) { method.invoke(userService1, null); } } \"]},\"443\":{\"h\":\"构造方法推断\",\"t\":[\"Spring发现有多个构造方法的时候，如果有无参构造方法则调用无参构造，如果没有无参构造，并且有参构造不止一个则会报错。（例如不存在无参构造，但是存在多个不同参数的有参构造方法）\",\"可以使用@Autowired注解默认使用的构造方法。\"]},\"444\":{\"h\":\"先ByType再ByName\",\"t\":[\"在单例池Map中会存在多个类型相同的Bean。\",\"@Configuration public class BeanConfig { @Bean UserService userService1(){ return new UserService(); } @Bean UserService userService2(){ return new UserService(); } } \",\"会产生两个UserService类型的Bean，但是名字不同。\",\"依赖注入时，如果执行有参构造方法，发现UserService类型的Bean只有一个则直接注入（ByType），发现有多个则根据名称注入（ByName）。\",\"@Autowired public OrderService(UserService userService2){ this.userService = userService2; };//注入的是第二个名为“userService2”的Bean \",\"@Autowired只能根据类型注入的，可以使用@Qualifier(\\\"userService1\\\")指定名称。\"]},\"445\":{\"h\":\"Spring事务\"},\"446\":{\"h\":\"事务实现原理\",\"t\":[\"事务Transactional本质也是通过代理对象调用普通对象的方法，并在前后做增强。\",\"class UserServiceProxy extends UserService{ UserService target; public void test(){ //@Transactional //事务管理器新建一个数据库连接conn;ThreadLocal<Map,conn> //conn.autocommit=false;//关闭自动提交 //target.test();//执行数据库操作 //没有出现异常则提交conn.commit();否则回滚conn.rollBack(); } } \"]},\"447\":{\"h\":\"Spring事务传播机制\",\"t\":[\"多个事务方法相互调用的时候，事务包含以下的转播机制。\",\"REQUIRED（默认）：如果当前没有事务则开启一个新的事务，如果存在事务则加入。\",\"SUPPORTS：如果存在事务则加入，否则以非事务模式运行。\",\"MANDATORY：如果存在事务则加入，如果不存在事务则抛出异常。\",\"REQUIRED_NEW：创建一个新的事务，如果已经存在事务，则将该事务挂起。\",\"NEVER：从来不使用事务。\",\"NESTED：如果存在事务则将当前事务嵌套进去，否则开启一个新的事务。\"]},\"448\":{\"h\":\"Spring事务失效的原因\",\"t\":[\"1、方法异常没有抛出\",\"@Transactional public void test(){ try { System.out.println(\\\"Spring事务\\\");//正常代码执行 int a=1/0;//异常代码 被捕获 }catch (Exception e){ System.out.println(\\\"出现异常\\\");//这里并没有抛出异常，而是自己处理了 因此Spring无法感知 } } \",\"异常不能被Spring感知就不会执行rollBack。\",\"2、使用@Transactional修饰的方法不是public方法\",\"通过实现类或者是父类生成代理对象，代理对象不能调用子类private方法。\",\"3、自身调用\",\"事务是通过代理对象调用才能生效，如果在一个类里面调用本类的方法就相当于this调用，事务不会生效。\",\"4、propagation事务传播机制设置错误\",\"如果内部方法的事务传播类型为不支持事务的传播类型，那么，内部方法的事务在Spring中会失效。\",\"@Transactional(propagation = Propagation.NEVER) //如果有一个事务已经存在则会抛出异常 \",\"5、数据库不支持事务\",\"6、异常类型错误\",\"7、没有被Spring管理\"]},\"449\":{\"h\":\"SpringAOP怎么工作的？\",\"t\":[\"SpringAOP是通过动态代理机制，如果Bean实现了接口，就会采用JDK动态代理来生成该接口的代理对象（实现类），如果没有实现接口，则通过CGLIB来生成当前类的一个代理对象（父类）。\",\"AOP表示面向切面编程，是一个思想，AspectJ就是其中的一种实现方式，会在编译器对类进行增强，需要使用AspectJ提供的编译器，提供了例如@Before、@After、@Around等注解，而SpringAOP是采用动态代理的方式实现AOP，同样也使用了这些注解但是实现方式是完全不同的。\"]},\"450\":{\"h\":\"Spring为什么要使用三级缓存来解决循环依赖？\",\"t\":[\"Bean的创建生命周期\",\"创建普通对象；\",\"填充属性；\",\"填充其他属性；\",\"其他操作；\",\"初始化后；\",\"放入单例池。\",\"三级缓存，就是三个Map集合。\",\"第一级缓存：singletonObjects，它用来存放经过完整Bean生命周期过程的单例Bean对象；\",\"第二级缓存：earlySingletonObjects，它用来保存哪些没有经过完整Bean生命周期的单例Bean对象，用来保证不完整的bean也是单例；\",\"第三级缓存：singletonFactories，它保存的就是一个lambda表达式，它主要的作用就是bean出现循环依赖后，某一个bean到底会不会进行AOP操作。\",\"循环依赖为什么用三级缓存\",\"AService和BService相互依赖。\",\"如果采用以下方法：\",\"创建AService普通对象之后放入二级缓存，注入BService时发现没有，转而去创建BService对象，BService对象需要依赖注入AService对象，因此从二级缓存中拿去AService进行依赖注入，完成创建周期后将BService放入一级缓存中，返回AService的创建过程就能进行BService的依赖注入，之后AService也完成创建周期。\",\"二级缓存就能解决普通对象的循环依赖问题，那三级缓存的作用？\",\"比如，可能AService会进行AOP操作，会创建AServiceProxy代理对象（正常情况是在属性注入之后进行AOP），然后将代理对象放入单例池中，但是BService进行属性赋值，依赖注入的时候是把二级缓存中的AService的普通对象进行赋值，同时存在普通对象和代理对象违背了单例池规则。\",\"解决办法就是在AService创建普通对象之后存入一个Lamda表达式到三级缓存中。\",\"创建AService普通对象；\",\"放入Lambda表达式到三级缓存中；\",\"尝试注入BService发现没有；\",\"创建BService普通对象，尝试注入AService属性；\",\"发现一二级缓存都没有；\",\"执行三级缓存中的Lambda表达式返回AService普通对象或者代理对象；\",\"将返回的对象放入二级缓存中，称为早期Bean对象；\",\"将二级缓存中的AService对象或者AService代理对象注入到BService中；\",\"BService完成创建周期放入一级缓存；\",\"AService普通对象注入一级缓存中的BService完整对象；\",\"根据是否需要AOP决定最后放入单例池中的对象是普通对象还是代理对象。\",\"通过对注入属性添加@Lazy实现懒惰式加载，只有在调用方法用到属性的时候才会进行初始化，此时本类已经完成创建周期，因此不会出现循环依赖。\"]},\"451\":{\"h\":\"Spring框架中的Bean是线程安全的吗？\",\"t\":[\"Spring本身没有提供Bean的线程安全策略，也就是说Bean是线程不安全的。\",\"Bean有多种作用域：\",\"singleton：容器中仅存在一个实例。\",\"prototype：为每个Bean请求创建实例。不存在线程安全问题。\",\"request：为每个request创建实例，请求完成之后失效。\",\"session：每次session才会创建实例，会话断开后失效。\",\"global-session：全局作用域。\",\"默认是singleton但是对于开发中大部分的Bean是无状态的，因此不需要保证线程安全。如果要保证线程安全可以将作用域改为Prototype，另外还能使用ThreadLocal解决线程安全问题。\",\"无状态表示这个实例没有属性对象，不能保存数据，是不变的类，例如：Controller、Service、Dao。\"]},\"452\":{\"h\":\"ApplicationContext和BeanFactory有什么区别？\",\"t\":[\"BeanFactory是Spring中非常核心的组件，表示Bean工厂，可以生成和维护Bean，而ApplicationContext继承了BeanFactory，所以ApplicationContext拥有BeanFactory的所有特点，也是一个Bean工厂，另外还继承了其他接口例如EnvironmentCapable、MessageSourse、ApplicationEventPublisher等接口，从而让ApplicationContext具有BeanFactory不具备的功能。\"]},\"453\":{\"h\":\"Spring容器的启动流程\",\"t\":[\"创建Spring容器时会先进行扫描，得到所有的BeanDefinition对象，并放在一个Map中。\",\"然后筛选出非懒加载的单例BeanDefinition进行创建Bean，对于多例Bean不需要在启动过程中取创建，而是每次获取的时候才会创建。\",\"利用BeanDefinition创建Bean就是Bean的创建生命周期，包括了合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP发生在初始化后这个步骤。\",\"单例Bean创建完成之后Spring发布一个容器启动事件。\",\"Spring启动结束。\"]},\"454\":{\"h\":\"SpringMVC、SpringBoot\"},\"455\":{\"h\":\"SpringMVC\"},\"456\":{\"h\":\"SpringMVC处理请求的底层原理\",\"t\":[\"请求会被DispatcherServlet拦截，DispatcherServlet结构如图。\",\"SpringMVC中的一次请求流程：\",\"客户端（浏览器）发送请求， DispatcherServlet拦截请求。\",\"DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 uri 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器） ，并会将请求涉及到的拦截器和 Handler 一起封装。\",\"DispatcherServlet 调用 HandlerAdapter适配器执行 Handler 。\",\"Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给DispatcherServlet，ModelAndView包含了数据模型以及相应的视图的信息。Model 是返回的数据对象，View 是个逻辑上的 View。\",\"ViewResolver 会根据逻辑 View 查找实际的 View。\",\"DispaterServlet 把返回的 Model 传给 View（视图渲染）。\",\"把 View 返回给请求者（浏览器）。\"]},\"457\":{\"h\":\"SpringMVC的核心组件有哪些？\",\"t\":[\"DispatcherServlet：核心的中央处理器，负责接收请求、分发、并给予客户端响应。\",\"HandlerMapping：处理器映射器，根据uri去匹配查找能处理的Handler，并会将请求涉及到的拦截器和Handler一起封装，Handler其实就是Controller。\",\"HandlerAdapter：处理器适配器，根据HandlerMapping找到的Handler，适配执行对应的Handler。\",\"Handler：请求处理器，处理实际请求的处理器。\",\"ViewResolver：视图解析器，根据Handler返回的逻辑视图/视图，解析并渲染真正的视图，并传递给DispatcherServlet响应给客户端。\"]},\"458\":{\"h\":\"SpringMVC零配置\",\"t\":[\"public class MyWebApplicationInitializer implements WebApplicationInitializer { @Override public void onStartup(ServletContext servletContext) throws ServletException { AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.register(AppConfig.class); DispatcherServlet servlet = new DispatcherServlet(context); ServletRegistration.Dynamic registration = servletContext.addServlet(\\\"app\\\", servlet); registration.addMapping(\\\"/app/*\\\"); } } \",\"直接使用类也能完成配置文件中类似的配置；\",\"创建容器，创建DispatcherServlet，并将容器放入，创建Servlet，并添加Servlet匹配路径。\"]},\"459\":{\"h\":\"统一异常处理\",\"t\":[\"使用到 @ControllerAdvice + @ExceptionHandler 这两个注解实现统一异常处理。\",\"@ControllerAdvice @ResponseBody public class GlobalExceptionHandler { @ExceptionHandler(BaseException.class) public ResponseEntity<?> handleAppException(BaseException ex, HttpServletRequest request) { //...... } @ExceptionHandler(ResourceNotFoundException.class) public ResponseEntity<ErrorReponse> handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) { //...... } } \",\"这种异常处理方式下，会给所有或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被@ExceptionHandler 注解修饰的方法进行处理。\"]},\"460\":{\"h\":\"SpringBoot\"},\"461\":{\"h\":\"SpringBootApplication注解的作用？\",\"t\":[\"@SpringBootApplication是一个复合注解：\",\"@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan public @interface SpringBootApplication { } \",\"添加了@SpringBootApplication，相当于添加了@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan三个注解。\",\"@SpringBootConfiguration：相当于注解@Configuration表示这是一个配置类。\",\"@EnableAutoConfiguration：这个注解会负责进行自动配置类的导入，就是将项目中的自动配置类导入到Spring容器中，从而得到解析。\",\"此注解内部有@Import({AutoConfigurationImportSelector.class})注解，用来扫描项目中的自动配置类并将其返回为自动配置类的名字String[]给Spring容器进行加载。\",\"@ComponentScan：Spring容器会进行扫描，默认扫描路径就是这个类所在的包路径。\"]},\"462\":{\"h\":\"SpringBoot中的spring.factories文件有什么作用？\",\"t\":[\"spring.factories是SpringBoot SPI实现的核心，SPI机制表示扩展机制，所以spring.factories就是对SpringBoot进行扩展的，比如要添加Listener，只需要在这个文件中添加类路径名。\",\"SpringBoot在启动的过程中，会找出项目中所有的spring.factories文件，从而向Spring容器中去添加各种spring.factories中指定的组件、配置类等，使得对SpringBoot的扩展的变得很容易。\"]},\"463\":{\"h\":\"SpringBoot的启动流程\",\"t\":[\"加载主要配置类： Spring Boot 的入口是一个主要的配置类，通常是带有 @SpringBootApplication 注解的类。在启动过程中，Spring Boot 首先会加载这个配置类。\",\"创建 Spring 应用上下文： Spring Boot 使用 Spring 的核心容器，即应用上下文（Application Context）来管理和组织组件。在启动过程中，Spring Boot 会创建一个根应用上下文，并将主要配置类加载到这个应用上下文中。\",\"执行自动配置： Spring Boot 的核心功能之一是自动配置（Auto-Configuration），它通过条件化配置来根据应用的依赖和配置来自动装配和配置各种功能和组件。在启动过程中，Spring Boot 会根据配置和类路径上的依赖，自动配置各种功能，如数据库连接、Web MVC、安全性等。\",\"执行启动器（Starters）： Spring Boot 提供了一系列的启动器，它们是一组预配置的依赖关系，可以快速启动特定类型的应用。启动器通过自动配置和依赖管理来简化应用的搭建和配置。在启动过程中，Spring Boot 会根据应用的类型和配置，自动加载适当的启动器。\",\"启动 Web 容器： 如果应用是一个 Web 应用，Spring Boot 会自动启动一个嵌入式的 Web 容器（如Tomcat、Jetty等），并将应用部署到该容器中。\",\"运行应用：\\n一切就绪后，Spring Boot 会开始运行应用。它会触发各种生命周期事件，调用初始化方法、执行业务逻辑等。\"]},\"464\":{\"h\":\"Spring\"},\"465\":{\"h\":\"Java基础一\",\"t\":[\"一切就从这里开始吧\",\"笔记来源网络，仅做个人学习，非商业用途。\"]},\"466\":{\"h\":\"JVM JRE JDK\",\"t\":[\"JVM是java虚拟机，针对不同系统有不同的实现，常用的为HotSpot VM。\",\"JDK是功能齐全的SDK，包含JRE和一些其他的工具，例如javac，java等。\",\"JRE是Java运行时环境，仅包含Java应用程序运行时的必要环境。\"]},\"467\":{\"h\":\"什么是字节码？采用字节码的好处？\",\"t\":[\"JVM能理解的代码就是字节码，字节码解决了传统解释语言运行效率低的问题，还具有很好的可移植性，一次编译，任何地方运行。\",\".java文件经过javac编译之后变成.class文件，.class通过解释器和JIT（运行时编译器）编译成机器可以理解的代码，JIT完成一次编译之后，就会将对应的机器码保存下来，之后复用，其中编译的是热点代码。所以Java也是编译与解释共存的语言。\"]},\"468\":{\"h\":\"Java 和 C++ 的区别\",\"t\":[\"Java和C++都是面向对象的语言，都支持封装继承多态。\",\"Java不支持通过指针来直接访问内存，程序内存更加安全。\",\"Java的类是单继承的，C++支持多继承。\",\"Java有自动的垃圾回收机制，不需要手动释放内存。\"]},\"469\":{\"h\":\"基本数据类型\",\"t\":[\"Java有8种基本数据类型：\",\"6种数字类型 \",\"4种整数类型：byte、short、int、long\",\"2种浮点数类型：float、double\",\"1种字符类型：char\",\"1种布尔类型：boolean\"]},\"470\":{\"h\":\"基本类型和包装类型\",\"t\":[\"包装类型能用于泛型，而基本类型不可以。\",\"基本数据类型的局部变量存放在Java虚拟机栈中的局部变量表中（线程私有），基本数据类型的成员变量没有被static修饰的话放在堆中。而包装类型属于对象类型。\",\"包装类型占用的空间比基本类型要大。\",\"成员包装类型不赋值就是null，而基本类型有默认值并且不是null。\",\"基本数据类型使用==进行比较，而包装类型通过equals()进行比较。\",\"在HotSpot虚拟机中引入JIT优化之后，会对对象进行逃逸分析，如果对象的作用范围没有超过当前方法，则可能通过标量替换来实现栈（线程私有）上分配，避免堆上分配对象。\"]},\"471\":{\"h\":\"包装类的缓存机制\",\"t\":[\"Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，8位补码的表示范围。\",\"Character创建了 [0，127] 范围的缓存数据，7位无符号数的表示范围，Boolean直接返回True或者是False。\"]},\"472\":{\"h\":\"自动拆装箱\",\"t\":[\"装箱就是使用包装类的valueOf方法，拆箱就是使用xxValue方法。\",\"Integer i=10等价于Integer i = Integer.valueOf(10)\",\"int n = i 等价于int n = i.intValue()\"]},\"473\":{\"h\":\"浮点数运算的时候会有精度丢失的风险？\",\"t\":[\"计算机组成原理第二章浮点加减法。\"]},\"474\":{\"h\":\"如何解决浮点数运算的时候精度丢失问题？\",\"t\":[\"使用BigDecimal类进行浮点数运算，不会造成精度丢失问题。\"]},\"475\":{\"h\":\"超过long 64位补码的范围数字应该如何表示？\",\"t\":[\"通过BigInteger存储，BigInteger内部使用int[]存储任意大小的整型数据。\"]},\"476\":{\"h\":\"变量\",\"t\":[\"public class Example{ //成员变量 private String name; private int age; public void method(){ int num1 = 0;//栈中分配的局部变量，没有逃逸出本方法 System.out.println(num1); } // 带参数的方法中的局部变量 public void method2(int num2) { int sum = num2 + 10; // 栈中分配的局部变量 System.out.println(sum); } } \"]},\"477\":{\"h\":\"静态变量\",\"t\":[\"静态变量就是被static修饰的变量，被static修饰的变量为类所共享的，无论创建了多少个类实例，这个变量都是共享的，只会分配一次内存，静态变量通过类名.进行访问。\",\"通常情况下被final修饰的static变量会成为常量。\"]},\"478\":{\"h\":\"方法\"},\"479\":{\"h\":\"静态方法为什么不能调用非静态成员？\",\"t\":[\"静态方法属于类，在类加载的时候就会分配内存，通过类名直接访问，非静态方法属于实例对象，需要通过类的实例对象去调用。\",\"在类的非静态成员不存在的时候静态方法就已经存在，此时调用内存中不存在的非静态成员不合法。\"]},\"480\":{\"h\":\"重载和重写\",\"t\":[\"重载就是对同一个方法根据输入的不同作出不同的方法处理。\",\"重写一般在子类继承父类，输入的数据一样，但是方法内的代码不同。\",\"重载\",\"public class Example { public void method(String a) { System.out.println(\\\"输入了一个参数\\\"); } public void method(String a, String b) { System.out.println(\\\"输入了两个参数\\\"); } } \",\"重写\",\"重写发生在运行时，是子类对父类方法的实现过程重新编写\",\"方法名，参数列表必须相同，子类方法返回值类型比父类方法返回值类型更小或者是相等，子类抛出的异常应该小于或者等于父类，访问修饰符范围大于等于父类\",\"如果父类方法访问修饰符是private/final/static则子类不能重写方法，被static修饰的方法能被再次声明。\",\"构造方法无法被重写\",\"方法的重写要遵循“两同两小一大”\",\"“两同”即方法名相同、形参列表相同；\",\"“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；\",\"“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。\"]},\"481\":{\"h\":\"Java基础二\"},\"482\":{\"h\":\"面向对象\"},\"483\":{\"h\":\"面向对象和面向过程的区别\",\"t\":[\"面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。\",\"面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。\",\"一个注重过程，一个注重内部属性。\"]},\"484\":{\"h\":\"对象的相等和引用的相等\",\"t\":[\"对象的相等是是比较内存中存放的对象是否相等。\",\"引用相等是指向的内存地址是否相等。\",\"String str1 = \\\"a\\\"; String str2 = new String(\\\"a\\\"); String str3 = \\\"a\\\"; System.out.println(str1 == str2);//false System.out.println(str1 == str3);//true System.out.println(str1.equals(str2));//true System.out.println(str1.equals(str3));//true \",\"System.out.println(str1 == str2);//false详见后半部分String。\"]},\"485\":{\"h\":\"如果没有声明构造方法，程序能正确执行吗？\",\"t\":[\"如果类没有声明构造方法则会默认生成一个不带参数的构造方法。\",\"如果自己添加了构造方法无论是否有参数都不会再自动生成无参构造方法。\",\"构造方法不能被重写@Override，但是能重载（有参构造和无参构造）。\"]},\"486\":{\"h\":\"面向对象的三个特征\",\"t\":[\"封装\",\"封装是将一个对象的状态信息隐藏在内部，不允许外部直接访问这些属性，但是会提供方法来操作属性。\",\"继承\",\"不同类型的对象可能会具有相似特点，例如游戏中的每一个英雄都有血量，移速等基础属性，但是每一个英雄的技能各有不同，则可以通过继承复用减少开发难度。\",\"子类拥有父类的所有属性和方法（包括私有属性和私有方法）。\",\"子类能对父类进行扩展。\",\"多态\",\"表示一个对象具有多种状态，上述代码中创建对象：\",\"Hero hero = new Hero1(); hero.skill();//打印技能1，编译是否能通过看左边，执行结果看右边。 \",\"对象类型和引用类型之间具有继承/实现关系；\",\"引用类型变量发出的方法调用到底是哪个类中的方法，在程序运行的时候才能确定；\",\"多态不能调用只在子类中存在，但是父类中不存在的方法，也就是hero能调用的方法是看父类Hero的，执行的结果看子类Hero1；\",\"如果子类重写了父类方法，则执行的是子类中的方法，如果没有重写则执行的是父类中的方法。\"]},\"487\":{\"h\":\"接口和抽象类的共同点\",\"t\":[\"共同点\",\"都不能被实例化；\",\"都可以包含抽象方法；\",\"都可以有默认的实现方法（Java8可以用default关键字在接口中定义默认方法）。\",\"不同点\",\"接口强调行为的约束，实现某个接口就相当于有某个责任，必须实现对应的方法，继承则是强调复用，子类继承父类并不一定要重写父类方法；\",\"一个类只能extends一个类，但是能implements多个接口；\",\"接口中的成员变量只能是public static final类型，不能被修改而且必须有初始值，抽象类中的成员变量默认default，可以在子类中被重新定义，重新赋值。\"]},\"488\":{\"h\":\"浅拷贝，深拷贝，引用拷贝\",\"t\":[\"浅拷贝\",\"在堆上创建一个新对象N，N对象中的内部对象是引用类型的话，会直接复制原本类O的内部对象引用地址；\",\"也就是新对象N内部对象和原来的对象O的内部对象是同一个。\",\"深拷贝\",\"不仅仅拷贝对象，将原本对象内部的所有属性都单独复制一份；\",\"新对象的内部引用对象不再是原来对象的内部引用对象。\",\"引用拷贝\",\"两个不同对象的引用指向同一个对象。\"]},\"489\":{\"h\":\"Object\"},\"490\":{\"h\":\"==和equals区别\",\"t\":[\"对于基本类型来说==是比较值；\",\"对于引用类型来说==是比较地址。\",\"equals存在两种情况：\",\"类没有重写equals方法：则通过equals比较两个对象的时候等价于==；\",\"重写了equals方法：则是比较两个对象内部的属性是否相等。\",\"创建String类型的对象，虚拟机会在字符串常量池中查找有没有相同值的对象，如果有则直接返回这个对象的引用，如果没有就创建一个String对象。\"]},\"491\":{\"h\":\"hashCode()作用\",\"t\":[\"hashCode()方法用来获哈希码，作用是确定在哈希表中的位置。\",\"hashCode()定义在Object类中，所以所有的对象都有这个方法。hashCode()是本地方法，也就是通过C或者是C++实现的。\",\"HashMap通过计算Hash值使得查找元素的时间复杂度为1，数据结构散列表。\"]},\"492\":{\"h\":\"为什么重写 equals() 时必须重写 hashCode() 方法？\",\"t\":[\"Java中如果两个对象相同则HashCode，必须相等；\",\"如果HashCode相同，则对象不一定相等；\",\"如果两个对象的HashCode不同则对象一定不同。\",\"重写equals()代表这个方法是用来比较两个对象是否相等，如果不重写HashCode()方法可能会导致判断是相等的两个对象但是HashCode不等。\"]},\"493\":{\"h\":\"String\"},\"494\":{\"h\":\"String、StringBuffer、StringBuilder 的区别？\",\"t\":[\"String是不可变的，可以看成常量，线程安全。对内部方法加了同步锁，是线程安全的。StringBuilder没有添加同步锁，所以是线程不安全的。\",\"每次对String类型进行修改的时候，都会新生成一个String类型，然后将引用指向新的String对象。StringBuffer和StringBuilder是对对象本身进行操作，不会生成新的对象，相同情况下使用StringBuilder会带来一点性能提升，但是线程不安全。\",\"少量数据使用String，单线程下大量数据使用StringBuilder，多线程下使用StringBuffer。\"]},\"495\":{\"h\":\"String为何不可变？\",\"t\":[\"JDK8中的源码：\",\"public final class String implements java.io.Serializable, Comparable<String>, CharSequence { private final char value[]; //... } \",\"保存字符串的数组是final修饰的，并且内部没有暴露能修改这个数组的方法；\",\"String类本身也被final修饰导致不能被继承，从而避免子类破坏String的不变性。\"]},\"496\":{\"h\":\"字符串拼接用“+” 还是 StringBuilder?\",\"t\":[\"+和+=是Java中唯二为String重载过的运算符。\",\"String对象使用+进行拼接，实际就是通过StringBuilder调用append()方法，拼完之后调用toString()方法返回String对象。\",\"相关信息\",\"如果在循环内使用+进行拼接多个字符串，编译器不会复用StringBuilder，而是每次循环都创建一个StringBuilder。\",\"直接使用StringBuilder进行拼接就能解决这个问题。\"]},\"497\":{\"h\":\"String s1 = new String(\\\"abc\\\");这句话创建了几个字符串对象？\",\"t\":[\"会创建1个或者2个字符串对象。\",\"String str = new String(\\\"abc\\\");\",\"String str = new String(\\\"abc\\\"); \",\"如果字符串常量池中不存在\\\"abc\\\"的引用，则会在堆中创建2个字符串对象\\\"abc\\\"。一个是在字符串常量池中创建的\\\"abc\\\"，另外是new在堆中创建的对象。\",\"如果字符串常量池中存在\\\"abc\\\"的引用，则会在堆中创建1个字符串对象\\\"abc\\\"。也就是new在堆中创建的对象。\",\"示意图：\"]},\"498\":{\"h\":\"String#intern 方法有什么作用?\",\"t\":[\"String.intern()是一个本地方法，作用是将指定的字符串对象保存到字符串常量池中。\",\"如果字符串常量池中保存了对应的字符串对象的引用，则返回引用。\",\"如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。\",\"// 在堆中创建字符串对象”Java“ // 将字符串对象”Java“的引用保存在字符串常量池中 String s1 = \\\"Java\\\"; // 直接返回字符串常量池中字符串对象”Java“对应的引用 String s2 = s1.intern(); // 会在堆中在单独创建一个字符串对象 String s3 = new String(\\\"Java\\\"); // 直接返回字符串常量池中字符串对象”Java“对应的引用 String s4 = s3.intern(); // s1 和 s2 指向的是堆中的同一个对象 System.out.println(s1 == s2); // true // s3 和 s4 指向的是堆中不同的对象 System.out.println(s3 == s4); // false // s1 和 s4 指向的是堆中的同一个对象 System.out.println(s1 == s4); //true \"]},\"499\":{\"h\":\"编译器对字符串拼接的优化\",\"t\":[\"String str1 = \\\"a\\\"; String str2 = \\\"b\\\"; String str3 = \\\"a\\\" + \\\"b\\\";//常量池中创建的对象 String str4 = str1 + str2;//堆中创建的对象 \",\"对于String str3 = \\\"a\\\" + \\\"b\\\"等价于String str3 = \\\"ab\\\"；对于在编译期间就能确定的字符串，编译器会在编译期间直接放入字符串常量池中。\",\"String str4 = str1 + str2;则不会在编译期间确定结果，不会产生优化。\",\"final String str1 = \\\"str\\\"; final String str2 = \\\"ing\\\"; // 下面两个表达式其实是等价的 String c = \\\"str\\\" + \\\"ing\\\";// 常量池中的对象 String d = str1 + str2; // 常量池中的对象 System.out.println(c == d);// true \",\"使用final修饰则看成常量，在编译期间就会优化放入字符串常量池中。\"]},\"500\":{\"h\":\"Java值传递\"},\"501\":{\"h\":\"形参和实参\",\"t\":[\"String s = \\\"abc\\\"; //s 为实参 method(s); //str 为形参 void method(String str){ System.out.println(str); } \"]},\"502\":{\"h\":\"值传递&引用传递\",\"t\":[\"值传递：方法接收的是实参的拷贝，会创建副本；\",\"引用传递：方法接收的直接是实参所引用对象在堆中的地址，不会创建副本，对形参的修改将会影响到实参。\"]},\"503\":{\"h\":\"Java只有值传递\",\"t\":[\"public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); change(arr); System.out.println(arr[0]);//输出为 0 } public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0; } \",\"array为引用类型，但是不称为引用传递，案例中仍然是值传递，值是实参的地址。\",\"引用传递值得是：对形参本身修改会导致实参变化。\"]},\"504\":{\"h\":\"Java序列化\",\"t\":[\"序列化：将数据结构或对象转换成二进制字节流的过程\",\"反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程\",\"序列化协议属于TCP/IP中的应用层。\",\"Java中通过实现Serializable接口实现序列化功能。\"]},\"505\":{\"h\":\"serialVersionUID 有什么作用？\",\"t\":[\"serialVersionUID的作用是版本控制，反序列化的时候会检查serialVersionUID是否和当前类的serialVersionUID相同，如果不同则会抛出InvalidClassException异常。如果不指定serialVersionUID，编译器会自动生成。\",\"private static final long serialVersionUID = 1905122041950251207L; \",\"serialVersionUID用来给JVM识别的，并不会被序列化。\"]},\"506\":{\"h\":\"Java反射\",\"t\":[\"反射可以获取任意一个类的所有属性和方法，还能调用这些方法和属性。\"]},\"507\":{\"h\":\"反射的应用场景\",\"t\":[\"Spring/SpringBoot/Mybatis等框架中都大量使用了反射机制。\",\"框架中也使用了动态代理，动态代理就是依赖反射。\",\"JDK动态代理：\",\"public class DebugInvocationHandler implements InvocationHandler { /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException { System.out.println(\\\"before method \\\" + method.getName()); Object result = method.invoke(target, args); System.out.println(\\\"after method \\\" + method.getName()); return result; } } \",\"其中的Method就是反射类。\",\"SpringBoot中使用@Component就能声明一个Bean，原理就是基于反射获取到对应类上的注解，再做处理。\"]},\"508\":{\"h\":\"反射的优缺点\",\"t\":[\"优点：让代码更加灵活，为各种框架提供开箱即用的便利。\",\"缺点：拥有分析操作类的能力，增加了安全隐患。\"]},\"509\":{\"h\":\"反射获取Class对象\",\"t\":[\"知道具体类的情况下：\",\"Class clazz = Target.class; \",\"通过Class.forName()传入类的全路径名：\",\"Class clazz = Class.forName(\\\"com.zyl.Target\\\"); \",\"通过实例对象的getClass()获取：\",\"Target t = new Target(); Class clazz = t.getClass(); \",\"通过类加载器xxxClassLoader.loadClasss()传入类路径获取：\",\"ClassLoader.getSystemClassLoader().loadClass(\\\"com.zyl.Target\\\"); \",\"通过类加载器获取Class对象不会进行初始化，意味着静态代码块和静态对象不会得到执行。\"]},\"510\":{\"h\":\"获取方法并执行\",\"t\":[\"Method privateMethod = targetClass.getDeclaredMethod(\\\"privateMethod\\\"); //为了调用private方法取消安全检查 privateMethod.setAccessible(true); privateMethod.invoke(targetObject); \"]},\"511\":{\"h\":\"代理模式\",\"t\":[\"使用代理对象来代替真实对象的访问，这样能在不改变目标对象的前提下，提供额外的功能，扩展目标对象。\",\"代理模式有静态代理和动态代理两种实现方式。\"]},\"512\":{\"h\":\"静态代理\",\"t\":[\"静态代理中，对方法的增强是手动完成的，非常不灵活，从JVM层面来说，静态代理在编译的时候就将接口、实现类、代理类变成一个个class文件。编译从.java变成.class。\"]},\"513\":{\"h\":\"动态代理\",\"t\":[\"相对于静态代理，动态代理更加灵活，不需要对每一个目标对象创建一个代理类，也不需要强制实现接口。\",\"动态代理属于运行时动态生成类字节码，并加载到JVM中。\",\"动态代理主要有两种：JDK动态代理、CGLIB动态代理。\"]},\"514\":{\"h\":\"JDK动态代理\",\"t\":[\"Java中动态代理中InvocationHandler接口和Proxy类是核心。\",\"Proxy类中使用较多的方法是newProxyInstance()，用来生成一个代理对象。\",\"public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException { ...... } \",\"newProxyInstance()方法有三个参数：\",\"loader：类加载器，用来加载代理对象；\",\"interfaces：被代理类实现的接口；\",\"h：实现了InvocationHandler接口的对象。\",\"要实现动态代理，还要实现InvocationHandler接口，使用动态代理类调用方法的时候，方法就会被转发到实现InvocationHandler接口类的invoke方法来调用。\",\"public interface InvocationHandler { /** * 当你使用代理对象调用方法的时候实际会调用到这个方法 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; } \",\"invoke()方法有三个参数：\",\"proxy：动态生成的代理类；\",\"method：与代理类对象调用的方法相对应；\",\"args：当前method方法的参数。\",\"流程：通过proxy类的newInstance()创建代理对象调用方法，会实际调用实现InvocationHandler接口类的invoke()方法。\",\"实现：\"]},\"515\":{\"h\":\"CGLIB动态代理\",\"t\":[\"JDK代理需要实现接口的类才能作为目标对象，为了解决这个问题，可以使用CGLIB动态代理。\",\"CGLIB动态代理中MethodIntercepter接口和Enhancer类是核心。\",\"需要自定义接口MethodIntercepter并重写intercept方法，用于拦截增强被代理类的方法。\",\"public interface MethodInterceptor extends Callback{ // 拦截被代理类中的方法 public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy) throws Throwable; } \",\"obj：被代理的对象（需要增强的对象）；\",\"method：被拦截的方法；\",\"args：方法参数；\",\"proxy：用于调用原始方法。\",\"通过Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是MethodInterceptor中的intercept方法。\",\"实现：\",\"添加依赖\",\"<dependency> <groupId>cglib</groupId> <artifactId>cglib</artifactId> <version>3.3.0</version> </dependency> \"]},\"516\":{\"h\":\"JDK动态代理和CGLIB动态代理的区别\",\"t\":[\"1.JDK动态代理需要目标类实现接口或直接代理接口，CGLIB则不需要，CGLIB是通过生成一个被代理类的子类来拦截代理类的方法调用，因此不能代理声明final类型的类和方法。\",\"JDK动态代理的效率要更好。\"]},\"517\":{\"h\":\"静态代理和动态代理的区别\",\"t\":[\"动态代理更加灵活，不需要实现接口可以直接代理实现类，并且不用为每一个目标类都创建一个代理类，静态代理中接口新增方法，则目标类和代理类都要修改。\",\"静态代理在编译时就将接口、实现类、代理类这些都变成一个个class文件，而动态代理是在运行时产生class文件，并加载到JVM中。\"]},\"518\":{\"h\":\"单例模式\",\"t\":[\"保证在整个系统中，对某一个类只会存在一个对象实例，并且类只提供一个取得对象实例的方法。\"]},\"519\":{\"h\":\"单例模式实现方式\",\"t\":[\"饿汉式 \",\"静态常量\",\"静态代码块\",\"懒汉式 \",\"线程不安全法(不推荐)\",\"线程安全法，同步方法(不推荐)\",\"线程安全，同步代码块\",\"其他 \",\"双重检查（重要）\",\"静态内部类（重要）\",\"枚举\"]},\"520\":{\"h\":\"饿汉式（静态常量）\",\"t\":[\"public class Singleton{ //构造器私有化 private Singleton(){} //本类内部创建对象实例 private final static Singleton singleton = new Singleton(); //对外暴露一个静态的公共方法，返回实例对象 public static Singleton getInstance(){ return singleton; } } \"]},\"521\":{\"h\":\"饿汉式（静态代码块）\",\"t\":[\"public class Singleton{ private Singleton(){} private static Singleton singleton; //在静态代码块中创建单例对象 static { singleton = new Singleton(); } public static Singleton getInstance(){ return singleton; } } \",\"饿汉式在类装载的时候就完成实例化，避免了线程同步问题。如果一直没有使用这个实例，则会浪费内存。\"]},\"522\":{\"h\":\"懒汉式(线程安全， 同步方法)\",\"t\":[\"public class Singleton{ private Singleton(){} private static Singleton singleton; //提供一个静态的共有方法，当使用该方法时，才去创建singleton public static synchronized Singleton getInstance(){ if(singleton == null){ singleton = new Singleton(); } return singleton; } } \",\"效率较低\"]},\"523\":{\"h\":\"双重检查（重要）\",\"t\":[\" class Singleton{ private Singleton(){} //注意使用volatile修饰singleton，实现可见性，有序性 private static volatile Singleton singleton; public static Singleton getInstance(){ if(singleton == null){ synchronized (Singleton.class){ if(singleton == null){ singleton = new Singleton(); } } } return singleton; } } \",\"线程安全；延迟加载；效率较高\"]},\"524\":{\"h\":\"静态内部类（重要）\",\"t\":[\"public class Singleton{ private Singleton(){} private static class SingletonInstance{ private static final Singleton SINGLETON = new Singleton(); } public static Singleton getInstance(){ return SingletonInstance.SINGLETON; } } \",\"由于静态内部类在Singleton被装载的时候，并不会实例化静态内部类SingletonInstance，只有在被用到的时候才会实例化，线程安全，延时加载，效率高。\"]},\"525\":{\"h\":\"枚举\",\"t\":[\"enum Singleton{ SINGLETON; } \",\"不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，枚举仍然算饿汉式。\"]},\"526\":{\"h\":\"Java基础\"},\"527\":{\"h\":\"Java集合一\"},\"528\":{\"h\":\"集合\",\"t\":[\"Java集合由两大接口派生而来，分别是用来存放单一元素的Collection和用来存放键值对的Map接口。对于Collection接口有三个子接口，分别是List、Set、Queue。\"]},\"529\":{\"h\":\"说说 List, Set, Queue, Map 四者的区别？\",\"t\":[\"List（顺序存储）存储的元素是有序的，可以重复；\",\"Set（独一无二）存储的元素无序，不可重复；\",\"Queue（排队）按特定的排队规则确定元素先后顺序，元素是有序的，可重复的；\",\"Map（用key搜索）使用键值对存储，key是无序的，不可重复的，value是无序的，可重复的。\"]},\"530\":{\"h\":\"集合框架底层数据结构\",\"t\":[\"List\",\"ArrayList：Object[]数组；\",\"Vector：Object[]数组；\",\"LinkedList：双向链表（JDK1.6之前为循环链表，JDK1.7取消）。\",\"Set\",\"HashSet（无序，唯一）：基于HashMap实现，底层使用HashMap保存数据；\",\"LinkedHashMap：LinkedHashSet是HashSet子类，内部都是通过LinkedHashMap实现；\",\"TreeSet（有序，唯一）：红黑树（自平衡的排序二叉树）。\",\"Queue\",\"PriorityQueue: Object[] 数组来实现二叉堆；\",\"ArrayQueue: Object[] 数组 + 双指针。\",\"Map\",\"HashMap：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在。JDK1.8 以后由数组+链表/红黑树组成，当链表长度大于阈值（默认为8），数组长度大于等于64的时候会进行树化，转化为红黑树加快查找。\",\"LinkedHashMap：LinkedHashMap 继承自 HashMap，底层是数组+链表/红黑树。LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。\",\"Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在\"]},\"531\":{\"h\":\"List\"},\"532\":{\"h\":\"说说ArrayList\",\"t\":[\"ArrayList存储元素的特点是顺序，可重复；\",\"ArrayList会根据实际存储的元素动态扩容或者缩容；\",\"ArrayList只能存储对象，不能存储基本类型，需要使用包装类；\",\"ArrayList支持插入、删除、遍历等操作；\",\"ArrayList能插入null；\",\"超过容量之后触发扩容；\",\"扩容后大小为int newCapacity = oldCapacity + (oldCapacity >> 1);;\",\"JDK1.8以无参数构造方法创建ArrayList时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。\"]},\"533\":{\"h\":\"ArryList和Vector区别？\",\"t\":[\"ArrayList是List的主要实现类，底层用Object[]存储，适用于频繁查找的场景，线程不安全；\",\"Vector是List的古老实现类，底层用Object[]存储，线程安全。\"]},\"534\":{\"h\":\"ArrayList 与 LinkedList 区别?\",\"t\":[\"首先两者都不是线程安全的实现；\",\"ArrayList底层使用Object[]存储元素，LinkedList底层使用双向链表存储数据（JDK1.6之前为循环链表，1.7取消循环）；\",\"ArrayList实现了RandomAccess接口，可以随机访问，LinkedList不支持随机访问；\",\"由于LinkedList内部包含前驱和后继，占用内存比ArrayList大。\"]},\"535\":{\"h\":\"Set\"},\"536\":{\"h\":\"比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\",\"t\":[\"HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。\",\"HashSet底层是哈希表，LinkedHashSet底层是链表和哈希表，元素的插入满足队列特性，TreeSet底层是红黑树，元素是有序的。\",\"根据应用场景不同，对元素顺序无要求则用HashSet，有要求使用TreeSet，需要满足FIFO使用LinkedHashSet。\"]},\"537\":{\"h\":\"Queue\",\"t\":[\"队列满足FIFO性质，Queue因为容量问题导致操作失败后的处理方式不同分为两类方法；\",\"Queue\",\"抛出异常\",\"返回特殊值\",\"插入队尾\",\"add(E e)\",\"offer(E e)\",\"删除队首\",\"remove()\",\"poll()\",\"查询队首元素\",\"element()\",\"peek()\",\"Deque是双端队列，在队列两端都能插入和删除元素，同样根据返回值不同分为两类方法\",\"Deque\",\"抛出异常\",\"返回特殊值\",\"插入队尾\",\"addFirst(E e)\",\"offerFirst(E e)\",\"插入队首\",\"addLast(E e)\",\"offerLast(E e)\",\"删除队首\",\"removeFirst()\",\"pollFirst()\",\"删除队尾\",\"removeLast()\",\"pollLast()\",\"查询队首元素\",\"getFirst()\",\"peekFirst()\",\"查询队尾元素\",\"getLast()\",\"peekLast()\"]},\"538\":{\"h\":\"ArrayDeque 与 LinkedList 的区别\",\"t\":[\"ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现；\",\"ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持；\",\"ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在；\",\"ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。\"]},\"539\":{\"h\":\"PriorityQueue\",\"t\":[\"PriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。\",\"PriorityQueue使用变长数组存储元素，使用二叉堆实现结构；\",\"PriorityQueue使用堆实现了在O(logn)的时间复杂度内插入和删除元素；\",\"PriorityQueue是线程不安全的，不支持存储null和non-comparable对象；\",\"PriorityQueue默认是小顶堆。\",\"堆排序的伪代码（重要）。\",\"//调整函数 建立大顶堆 void Sift(int R[], int low, int high){ int i = low; int j =2*i; int temp = R[i]; while(j<=high){ if(j < high && R[j] < R[i+1]) ++j;//j指向左右孩子中大的那个 if(temp < R[j]){ R[i] = R[j]; i = j; j = 2*i; }else{ break; } } R[i] = temp; } //堆排序 void headSort(int R[], int n){ int i; int temp; for (int j = n / 2; j >= 1; j--) { Sift(R,i,n); } for (i = n; i >= 2; --i){ temp = R[1]; R[1] = R[i]; R[i] = temp; Sift(R, 1, i-1); } } \"]},\"540\":{\"h\":\"BlockingQueue\",\"t\":[\"BlockingQueue （阻塞队列）是一个接口，继承自 Queue。BlockingQueue阻塞的原因是其支持当队列没有元素时一直阻塞，直到有有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。\",\"BlockingQueue 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。\"]},\"541\":{\"h\":\"Java集合二\"},\"542\":{\"h\":\"Map\"},\"543\":{\"h\":\"HashMap 和 Hashtable 的区别\",\"t\":[\"线程是否安全：HashMap是非线程安全的，Hashtable是线程安全的，内部方法使用synchronized修饰。\",\"效率：因为锁的问题，HashMap的效率要稍微好点。\",\"是否能存储Null Key和Value：HashMap能存储null的key和value，但是作为null的key只能有一个，Hashtable不能有nullkey和value。\",\"扩容：Hashtable默认初始大小是11，扩容之后变为2n+1。HashMap默认大小是16，当元素个数超过负载因子*表长时扩容，每次扩容变为原来的两倍。\",\"底层：JDK1.8之后HashMap底层使用数组+链表/红黑树，特定条件链表转化为红黑树，Hashtable则没有转化为红黑树的机制。\"]},\"544\":{\"h\":\"HashMap 和 TreeMap 区别\",\"t\":[\"TreeMap 和HashMap 都继承自AbstractMap ，TreeMap还实现了NavigableMap接口和SortedMap 接口。实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序。\"]},\"545\":{\"h\":\"HashMap 的底层实现\"},\"546\":{\"h\":\"JDK1.8 之前\",\"t\":[\"JDK1.8之前HashMap底层是数组和链表集合一起，通过key的hashcode经过扰动函数之后获得hash值，通过(n-1)&hash计算元素存放的位置。\",\"找到存放位置之后判断当前位置元素和要存入的元素hash值和key是否相同，相同则直接覆盖，否则通过链表法解决冲突。\",\"JDK1.8中的扰动函数源码：\",\"static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^：按位异或 // >>>:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } \"]},\"547\":{\"h\":\"JDK1.8 之后\",\"t\":[\"JDK1.8之后HashMap使用数组+链表/红黑树作为底层，当单个链表的长度大于8（默认8），数组长度大于等于64的时候就会触发树化，将链表转化为红黑树，以此减少查找时间。\"]},\"548\":{\"h\":\"HashMap 的长度为什么是 2 的幂次方?\",\"t\":[\"Hash值的取值为32位补码的取值范围，一般情况很难出现碰撞。但是范围过大不可能直接放入内存中进行计算，因此需要先通过取模运算（数据结构散列表中除留余数法），通过位运算实现取模。\",\"假设数组长度n为16；Hash值为0111 0000 1001 0000 000 1001 1110 1101 \",\"Hash\",\"0111 0000 1001 0000 0000 1001 1110 1101\",\"n-1\",\"0000 0000 0000 0000 0000 0000 0000 1111\",\"Hash&(n-1)\",\"0000 0000 0000 0000 0000 0000 0000 1101\"]},\"549\":{\"h\":\"HashMap 多线程操作导致死链问题\",\"t\":[\"JDK1.7 及之前版本的 HashMap 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。\",\"JDK1.8之后通过尾插法解决上述问题。但是在多线程下还是会出现数据覆盖问题，推荐使用线程安全的CucurrentHashMap。\"]},\"550\":{\"h\":\"ConcurrentHashMap 和 Hashtable 的区别\",\"t\":[\"ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\",\"底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 分段的Segment、HashEntry数组+链表 实现，JDK1.8 时采用**Node+链表/红黑二叉树**。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。\",\"实现线程安全的方式（重要）： \",\"JDK1.7的时候，ConcurrentHashMap 底层采用 分段的Segment、HashEntry数组+链表 实现，每一把锁锁住一个Segment，Segment的个数固定默认16，也就是并发度固定为16。\",\"到了 JDK1.8 的时候，ConcurrentHashMap 已经摒弃了 Segment 的概念，改用**Node数组+链表/红黑树**，采用 Node + CAS + synchronized 来保证并发安全。\",\"Hashtable使用同一个锁进行并发控制，效率低下。\"]},\"551\":{\"h\":\"JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？\",\"t\":[\"线程安全实现方式：\",\"线程安全实现方式：JDK 1.7 采用 Segment 分段锁来保证安全， Segment 是继承自 ReentrantLock。JDK1.8 放弃了 Segment 分段锁的设计，采用 Node + CAS + synchronized 保证线程安全，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点。\",\"Hash解决碰撞办法：JDK1.7采用拉链法，JDK1.8采用拉链法+红黑树。\",\"并发度：JDK1.7中最大的并发度是Segment的个数，默认是16。JDK1.8最大并发度是Node的个数，并发度更大。\"]},\"552\":{\"h\":\"集合\"},\"553\":{\"h\":\"并发编程一\"},\"554\":{\"h\":\"进程和线程\"},\"555\":{\"h\":\"进程\",\"t\":[\"进程是程序的一次执行过程，启动main函数就相当于启动了一个JVM进程，而main函数所在的线程称为主线程。\"]},\"556\":{\"h\":\"线程\",\"t\":[\"引入线程之后，调度的最小单位从进程变成了线程，一个进程能在运行的时候产生多个线程，每一个线程共享进程的堆和方法区（线程共有），每一个线程有自己的程序计数器，虚拟机栈，本地方法栈，所以线程之间的切换开销远远小于进程，线程又称为轻量级进程。\"]},\"557\":{\"h\":\"从 JVM 角度说进程和线程之间的关系\",\"t\":[\"一个进程能有很多个线程，多个线程共享本进程的堆和方法区（1.8之后的元空间），每一个线程拥有自己的虚拟机栈，本地方法栈，程序计数器。\",\"五分钟记住JVM内存结构\"]},\"558\":{\"h\":\"程序计数器为什么是线程私有？\",\"t\":[\"程序计数器存放的是下一条将要执行指令的地址。\",\"在多线程下，程序计数器用来记录当前线程执行的位置，当线程切换回来的时候能够知道上次运行到哪里了。\",\"所以程序计数器的作用就是线程切换之后能恢复到正确的位置。\"]},\"559\":{\"h\":\"虚拟机栈和本地方法栈为什么是私有的?\",\"t\":[\"虚拟机栈用于存放栈帧，而每一个栈帧就对应着一个Java方法，用于存放局部变量表，操作数栈，常量池等信息。从方法调用到执行完成的过程，就对应着栈帧的入栈和出栈。\",\"本地方法栈用于存放Native方法，这种方法一般是C或者C++实现的。本地方法栈和虚拟机栈发挥的作用类似。\"]},\"560\":{\"h\":\"堆和方法区\",\"t\":[\"堆和方法区都是线程共享的资源，堆是进程内存中最大的一块区域，用于存放新创建的对象，方法区用来存放已经被加载的类信息、常量、静态变量、即时编译器编译之后的代码。\"]},\"561\":{\"h\":\"线程的生命周期和状态\",\"t\":[\"NEW：初始状态，线程已经创建但是没有调用start();\",\"RUNNABLE：运行状态，线程调用了start()等待运行；\",\"BLOCKED：阻塞状态，需要等待锁释放；\",\"WAITING：等待状态，需要等待其他线程作出动作（通知或中断）；\",\"TIME_WAITING：超时等待状态，可以在等待一段时间之后自行返回，而不是像WAITING一样一直等待。\",\"TERMINATED：终止状态，表示线程运行完毕。\"]},\"562\":{\"h\":\"什么是死锁？如何避免\"},\"563\":{\"h\":\"死锁\",\"t\":[\"两个或者以上的线程因为竞争资源导致阻塞，若无外力作用都无法向前推进。\",\"死锁的四个必要条件：\",\"互斥\",\"不剥夺\",\"请求并保持\",\"环路等待\"]},\"564\":{\"h\":\"如何预防死锁？\",\"t\":[\"预防死锁就是破坏四个必要条件中的任意一个。\",\"破坏不剥夺条件：占用部分资源的线程在进一步申请资源失败时，主动放出已经保持的资源。\",\"破坏请求并保持：一次性分配所需要的所有资源。\",\"破坏环路等待：资源有序分配。\"]},\"565\":{\"h\":\"如何避免死锁？\",\"t\":[\"银行家算法，防止当前系统进入不安全状态。\"]},\"566\":{\"h\":\"sleep() 方法和 wait() 方法对比\",\"t\":[\"两个方法都能暂停线程的执行。\",\"区别：\",\"sleep()方法没有释放锁，而wait()方法释放了锁；\",\"wait()通常用于线程之间的通信，sleep()用于线程的暂停执行；\",\"wait()方法被调用之后，线程不会自动苏醒，需要别的线程调用同一个对象的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。\",\"sleep方法是Thread类的静态本地方法，wait()则是Object类的本地方法\"]},\"567\":{\"h\":\"为什么wait()方法不定义在Thread中？\",\"t\":[\"wait()是让获得对象锁的线程等待，会释放对象锁，每一个Object都有对象锁，要释放当前线程占有的对象锁并让其进入WAITING状态，当然是使用对象的操作而不是线程的操作。\",\"因为sleep()方法是让当前线程暂停执行，不涉及对象，所以定义在Thread类中。\"]},\"568\":{\"h\":\"直接调用run()和start()的区别\",\"t\":[\"new一个Thread，并调用start()方法会创建一个新的线程并让其进入就绪状态。start()的方法会执行线程的准备工作，然后自动调用run()方法，这样才能实现多线程。\",\"如果直接调用run()方法，则是通过调用线程来运行的，会把run()方法当成普通方法执行。\",\"调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。\"]},\"569\":{\"h\":\"并发编程二\"},\"570\":{\"h\":\"Java内存模型\"},\"571\":{\"h\":\"指令重排序\",\"t\":[\"编译器优化重排：编译器在不改变单线程程序语义的前提下，重新安排语句执行顺序。\",\"指令并行重排：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\",\"指令重排序可以保证串行语义的一致，但是没义务保证多线程之间语义的一致，在多线程下，指令重排可能会导致问题。\"]},\"572\":{\"h\":\"什么是Java内存模型？为什么需要Java内存模型？\",\"t\":[\"JMM是Java定义的并发编程相关的一组规范，除了抽象了线程和内存之间的关系之外，还规定了Java源代码到CPU可执行指令这个转化过程要遵循哪些和并发相关的原则和规范，主要目的是为了简化编程，增强代码的可移植性。\"]},\"573\":{\"h\":\"什么是主内存？什么是本地内存？\",\"t\":[\"主内存：所有线程创建的对象实例都放在主内存中；\",\"本地内存：每个线程都有私有的本地内存来存储共享变量的副本，并且每一个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是JMM抽象出的概念，存储了主内存中的变量副本。\"]},\"574\":{\"h\":\"Java内存结构和Java内存模型的区别\",\"t\":[\"Java内存结构和运行时区域有关，定义了JVM在运行时如何分区存储数据，例如堆主要用来存放对象实例。\",\"JMM和Java的并发编程有关，抽象了线程和内存之间的关系，规定了Java源代码到CPU可执行指令这个转化过程要遵循哪些并发相关的原则和规范，目的主要是简化多线程编程，增强程序的可移植性\"]},\"575\":{\"h\":\"happens-before\",\"t\":[\"前一个操作的结果应该对后一个操作是可见的，无论这两个操作是不是在同一个线程里。\",\"int userNum = getUserNum(); // 1 int teacherNum = getTeacherNum(); // 2 int totalNum = userNum + teacherNum; // 3 \",\"在线程并发执行的时候，可能1 2 操作的结果还没有存入变量中，3操作已经开始执行，这时得到的结果就不是正确结果。（指令流水线数据相关）\"]},\"576\":{\"h\":\"happens-before 常见规则\",\"t\":[\"程序顺序规则：一个线程内，书写在前的操作happens-before于书写在后面的操作；\",\"解锁规则：解锁happens-before加锁；\",\"volatile变量规则：对于一个volatile变量的写操作happens-before后面对这个变量的读操作，也就是对这个变量的修改对其后的所有操作都可见；\",\"传递规则：如果A happens-before B，B happens-before C，则A happens-before C；\",\"线程启动规则：Thread对象的start()方法happens-before这个线程的每一个操作。\",\"如果两个操作不满足上述条件的任意一个，则这两个操作就没有顺序保障，JVM可以对这两个操作进行重排序。\"]},\"577\":{\"h\":\"并发编程的三个特性\",\"t\":[\"原子性：\",\"一次操作或者多次操作，要么所有的操作都能全部执行不会收到任何外界因素干扰而中断，要么都不执行。\",\"synchronized和各种Lock来实现原子性。\",\"可见性：\",\"当一个线程对共享变量进行修改，那么另外的线程都是能立即看到的。\",\"synchronized、volatile、各种Lock实现可见性。\",\"有序性：\",\"由于指令重排序问题，代码的执行顺序未必就是编写代码的顺序。\",\"使用volatile关键字可以禁止指令进行重排序优化。\"]},\"578\":{\"h\":\"volatile关键字\",\"t\":[\"在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\",\"volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\"]},\"579\":{\"h\":\"volatile如何禁止指令重排序？\",\"t\":[\"如果将变量通过volatile修饰，则对这个变量读写的时候会添加上特定的读写屏障保证可见性。\",\"在CPU的物理世界里，内存屏障通常有三种：\",\"lfence: 读屏障（load fence)，即立刻让CPU Cache失效，从内存中读取数据，并装载入Cache中。\",\"sfence: 写屏障（write fence）, 即立刻进行flush，把缓存中的数据刷入内存中。\",\"mfence: 全屏障 (memory fence)，即读写屏障，保证读写都串行化，确保数据都写入内存并清除缓存。\",\"双检查单例模式：\",\"public class Singleton{ private Singleton{}//构造方法私有 private volatile Singleton singleton;//volatile修饰的singleton 保证可见性 public static Singleton getInstance(){ if(singleton==null){ synchronized(Singleton.class){//对类对象加锁 if(singleton==null){ singleton=new Singleton(); } } } return singleton; } } \",\"volatile是“轻量级”synchronized，保证了共享变量的“可见性”（JMM确保所有线程看到这个变量的值是一致的），当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，并且锁住缓存行，因此当其他CPU需要读取这个变量时，要等锁释放，并发现自己缓存行是无效的，那么它就会从内存重新读取。\"]},\"580\":{\"h\":\"乐观锁和悲观锁\"},\"581\":{\"h\":\"什么是乐观锁？\",\"t\":[\"乐观锁总是假设最好的情况，即认为将要修改的数据并没有被其他线程修改，修改失败采用重复尝试的办法。\",\"验证数据是否被其他线程修改可通过版本号机制或者CAS算法。\",\"在 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式 CAS 实现的。AtomicInteger类主要利用CAS(compare and swap)+volatile和native方法来保证原子操作，从而避免synchronized的高开销，执行效率大为提升。\"]},\"582\":{\"h\":\"什么是悲观锁？\",\"t\":[\"悲观锁总是假设最坏的情况，认为共享资源总是会被其他线程修改了，所以在访问资源的时候采取加锁的方案，防止其他线程修改，像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。\",\"高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。\"]},\"583\":{\"h\":\"CAS 算法\",\"t\":[\"CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。\",\"CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。\",\"CAS 涉及到三个操作数：\",\"V：要更新的变量值(Var)\",\"E：预期值(Expected)\",\"N：拟写入的新值(New)\"]},\"584\":{\"h\":\"ABA问题\",\"t\":[\"如果有一个线程将变量值A改为B，之后又有一个线程将B改为A，则第三个线程采用CAS进行修改的时候发现预期值A正确，则认为变量没有被修改，其实已经修改了两次。\",\"解决ABA问题就是添加版本号或者是时间戳。\"]},\"585\":{\"h\":\"CAS问题\",\"t\":[\"CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。\",\"CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行 CAS 操作。\"]},\"586\":{\"h\":\"synchronized\"},\"587\":{\"h\":\"synchronized 是什么？有什么用？\",\"t\":[\"synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\",\"早期版本中synchronized 属于重量级锁，Java 6 之后对synchronized 做了优化。\",\"详见synchronized锁优化。\"]},\"588\":{\"h\":\"sychronized修饰方法\",\"t\":[\"synchronized 关键字的使用方式主要有下面 3 种：\",\"synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁；\",\"synchronized 关键字加到实例方法上是给对象实例上锁；\"]},\"589\":{\"h\":\"synchronized底层原理\",\"t\":[\"修饰同步代码块\",\"synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\",\"在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。\",\"对象锁的的拥有者线程才可以执行 monitorexit 指令来释放锁。在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。\",\"修饰方法\",\"synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\",\"synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\",\"两者本质都是对对象监视器monitor的获取。\"]},\"590\":{\"h\":\"synchronized 和 volatile 有什么区别？\",\"t\":[\"volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。\",\"volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\",\"volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。\"]},\"591\":{\"h\":\"ReentrantLock\"},\"592\":{\"h\":\"ReentrantLock 是什么？\",\"t\":[\"ReentrantLock 实现了 Lock 接口，是一个可重入且独占式的锁，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。\",\"ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。\",\"详见AQS抽象队列同步器。\"]},\"593\":{\"h\":\"公平锁和非公平锁有什么区别？\",\"t\":[\"公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。\",\"非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。\"]},\"594\":{\"h\":\"synchronized 和 ReentrantLock 有什么区别？\",\"t\":[\"两者都是可重入锁，也就是线程可以再次获取自己的内部锁。\",\"synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API。\",\"ReentrantLock 比synchronized 增加了一些高级功能： \",\"等待可中断：ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。\",\"可实现公平锁: ReentrantLock可以指定是公平锁还是非公平锁，而synchronized只能是非公平锁。\",\"可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock也可以实现，但是需要借助于Condition接口与newCondition()方法。\"]},\"595\":{\"h\":\"可中断锁和不可中断锁有什么区别？\",\"t\":[\"可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。\",\"不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁。\"]},\"596\":{\"h\":\"并发编程三\"},\"597\":{\"h\":\"ThreadLocal\"},\"598\":{\"h\":\"ThreadLocal 有什么用？\",\"t\":[\"ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。\",\"如果创建了一个ThreadLocal变量，那么访问这个变量的每一个线程都有这个变量的副本。可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。\"]},\"599\":{\"h\":\"ThreadLocal原理\",\"t\":[\"Thread类源码：\",\"public class Thread implements Runnable { //与此线程有关的ThreadLocal值。由ThreadLocal类维护 ThreadLocal.ThreadLocalMap threadLocals = null; //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护 ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; //...... } \",\"变量是放在了当前线程的ThreadLocalMap中，并不是存在ThreadLocal中,ThreadLocal可以理解为ThreadLocalMap的封装。\",\"ThreadLocal类的set()方法：\",\"public void set(T value) { //获取当前请求的线程 Thread t = Thread.currentThread(); //取出 Thread 类内部的 threadLocals 变量(哈希表结构) ThreadLocalMap map = getMap(t); if (map != null) // 将需要存储的值放入到这个哈希表中 map.set(this, value); else createMap(t, value); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } \",\"每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap存储以ThreadLocal为key，Object对象为value的键值对（JDK1.8）。\",\"ThreadLocalMap是ThreadLocal的静态内部类。\"]},\"600\":{\"h\":\"ThreadLocal内存泄露\",\"t\":[\"ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。\",\"这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。\"]},\"601\":{\"h\":\"线程池\"},\"602\":{\"h\":\"什么是线程池?\",\"t\":[\"线程池是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。\"]},\"603\":{\"h\":\"为什么要用线程池？\",\"t\":[\"池化技术是为了减少每次获取资源的消耗，提高资源利用率。\",\"使用线程池的好处：\",\"降低资源消耗；\",\"提高响应速度；\",\"提高线程的可管理性。\"]},\"604\":{\"h\":\"如何创建线程池？\",\"t\":[\"通过ThreadPoolExecutor构造函数来创建；\",\"通过 Executor 框架的工具类 Executors 来创建。\",\"不同类型的ThreadPoolExecutor:\",\"FixedThreadPool：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。核心线程数为n，最大线程数为n。\",\"SingleThreadExecutor： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。核心线程数为1，最大线程数为1。\",\"CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。核心线程数为0，最大线程数为Integer.MAX_VALUE。\",\"ScheduledThreadPool：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。核心线程数为n，最大线程数为Integer.MAX_VALUE。\",\"ThreadPoolExecutor\",\"corePoolSize\",\"maximumPoolSize\",\"任务队列\",\"可创建的最大线程数\",\"FixedThreadPool\",\"n\",\"n\",\"LinkedBlockingQueue无界队列\",\"n\",\"SingleThreadExecutor\",\"1\",\"1\",\"LinkedBlockingQueue无界队列\",\"1\",\"CachedThreadPool\",\"0\",\"Integer.MAX_VALUE\",\"SynchronousQueue同步队列\",\"Integer.MAX_VALUE\",\"ScheduledThreadPool\",\"n\",\"Integer.MAX_VALUE\",\"DelayedWorkQueue延迟阻塞队列\",\"n\",\"注意\",\"最大线程数是线程池参数，与可创建的最大线程数不是一个意思。\"]},\"605\":{\"h\":\"线程池的主要参数\",\"t\":[\"int corePoolSize,//线程池的核心线程数量 int maximumPoolSize,//线程池的最大线程数 long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间 TimeUnit unit,//时间单位 BlockingQueue<Runnable> workQueue,//任务队列 ThreadFactory threadFactory,//线程工厂 RejectedExecutionHandler handler//拒绝策略 \",\"ThreadPoolExecutor 3 个最重要的参数：\",\"corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。\",\"maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\",\"workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\",\"ThreadPoolExecutor其他常见参数 :\",\"keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；\",\"unit : keepAliveTime 参数的时间单位。\",\"threadFactory :executor 创建新线程的时候会用到。\",\"handler :饱和策略。\"]},\"606\":{\"h\":\"线程池的饱和策略有哪些？\",\"t\":[\"如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，新来的任务将会被：\",\"ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。\",\"ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。\",\"ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。\",\"ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。\"]},\"607\":{\"h\":\"线程池中常用的阻塞队列有哪些？\",\"t\":[\"新任务到来的时候，如果核心线程已经满了，就会放入到阻塞队列中。\",\"常见的阻塞队列：\",\"容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）：FixedThreadPool 和 SingleThreadExector 。由于队列永远不会被放满，因此**FixedThreadPool最多只能创建核心线程数的线程**。\",\"SynchronousQueue（同步队列）：CachedThreadPool 。SynchronousQueue 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，CachedThreadPool 的最大线程数是 Integer.MAX_VALUE ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。\",\"DelayedWorkQueue（延迟阻塞队列）：ScheduledThreadPool 和 SingleThreadScheduledExecutor 。DelayedWorkQueue 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。DelayedWorkQueue 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 Integer.MAX_VALUE，所以最多只能创建核心线程数的线程。\"]},\"608\":{\"h\":\"线程池处理任务的流程了解吗？\",\"t\":[\"如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。\",\"如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。\",\"如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。\",\"如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用RejectedExecutionHandler.rejectedExecution()方法。\"]},\"609\":{\"h\":\"如何设定线程池的大小？\",\"t\":[\"CPU 密集型任务(N+1)：N表示CPU核心数，比N多1是为了处理线程偶然发生的缺页中断，或者是其他原因导致任务暂停带来的影响。\",\"I/O 密集型任务(2N)：系统大部分时间用来IO交互，而在处理IO的时候不会占用CPU资源，这时可将CPU资源交给其他任务，因此创建N+N个核心线程。\"]},\"610\":{\"h\":\"Future\"},\"611\":{\"h\":\"Future类有什么用？\",\"t\":[\"Future 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。\",\"简单理解：有一个任务，提交给了 Future 来处理。任务执行期间自己可以去做任何想做的事情。并且，在这期间还可以取消任务以及获取任务的执行状态。一段时间之后，可以从 Future 那里直接取出任务执行结果。\"]},\"612\":{\"h\":\"Callable 和 Future 有什么关系？\",\"t\":[\"FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit() 方法返回的其实就是 Future 的实现类 FutureTask。\",\"FutureTask 有两个构造函数，可传入 Callable 或者 Runnable 对象。实际上，传入 Runnable 对象也会在方法内部转换为Callable 对象。\",\"FutureTask相当于对Callable 进行了封装，管理着任务执行的情况，存储了 Callable 的 call 方法的任务执行结果。\"]},\"613\":{\"h\":\"CompletableFuture 类有什么用？\",\"t\":[\"Future 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。\",\"Java 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。\",\"CompletableFuture<SkuInfoEntity> future1 = CompletableFuture.supplyAsync(() -> { //sku基本信息的获取 pms_sku_info SkuInfoEntity info = this.getById(skuId); skuItemVo.setInfo(info); return info; }, executor); CompletableFuture<SkuInfoEntity> future2 = future1.thenAcceptAsync(() -> { //业务代码2，需要future1完成之后才能执行 }, executor); CompletableFuture<SkuInfoEntity> future3 = CompletableFuture.supplyAsync(() -> { //业务代码 }, executor); CompletableFuture<SkuInfoEntity> future4 = CompletableFuture.supplyAsync(() -> { //业务代码 }, executor); //多个任务等待异步完成 CompletableFuture.allOf(future1,future2,future3,future4).get(); \"]},\"614\":{\"h\":\"synchronized锁优化\",\"t\":[\"锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\"]},\"615\":{\"h\":\"自旋锁与自适应自旋\",\"t\":[\"当获取锁失败的时候线程不会立马阻塞，而是采用忙循环（自旋）去再次尝试获取锁。重试的次数默认是10次。\",\"JDK1.6之后引入自适应锁，自旋锁重试次数是固定的，不够灵活，如果在同一个锁对象上，最近通过自旋获得过这个锁，则认为此次的自旋也有较大概率获得锁，会自旋更多次。另外如果对于某个锁自旋很少成功获得，则以后在获取锁失败之后很可能会省略自旋的过程。\"]},\"616\":{\"h\":\"锁消除\",\"t\":[\"虚拟机即时编译的时候，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持。\",\"在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程所访问到，就可以把它们当做栈上数据，认为是线程私有的，同步锁就没有必要加上了。\"]},\"617\":{\"h\":\"锁粗化\",\"t\":[\"在编写代码的时候，推荐将加锁的范围尽可能的变小以获得更好的性能。\",\"大部分情况下，上面的原则都是正确的，例如在一个循环内对同一个对象进行加锁解锁，频繁的同步操作会导致不必要的性能损耗，则虚拟机会把加锁的范围扩展（粗化）以减少加锁和解锁的次数。\"]},\"618\":{\"h\":\"轻量级锁\",\"t\":[\"轻量级锁是JDK 1.6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”锁。\",\"它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。\",\"整个加解锁过程其实就是一个新旧数据比对的过程（通过CAS），根据数据的变化来确定同步代码块是否多个线程抢占共享变量，如果在某段时间内没有多个线程访问这块同步代码那就可以不需要去指向操作系统互斥量（这个对象的内存相比较2bit的锁标志位是要大很多的，同时还能减少传统的重量级锁使用操作系统互斥量产生的性能消耗），如果是出现了多个线程进行抢占共享变量，就会使用操作系统互斥量达到互斥同步。也可以理解成如果同步代码块没有多个出现并发问题的话，就应该尽可能的减少实现同步互斥所带来的一系列损耗。\"]},\"619\":{\"h\":\"偏向锁\",\"t\":[\"偏向锁也是JDK 1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。\",\"偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。\"]},\"620\":{\"h\":\"AQS抽象队列同步器\",\"t\":[\"AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面。\",\"AQS 就是一个抽象类，主要用来构建锁和同步器。\",\"比如 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。\"]},\"621\":{\"h\":\"AQS原理\"},\"622\":{\"h\":\"AQS核心思想\",\"t\":[\"AQS的核心思想是如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源的状态设置为锁定状态。如果资源被占用，则需要一套线程阻塞等待以及被唤醒分配的机制，这个机制AQS是基于CLH锁实现的。\",\"CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。\",\"CLH锁的结构如下：\",\"AQS的核心原理图如下：\",\"AQS 使用 int 成员变量 state 表示同步状态，通过内置的 线程等待队列 来完成获取资源线程的排队工作。\",\"state 变量由 volatile 修饰，用于展示当前临界资源的获锁情况。\"]},\"623\":{\"h\":\"AQS资源共享方式\",\"t\":[\"AQS 定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。\"]},\"624\":{\"h\":\"Semaphore（信号量）\",\"t\":[\"synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，而Semaphore(信号量)可以用来控制同时访问特定资源的线程数量。\",\"Semaphore 的使用简单，假设有 N(N>5) 个线程来获取 Semaphore 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。\",\"final Semaphore semaphore = new Semaphore(5); // 获取1个许可，相当于P操作 semaphore.acquire(); // 释放1个许可，相当于V操作 semaphore.release(); \",\"Semaphore 有两种模式：\",\"公平模式： 调用 acquire() 方法的顺序就是获取许可证的顺序，遵循 FIFO；\",\"非公平模式： 抢占式的，默认模式。\",\"原理：\",\"Semaphore 是共享锁的一种实现，它默认构造 AQS 的 state 值为 permits，你可以将 permits 的值理解为许可证的数量，只有拿到许可证的线程才能执行。\",\"P操作：调用semaphore.acquire() ，线程尝试获取许可证，如果 state >= 0 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 state 的值 state=state-1。如果 state<0 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。\",\"V操作：调用semaphore.release() ，线程尝试释放许可证，并使用 CAS 操作去修改 state 的值 state=state+1。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 state 的值 state=state-1 ，如果 state>=0 则获取令牌成功，否则重新进入阻塞队列，挂起线程。\",\"除了 acquire() 方法之外，另一个比较常用的与之对应的方法是 tryAcquire() 方法，该方法如果获取不到许可就立即返回 false。\"]},\"625\":{\"h\":\"CountDownLatch （倒计时器）\",\"t\":[\"CountDownLatch 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。\",\"CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。\",\"CountDownLatch 是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用 countDown() 方法时,其实使用了tryReleaseShared方法以 CAS 的操作来减少 state,直至 state 为 0 。当调用 await() 方法的时候，如果 state 不为 0，那就证明任务还没有执行完毕，await() 方法就会一直阻塞，也就是说 await() 方法之后的语句不会被执行。然后，CountDownLatch 会自旋 CAS 判断 state == 0，如果 state == 0 的话，就会释放所有等待的线程，await() 方法之后的语句得到执行。\",\" \",\"两种典型用法：\",\"等待n个线程完成任务之后，主线程继续工作。\",\"子线程1： //业务代码 countDownLatch.countDown();//将state值-1 子线程2： //业务代码 countDownLatch.countDown();//将state值-1 ---- 主线程：countDownLatch.await();//等到state值为0的时候才不会被阻塞，等待两个线程执行完成 \",\"等待n个线程准备，在执行任务前先countDownLatch.awit()，然后主线程调用countDown()计数值变0，n个线程同时被唤醒。\",\"子线程1：countDownLatch.await();//等待state值变为0 //业务代码 子线程2：countDownLatch.await(); //业务代码 ---- 主线程：countDownLatch.countDown();//将state值变为0，类似信号枪响 \"]},\"626\":{\"h\":\"CyclicBarrier(循环栅栏)\",\"t\":[\"CyclicBarrier 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1，并将自身阻塞。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，此时才会将栅栏放开，让所有线程继续执行下去。\",\"使用await()方法告诉CyclicBarrier 已经到达了屏障，然后当前线程被阻塞。当count值为0则会将被阻塞的线程唤醒。\"]},\"627\":{\"h\":\"JUC常见并发容器\",\"t\":[\"JDK 提供的这些容器大部分在 java.util.concurrent 包中。\",\"ConcurrentHashMap : 线程安全的 HashMap\",\"CopyOnWriteArrayList : 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector。\",\"ConcurrentLinkedQueue : 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。\",\"BlockingQueue : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。\",\"ConcurrentSkipListMap : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。\"]},\"628\":{\"h\":\"CopyOnWriteArrayList\",\"t\":[\"为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。\"]},\"629\":{\"h\":\"CopyOnWriteArrayList 原理\",\"t\":[\"CopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作。\"]},\"630\":{\"h\":\"ConcurrentLinkedQueue\",\"t\":[\"Java 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，使用链表作为其数据结构。在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。\",\"ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全。\",\"ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。\"]},\"631\":{\"h\":\"BlockingQueue\",\"t\":[\"BlockingQueue （阻塞队列）是一个接口，继承自 Queue。BlockingQueue阻塞的原因是其支持当队列没有元素时一直阻塞，直到有有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。\",\"BlockingQueue 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。\"]},\"632\":{\"h\":\"ArrayBlockingQueue\",\"t\":[\"ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁 ReentrantLock ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。默认是不公平实现的。.\"]},\"633\":{\"h\":\"LinkedBlockingQueue\",\"t\":[\"LinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。\"]},\"634\":{\"h\":\"PriorityBlockingQueue\",\"t\":[\"PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。\",\"简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。\"]},\"635\":{\"h\":\"ConcurrentSkipListMap\",\"t\":[\"跳表的本质是同时维护了多个链表，并且链表是分层的，最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。\",\"跳表内的所有链表的元素都是排序的。\",\"查找时，可以从顶级链表开始找。一旦发现被查找的元素处于两个元素值的区间，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。\",\"查找18原本要遍历18次，现在只需要7次。\"]},\"636\":{\"h\":\"并发编程\"},\"637\":{\"h\":\"JVM内存结构\"},\"638\":{\"h\":\"运行时数据区域\"},\"639\":{\"h\":\"线程私有的：\"},\"640\":{\"h\":\"程序计数器\",\"t\":[\"一块很小的内存区域，保存了将要执行指令的地址。为了线程切换之后能恢复到正确的执行位置，每一个线程都需要一个程序计数器，各线程之间计数器互不影响，称为“线程私有”的内存。\",\"程序计数器是唯一一个不会出现OOM的内存区域，随着线程的创建而创建，线程的消亡而消亡。\"]},\"641\":{\"h\":\"虚拟机栈\",\"t\":[\"虚拟机栈也是线程私有的，方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。\",\"栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。\",\"局部变量表：主要存放了编译期可知的各种数据类型、对象引用。\",\"操作数栈：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。\",\"动态链接 ：主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其 。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 动态链接 。\"]},\"642\":{\"h\":\"本地方法栈\",\"t\":[\"和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。\"]},\"643\":{\"h\":\"线程共有的：\"},\"644\":{\"h\":\"堆\",\"t\":[\"Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**堆的内存结构在垃圾回收章节提及。\",\"注意\",\"在JDK1.7开启了逃逸分析，如果一个对象引用不会逃出本方法的作用范围，则认为没有逃逸，直接进行栈上分配。\"]},\"645\":{\"h\":\"方法区\",\"t\":[\"方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。从内存分布图中可以看出永久代是 JDK 1.8 之前的方法区实现（运行时数据区），JDK 1.8 及以后方法区的实现变成了元空间（本地内存）。\",\"转到本地内存的原因：元空间使用本地内存，可能会受到本机内存的限制，但是出现溢出的概率比原来的永久代小很多。\"]},\"646\":{\"h\":\"运行时常量池（方法区内部）\",\"t\":[\"Class文件中除了有类的版本号、字段、方法、接口等描述信息，还有用于存放各种字面量和符号引用的常量池表。\",\"字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。\",\"常量池表会在类加载后存放到方法区的运行时常量池中。既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。\"]},\"647\":{\"h\":\"字符串常量池\",\"t\":[\"JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。\",\"因为方法区的GC效率很低，堆的GC效率很高，Java程序中通常有大量的字符串等待回收，放入堆中能加快回收频率。\",\"字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\",\"HotSpot 虚拟机中字符串常量池的实现是 stringTable.cpp ，StringTable 可以简单理解为一个固定大小的HashTable ，容量为 StringTableSize（可以通过 -XX:StringTableSize 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。\"]},\"648\":{\"h\":\"JVM中对象的创建\"},\"649\":{\"h\":\"1. 类加载检查\",\"t\":[\"虚拟机遇到new指令时，先会检查指令的参数能否在常量池中找到这个参数对应类的符号引用，并检查这个符号引用代表的类是否已经加载，解析和初始化。如果没有需要先执行响应的类加载过程。\"]},\"650\":{\"h\":\"2. 分配内存\",\"t\":[\"类加载完成之后开始分配内存，所需要的内存大小在类加载完成之后就能确定。内存的分配方式有“指针碰撞”和“空闲列表”两种。\",\"指针碰撞\",\"适合内存规整的情况。\",\"将用过的内存整理到一边，没用过的放在另外一边，通过移动中间的指针，和另外一边的边界划定一个对象内存大小的区域。\",\"使用指针碰撞分配方式的GC收集器：Serial，ParNew。\",\"空闲列表\",\"适合内存不规整的情况。\",\"虚拟机维护一个列表，用来表示哪部分的内存是空闲的，在分配的时候找到一块能满足分配大小的空闲内存进行分配。\",\"使用空闲列表的GC收集器：CMS。\",\"保证内存分配时的线程安全\",\"CAS+重试：虚拟机采用CAS和失败重试的方式保证更新操作的原子性。\",\"：每一个线程都有一个TLAB（线程本地分配缓冲区），在线程中对象分配内存的时候先会在TLAB中分配，当对象大于TLAB剩余空内存或者TLAB内存耗尽的时候，才会使用CAS+重试的分配方式。\"]},\"651\":{\"h\":\"3. 初始化零值\",\"t\":[\"内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\"]},\"652\":{\"h\":\"4. 设置对象头\",\"t\":[\"初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\"]},\"653\":{\"h\":\"5. 执行 init 方法\",\"t\":[\"执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\"]},\"654\":{\"h\":\"对象的内存布局\",\"t\":[\"在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。\",\"对象头包含两部分信息：一部分用于存储对象自身的运行时数据（哈希码，GC分代年龄，锁状态标志），另外一部分是类型指针，即对象指向他的类数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\",\"实例数据部分是对象真正存储的有效信息，对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。（内存对齐存放）\"]},\"655\":{\"h\":\"对象的访问定位\",\"t\":[\"对象的访问定位就是如何找到创建的对象信息，包括实例和类数据。\"]},\"656\":{\"h\":\"直接指针\",\"t\":[\"如果使用直接指针访问，reference 中存储的直接就是对象的地址。\"]},\"657\":{\"h\":\"句柄\",\"t\":[\"如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。\"]},\"658\":{\"h\":\"JVM垃圾回收\"},\"659\":{\"h\":\"内存分配和回收原则\"},\"660\":{\"h\":\"对象优先在Eden中分配\",\"t\":[\"大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。\"]},\"661\":{\"h\":\"大对象直接进入老年代\",\"t\":[\"大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。\",\"大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。\"]},\"662\":{\"h\":\"长期存活的对象将进入老年代\",\"t\":[\"虚拟机给每个对象一个对象年龄（Age）计数器。\",\"大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。\",\"对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。\",\"对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。\",\"额外的\",\"Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 -XX:TargetSurvivorRatio=percent 来设置），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。\"]},\"663\":{\"h\":\"GC区域\",\"t\":[\"针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：\",\"部分收集 (Partial GC)：\",\"新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；\",\"老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；\",\"混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。\",\"整堆收集 (Full GC)：收集整个 Java 堆和方法区。\"]},\"664\":{\"h\":\"空间分配担保\",\"t\":[\"在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的，如果不成立，则虚拟机会先查看 -XX:HandlePromotionFailure 参数的设置值是否允许担保失败(Handle Promotion Failure)；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 -XX: HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次 Full GC。\",\"可能存在所有的新生代对象都在这次GC之后晋升至老年代，老年代如果没有足够的内存则无法担保分配\"]},\"665\":{\"h\":\"死亡对象的判断方法\"},\"666\":{\"h\":\"引用计数法\",\"t\":[\"给对象添加一个计数器：\",\"有地方引用的时候就将计数器+1；\",\"引用失效，将计数器-1；\",\"计数器为0的对象就是不会再被使用的对象。\",\"简单高效，但是对象之间存在循环引用，导致他们的计数值都不为0，无法通知GC回收器回收它们。\"]},\"667\":{\"h\":\"可达性分析\",\"t\":[\"这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。\"]},\"668\":{\"h\":\"可以作为 GC Roots 的对象\",\"t\":[\"虚拟机栈中的对象；\",\"本地方法栈中的对象；\",\"方法区中静态属性引用的变量；\",\"方法区中常量引用的对象；\",\"所有被同步锁持有的对象。\"]},\"669\":{\"h\":\"对象可以被回收，就代表一定会被回收吗？\",\"t\":[\"即使被标记为不可达的对象，也并不会立即被回收，而是处于”缓刑“阶段，经过真正的宣告对象死亡，至少要经过两次标记过程；\",\"可达性分析中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法。\",\"对象没有覆盖finalize方法，或者finalize方法已经被虚拟机调用过，虚拟机把这两种情况视为没有必要执行。\",\"被判断需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象的引用链上的任何一个对象建立关联，否则就会被回收。\"]},\"670\":{\"h\":\"引用类型总结\",\"t\":[\"强引用：必不可少的，垃圾回收器绝对不会回收的对象。\",\"软引用：可有可无的，内存足够不会回收，如果内存不太够则可能会回收。\",\"弱引用：可有可无的，与软引用的区别在于：具有弱引用的对象具有更短的声明周期，垃圾回收器一旦发现，不管内存空间是否紧张都会回收这个对象。\",\"虚引用：形同虚设，虚引用不会决定对象的声明周期，如果一个对象仅持有虚引用，则和没有任何引用一样，任何时候都有可能被回收。\",\"虚引用主要用来跟踪对象被垃圾回收的活动。\",\"虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\",\"程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\",\"特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。\"]},\"671\":{\"h\":\"如何判断一个常量是废弃常量？\",\"t\":[\"JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。\",\"JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。\",\"JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)。\",\"假如在字符串常量池中存在字符串 \\\"abc\\\"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 \\\"abc\\\" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，\\\"abc\\\" 就会被系统清理出常量池了。\"]},\"672\":{\"h\":\"如何判断一个类是无用的类？\",\"t\":[\"判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。\",\"类需要同时满足下面 3 个条件才能算是 “无用的类”：\",\"该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\",\"加载该类的 ClassLoader 已经被回收。\",\"该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\",\"虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。\"]},\"673\":{\"h\":\"垃圾收集算法\"},\"674\":{\"h\":\"标记-清除算法\",\"t\":[\"标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。\",\"效率问题：标记和清除两个过程效率都不高。\",\"空间问题：标记清除后会产生大量不连续的内存碎片。\"]},\"675\":{\"h\":\"复制算法\",\"t\":[\"为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\",\"对应到新生代就是survivor中的from区和to区。\",\"1.可用内存变小：可用内存缩小为原来的一半，一半作为from区，一半作为to。\",\"2.不适合老年代：如果存活对象数量比较大，复制性能会变得很差。\"]},\"676\":{\"h\":\"分代收集算法/HotSpot为什么要分代\",\"t\":[\"当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点选择合适的垃圾收集算法。\",\"在新生代中，每次收集都有大量对象死去，所以可以采用“标记-复制算法”，只需要付出少量对象的复制成本就能完成垃圾收集，而老年代中对象存活的久，并且没有额外的空间对它进行分配担保，所以选择“标记-清除”或“标记-整理”算法进行垃圾收集。\"]},\"677\":{\"h\":\"垃圾回收器\"},\"678\":{\"h\":\"Serial 收集器\",\"t\":[\"Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。只会使用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ \\\"Stop The World\\\" ），直到它收集结束。简单高效。\",\"新生代采用标记-复制算法，老年代采用标记-整理算法。\"]},\"679\":{\"h\":\"ParNew 收集器\",\"t\":[\"ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。\",\"新生代采用标记-复制算法，老年代采用标记-整理算法。\",\"除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。\",\"并发：一个时间段内同时执行，操作系统基本特征。\",\"并行：一个时刻同时执行。\"]},\"680\":{\"h\":\"Parallel Scavenge 收集器\",\"t\":[\"采用标记-复制算法的多线程收集器，重点关注吞吐量（高效利用CPU），CMS垃圾收集器关注的是停顿时间。\",\"新生代采用标记-复制算法，老年代采用标记-整理算法。\",\"JDK1.8的默认收集器。\"]},\"681\":{\"h\":\"Serial Old收集器\",\"t\":[\"Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。\"]},\"682\":{\"h\":\"Parallel Old 收集器\",\"t\":[\"Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。\"]},\"683\":{\"h\":\"CMS收集器\",\"t\":[\"CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。\",\"CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\",\"CMS 收集器是一种“标记-清除”算法实现的，运行步骤：\",\"初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；\",\"并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\",\"重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\",\"并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\",\"优点：\",\"并发收集、低停顿。\",\"缺点：\",\"对 CPU 资源敏感；\",\"无法处理浮动垃圾；（在并发标记阶段用户新产生的垃圾，在重新标记阶段不会标记浮动的新垃圾）\",\"它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\"]},\"684\":{\"h\":\"G1 收集器\",\"t\":[\"G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.\",\"G1也是遵循分代收集理论设计的，它不再坚持以固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域，每一个Region都可以根据需要扮演Eden空间、Survivor空间或者老年代空间。收集器根据不同的角色采用不同的策略处理这些Region。Region中还有一类特殊的Humongous区域，专门用来存储大对象。这些Humongous被当作老年代处理。有以下特点：\",\"并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。\",\"分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。\",\"空间整合：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。（一个Region复制到另外一个Region）\",\"可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。\",\"G1 收集器的运作大致分为以下几个步骤：\",\"初始标记：标记一下GC Roots能直接关联到的对象，再修改TAMS指针。借用Minor GC的时候同步完成。\",\"并发标记：遍历对象图，找出需要回收的对象，与用户线程并发执行。处理原始快照在并发时变动的对象。\",\"最终标记：处理并发阶段结束后仍遗留下来的少量SATB记录。\",\"筛选回收：更新Region的统计数据，对各个Region的回收价值和成本进行排序，然后根据用户的期望停顿时间制定回收计划，最后把需要回收的Region里的存活对象复制到新region中，再清空旧region。需要STW，多条收集线程并发执行。\",\"G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\",\"G1存在着很多问题：\",\"还是跨代引用的问题，这么多Region，在判断对象是否可达的时候，就需要每个Region都维护一个Remember Set，内存占用是非常高的。\",\"浮动垃圾。为每个Region设置两个TAMS指针，新对象都分配在这个两个指针之间，默认认为这些新对象不是垃圾。如果回收速度赶不上分配速度，也会导致冻结用户线程，进行FullGC。\"]},\"685\":{\"h\":\"CMS和G1的异同\",\"t\":[\"首先CMS是老年代的收集器，一般配合ParNew使用，但是这个组合在G1出现后已经被废弃了。G1 面向整堆进行收集。\",\"CMS采用标记清除算法，因此会产生内存碎片，导致Concurrent mode failure进而Full GC。\",\"G1宏观上采用标记清除，但是微观上是在各个region之间标记复制，所以降低了内存碎片的产生数量。\",\"再就是二者的回收过程不同，CMS大致可以分为初始标记、并发标记、重新标记和并发清理；G1 大致可以分为初始标记、并发标记、重新标记和清除。这二者在针对并发标记过程中用户线程对可达性分析的影响的处理方式不同，一个是增量更新（CMS），一个是原始快照（G1）。\",\"CMS和G1都是响应时间优先的收集器，但是CMS是追求最小的停顿时间为目标，而G1通过衰减均值来建立可预测的停顿模型，也就是分析每个Region的回收收益，根据均值、标准差、置信度等指标来决定到底要收集哪些region，并且收集这些region所需的停顿时间要大概率不超过期望的停顿时间。\"]},\"686\":{\"h\":\"到底多大的对象会被直接扔到老年代\",\"t\":[\"用-XX: PretunureSizeThreshold指定对象大小的阈值，超过这个数就直接放入老年代，减少内存复制开销。但是这个参数只支持Serial和ParNew。像G1的话，只要对象大小超过Region的一半，那就会直接放到Humongous里，这个Humongous也被认为是老年代。\"]},\"687\":{\"h\":\"CMS和G1的STW的区别\",\"t\":[\"首先，根节点枚举都是需要STW的，CMS和G1在根节点枚举上的区别就在于处理跨代引用上，跨代引用一般是使用记忆集解决，G1的记忆集和CMS的不一样，因为G1的分区是按Region分的，因此G1的记忆集是一个哈希表，Key是别的Region的起始地址，value是一个集合，里面存储的是卡表的索引号。这个哈希表表示我指向谁，谁又指向我的，是一种双向卡表。而CMS的卡表比较简单，只标识着某个内存区域是否为脏。\",\"然后CMS在可达性分析的时候有两个步骤需要STW，一个是初始标记，一个是重新标记；G1 有三个步骤需要STW，一个是初始标记，一个是最终标记，还有一个是筛选回收。初始标记很好理解，就是将GC roots直接引用的对象标记一遍，速度很快；关键点在于这二者都存在一个并发标记的步骤，此时与用户线程并发执行，难免用户线程会修改对象图的引用关系。这两个收集器的处理策略是不同的，CMS采用的是增量更新，G1 则采用的是原始快照。\",\"增量更新就是将那些新加入引用的位置记录，在重新标记阶段进行处理。原始快照就是将那些被删除的引用记录保存下来，也就是保存个快照，在并发标记的最后以及最终标记中进行处理。\"]},\"688\":{\"h\":\"类文件结构\"},\"689\":{\"h\":\"字节码\",\"t\":[\"在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。\"]},\"690\":{\"h\":\"Class文件结构总结\"},\"691\":{\"h\":\"魔数（Magic Number）\",\"t\":[\" u4 magic; //Class 文件的标志 \",\"每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。\"]},\"692\":{\"h\":\"Class 文件版本号（Minor&Major Version）\",\"t\":[\" u2 minor_version;//Class 的小版本号 u2 major_version;//Class 的大版本号 \",\"四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是次版本号（2个字节），第 7 和第 8 位是主版本号（2个字节）。\",\"每当Java发布大版本的时候，主版本号都会加1。\",\"高版本的JVM能运行低版本编译器生成的.class文件，但是低版本的JVM不会向上兼容高版本的.class文件。\"]},\"693\":{\"h\":\"常量池（Constant Pool）\",\"t\":[\" u2 constant_pool_count;//常量池的数量 cp_info constant_pool[constant_pool_count-1];//常量池 \",\"紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”）。\",\"常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：\",\"类和接口的全限定名\",\"字段的名称和描述符\",\"方法的名称和描述符\",\"常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型。\"]},\"694\":{\"h\":\"访问标志(Access Flags)\",\"t\":[\" u2 access_flags;//Class 的访问标记 \",\"在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。\"]},\"695\":{\"h\":\"当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合\",\"t\":[\" u2 this_class;//当前类 u2 super_class;//父类 u2 interfaces_count;//接口 u2 interfaces[interfaces_count];//一个类可以实现多个接口 \",\"Java 类的继承关系由类索引、父类索引和接口索引集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后，\",\"类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。\",\"接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implements (如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。\"]},\"696\":{\"h\":\"字段表集合（Fields）\",\"t\":[\" u2 fields_count;//Class 文件的字段的个数 field_info fields[fields_count];//一个类会可以有个字段 \",\"字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。\"]},\"697\":{\"h\":\"方法表集合（Methods）\",\"t\":[\" u2 methods_count;//Class 文件的方法的数量 method_info methods[methods_count];//一个类可以有个多个方法 \",\"methods_count 表示方法的数量，而 method_info 表示方法表。\",\"Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。\"]},\"698\":{\"h\":\"属性表集合（Attributes）\",\"t\":[\" u2 attributes_count;//此类的属性表中的属性数 attribute_info attributes[attributes_count];//属性表集合 \",\"在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。\"]},\"699\":{\"h\":\"类加载过程\"},\"700\":{\"h\":\"类的生命周期\",\"t\":[\"类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，前三个阶段可以统称为连接（Linking）。\",\"类加载过程：加载->连接->初始化。\",\"其中连接过程分为：验证->准备->解析。\",\"整体流程为：加载->验证->准备->解析->初始化。\"]},\"701\":{\"h\":\"类加载过程\"},\"702\":{\"h\":\"加载\",\"t\":[\"类加载过程的第一步，完成以下三件事情：\",\"通过全类名获取定义此类的二进制字节流。\",\"将字节流所代表的静态存储结构转化为方法区的运行时数据结构。\",\"在内存中生成一个类的.class文件，作为方法区这些数据的入口。\",\"加载这一步通过类加载器完成的。\"]},\"703\":{\"h\":\"验证\",\"t\":[\"验证是连接中的第一步。这一步的作用是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。\",\"验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的，但很有必要，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。\",\"验证阶段主要由四个检验阶段组成：\",\"文件格式验证（Class文件格式检查）\",\"验证字节流是否符合Class文件格式的规范。例如是否以魔数开头，主版本号是否在当前虚拟机的处理范围内，详见类文件结构。主要目的是保证输入的字节流能正确的解析并存储于方法区内，其余的三个验证阶段都是基于方法区的存储结构上进行，不会再直接读取、操作字节流了。\",\"元数据验证（字节码语义检查）\",\"对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》要求。例如这个类是否有父类，这个类是否继承了不允许继承的类。\",\"字节码验证（程序语义检查）\",\"通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的。例如函数的参数类型是否正确，对象的类型转换是否合理。\",\"符号引用验证（类的正确性检查）\",\"验证类的正确性。例如该类要使用的其他类、方法、字段是否存在，是否有正确的访问权限。发生在类加载阶段的解析阶段，具体来说就是JVM将符号引用转化为直接引用的时候。\"]},\"704\":{\"h\":\"准备\",\"t\":[\"准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都在方法区内分配。\",\"这时候进行内存分配的仅包括类变量（即是静态变量，被static修饰的变量，只与类有关，因此称为类变量），不包括实例变量。实例变量会在对象实例化的时候随着对象一块分配在Java堆中。\",\"类变量所使用的内存都应该在方法区中分配，但是在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。\",\"这是设置的初始值“通常情况”下是数据类型的默认值，例如public static int value = 111，那么value变量在准备阶段的的初始值是0而不是111（初始化阶段才会赋值）。特殊情况，变量添加final修饰，则可以看成常量，直接就会在准备阶段赋值。\"]},\"705\":{\"h\":\"解析\",\"t\":[\"解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符进行引用。\",\"符号引用以一组符号来描述所引用的对象，符号可以使任何字面量，只要能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存中的内容。\",\"直接引用是可以直接指向目标的指针、相对偏移量或者是一个能定位到目标的句柄。如果使用了直接引用，则引用目标必定在虚拟机的内存中。\",\"当程序执行方法的时候，系统需要明确知道这个方法所处的位置。Java为每一个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就能调用这个方法了。通过解析操作符号引用就能直接变成为目标方法在类中方法表的位置，从而方法才能被调用。\",\"综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。\"]},\"706\":{\"h\":\"初始化\",\"t\":[\"初始化阶段是执行初始化方法 <clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。\",\"对于初始化，以下几种情况必须对类进行初始化：\",\"当遇到new 、getstatic、putstatic、invokestatic这4条字节码指令。\",\"使用java.lang.reflect包的方法对类进行反射调用时如果类没有初始化，则需要先进行初始化。\",\"初始化一个类，父类还没有初始化，则需要先初始化父类。\",\"虚拟机启动时，用户需要定义一个需要执行的主类，虚拟机会先初始化这个类。\",\"MethodHandle和VarHandle可以看做轻量级的反射调用机制，使用这两个调用就要先使用findStaticVarHandle来初始化要调用的类。\",\"当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。\"]},\"707\":{\"h\":\"类卸载\",\"t\":[\"卸载类，即该类的Class对象被GC。\",\"需要满足三个条件才能卸载：\",\"该类的所有实例对象都被GC，也就是说堆中不存在该类的实例对象。\",\"该类没有在其他任何地方被引用。\",\"该类的类加载器的实例已经被GC。\",\"所以在JVM生命周期内，由JVM自带的类加载器（JDK 自带的 BootstrapClassLoader, ExtClassLoader, AppClassLoader ）加载的类是不会被卸载的，但是自定义的类加载器加载的类是可能被卸载的。\"]},\"708\":{\"h\":\"类加载器\"},\"709\":{\"h\":\"类加载器\",\"t\":[\"类加载器是一个负责加载类的对象，用于实现类加载过程中的第一步。\",\"每一个Java类都有一个引用指向加载它的ClassLoader。\",\"数组类不是通过ClassLoader创建的，是由JVM自动产生的\",\"类加载器的作用就是加载Java类的字节码（.class文件）到JVM中，字节码可以使源程序（.java文件）经过编译而来，也可以是通过工具动态生成或者是从网络上下载而来。\"]},\"710\":{\"h\":\"类加载器的加载规则\",\"t\":[\"JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。\",\"对于已经加载的类会被放在 ClassLoader 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。\"]},\"711\":{\"h\":\"类加载器总结\",\"t\":[\"JVM中内置了三个ClassLoader：\",\"BootstrapClassLoader(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ %JAVA_HOME%/lib目录下的 rt.jar、resources.jar、charsets.jar等 jar 包和类）以及被 -Xbootclasspath参数指定的路径下的所有类。\",\"ExtensionClassLoader(扩展类加载器)：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类以及被 java.ext.dirs 系统变量所指定的路径下的所有类。\",\"AppClassLoader(应用程序类加载器)：面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。\",\"除了 BootstrapClassLoader 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 ClassLoader抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。\",\"每个 ClassLoader 可以通过getParent()获取其父 ClassLoader，如果获取到 ClassLoader 为null的话，那么该类是通过 BootstrapClassLoader 加载的。\",\"ClassLoader 为null就是 BootstrapClassLoader 加载的呢？ 这是因为BootstrapClassLoader 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。\"]},\"712\":{\"h\":\"自定义类加载器\",\"t\":[\"除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader抽象类。\",\"ClassLoader 类有两个关键的方法：\",\"protected Class loadClass(String name, boolean resolve)：加载指定二进制名称的类，实现了双亲委派机制 。name 为类的二进制名称，resove 如果为 true，在加载时调用 resolveClass(Class<?> c) 方法解析该类。\",\"protected Class findClass(String name)：根据类的二进制名称来查找类，默认实现是空方法。\",\"如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。\"]},\"713\":{\"h\":\"双亲委派\",\"t\":[\"ClassLoader 类使用委托模型来搜索类和资源。每个 ClassLoader 实例都有一个相关的父类加载器。需要查找类或资源时，ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。 虚拟机中被称为 \\\"bootstrap class loader\\\"的内置类加载器本身没有父类加载器，但是可以作为 ClassLoader 实例的父类加载器。\",\"ClassLoader 类使用委托模型来搜索类和资源。\",\"双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。\",\"ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。\",\"下图展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型(Parents Delegation Model)”。\",\"info::: warning\",\"双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。\",\":::\",\"另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。\",\"public abstract class ClassLoader { ... // 组合 private final ClassLoader parent; protected ClassLoader(ClassLoader parent) { this(checkCreateClassLoader(), parent); } ... } \"]},\"714\":{\"h\":\"双亲委派模型的执行流程\",\"t\":[\"protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { //首先，检查该类是否已经加载过 Class c = findLoadedClass(name); if (c == null) { //如果 c 为 null，则说明该类没有被加载过 long t0 = System.nanoTime(); try { if (parent != null) { //当父类的加载器不为空，则通过父类的loadClass来加载该类 //重写loadClass方法 就能破坏双亲委派 c = parent.loadClass(name, false); } else { //当父类的加载器为空，则调用启动类加载器来加载该类 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //非空父类的类加载器无法找到相应的类，则抛出异常 } if (c == null) { //当父类加载器无法加载时，则调用findClass方法来加载该类 //用户可通过覆写该方法，来自定义类加载器 long t1 = System.nanoTime(); c = findClass(name); //用于统计类加载器相关的信息 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { //对类进行link操作 resolveClass(c); } return c; } } \",\"每当一个类加载器接收到加载请求的时候，会先将请求转发给父类加载器，在父类加载器没有找到所请求的类情况下，该类才会尝试去加载。\",\"执行流程：\",\"在类加载的时候，先判断这个类是否已经加载过了，加载过了会直接返回，否则才会尝试加载。\",\"类加载器在进行类加载的时候，它首先不会尝试去加载这个类，而是把请求委派给父类加载器去完成。最终的请求都会到顶层的启动类加载器BootstrapClassLoader中。\",\"只有父类加载器反馈不能完成这个加载请求的时候，子加载器才会尝试自己加载。\",\"☀️ JVM检查两个Java类是否相同的依据：检查类的全名是否相同，还要看类的加载器是否相同，只有两者都是一样的才认为是相同的Java类。即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，则这两个类不同。\"]},\"715\":{\"h\":\"双亲委派的好处\",\"t\":[\"双亲委派模式，保证了Java程序的稳定运行，可以避免类的重复加载，也保证了Java的核心API不会被修改。\",\"例如自己写一个java.lang.Object类，在程序运行的时候就会产生两个Object类，一个是JRE里面的，一个是自己写的，使用双亲委派通过启动类加载器BootStrapClassLoader发现这个类已经加载了，则会直接返回，不会加载自己写的Object。\"]},\"716\":{\"h\":\"打破双亲委派模型方法\",\"t\":[\"自定义加载器的话，需要继承 ClassLoader 。如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。\",\"类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成（调用父类的loadClass()方法来加载类）。\"]},\"717\":{\"h\":\"JVM重要参数\"},\"718\":{\"h\":\"堆内存相关\"},\"719\":{\"h\":\"指定堆内存 -Xms 和 -Xmx\",\"t\":[\"-Xms<heap size>[unit] -Xmx<heap size>[unit] \",\"为JVM堆内存分配最大5GB，最小2GB内存：\",\"-Xms2G -Xmx5G \"]},\"720\":{\"h\":\"指定新生代内存（Young Generation）\",\"t\":[\"一共有两种指定新生代内存大小的办法：\",\"1. 通过-XX:NewSize和-XX:MaxNewSize指定\",\"-XX:NewSize=256m -XX:MaxNewSize=1024m \",\"2.通过-Xmn<young size>[unit]指定\",\"为新生代分配256MB内存：\",\"-Xmn256m \",\"还可以通过 -XX:NewRatio=<int> 来设置老年代与新生代内存的比值：\",\"老年代与新生代比值为1:1，说明新生代占整个内存的1/2；\",\"-XX:NewRatio=1 \"]},\"721\":{\"h\":\"指定永久代/元空间大小\",\"t\":[\"从 Java 8 开始，如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。\",\"JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小：\",\"-XX:PermSize=N #方法区 (永久代) 初始大小 -XX:MaxPermSize=N #方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen \",\"JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。\",\"-XX:MetaspaceSize=N #设置 Metaspace 的FGC阈值 -XX:MaxMetaspaceSize=N #设置 Metaspace 的最大大小 \",\"Metaspace 由于使用不断扩容到-XX:MetaspaceSize参数指定的量，就会发生 Full GC，且之后每次 Metaspace 扩容都会发生 Full GC。\"]},\"722\":{\"h\":\"垃圾收集器相关\"},\"723\":{\"h\":\"垃圾回收器\",\"t\":[\"JVM 具有四种类型的 GC 实现：\",\"串行垃圾收集器\",\"并行垃圾收集器\",\"CMS 垃圾收集器\",\"G1 垃圾收集器\",\"可以使用以下参数声明这些实现：\",\"-XX:+UseSerialGC -XX:+UseParallelGC -XX:+UseParNewGC -XX:+UseG1GC \"]},\"724\":{\"h\":\"GC 日志记录\",\"t\":[\"生产环境上，或者其他要测试 GC 问题的环境上，一定会配置上打印 GC 日志的参数，便于分析 GC 相关的问题。\",\"# 必选 # 打印基本 GC 信息 -XX:+PrintGCDetails -XX:+PrintGCDateStamps # 打印对象分布 -XX:+PrintTenuringDistribution # 打印堆数据 -XX:+PrintHeapAtGC # 打印Reference处理信息 # 强引用/弱引用/软引用/虚引用/finalize 相关的方法 -XX:+PrintReferenceGC # 打印STW时间 -XX:+PrintGCApplicationStoppedTime # 可选 # 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 # GC日志输出的文件路径 -Xloggc:/path/to/gc-%t.log # 开启日志文件分割 -XX:+UseGCLogFileRotation # 最多分割几个文件，超过之后从头文件开始写 -XX:NumberOfGCLogFiles=14 # 每个文件上限大小，超过就触发分割 -XX:GCLogFileSize=50M \"]},\"725\":{\"h\":\"处理 OOM\",\"t\":[\"对于大型应用程序来说，面对内存不足错误是非常常见的，这反过来会导致应用程序崩溃。这是一个非常关键的场景，很难通过复制来解决这个问题。\",\"这就是为什么 JVM 提供了一些参数，这些参数将堆内存转储到一个物理文件中，以后可以用来查找泄漏:\",\"-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./java_pid<pid>.hprof -XX:OnOutOfMemoryError=\\\"< cmd args >;< cmd args >\\\" -XX:+UseGCOverheadLimit \",\"HeapDumpOnOutOfMemoryError 指示 JVM 在遇到 OutOfMemoryError 错误时将 heap 转储到物理文件中。\",\"HeapDumpPath 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 <pid> 标记，则当前进程的进程 id 将附加到文件名中，并使用.hprof格式\",\"OnOutOfMemoryError 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 cmd args 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: -XX:OnOutOfMemoryError=\\\"shutdown -r\\\" 。\",\"UseGCOverheadLimit 是一种策略，它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例\"]},\"726\":{\"h\":\"其他\",\"t\":[\"-server : 启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM\",\"-XX:+UseStringDeduplication : Java 8u20 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 char [] 数组来优化堆内存。\",\"-XX:+UseLWPSynchronization: 设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步。\",\"``-XX:LargePageSizeInBytes `: 设置用于 Java 堆的较大页面大小; 它采用 GB/MB/KB 的参数; 页面大小越大，我们可以更好地利用虚拟内存硬件资源; 然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。\",\"-XX:MaxHeapFreeRatio : 设置 GC 后, 堆空闲的最大百分比，以避免收缩。\",\"-XX:SurvivorRatio : eden/survivor 空间的比例, 例如-XX:SurvivorRatio=6 设置每个 survivor 和 eden 之间的比例为 1:6。\",\"-XX:+UseLargePages : 如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。\",\"-XX:+UseStringCache : 启用 String 池中可用的常用分配字符串的缓存。\",\"-XX:+UseCompressedStrings : 对 String 对象使用 byte [] 类型，该类型可以用纯 ASCII 格式表示。\",\"-XX:+OptimizeStringConcat : 它尽可能优化字符串串联操作。\"]},\"727\":{\"h\":\"GC调优\"},\"728\":{\"h\":\"确定目标\",\"t\":[\"需要低延时使用：\",\"CMS\",\"G1\",\"ZGC\",\"需要吞吐量使用：\",\"ParallelGC\"]},\"729\":{\"h\":\"最快的GC是不发生GC\",\"t\":[\"查看FullGC前后的内存占用，考虑以下几个问题：\",\"数据是不是太多\",\"resultSet = statement.executeQuery(\\\"select *from 大表 limit n\\\")；\",\"查询应该避免使用*查询过多的数据。\",\"数据表示是否太臃肿\",\"数据库查询需要什么字段就返回对应字段，不应该查询所有返回再筛选。\",\"Java对象最小是16字节，如果使用包装类（例如Integer对象头就已经占用16字节），则占用的内存比基本数据类型大很多，所以能使用基本数据类型的情况下不要使用包装类型。\",\"是否存在内存泄露\",\"例如使用一个static Map map不断的放入对象，就会导致内存泄漏。ThreadLocal中就存在内存泄漏。\",\"不建议使用Java中的数据结构作为缓存实现。\"]},\"730\":{\"h\":\"新生代GC调优\",\"t\":[\"新生代的特点：\",\"所有的new操作的内存分配非常廉价；\",\"TLAB 线程本地分配缓存，new对象手下会在TLAB中分配，由于是线程私有的，所以同时也解决了并发问题；\",\"死亡对象的回收代价是零;标记复制算法\",\"大部分对象用过即死；\",\"Minor GC的时间远低于Full GC。\",\"总空间不变的情况下，新生代越大，老年代越小，引发的Full GC的概率就更大，推荐新生代大小占整个堆的百分之25到百分之50。新生代的空间越大也会导致每次MinorGC的时间变长。\"]},\"731\":{\"h\":\"幸存区\",\"t\":[\"幸存区大到能保留【当前活跃对象+需要晋升的对象】。\",\"调节晋升阈值，让长时间存活的对象尽快晋升\",\"-XX:MaxTenuringThreshold=threshold -XX:PrintTenuringDistribution \"]},\"732\":{\"h\":\"老年代调优\",\"t\":[\"以CMS为例：\",\"CMS的老年代内存越大越好；\",\"观察发生Full GC时老年代内存占用，将老年代内存预设调大1/4~1/3\",\"-XX:CMSInitiatingOccupancyFraction=percent \"]},\"733\":{\"h\":\"案例\"},\"734\":{\"h\":\"案例1\",\"t\":[\"FullGC和MinorGC频繁。\",\"尝试增大新生代，MinorGC次数就会减少，增加晋升阈值，让新生代的对象晋升时间更长，进一步让老年代FullGC不再频繁。\"]},\"735\":{\"h\":\"案例2\",\"t\":[\"请求高峰期发生FullGC，单次暂停时间特别长（CMS）。\",\"业务需求低延时所以选择了CMS。\",\"查看CMS四个阶段中哪个阶段花的时间太长。 \",\"重新标记阶段会花费很长的时间，重新标记会扫描所有新生代对象，而在请求高峰期会产生很多新生代对象。\",\"可以在重新标记前进行一次垃圾回收，存活对象少了，重新标记花的时间就少了。\",\"-XX:+CMSScavengeBeforeRemark \",\"参数表示在重新标记之前先对新生代进行垃圾清理。\"]},\"736\":{\"h\":\"案例3\",\"t\":[\"老年代充裕的情况下，发生FullGC（1.7）。\",\"1.7采用永久代，之后变成元空间使用操作系统的空间。\",\"则这种情况属于永久代内存不足导致FullGC。\"]},\"737\":{\"h\":\"JVM\"}},\"dirtCount\":0,\"index\":[[\"案例3\",{\"0\":{\"736\":1}}],[\"案例2\",{\"0\":{\"735\":1}}],[\"案例1\",{\"0\":{\"734\":1}}],[\"案例\",{\"0\":{\"733\":1}}],[\"案例中仍然是值传递\",{\"1\":{\"503\":1}}],[\"观察发生full\",{\"1\":{\"732\":1}}],[\"观察者模式\",{\"1\":{\"437\":1}}],[\"幸存区大到能保留\",{\"1\":{\"731\":1}}],[\"幸存区\",{\"0\":{\"731\":1}}],[\"格式表示\",{\"1\":{\"726\":1}}],[\"格式的问题\",{\"1\":{\"416\":1}}],[\"池中可用的常用分配字符串的缓存\",{\"1\":{\"726\":1}}],[\"池化技术是为了减少每次获取资源的消耗\",{\"1\":{\"603\":1}}],[\"页面大小越大\",{\"1\":{\"726\":1}}],[\"页面单位时间的访问数\",{\"1\":{\"309\":1,\"385\":1}}],[\"`\",{\"1\":{\"726\":1}}],[\"``\",{\"1\":{\"726\":1}}],[\"便于分析\",{\"1\":{\"724\":1}}],[\"便处理在任务队列中的任务\",{\"1\":{\"604\":1}}],[\"问题的环境上\",{\"1\":{\"724\":1}}],[\"☀️\",{\"1\":{\"714\":1}}],[\"☀️详见redis集群\",{\"1\":{\"371\":1}}],[\"☀️详见rabbitmq\",{\"1\":{\"129\":1}}],[\"☀️详见\",{\"1\":{\"306\":1,\"307\":1,\"318\":1}}],[\"☀️详见mysql锁\",{\"1\":{\"292\":1}}],[\"☀️详见分布式事务\",{\"1\":{\"72\":1}}],[\"官方推荐的一种方式\",{\"1\":{\"713\":1}}],[\"卸载类\",{\"1\":{\"707\":1}}],[\"符号可以使任何字面量\",{\"1\":{\"705\":1}}],[\"符号引用与虚拟机实现的内存布局无关\",{\"1\":{\"705\":1}}],[\"符号引用以一组符号来描述所引用的对象\",{\"1\":{\"705\":1}}],[\"符号引用验证\",{\"1\":{\"703\":1}}],[\"符合逻辑的\",{\"1\":{\"703\":1}}],[\"符合重试场景\",{\"1\":{\"360\":1}}],[\"符合a>=1条件的二级索引记录的范围里\",{\"1\":{\"271\":1}}],[\"符合3nf要求的数据库设计\",{\"1\":{\"220\":1}}],[\"准备\",{\"0\":{\"704\":1},\"1\":{\"700\":1}}],[\"准备阶段是正式为类变量分配内存并设置类变量初始值的阶段\",{\"1\":{\"704\":1}}],[\"准备阶段\",{\"1\":{\"122\":1}}],[\"入自己定义的属性信息\",{\"1\":{\"698\":1}}],[\"描述符索引\",{\"1\":{\"697\":1}}],[\"名称索引\",{\"1\":{\"697\":1}}],[\"声明为\",{\"1\":{\"693\":1}}],[\"项常量空出来是有特殊考虑的\",{\"1\":{\"693\":1}}],[\"项目课程中使用springsession进行登录数据存储\",{\"1\":{\"146\":1}}],[\"项目编译完成之后会产生一些不会发生变化的静态文件\",{\"1\":{\"141\":1}}],[\"项目整体较为复杂\",{\"1\":{\"136\":1}}],[\"项目中库存的释放统一由一个队列完成\",{\"1\":{\"155\":1}}],[\"项目中用到了哪些springsecurity过滤器\",{\"0\":{\"148\":1}}],[\"项目中使用springcache作为缓存框架\",{\"1\":{\"151\":1}}],[\"项目中使用到的技术栈为springcloud\",{\"1\":{\"137\":1}}],[\"项目中使用的消息队列是\",{\"1\":{\"77\":1}}],[\"项目中可能会涉及到的疑问点参考诚哥的博客文章秋招笔记整理\",{\"1\":{\"136\":1}}],[\"项目中订单取消之后的解锁库存操作可以通过消息队列实现\",{\"1\":{\"69\":1}}],[\"紧接着的两个字节代表访问标志\",{\"1\":{\"694\":1}}],[\"紧接着主次版本号之后的是常量池\",{\"1\":{\"693\":1}}],[\"紧急上线专门用于记录消息的队列\",{\"1\":{\"103\":1}}],[\"魔数\",{\"0\":{\"691\":1}}],[\"难免用户线程会修改对象图的引用关系\",{\"1\":{\"687\":1}}],[\"谁又指向我的\",{\"1\":{\"687\":1}}],[\"置信度等指标来决定到底要收集哪些region\",{\"1\":{\"685\":1}}],[\"浮动垃圾\",{\"1\":{\"684\":1}}],[\"浮点数和字符串字面量\",{\"1\":{\"646\":1}}],[\"浮点数运算的时候会有精度丢失的风险\",{\"0\":{\"473\":1}}],[\"浮点数\",{\"1\":{\"309\":1,\"383\":1}}],[\"划分内存空间以及有优先级的区域回收方式\",{\"1\":{\"684\":1}}],[\"筛选回收\",{\"1\":{\"684\":1}}],[\"筛选的条件是此对象是否有必要执行finalize方法\",{\"1\":{\"669\":1}}],[\"借用minor\",{\"1\":{\"684\":1}}],[\"毫秒\",{\"1\":{\"684\":1}}],[\"毫秒的时间片段内\",{\"1\":{\"684\":1}}],[\"毫秒为单位\",{\"1\":{\"375\":1}}],[\"停顿时间\",{\"1\":{\"684\":1}}],[\"停顿时间要求的同时\",{\"1\":{\"684\":1}}],[\"停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认\",{\"1\":{\"203\":1}}],[\"停止等待协议\",{\"0\":{\"203\":1}}],[\"停止正常的服务\",{\"1\":{\"165\":1}}],[\"停止\",{\"1\":{\"109\":1}}],[\"暂停所有的其他线程\",{\"1\":{\"683\":1}}],[\"暂时获取不到锁的线程将被加入到该队列中\",{\"1\":{\"622\":1}}],[\"控制参数\",{\"1\":{\"679\":1}}],[\"控制器\",{\"1\":{\"456\":1}}],[\"历史最悠久的垃圾收集器了\",{\"1\":{\"678\":1}}],[\"串行垃圾收集器\",{\"1\":{\"723\":1}}],[\"串行\",{\"1\":{\"678\":1}}],[\"清除\",{\"1\":{\"674\":2,\"676\":1,\"683\":2,\"684\":1}}],[\"清除算法的效率和内存碎片问题\",{\"1\":{\"675\":1}}],[\"清除算法\",{\"0\":{\"674\":1}}],[\"清空数据库和上面\",{\"1\":{\"366\":1}}],[\"清空数据库\",{\"0\":{\"366\":1}}],[\"清空数据\",{\"1\":{\"221\":1}}],[\"垃圾收集器\",{\"1\":{\"723\":2}}],[\"垃圾收集器相关\",{\"0\":{\"722\":1}}],[\"垃圾收集算法\",{\"0\":{\"673\":1}}],[\"垃圾回收器\",{\"0\":{\"677\":1,\"723\":1}}],[\"垃圾回收器一旦发现\",{\"1\":{\"670\":1}}],[\"垃圾回收器绝对不会回收的对象\",{\"1\":{\"670\":1}}],[\"废弃常量\",{\"1\":{\"672\":1}}],[\"判定一个常量是否是\",{\"1\":{\"672\":1}}],[\"判断\",{\"1\":{\"625\":1}}],[\"判断指定元素是否在指定集合中\",{\"1\":{\"393\":1}}],[\"判断指定\",{\"1\":{\"384\":1}}],[\"判断是否为持锁线程\",{\"1\":{\"376\":1}}],[\"判断是否查到用户\",{\"1\":{\"146\":1}}],[\"判断一个元素是否存在于布隆过滤器中\",{\"1\":{\"353\":1}}],[\"判断数据可见性\",{\"1\":{\"285\":1}}],[\"虚引用必须和引用队列\",{\"1\":{\"670\":1}}],[\"虚引用与软引用和弱引用的一个区别在于\",{\"1\":{\"670\":1}}],[\"虚引用主要用来跟踪对象被垃圾回收的活动\",{\"1\":{\"670\":1}}],[\"虚引用不会决定对象的声明周期\",{\"1\":{\"670\":1}}],[\"虚引用\",{\"1\":{\"670\":1,\"724\":1}}],[\"虚拟的双向队列即不存在队列实例\",{\"1\":{\"622\":1}}],[\"虚拟机会耗尽所有可用的系统内存\",{\"1\":{\"721\":1}}],[\"虚拟机会先初始化这个类\",{\"1\":{\"706\":1}}],[\"虚拟机会在字符串常量池中查找有没有相同值的对象\",{\"1\":{\"490\":1}}],[\"虚拟机启动时\",{\"1\":{\"706\":1}}],[\"虚拟机运行时会忽略掉它不认识的属性\",{\"1\":{\"698\":1}}],[\"虚拟机第一款真正意义上的并发收集器\",{\"1\":{\"683\":1}}],[\"虚拟机可以对满足上述\",{\"1\":{\"672\":1}}],[\"虚拟机对方法区的实现为永久代\",{\"1\":{\"671\":1}}],[\"虚拟机把这两种情况视为没有必要执行\",{\"1\":{\"669\":1}}],[\"虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间\",{\"1\":{\"664\":1}}],[\"虚拟机给每个对象一个对象年龄\",{\"1\":{\"662\":1}}],[\"虚拟机将发起一次\",{\"1\":{\"660\":1}}],[\"虚拟机通过这个指针来确定这个对象是哪个类的实例\",{\"1\":{\"654\":1}}],[\"虚拟机中被称为\",{\"1\":{\"713\":1}}],[\"虚拟机中\",{\"1\":{\"654\":1}}],[\"虚拟机中字符串常量池的实现是\",{\"1\":{\"647\":1}}],[\"虚拟机要对对象进行必要的设置\",{\"1\":{\"652\":1}}],[\"虚拟机需要将分配到的内存空间都初始化为零值\",{\"1\":{\"651\":1}}],[\"虚拟机采用cas和失败重试的方式保证更新操作的原子性\",{\"1\":{\"650\":1}}],[\"虚拟机维护一个列表\",{\"1\":{\"650\":1}}],[\"虚拟机遇到new指令时\",{\"1\":{\"649\":1}}],[\"虚拟机所管理的内存中最大的一块\",{\"1\":{\"644\":1}}],[\"虚拟机即时编译的时候\",{\"1\":{\"616\":1}}],[\"虚拟机栈中的对象\",{\"1\":{\"668\":1}}],[\"虚拟机栈为虚拟机执行\",{\"1\":{\"642\":1}}],[\"虚拟机栈也是线程私有的\",{\"1\":{\"641\":1}}],[\"虚拟机栈用于存放栈帧\",{\"1\":{\"559\":1}}],[\"虚拟机栈\",{\"0\":{\"641\":1},\"1\":{\"556\":1}}],[\"虚拟机栈和本地方法栈为什么是私有的\",{\"0\":{\"559\":1}}],[\"虚拟机栈和本地方法栈\",{\"1\":{\"5\":1}}],[\"虚拟主机\",{\"1\":{\"97\":1}}],[\"弱引用\",{\"1\":{\"670\":1,\"724\":1}}],[\"强引用\",{\"1\":{\"670\":1,\"724\":1}}],[\"至少要经过两次标记过程\",{\"1\":{\"669\":1}}],[\"阶段之前\",{\"1\":{\"724\":1}}],[\"阶段\",{\"1\":{\"669\":1,\"674\":1}}],[\"老年代充裕的情况下\",{\"1\":{\"736\":1}}],[\"老年代调优\",{\"0\":{\"732\":1}}],[\"老年代越小\",{\"1\":{\"730\":1}}],[\"老年代与新生代比值为1\",{\"1\":{\"720\":1}}],[\"老年代采用标记\",{\"1\":{\"678\":1,\"679\":1,\"680\":1}}],[\"老年代如果没有足够的内存则无法担保分配\",{\"1\":{\"664\":1}}],[\"老年代收集\",{\"1\":{\"663\":1}}],[\"收集算法\",{\"1\":{\"679\":1}}],[\"收集算法出现了\",{\"1\":{\"675\":1}}],[\"收集器在有限时间内可以尽可能高的收集效率\",{\"1\":{\"684\":1}}],[\"收集器在后台维护了一个优先列表\",{\"1\":{\"684\":1}}],[\"收集器仍然可以通过并发的方式让\",{\"1\":{\"684\":1}}],[\"收集器根据不同的角色采用不同的策略处理这些region\",{\"1\":{\"684\":1}}],[\"收集器是一种\",{\"1\":{\"683\":1}}],[\"收集器是一种以获取最短回收停顿时间为目标的收集器\",{\"1\":{\"683\":1}}],[\"收集器是\",{\"1\":{\"683\":1}}],[\"收集器是最基本\",{\"1\":{\"678\":1}}],[\"收集器和\",{\"1\":{\"682\":1}}],[\"收集器搭配使用\",{\"1\":{\"681\":1}}],[\"收集器的运作大致分为以下几个步骤\",{\"1\":{\"684\":1}}],[\"收集器的后备方案\",{\"1\":{\"681\":1}}],[\"收集器的老年代版本\",{\"1\":{\"681\":1,\"682\":1}}],[\"收集器的多线程版本\",{\"1\":{\"679\":1}}],[\"收集器配合工作\",{\"1\":{\"679\":1}}],[\"收集器外\",{\"1\":{\"679\":1}}],[\"收集器完全一样\",{\"1\":{\"679\":1}}],[\"收集器其实就是\",{\"1\":{\"679\":1}}],[\"收集器\",{\"0\":{\"678\":1,\"679\":1,\"680\":1,\"682\":1,\"684\":1},\"1\":{\"682\":1}}],[\"收集整个\",{\"1\":{\"663\":1}}],[\"收货人\",{\"1\":{\"155\":1}}],[\"混合收集\",{\"1\":{\"663\":1}}],[\"混合持久化\",{\"1\":{\"416\":1}}],[\"遍历对象图\",{\"1\":{\"684\":1}}],[\"遍历所有对象时\",{\"1\":{\"662\":1}}],[\"遍历等操作\",{\"1\":{\"532\":1}}],[\"额外的\",{\"1\":{\"662\":1}}],[\"岁\",{\"1\":{\"662\":2}}],[\"年龄就增加\",{\"1\":{\"662\":1}}],[\"长度和内容不同\",{\"1\":{\"698\":1}}],[\"长度加限制\",{\"1\":{\"175\":1}}],[\"长期存活的对象将进入老年代\",{\"0\":{\"662\":1}}],[\"句柄\",{\"0\":{\"657\":1}}],[\"块区域\",{\"1\":{\"654\":1}}],[\"没用过的放在另外一边\",{\"1\":{\"650\":1}}],[\"没有任何引用链相连的话\",{\"1\":{\"667\":1}}],[\"没有容量\",{\"1\":{\"607\":1}}],[\"没有被外部强引用的情况下\",{\"1\":{\"600\":1}}],[\"没有被spring管理\",{\"1\":{\"448\":1}}],[\"没有逃逸出本方法\",{\"1\":{\"476\":1}}],[\"没有出现异常则提交conn\",{\"1\":{\"446\":1}}],[\"没有办法实时或者秒级持久化数据\",{\"1\":{\"416\":1}}],[\"没有经过缓存层\",{\"1\":{\"352\":1}}],[\"没有原生的集群模式\",{\"1\":{\"299\":1}}],[\"没有选择红黑树的主要原因\",{\"1\":{\"261\":1}}],[\"没有用到表内索引进行排序\",{\"1\":{\"243\":1}}],[\"没有命中缓存的话\",{\"1\":{\"226\":1}}],[\"没有收到\",{\"1\":{\"197\":1}}],[\"没有\",{\"1\":{\"181\":1}}],[\"没有区别\",{\"1\":{\"175\":1}}],[\"没有支付则释放库存和取消订单\",{\"1\":{\"96\":1}}],[\"没有分配的内存多出的碎片\",{\"1\":{\"12\":1}}],[\"空间的比例\",{\"1\":{\"726\":1}}],[\"空间中使用适当的命令\",{\"1\":{\"725\":1}}],[\"空间整合\",{\"1\":{\"684\":1}}],[\"空间问题\",{\"1\":{\"674\":1}}],[\"空间分配担保\",{\"0\":{\"664\":1}}],[\"空间\",{\"1\":{\"662\":1}}],[\"空闲列表\",{\"1\":{\"650\":2}}],[\"空位都以0补齐\",{\"1\":{\"546\":1}}],[\"专门用来存储大对象\",{\"1\":{\"684\":1}}],[\"专门开辟的一块区域\",{\"1\":{\"647\":1}}],[\"专为远程登录会话和其他网络服务提供安全性的协议\",{\"1\":{\"191\":1}}],[\"错误之前在\",{\"1\":{\"725\":1}}],[\"错误时将\",{\"1\":{\"725\":1}}],[\"错误\",{\"1\":{\"646\":1}}],[\"既然运行时常量池是方法区的一部分\",{\"1\":{\"646\":1}}],[\"元空间使用的是本地内存\",{\"1\":{\"721\":1}}],[\"元空间使用本地内存\",{\"1\":{\"645\":1}}],[\"元空间大小\",{\"0\":{\"721\":1}}],[\"元数据验证\",{\"1\":{\"703\":1}}],[\"元素的插入满足队列特性\",{\"1\":{\"536\":1}}],[\"元素是有序的\",{\"1\":{\"529\":1,\"536\":1}}],[\"局部变量表\",{\"1\":{\"641\":2}}],[\"局域网\",{\"1\":{\"174\":1}}],[\"栈由一个个栈帧组成\",{\"1\":{\"641\":1}}],[\"栈中分配的局部变量\",{\"1\":{\"476\":2}}],[\"现在只需要7次\",{\"1\":{\"635\":1}}],[\"损耗大量内存\",{\"1\":{\"633\":1}}],[\"尝试增大新生代\",{\"1\":{\"734\":1}}],[\"尝试从一个空队列中取一个元素也会同样阻塞\",{\"1\":{\"632\":1}}],[\"尝试将元素放入队列将导致操作阻塞\",{\"1\":{\"632\":1}}],[\"尝试注入aservice属性\",{\"1\":{\"450\":1}}],[\"尝试注入bservice发现没有\",{\"1\":{\"450\":1}}],[\"跳表内的所有链表的元素都是排序的\",{\"1\":{\"635\":1}}],[\"跳表的本质是同时维护了多个链表\",{\"1\":{\"635\":1}}],[\"跳表的实现\",{\"1\":{\"627\":1}}],[\"跳跃表\",{\"1\":{\"382\":1}}],[\"了\",{\"1\":{\"626\":1}}],[\"倒计时器\",{\"0\":{\"625\":1}}],[\"挂起线程\",{\"1\":{\"624\":1}}],[\"挂起当前线程\",{\"1\":{\"624\":1}}],[\"抢占式的\",{\"1\":{\"624\":1}}],[\"遵循\",{\"1\":{\"624\":1}}],[\"遵从请求的幂等性\",{\"1\":{\"158\":1}}],[\"公平模式\",{\"1\":{\"624\":1}}],[\"公平锁和非公平锁有什么区别\",{\"0\":{\"593\":1}}],[\"公平锁和非公平锁等高级功能\",{\"1\":{\"592\":1}}],[\"公平锁\",{\"1\":{\"377\":1,\"593\":1}}],[\"翻译过来的意思就是抽象队列同步器\",{\"1\":{\"620\":1}}],[\"翻译成中文是同步的意思\",{\"1\":{\"587\":1}}],[\"粗化\",{\"1\":{\"617\":1}}],[\"偏袒的\",{\"1\":{\"619\":1}}],[\"偏\",{\"1\":{\"619\":3}}],[\"偏向锁的\",{\"1\":{\"619\":1}}],[\"偏向锁也是jdk\",{\"1\":{\"619\":1}}],[\"偏向锁\",{\"0\":{\"619\":1}}],[\"偏向锁状态\",{\"1\":{\"614\":1}}],[\"偏移量\",{\"1\":{\"420\":1}}],[\"组合\",{\"1\":{\"713\":1}}],[\"组成一个完整的链式调用\",{\"1\":{\"613\":1}}],[\"组根服务器\",{\"1\":{\"185\":1}}],[\"你可以选择这个策略\",{\"1\":{\"606\":1}}],[\"你可以将\",{\"1\":{\"8\":1,\"624\":1}}],[\"抛出\",{\"1\":{\"606\":1}}],[\"抛出异常\",{\"1\":{\"537\":2}}],[\"饱和策略会调用rejectedexecutionhandler\",{\"1\":{\"608\":1}}],[\"饱和策略\",{\"1\":{\"605\":1}}],[\"拒绝策略\",{\"1\":{\"605\":1}}],[\"待线程空闲\",{\"1\":{\"604\":1}}],[\"待有线程空闲时\",{\"1\":{\"604\":1}}],[\"待数据同步完成再释放资源\",{\"1\":{\"113\":1}}],[\"永久代\",{\"1\":{\"721\":2}}],[\"永久代并不会出现这种情况\",{\"1\":{\"721\":1}}],[\"永久性\",{\"1\":{\"213\":1}}],[\"永远无法被\",{\"1\":{\"600\":1}}],[\"盒子中可以存储每个线程的私有数据\",{\"1\":{\"598\":1}}],[\"改为处理其他事情\",{\"1\":{\"594\":1}}],[\"改用\",{\"1\":{\"190\":1,\"550\":1}}],[\"做了优化\",{\"1\":{\"587\":1}}],[\"做了更多优化\",{\"1\":{\"389\":1}}],[\"拟写入的新值\",{\"1\":{\"583\":1}}],[\"涉及到三个操作数\",{\"1\":{\"583\":1}}],[\"涉及的索引都不会被使用到\",{\"1\":{\"278\":1}}],[\"影响程序的整体性能\",{\"1\":{\"606\":1}}],[\"影响代码的正常运行\",{\"1\":{\"582\":1}}],[\"影响命中率\",{\"1\":{\"302\":1}}],[\"悲观锁还可能会存在死锁问题\",{\"1\":{\"582\":1}}],[\"悲观锁总是假设最坏的情况\",{\"1\":{\"582\":1}}],[\"激烈的锁竞争会造成线程阻塞\",{\"1\":{\"582\":1}}],[\"乐观锁总是假设最好的情况\",{\"1\":{\"581\":1}}],[\"乐观锁和悲观锁\",{\"0\":{\"580\":1}}],[\"轻量级进程\",{\"1\":{\"726\":1}}],[\"轻量级锁是jdk\",{\"1\":{\"618\":1}}],[\"轻量级锁\",{\"0\":{\"618\":1}}],[\"轻量级锁状态\",{\"1\":{\"614\":1}}],[\"轻量级\",{\"1\":{\"579\":1,\"618\":1}}],[\"书写在前的操作happens\",{\"1\":{\"576\":1}}],[\"规定了java源代码到cpu可执行指令这个转化过程要遵循哪些并发相关的原则和规范\",{\"1\":{\"574\":1}}],[\"银行家算法\",{\"1\":{\"565\":1}}],[\"破坏环路等待\",{\"1\":{\"564\":1}}],[\"破坏请求并保持\",{\"1\":{\"564\":1}}],[\"破坏不剥夺条件\",{\"1\":{\"564\":1}}],[\"环路等待\",{\"1\":{\"563\":1}}],[\"终止状态\",{\"1\":{\"561\":1}}],[\"终将美好\",{\"1\":{\"0\":1}}],[\"五分钟记住jvm内存结构\",{\"1\":{\"557\":1}}],[\"角度说进程和线程之间的关系\",{\"0\":{\"557\":1}}],[\"调节晋升阈值\",{\"1\":{\"731\":1}}],[\"调度的最小单位从进程变成了线程\",{\"1\":{\"556\":1}}],[\"调整函数\",{\"1\":{\"539\":1}}],[\"调用父类的loadclass\",{\"1\":{\"716\":1}}],[\"调用semaphore\",{\"1\":{\"624\":2}}],[\"调用执行自己的线程运行任务\",{\"1\":{\"606\":1}}],[\"调用初始化方法\",{\"1\":{\"463\":1}}],[\"调用失败之后回调方法\",{\"1\":{\"165\":1}}],[\"调用channel\",{\"1\":{\"101\":1}}],[\"调用后\",{\"1\":{\"18\":1}}],[\"调用\",{\"1\":{\"18\":1,\"442\":1,\"456\":1,\"568\":1,\"624\":1}}],[\"堆空闲的最大百分比\",{\"1\":{\"726\":1}}],[\"堆空间的大小减小\",{\"1\":{\"726\":1}}],[\"堆内存相关\",{\"0\":{\"718\":1}}],[\"堆分为新生代和老年代\",{\"1\":{\"676\":1}}],[\"堆的较大页面大小\",{\"1\":{\"726\":1}}],[\"堆的gc效率很高\",{\"1\":{\"647\":1}}],[\"堆的内存结构在垃圾回收章节提及\",{\"1\":{\"644\":1}}],[\"堆中不存在该类的任何实例\",{\"1\":{\"672\":1}}],[\"堆中将会划分出一块内存来作为句柄池\",{\"1\":{\"657\":1}}],[\"堆中\",{\"1\":{\"647\":1,\"704\":1}}],[\"堆中创建的对象\",{\"1\":{\"499\":1}}],[\"堆是所有线程共享的一块内存区域\",{\"1\":{\"644\":1}}],[\"堆是进程内存中最大的一块区域\",{\"1\":{\"560\":1}}],[\"堆上的所有数据都不会逃逸出去从而被其他线程所访问到\",{\"1\":{\"616\":1}}],[\"堆\",{\"0\":{\"644\":1},\"1\":{\"607\":1,\"684\":1}}],[\"堆和方法区都是线程共享的资源\",{\"1\":{\"560\":1}}],[\"堆和方法区\",{\"0\":{\"560\":1},\"1\":{\"663\":1}}],[\"堆排序\",{\"1\":{\"539\":1}}],[\"堆排序的伪代码\",{\"1\":{\"539\":1}}],[\"早期版本中synchronized\",{\"1\":{\"587\":1}}],[\"早期被用来用于处理海量的日志\",{\"1\":{\"77\":1}}],[\"早在\",{\"1\":{\"538\":1}}],[\"底层基于单向链表实现的阻塞队列\",{\"1\":{\"633\":1}}],[\"底层依赖于一条\",{\"1\":{\"583\":1}}],[\"底层采用数组来实现\",{\"1\":{\"632\":1}}],[\"底层采用\",{\"1\":{\"550\":2}}],[\"底层数据结构\",{\"1\":{\"550\":1}}],[\"底层\",{\"1\":{\"543\":1}}],[\"底层用object\",{\"1\":{\"533\":2}}],[\"底层是数组+链表\",{\"1\":{\"530\":1}}],[\"底层使用hashmap保存数据\",{\"1\":{\"530\":1}}],[\"顺序存储\",{\"1\":{\"529\":1}}],[\"效率问题\",{\"1\":{\"674\":1}}],[\"效率低下\",{\"1\":{\"550\":1}}],[\"效率\",{\"1\":{\"543\":1}}],[\"效率高\",{\"1\":{\"524\":1}}],[\"效率较高\",{\"1\":{\"523\":1}}],[\"效率较低\",{\"1\":{\"522\":1}}],[\"才开始真正执行类中定义的\",{\"1\":{\"706\":1}}],[\"才被引入completablefuture\",{\"1\":{\"613\":1}}],[\"才被引入的\",{\"1\":{\"538\":1}}],[\"才能进行其他逻辑处理\",{\"1\":{\"595\":1}}],[\"才真正分配容量\",{\"1\":{\"532\":1}}],[\"才去创建singleton\",{\"1\":{\"522\":1}}],[\"才会使用cas+重试的分配方式\",{\"1\":{\"650\":1}}],[\"才会使用到\",{\"1\":{\"376\":1}}],[\"才会设置\",{\"1\":{\"374\":1}}],[\"枚举仍然算饿汉式\",{\"1\":{\"525\":1}}],[\"枚举\",{\"0\":{\"525\":1},\"1\":{\"519\":1}}],[\"拦截被代理类中的方法\",{\"1\":{\"515\":1}}],[\"意味着静态代码块和静态对象不会得到执行\",{\"1\":{\"509\":1}}],[\"意向排他锁\",{\"1\":{\"240\":1}}],[\"意向共享锁\",{\"1\":{\"240\":1}}],[\"意向锁之间是相互兼容的\",{\"1\":{\"240\":1}}],[\"意向锁是由数据引擎自己维护的\",{\"1\":{\"240\":1}}],[\"意向锁是表级锁\",{\"1\":{\"240\":1}}],[\"意向锁有什么作用\",{\"0\":{\"240\":1}}],[\"知道具体类的情况下\",{\"1\":{\"509\":1}}],[\"知道内核把数据拷贝到用户空间\",{\"1\":{\"21\":1}}],[\"序列化协议属于tcp\",{\"1\":{\"504\":1}}],[\"序列化\",{\"1\":{\"504\":1}}],[\"序列化后的对象\",{\"1\":{\"309\":2,\"383\":1,\"385\":1}}],[\"示意图\",{\"1\":{\"497\":1}}],[\"拼完之后调用tostring\",{\"1\":{\"496\":1}}],[\"拼接\",{\"1\":{\"150\":1}}],[\"少量数据使用string\",{\"1\":{\"494\":1}}],[\"少量的丢包就可能导致整个\",{\"1\":{\"190\":1}}],[\"深拷贝\",{\"0\":{\"488\":1},\"1\":{\"488\":1}}],[\"浅拷贝\",{\"0\":{\"488\":1},\"1\":{\"488\":1}}],[\"抽象了线程和内存之间的关系\",{\"1\":{\"574\":1}}],[\"抽象类中的成员变量默认default\",{\"1\":{\"487\":1}}],[\"抽奖系统\",{\"1\":{\"314\":1,\"394\":1}}],[\"移速等基础属性\",{\"1\":{\"486\":1}}],[\"移除了永久代用元空间\",{\"1\":{\"671\":1}}],[\"移除并获取指定列表的最后一个元素\",{\"1\":{\"387\":1}}],[\"移除并获取指定列表的第一个元素\",{\"1\":{\"387\":1}}],[\"移除\",{\"1\":{\"345\":1,\"362\":1}}],[\"移除最不经常使用的\",{\"1\":{\"328\":1}}],[\"移除最近最少使用的\",{\"1\":{\"328\":1}}],[\"继承自\",{\"1\":{\"530\":1,\"540\":1,\"631\":1}}],[\"继承则是强调复用\",{\"1\":{\"487\":1}}],[\"继承\",{\"1\":{\"486\":1,\"592\":1}}],[\"形同虚设\",{\"1\":{\"670\":1}}],[\"形参和实参\",{\"0\":{\"501\":1}}],[\"形参列表相同\",{\"1\":{\"480\":1}}],[\"形成这个扫描区间的条件是a>1\",{\"1\":{\"271\":1}}],[\"拆箱就是使用xxvalue方法\",{\"1\":{\"472\":1}}],[\"拆分成微服务之后\",{\"1\":{\"144\":1}}],[\"拆分为网关\",{\"0\":{\"143\":1},\"1\":{\"136\":1}}],[\"装箱就是使用包装类的valueof方法\",{\"1\":{\"472\":1}}],[\"程序代码\",{\"1\":{\"706\":1}}],[\"程序语义检查\",{\"1\":{\"703\":1}}],[\"程序安全都是第一位\",{\"1\":{\"703\":1}}],[\"程序无须重新编译便可在多种不同操作系统的计算机上运行\",{\"1\":{\"689\":1}}],[\"程序运行时比较高效\",{\"1\":{\"689\":1}}],[\"程序继续执行\",{\"1\":{\"684\":1}}],[\"程序如果发现某个虚引用已经被加入到引用队列\",{\"1\":{\"670\":1}}],[\"程序可以通过判断引用队列中是否已经加入了虚引用\",{\"1\":{\"670\":1}}],[\"程序能访问到这些字段的数据类型所对应的零值\",{\"1\":{\"651\":1}}],[\"程序能正确执行吗\",{\"0\":{\"485\":1}}],[\"程序顺序规则\",{\"1\":{\"576\":1}}],[\"程序计数器是唯一一个不会出现oom的内存区域\",{\"1\":{\"640\":1}}],[\"程序计数器用来记录当前线程执行的位置\",{\"1\":{\"558\":1}}],[\"程序计数器存放的是下一条将要执行指令的地址\",{\"1\":{\"558\":1}}],[\"程序计数器为什么是线程私有\",{\"0\":{\"558\":1}}],[\"程序计数器\",{\"0\":{\"640\":1},\"1\":{\"557\":1}}],[\"程序内存更加安全\",{\"1\":{\"468\":1}}],[\"程序状态字\",{\"1\":{\"8\":1}}],[\"编译从\",{\"1\":{\"512\":1}}],[\"编译器在不改变单线程程序语义的前提下\",{\"1\":{\"571\":1}}],[\"编译器优化重排\",{\"1\":{\"571\":1}}],[\"编译器会自动生成\",{\"1\":{\"505\":1}}],[\"编译器会在编译期间直接放入字符串常量池中\",{\"1\":{\"499\":1}}],[\"编译器对字符串拼接的优化\",{\"0\":{\"499\":1}}],[\"编译器不会复用stringbuilder\",{\"1\":{\"496\":1}}],[\"编译是否能通过看左边\",{\"1\":{\"486\":1}}],[\"编译成机器可以理解的代码\",{\"1\":{\"467\":1}}],[\"编码或者解码或者图片的路径\",{\"1\":{\"309\":1,\"383\":1}}],[\"启动类加载器\",{\"1\":{\"711\":1}}],[\"启动的时候\",{\"1\":{\"710\":1}}],[\"启动main函数就相当于启动了一个jvm进程\",{\"1\":{\"555\":1}}],[\"启动\",{\"1\":{\"463\":1}}],[\"启动器通过自动配置和依赖管理来简化应用的搭建和配置\",{\"1\":{\"463\":1}}],[\"启用\",{\"1\":{\"726\":2}}],[\"启用无磁盘复制\",{\"1\":{\"422\":1}}],[\"启用缓存后\",{\"1\":{\"58\":1}}],[\"启用缓冲之后\",{\"1\":{\"57\":1}}],[\"织入异常处理的逻辑\",{\"1\":{\"459\":1}}],[\"统一异常处理\",{\"0\":{\"459\":1}}],[\"统计指定页面的\",{\"1\":{\"317\":1}}],[\"统计页面\",{\"0\":{\"317\":1},\"1\":{\"317\":1}}],[\"统计\",{\"1\":{\"314\":1,\"316\":2,\"394\":1,\"403\":1}}],[\"统计活跃用户的话\",{\"1\":{\"316\":1}}],[\"统计活跃用户怎么做\",{\"0\":{\"316\":1}}],[\"统计活跃用户\",{\"1\":{\"306\":1}}],[\"去再次尝试获取锁\",{\"1\":{\"615\":1}}],[\"去匹配查找能处理的\",{\"1\":{\"456\":1}}],[\"去redis中找到用户数据\",{\"1\":{\"147\":1}}],[\"循环栅栏\",{\"0\":{\"626\":1}}],[\"循环依赖为什么用三级缓存\",{\"1\":{\"450\":1}}],[\"循环扫描算法\",{\"1\":{\"16\":1}}],[\"某一个bean到底会不会进行aop操作\",{\"1\":{\"450\":1}}],[\"填充其他属性\",{\"1\":{\"450\":1}}],[\"填充属性\",{\"1\":{\"450\":1}}],[\"填充率就会越小\",{\"1\":{\"430\":1}}],[\"填充率\",{\"1\":{\"430\":1}}],[\"父类还没有初始化\",{\"1\":{\"706\":1}}],[\"父类索引用于确定这个类的父类的全限定名\",{\"1\":{\"695\":1}}],[\"父类索引和接口索引集合按照顺序排在访问标志之后\",{\"1\":{\"695\":1}}],[\"父类索引和接口索引集合三项确定\",{\"1\":{\"695\":1}}],[\"父类\",{\"0\":{\"695\":1},\"1\":{\"449\":1,\"695\":1}}],[\"父进程需要及时调用\",{\"1\":{\"10\":1}}],[\"注解的类\",{\"1\":{\"463\":1}}],[\"注解\",{\"1\":{\"461\":1}}],[\"注解修饰的方法进行处理\",{\"1\":{\"459\":1}}],[\"注入bservice时发现没有\",{\"1\":{\"450\":1}}],[\"注入的是第二个名为\",{\"1\":{\"444\":1}}],[\"注意锁可以升级不可降级\",{\"1\":{\"614\":1}}],[\"注意使用volatile修饰singleton\",{\"1\":{\"523\":1}}],[\"注意\",{\"1\":{\"60\":1,\"172\":2,\"191\":2,\"240\":1,\"604\":1,\"644\":1}}],[\"构造器私有化\",{\"1\":{\"520\":1}}],[\"构造方法私有\",{\"1\":{\"579\":1}}],[\"构造方法不能被重写\",{\"1\":{\"485\":1}}],[\"构造方法无法被重写\",{\"1\":{\"480\":1}}],[\"构造方法推断\",{\"0\":{\"443\":1}}],[\"构造数据库查询条件的wrapper就是包装器模式\",{\"1\":{\"437\":1}}],[\"想加入一个特定的user对象到userservice\",{\"1\":{\"439\":1,\"442\":1}}],[\"推荐新生代大小占整个堆的百分之25到百分之50\",{\"1\":{\"730\":1}}],[\"推荐将加锁的范围尽可能的变小以获得更好的性能\",{\"1\":{\"617\":1}}],[\"推荐使用线程安全的cucurrenthashmap\",{\"1\":{\"549\":1}}],[\"推荐使用我们上面提到的\",{\"1\":{\"377\":1}}],[\"推断构造方法\",{\"1\":{\"438\":1,\"453\":1}}],[\"工厂设计模式\",{\"1\":{\"437\":1}}],[\"工具就使用了\",{\"1\":{\"174\":1}}],[\"饿汉式在类装载的时候就完成实例化\",{\"1\":{\"521\":1}}],[\"饿汉式\",{\"0\":{\"520\":1,\"521\":1},\"1\":{\"435\":1,\"519\":1}}],[\"静态内部类\",{\"0\":{\"524\":1},\"1\":{\"519\":1}}],[\"静态常量\",{\"0\":{\"520\":1},\"1\":{\"519\":1}}],[\"静态代理在编译时就将接口\",{\"1\":{\"517\":1}}],[\"静态代理在编译的时候就将接口\",{\"1\":{\"512\":1}}],[\"静态代理和动态代理的区别\",{\"0\":{\"517\":1}}],[\"静态代理中接口新增方法\",{\"1\":{\"517\":1}}],[\"静态代理中\",{\"1\":{\"512\":1}}],[\"静态代理\",{\"0\":{\"512\":1}}],[\"静态代码块\",{\"0\":{\"521\":1},\"1\":{\"435\":1,\"519\":1}}],[\"静态方法和\",{\"1\":{\"588\":1}}],[\"静态方法属于类\",{\"1\":{\"479\":1}}],[\"静态方法为什么不能调用非静态成员\",{\"0\":{\"479\":1}}],[\"静态变量等移动到堆中\",{\"1\":{\"704\":1}}],[\"静态变量通过类名\",{\"1\":{\"477\":1}}],[\"静态变量就是被static修饰的变量\",{\"1\":{\"477\":1}}],[\"静态变量\",{\"0\":{\"477\":1},\"1\":{\"560\":1}}],[\"静态web配置\",{\"0\":{\"48\":1}}],[\"懒汉式\",{\"0\":{\"522\":1},\"1\":{\"435\":1,\"519\":1}}],[\"忽略符号位\",{\"1\":{\"546\":1}}],[\"忽略其余master意见\",{\"1\":{\"431\":1}}],[\"忽略数据一致性\",{\"1\":{\"431\":1}}],[\"省略步骤2\",{\"1\":{\"431\":1}}],[\"省略了对offset一致性校验\",{\"1\":{\"431\":1}}],[\"切换到执行cluster\",{\"1\":{\"431\":1}}],[\"心跳包的消息体内的数据就越多\",{\"1\":{\"430\":1}}],[\"心跳机制\",{\"0\":{\"425\":1}}],[\"浪费网络资源\",{\"1\":{\"430\":1}}],[\"未免有些太大了\",{\"1\":{\"430\":1}}],[\"固定数据保存在同一个节点\",{\"1\":{\"430\":1}}],[\"固定分区分配\",{\"1\":{\"12\":1}}],[\"海量数据存储问题\",{\"1\":{\"428\":1}}],[\"故障转移\",{\"0\":{\"431\":1}}],[\"故障转移步骤如下\",{\"1\":{\"427\":1}}],[\"故障恢复之后此节点成为slave1的从节点\",{\"1\":{\"427\":1}}],[\"故不用执行删除缓存操作\",{\"1\":{\"302\":1}}],[\"越小则优先级越高\",{\"1\":{\"426\":1}}],[\"越小优先级越高\",{\"1\":{\"426\":1}}],[\"越大说明数据越新\",{\"1\":{\"426\":1}}],[\"充当redis客户端的服务发现来源\",{\"1\":{\"424\":1}}],[\"监控\",{\"1\":{\"424\":1}}],[\"监听的是删除事件\",{\"1\":{\"381\":1}}],[\"监听可以配置成ip或端口或ip+端口\",{\"1\":{\"48\":1}}],[\"作用是将指定的字符串对象保存到字符串常量池中\",{\"1\":{\"498\":1}}],[\"作用是确定在哈希表中的位置\",{\"1\":{\"491\":1}}],[\"作用是什么\",{\"0\":{\"436\":1}}],[\"作用\",{\"0\":{\"424\":1,\"491\":1}}],[\"作为方法区这些数据的入口\",{\"1\":{\"702\":1}}],[\"作为新的晋升年龄阈值\",{\"1\":{\"662\":1}}],[\"作为\",{\"1\":{\"316\":1}}],[\"作为字符串结束的标识\",{\"1\":{\"311\":1}}],[\"作为唯一标识符\",{\"1\":{\"209\":1}}],[\"逐个发送给slave\",{\"1\":{\"422\":1}}],[\"适用于频繁查找的场景\",{\"1\":{\"533\":1}}],[\"适配执行对应的handler\",{\"1\":{\"457\":1}}],[\"适配器模式\",{\"1\":{\"437\":1}}],[\"适当提高repl\",{\"1\":{\"422\":1}}],[\"适合内存不规整的情况\",{\"1\":{\"650\":1}}],[\"适合内存规整的情况\",{\"1\":{\"650\":1}}],[\"适合在对性能要求相对较高\",{\"1\":{\"630\":1}}],[\"适合做数据的备份\",{\"1\":{\"416\":1}}],[\"适合允许重复中奖的场景\",{\"1\":{\"315\":1,\"394\":1}}],[\"适合不允许重复中奖的场景\",{\"1\":{\"315\":1,\"394\":1}}],[\"增量更新就是将那些新加入引用的位置记录\",{\"1\":{\"687\":1}}],[\"增量同步用的命令来自repl\",{\"1\":{\"421\":1}}],[\"增量同步\",{\"0\":{\"421\":1},\"1\":{\"422\":1}}],[\"增强程序的可移植性\",{\"1\":{\"574\":1}}],[\"增强代码的可移植性\",{\"1\":{\"572\":1}}],[\"增加晋升阈值\",{\"1\":{\"734\":1}}],[\"增加系统的性能开销\",{\"1\":{\"582\":1}}],[\"增加了轮询\",{\"1\":{\"592\":1}}],[\"增加了一些高级功能\",{\"1\":{\"594\":1}}],[\"增加了一条双向链表\",{\"1\":{\"530\":1}}],[\"增加了一个权重参数\",{\"1\":{\"395\":1}}],[\"增加了安全隐患\",{\"1\":{\"508\":1}}],[\"增加cache更新重试机制\",{\"1\":{\"360\":1}}],[\"增加\",{\"1\":{\"311\":1}}],[\"增加消费端实例\",{\"1\":{\"103\":1}}],[\"增加消费者的处理能力\",{\"1\":{\"103\":1}}],[\"低停顿\",{\"1\":{\"683\":1}}],[\"低\",{\"1\":{\"416\":2}}],[\"低很多\",{\"1\":{\"188\":1}}],[\"宕机恢复速度\",{\"1\":{\"416\":1}}],[\"综上\",{\"1\":{\"416\":1,\"705\":1}}],[\"版本演进中有多个版本的\",{\"1\":{\"416\":1}}],[\"版本后增加以下两种\",{\"1\":{\"328\":1}}],[\"策略\",{\"1\":{\"416\":1}}],[\"取而代之是元空间\",{\"1\":{\"721\":1}}],[\"取而代之\",{\"1\":{\"671\":1}}],[\"取这个年龄和\",{\"1\":{\"662\":1}}],[\"取出\",{\"1\":{\"599\":1}}],[\"取得代之的是\",{\"1\":{\"589\":1}}],[\"取决于刷盘策略\",{\"1\":{\"416\":1}}],[\"取决\",{\"1\":{\"416\":1}}],[\"取消状态进行库存释放\",{\"1\":{\"155\":1}}],[\"取消订单可以通过信息发送给相应的订单解锁队列\",{\"1\":{\"96\":1}}],[\"恢复大数据集的时候\",{\"1\":{\"416\":1}}],[\"变量添加final修饰\",{\"1\":{\"704\":1}}],[\"变量作为计数器\",{\"1\":{\"626\":1}}],[\"变量由\",{\"1\":{\"622\":1}}],[\"变量是放在了当前线程的threadlocalmap中\",{\"1\":{\"599\":1}}],[\"变量\",{\"0\":{\"476\":1},\"1\":{\"599\":1}}],[\"变得太大时\",{\"1\":{\"416\":1}}],[\"变成三次挥手\",{\"0\":{\"196\":1}}],[\"日志的参数\",{\"1\":{\"724\":1}}],[\"日志记录\",{\"0\":{\"724\":1}}],[\"日志记录阻塞\",{\"1\":{\"364\":1}}],[\"日志\",{\"1\":{\"416\":1}}],[\"灾难恢复\",{\"1\":{\"416\":1}}],[\"校验机制十分简单有效\",{\"1\":{\"415\":1}}],[\"校验机制是\",{\"1\":{\"415\":1}}],[\"校验机制了解吗\",{\"0\":{\"415\":1}}],[\"校验和\",{\"1\":{\"199\":1,\"415\":1}}],[\"严重的情况下甚至会直接把\",{\"1\":{\"416\":1}}],[\"严重影响性能\",{\"1\":{\"412\":1}}],[\"严格说来\",{\"1\":{\"185\":1}}],[\"严格匹配\",{\"1\":{\"54\":1}}],[\"达到压缩目的\",{\"1\":{\"411\":1}}],[\"达到微秒级\",{\"1\":{\"79\":1}}],[\"追加文件\",{\"1\":{\"410\":1}}],[\"追求更快的启动速度的场景\",{\"1\":{\"416\":1}}],[\"追求一致性和可用性\",{\"1\":{\"119\":1}}],[\"追求分区容错性和一致性\",{\"1\":{\"118\":1}}],[\"追求分区容错性和可用性\",{\"1\":{\"117\":1}}],[\"压缩率就会越高\",{\"1\":{\"430\":1}}],[\"压缩率越高\",{\"1\":{\"430\":1}}],[\"压缩\",{\"1\":{\"408\":1}}],[\"压缩列表\",{\"1\":{\"382\":1}}],[\"千万级别以上\",{\"1\":{\"403\":1}}],[\"百万\",{\"1\":{\"403\":1}}],[\"算出对应的唯一计数\",{\"1\":{\"402\":1}}],[\"算法不同\",{\"1\":{\"684\":1}}],[\"算法会导致收集结束时会有大量空间碎片产生\",{\"1\":{\"683\":1}}],[\"算法实现的收集器\",{\"1\":{\"684\":1}}],[\"算法实现的\",{\"1\":{\"683\":1,\"684\":1}}],[\"算法实现起来比较简单\",{\"1\":{\"16\":1}}],[\"算法进行垃圾收集\",{\"1\":{\"676\":1}}],[\"算法进行了改进\",{\"1\":{\"16\":2}}],[\"算法分为\",{\"1\":{\"674\":1}}],[\"算法计算得出的数字\",{\"1\":{\"415\":1}}],[\"算法转换成了一个整数\",{\"1\":{\"405\":1}}],[\"算法的思想是让客户端向\",{\"1\":{\"378\":1}}],[\"算法的变体\",{\"1\":{\"16\":1}}],[\"算法来解决\",{\"1\":{\"378\":1}}],[\"算法对\",{\"1\":{\"16\":2}}],[\"算法中磁头到了磁盘的边界才改变移动方向\",{\"1\":{\"16\":1}}],[\"算法能够保证所有的请求得到服务\",{\"1\":{\"16\":1}}],[\"算法能够最小化磁头的寻道时间\",{\"1\":{\"16\":1}}],[\"算法\",{\"0\":{\"583\":1},\"1\":{\"16\":2,\"682\":1}}],[\"稠密矩阵\",{\"1\":{\"401\":1}}],[\"稀疏矩阵\",{\"1\":{\"401\":1}}],[\"特殊情况\",{\"1\":{\"704\":1}}],[\"特性之外\",{\"1\":{\"613\":1}}],[\"特定条件链表转化为红黑树\",{\"1\":{\"543\":1}}],[\"特有的\",{\"1\":{\"401\":1}}],[\"特别注意\",{\"1\":{\"670\":1}}],[\"特别适合用于存储对象\",{\"1\":{\"389\":1}}],[\"特别当查询的字段是字符串时\",{\"1\":{\"278\":1}}],[\"活跃用户情况\",{\"1\":{\"400\":1}}],[\"活跃事务列表\",{\"1\":{\"288\":1}}],[\"求差集\",{\"1\":{\"396\":1}}],[\"求并集\",{\"1\":{\"396\":1}}],[\"求指定key的哈希\",{\"1\":{\"253\":1}}],[\"向指定有序集合添加一个或多个元素\",{\"1\":{\"396\":1}}],[\"向指定集合添加一个或多个元素\",{\"1\":{\"315\":1,\"332\":1,\"393\":1}}],[\"键\",{\"1\":{\"390\":1}}],[\"键值对\",{\"1\":{\"389\":1}}],[\"键值对数据\",{\"1\":{\"297\":1}}],[\"负责加载当前应用\",{\"1\":{\"711\":1}}],[\"负责接收请求\",{\"1\":{\"457\":1}}],[\"负数为减\",{\"1\":{\"390\":1}}],[\"负载均衡策略有\",{\"1\":{\"60\":1,\"140\":1}}],[\"负载均衡策略\",{\"0\":{\"60\":1}}],[\"负载均衡\",{\"0\":{\"59\":1},\"1\":{\"80\":1,\"137\":1}}],[\"域\",{\"1\":{\"390\":1}}],[\"域名系统\",{\"1\":{\"191\":1}}],[\"域名管理系统\",{\"1\":{\"172\":1,\"184\":1}}],[\"域名\",{\"1\":{\"62\":1}}],[\"链表则是主要为了解决哈希冲突而存在的\",{\"1\":{\"550\":1}}],[\"链表则是主要为了解决哈希冲突而存在\",{\"1\":{\"530\":2}}],[\"链表\",{\"1\":{\"389\":1}}],[\"链接上的虚拟链接\",{\"1\":{\"97\":1}}],[\"右边\",{\"1\":{\"387\":1}}],[\"右子树所有节点的值均大于根节点的值\",{\"1\":{\"259\":1}}],[\"举例\",{\"1\":{\"385\":2,\"388\":1,\"391\":1,\"394\":3,\"397\":2,\"400\":1,\"403\":1,\"406\":1}}],[\"举个例子\",{\"1\":{\"12\":1}}],[\"介绍\",{\"1\":{\"384\":1,\"387\":1,\"390\":1,\"393\":1,\"396\":1,\"399\":1,\"402\":1,\"405\":1}}],[\"介绍下项目的技术选型\",{\"0\":{\"137\":1}}],[\"介绍下rabbitmq\",{\"0\":{\"80\":1}}],[\"双亲委派模式\",{\"1\":{\"715\":1}}],[\"双亲委派模型的执行流程\",{\"0\":{\"714\":1}}],[\"双亲委派模型并不是一种强制性的约束\",{\"1\":{\"713\":1}}],[\"双亲委派模型\",{\"1\":{\"713\":1}}],[\"双亲委派模型要求除了顶层的启动类加载器外\",{\"1\":{\"713\":1}}],[\"双亲委派的好处\",{\"0\":{\"715\":1}}],[\"双亲委派\",{\"0\":{\"713\":1}}],[\"双检查单例模式\",{\"1\":{\"579\":1}}],[\"双指针\",{\"1\":{\"530\":1}}],[\"双重检查\",{\"0\":{\"523\":1},\"1\":{\"519\":1}}],[\"双向链表\",{\"1\":{\"382\":1,\"386\":1,\"530\":1}}],[\"双写模式下如果有两个数据同时写数据库\",{\"1\":{\"152\":1}}],[\"双写模式\",{\"1\":{\"152\":2}}],[\"势必会造成所有尝试获取锁的客户端来争夺锁\",{\"1\":{\"380\":1}}],[\"红黑二叉树\",{\"1\":{\"550\":1}}],[\"红黑树作为底层\",{\"1\":{\"547\":1}}],[\"红黑树组成\",{\"1\":{\"530\":1}}],[\"红黑树的插入和删除操作效率大大提高了\",{\"1\":{\"261\":1}}],[\"红黑树的查询效率稍有下降\",{\"1\":{\"261\":1}}],[\"红黑树并不追求严格的平衡\",{\"1\":{\"261\":1}}],[\"红黑树是一种自平衡的二叉查找树\",{\"1\":{\"261\":1}}],[\"红黑树\",{\"0\":{\"261\":1},\"1\":{\"530\":2,\"543\":1,\"550\":1}}],[\"红锁\",{\"1\":{\"377\":1}}],[\"拿锁且不设置锁超时时间\",{\"1\":{\"376\":1}}],[\"看门狗续期前也会先判断是否需要执行续期操作\",{\"1\":{\"376\":1}}],[\"看门狗就会执行续期操作\",{\"1\":{\"376\":1}}],[\"看门狗名字的由来于\",{\"1\":{\"376\":1}}],[\"看门狗\",{\"1\":{\"376\":1}}],[\"选举了新的slave节点之后\",{\"1\":{\"427\":1}}],[\"选举新的master\",{\"0\":{\"426\":1}}],[\"选用\",{\"1\":{\"374\":1}}],[\"选择合适的字段创建索引\",{\"0\":{\"274\":1}}],[\"选择其中一台作为主数据库\",{\"1\":{\"247\":1}}],[\"选择重传协议不再具有累计确认机制\",{\"1\":{\"205\":1}}],[\"选择重传协议\",{\"0\":{\"205\":1}}],[\"选择跳数最少的路径作为最佳路径\",{\"1\":{\"174\":1}}],[\"唯一\",{\"1\":{\"530\":2}}],[\"唯一值\",{\"1\":{\"374\":1}}],[\"唯一索引的属性页不能出现重复的数据\",{\"1\":{\"264\":1}}],[\"唯一索引是一种约束\",{\"1\":{\"264\":1}}],[\"唯一索引\",{\"1\":{\"264\":1}}],[\"啥也不做\",{\"1\":{\"374\":1}}],[\"任务执行期间自己可以去做任何想做的事情\",{\"1\":{\"611\":1}}],[\"任务队列已经满了\",{\"1\":{\"608\":1}}],[\"任务队列中存放的任务达到队列容量的时候\",{\"1\":{\"605\":1}}],[\"任务队列未达到队列容量时\",{\"1\":{\"605\":1}}],[\"任务队列\",{\"1\":{\"604\":1,\"605\":1}}],[\"任务会被保存在一个任务队列中\",{\"1\":{\"604\":1}}],[\"任意一个时刻\",{\"1\":{\"372\":1}}],[\"任何时候\",{\"1\":{\"703\":1}}],[\"任何时候都有可能被回收\",{\"1\":{\"670\":1}}],[\"任何人实现的编译器都可以向属性表中写\",{\"1\":{\"698\":1}}],[\"任何地方运行\",{\"1\":{\"467\":1}}],[\"任何节点的左右子树高度差的绝对值不超过1即为平衡\",{\"1\":{\"259\":1}}],[\"任何两个查询在任何字符上的不同都会导致缓存不命中\",{\"1\":{\"229\":1}}],[\"任何事务操作都可以得到响应结果\",{\"1\":{\"114\":1}}],[\"密集型任务\",{\"1\":{\"609\":2}}],[\"密集型服务部署在一起\",{\"1\":{\"369\":1}}],[\"密集型应用\",{\"1\":{\"369\":1}}],[\"密码加密解密通过passwordencoder实现类bcryptpasswordencoder完成\",{\"1\":{\"146\":1}}],[\"密码被securityfilterchain中的\",{\"1\":{\"146\":1}}],[\"密码编码器\",{\"1\":{\"146\":1}}],[\"扩容都会发生\",{\"1\":{\"721\":1}}],[\"扩容之后变为2n+1\",{\"1\":{\"543\":1}}],[\"扩容\",{\"1\":{\"543\":1}}],[\"扩容后大小为int\",{\"1\":{\"532\":1}}],[\"扩容时候需要进行数据迁移\",{\"1\":{\"367\":1}}],[\"扩展类加载器\",{\"1\":{\"711\":1}}],[\"扩展目标对象\",{\"1\":{\"511\":1}}],[\"扩展\",{\"1\":{\"306\":1}}],[\"扩展性\",{\"1\":{\"78\":1,\"81\":1}}],[\"刷盘阻塞\",{\"1\":{\"364\":1}}],[\"出生并经过第一次\",{\"1\":{\"662\":1}}],[\"出现异常\",{\"1\":{\"448\":1}}],[\"出一个子进程\",{\"1\":{\"363\":1}}],[\"出于多租户和安全因素设计的\",{\"1\":{\"97\":1}}],[\"代表当前这个常量属于哪种常量类型\",{\"1\":{\"693\":1}}],[\"代表\",{\"1\":{\"693\":1}}],[\"代表这个方法是用来比较两个对象是否相等\",{\"1\":{\"492\":1}}],[\"代码中可以不赋初始值就直接使用\",{\"1\":{\"651\":1}}],[\"代码块上都是是给\",{\"1\":{\"588\":1}}],[\"代码的执行顺序未必就是编写代码的顺序\",{\"1\":{\"577\":1}}],[\"代理类这些都变成一个个class文件\",{\"1\":{\"517\":1}}],[\"代理类变成一个个class文件\",{\"1\":{\"512\":1}}],[\"代理类中的真实对象\",{\"1\":{\"507\":1}}],[\"代理模式有静态代理和动态代理两种实现方式\",{\"1\":{\"511\":1}}],[\"代理模式\",{\"0\":{\"511\":1}}],[\"代理设计模式\",{\"1\":{\"437\":1}}],[\"代理对象不能调用子类private方法\",{\"1\":{\"448\":1}}],[\"代理对象\",{\"1\":{\"30\":1}}],[\"代替\",{\"1\":{\"362\":1}}],[\"减轻数据库的压力\",{\"1\":{\"357\":1}}],[\"减少内存复制开销\",{\"1\":{\"686\":1}}],[\"减少内存分配次数\",{\"1\":{\"311\":1}}],[\"减少传统的重量级锁使用操作系统互斥量产生的性能消耗\",{\"1\":{\"618\":1}}],[\"减少master压力\",{\"1\":{\"422\":1}}],[\"减少\",{\"1\":{\"311\":1}}],[\"减少回表次数\",{\"1\":{\"272\":1}}],[\"减少了处理开销\",{\"1\":{\"210\":1}}],[\"减少了对cpu资源的消耗\",{\"1\":{\"22\":1}}],[\"减少数据的发送\",{\"1\":{\"199\":1}}],[\"减少数据库压力\",{\"1\":{\"136\":1}}],[\"减少响应所需时间\",{\"0\":{\"69\":1}}],[\"减少延时\",{\"1\":{\"59\":1}}],[\"减少到后端请求的数量\",{\"1\":{\"58\":1}}],[\"减少tomcat的请求次数\",{\"1\":{\"55\":1}}],[\"得到所有的beandefinition对象\",{\"1\":{\"453\":1}}],[\"得到的哈希值判断位数组中的每一个元素是否都为1\",{\"1\":{\"353\":1}}],[\"得到哈希值\",{\"1\":{\"353\":1}}],[\"得上点硬菜了\",{\"1\":{\"135\":1}}],[\"击穿\",{\"0\":{\"351\":1}}],[\"雪崩\",{\"0\":{\"351\":1}}],[\"频繁的同步操作会导致不必要的性能损耗\",{\"1\":{\"617\":1}}],[\"频繁修改redis中的数据也会产生内存碎片\",{\"1\":{\"348\":1}}],[\"频繁需要排序的字段\",{\"1\":{\"274\":1}}],[\"慢\",{\"1\":{\"416\":1}}],[\"慢查询命令也就是执行时间长的命令\",{\"1\":{\"344\":1}}],[\"慢查询命令\",{\"0\":{\"344\":1}}],[\"慢开始算法的思路是当主机开始发送数据时\",{\"1\":{\"201\":1}}],[\"慢开始\",{\"1\":{\"201\":1}}],[\"溢出最不经常使用的key\",{\"1\":{\"342\":1}}],[\"热门帖子\",{\"1\":{\"403\":1}}],[\"热门网站每日\",{\"1\":{\"403\":1}}],[\"热\",{\"0\":{\"340\":1}}],[\"热点key失效\",{\"0\":{\"356\":1},\"1\":{\"153\":1}}],[\"秒的数据\",{\"1\":{\"416\":1}}],[\"秒的自动过期时间\",{\"1\":{\"375\":1}}],[\"秒为单位\",{\"1\":{\"375\":1}}],[\"秒\",{\"1\":{\"338\":1,\"376\":3}}],[\"秒杀没有结束前key不会过期\",{\"1\":{\"357\":1}}],[\"秒杀商品就属于热点key\",{\"1\":{\"356\":1}}],[\"秒杀商品的信号量key为sku\",{\"1\":{\"158\":1}}],[\"秒杀下一人一单占位使用lua脚本\",{\"1\":{\"306\":1}}],[\"秒杀下更新数据库时使用分布式锁\",{\"1\":{\"306\":1}}],[\"秒杀在快开始的时候才会将随机的uuid设置到sku详情中\",{\"1\":{\"162\":1}}],[\"秒杀项目是一个独立的微服务即使发生宕机也不会影响订单微服务\",{\"1\":{\"159\":1}}],[\"秒杀开始判断用户是否登录\",{\"1\":{\"158\":1}}],[\"秒杀开始前通过\",{\"1\":{\"158\":1}}],[\"秒杀库存数量\",{\"1\":{\"158\":1}}],[\"秒杀的流程是啥样的\",{\"0\":{\"158\":1}}],[\"秒杀场景下商品的过期时间应该在秒杀场结束之后\",{\"1\":{\"153\":1}}],[\"秒杀场景中\",{\"1\":{\"70\":1}}],[\"秒杀微服务只做秒杀\",{\"1\":{\"144\":1}}],[\"秒杀连接加密\",{\"0\":{\"160\":1,\"162\":1},\"1\":{\"136\":1}}],[\"秒杀遵从服务单一职责\",{\"0\":{\"157\":1},\"1\":{\"136\":1}}],[\"秒杀等微服务\",{\"0\":{\"143\":1},\"1\":{\"136\":1}}],[\"禁止驱逐数据\",{\"1\":{\"328\":1}}],[\"惰性删除\",{\"1\":{\"327\":1,\"335\":1,\"339\":1}}],[\"占用部分资源的线程在进一步申请资源失败时\",{\"1\":{\"564\":1}}],[\"占用内存比arraylist大\",{\"1\":{\"534\":1}}],[\"占用\",{\"1\":{\"401\":1}}],[\"占用空间很小\",{\"1\":{\"401\":1}}],[\"占用空间非常非常小\",{\"1\":{\"401\":1}}],[\"占用空间更小\",{\"1\":{\"242\":1}}],[\"占用的内存空间\",{\"1\":{\"324\":1}}],[\"已删除\",{\"1\":{\"324\":1}}],[\"已经被加载的类会直接返回\",{\"1\":{\"710\":1}}],[\"已经被回收\",{\"1\":{\"672\":1}}],[\"已经把原本放在永久代的字符串常量池\",{\"1\":{\"704\":1}}],[\"已经到达了屏障\",{\"1\":{\"626\":1}}],[\"已经摒弃了\",{\"1\":{\"550\":1}}],[\"已经存在\",{\"1\":{\"374\":1}}],[\"已经成为apache顶级项目\",{\"1\":{\"77\":1}}],[\"已经分配给进程使用但未被使用的内存\",{\"1\":{\"12\":1}}],[\"怎么做\",{\"0\":{\"317\":1}}],[\"怎么实现延迟队列\",{\"0\":{\"94\":1}}],[\"初始大小\",{\"1\":{\"721\":1}}],[\"初始标记很好理解\",{\"1\":{\"687\":1}}],[\"初始标记\",{\"1\":{\"683\":1,\"684\":1}}],[\"初始状态\",{\"1\":{\"561\":1}}],[\"初始化一个类\",{\"1\":{\"706\":1}}],[\"初始化阶段是执行初始化方法\",{\"1\":{\"706\":1}}],[\"初始化阶段才会赋值\",{\"1\":{\"704\":1}}],[\"初始化零值完成之后\",{\"1\":{\"652\":1}}],[\"初始化零值\",{\"0\":{\"651\":1}}],[\"初始化过程其实就是对应afterpropertiesset\",{\"1\":{\"439\":1}}],[\"初始化后等步骤\",{\"1\":{\"453\":1}}],[\"初始化后做的事情就是执行aop\",{\"1\":{\"440\":1}}],[\"初始化后是什么\",{\"0\":{\"440\":1}}],[\"初始化后\",{\"1\":{\"438\":1,\"450\":1}}],[\"初始化\",{\"0\":{\"706\":1},\"1\":{\"438\":1,\"453\":1,\"700\":1}}],[\"初始化前\",{\"1\":{\"438\":1,\"453\":1}}],[\"初始化数据\",{\"1\":{\"316\":1}}],[\"初始值为\",{\"1\":{\"201\":1}}],[\"精确到天\",{\"1\":{\"316\":1}}],[\"精确匹配\",{\"0\":{\"89\":1}}],[\"位\",{\"1\":{\"726\":1}}],[\"位是主版本号\",{\"1\":{\"692\":1}}],[\"位是次版本号\",{\"1\":{\"692\":1}}],[\"位置的值\",{\"1\":{\"399\":2}}],[\"位置的值设置为\",{\"1\":{\"387\":1}}],[\"位来表示某个元素对应的值或者状态\",{\"1\":{\"316\":1,\"398\":1}}],[\"位存储\",{\"1\":{\"308\":1}}],[\"音乐推荐\",{\"1\":{\"314\":1,\"394\":1}}],[\"音频\",{\"1\":{\"311\":1}}],[\"差集的操作\",{\"1\":{\"392\":1}}],[\"差集+交集\",{\"1\":{\"314\":1,\"394\":1}}],[\"差集\",{\"1\":{\"314\":2,\"345\":1,\"362\":1,\"394\":4}}],[\"好友推荐\",{\"1\":{\"314\":1,\"394\":1}}],[\"交集\",{\"1\":{\"314\":3,\"394\":5}}],[\"交换器类型\",{\"0\":{\"87\":1}}],[\"交换器会根据路由键和路由方式将消息发送给对应的queue中\",{\"1\":{\"84\":1}}],[\"交换器\",{\"0\":{\"84\":1},\"1\":{\"84\":1}}],[\"话题热度排行榜等等\",{\"1\":{\"313\":1,\"397\":1}}],[\"游戏中的段位排行榜\",{\"1\":{\"313\":1,\"397\":1}}],[\"朋友圈的微信步数排行榜\",{\"1\":{\"313\":1,\"397\":1}}],[\"像g1的话\",{\"1\":{\"686\":1}}],[\"像\",{\"1\":{\"377\":1,\"582\":1}}],[\"像一些二进制文件\",{\"1\":{\"311\":1}}],[\"像消息确认机制等功能还需要我们自己实现\",{\"1\":{\"306\":1}}],[\"获取其父\",{\"1\":{\"711\":1}}],[\"获取1个许可\",{\"1\":{\"624\":1}}],[\"获取计算结果的\",{\"1\":{\"613\":1}}],[\"获取当前请求的线程\",{\"1\":{\"599\":1}}],[\"获取后将锁计数器设为\",{\"1\":{\"589\":1}}],[\"获取方法并执行\",{\"0\":{\"510\":1}}],[\"获取\",{\"1\":{\"399\":1,\"509\":1}}],[\"获取集合数量\",{\"1\":{\"394\":1}}],[\"获取给定所有集合的差集\",{\"1\":{\"393\":1}}],[\"获取给定所有集合的并集\",{\"1\":{\"393\":1}}],[\"获取给定所有集合的交集\",{\"1\":{\"393\":1}}],[\"获取多个字段的值\",{\"1\":{\"391\":1}}],[\"获取单个字段的值\",{\"1\":{\"391\":1}}],[\"获取列表\",{\"1\":{\"387\":1}}],[\"获取列表元素数量\",{\"1\":{\"387\":1}}],[\"获取锁的过程中可以被中断\",{\"1\":{\"595\":1}}],[\"获取锁失败\",{\"1\":{\"379\":1}}],[\"获取锁\",{\"1\":{\"379\":1}}],[\"获取指定位置附近\",{\"1\":{\"405\":1}}],[\"获取指定位置附近的元素等功能\",{\"1\":{\"404\":1}}],[\"获取指定有序集合\",{\"1\":{\"396\":2}}],[\"获取指定有序集合中指定元素的排名\",{\"1\":{\"396\":1}}],[\"获取指定有序集合中指定元素的\",{\"1\":{\"396\":1}}],[\"获取指定有序集合的元素数量\",{\"1\":{\"396\":1}}],[\"获取指定集合的元素数量\",{\"1\":{\"393\":1}}],[\"获取指定集合中的所有元素\",{\"1\":{\"393\":1}}],[\"获取指定哈希表中字段的数量\",{\"1\":{\"390\":1}}],[\"获取指定哈希表中所有的键值对\",{\"1\":{\"390\":1}}],[\"获取指定哈希表中指定字段的值\",{\"1\":{\"390\":1}}],[\"获取指定哈希表中一个或者多个指定字段的值\",{\"1\":{\"332\":1,\"390\":1}}],[\"获取指定\",{\"1\":{\"384\":1,\"399\":1}}],[\"获取指定的分布式锁对象\",{\"1\":{\"376\":1}}],[\"获取一个或多个指定\",{\"1\":{\"332\":1,\"384\":1}}],[\"获取一个或者多个\",{\"1\":{\"317\":1,\"402\":1}}],[\"获取字符串长度的复杂度较低\",{\"1\":{\"311\":1}}],[\"获取redis数据失败的时候则认为是用户的免登录时间已经过期\",{\"1\":{\"149\":1}}],[\"节点所走过的路径称为引用链\",{\"1\":{\"667\":1}}],[\"节点加入阻塞队列\",{\"1\":{\"624\":1}}],[\"节点\",{\"1\":{\"380\":4}}],[\"节点的特性之外\",{\"1\":{\"380\":2}}],[\"节点的\",{\"1\":{\"378\":1}}],[\"节点可用\",{\"1\":{\"378\":1}}],[\"节点出现问题\",{\"1\":{\"378\":1}}],[\"节省网络流量\",{\"1\":{\"310\":1}}],[\"节流以及缓冲区大小受限等缺点\",{\"1\":{\"9\":1}}],[\"计数器为0的对象就是不会再被使用的对象\",{\"1\":{\"666\":1}}],[\"计数器\",{\"1\":{\"662\":1}}],[\"计数器的值只能在构造方法中初始化一次\",{\"1\":{\"625\":1}}],[\"计数值变0\",{\"1\":{\"625\":1}}],[\"计数达到某个阈值的时候\",{\"1\":{\"401\":1}}],[\"计数较少的时候\",{\"1\":{\"401\":1}}],[\"计数比如用户单位时间的请求数\",{\"1\":{\"309\":1}}],[\"计算的时候会把最后一行保存校验和的内容给忽略点\",{\"1\":{\"415\":1}}],[\"计算多个\",{\"1\":{\"345\":1,\"362\":1}}],[\"计算机组成原理第二章浮点加减法\",{\"1\":{\"473\":1}}],[\"计算机网络三\",{\"0\":{\"206\":1}}],[\"计算机网络\",{\"0\":{\"215\":1},\"1\":{\"203\":1}}],[\"计算机网络二\",{\"0\":{\"186\":1}}],[\"计算机网络一\",{\"0\":{\"170\":1}}],[\"计算机基础\",{\"0\":{\"25\":1,\"38\":1}}],[\"图片地址\",{\"1\":{\"385\":1}}],[\"图片的路径\",{\"1\":{\"309\":1}}],[\"图片的\",{\"1\":{\"309\":1,\"383\":1}}],[\"图片\",{\"1\":{\"309\":1,\"383\":1}}],[\"图片这些静态文件的io性能不好\",{\"1\":{\"55\":1}}],[\"散列插槽\",{\"0\":{\"430\":1}}],[\"散列\",{\"1\":{\"308\":1,\"382\":1}}],[\"维护排行榜\",{\"1\":{\"306\":1}}],[\"复制性能会变得很差\",{\"1\":{\"675\":1}}],[\"复制\",{\"1\":{\"675\":1,\"684\":1}}],[\"复制算法的多线程收集器\",{\"1\":{\"680\":1}}],[\"复制算法\",{\"0\":{\"675\":1},\"1\":{\"676\":1,\"678\":1,\"679\":1,\"680\":1}}],[\"复合类型的value包含的元素超过5000个\",{\"1\":{\"336\":1}}],[\"复杂业务场景\",{\"1\":{\"306\":1}}],[\"复用模型\",{\"1\":{\"299\":1}}],[\"复用的网络模型\",{\"1\":{\"299\":1}}],[\"复用的执行器\",{\"1\":{\"35\":1}}],[\"订阅号推荐\",{\"1\":{\"314\":1,\"394\":1}}],[\"订阅模式\",{\"1\":{\"306\":1}}],[\"订单状态等\",{\"1\":{\"155\":1}}],[\"订单号\",{\"1\":{\"155\":1}}],[\"订单创建的幂等性如何实现\",{\"0\":{\"155\":1}}],[\"订单创建的时候在延时队列中添加库存解锁信息\",{\"1\":{\"96\":1}}],[\"订单创建幂等性\",{\"0\":{\"154\":1},\"1\":{\"136\":1}}],[\"订单\",{\"0\":{\"143\":1},\"1\":{\"136\":1}}],[\"订单微服务中\",{\"1\":{\"110\":1}}],[\"订单模块负责订单取消\",{\"1\":{\"71\":1}}],[\"订单模块不需要等待库存释放完成才返回\",{\"1\":{\"69\":1}}],[\"订单取消之后发送一个库存释放任务到消息队列中\",{\"1\":{\"69\":1}}],[\"新加入的默认方法\",{\"1\":{\"706\":1}}],[\"新对象都分配在这个两个指针之间\",{\"1\":{\"684\":1}}],[\"新对象的内部引用对象不再是原来对象的内部引用对象\",{\"1\":{\"488\":1}}],[\"新生代的空间越大也会导致每次minorgc的时间变长\",{\"1\":{\"730\":1}}],[\"新生代的特点\",{\"1\":{\"730\":1}}],[\"新生代越大\",{\"1\":{\"730\":1}}],[\"新生代gc调优\",{\"0\":{\"730\":1}}],[\"新生代采用标记\",{\"1\":{\"678\":1,\"679\":1,\"680\":1}}],[\"新生代收集\",{\"1\":{\"663\":1}}],[\"新建线程将会使当前运行的线程超出最大线程数\",{\"1\":{\"608\":1}}],[\"新来的任务将会被\",{\"1\":{\"606\":1}}],[\"新任务到来的时候\",{\"1\":{\"607\":1}}],[\"新任务就会被存放在队列中\",{\"1\":{\"605\":1}}],[\"新任务来的时候会先判断当前运行的线程数量是否达到核心线程数\",{\"1\":{\"605\":1}}],[\"新的\",{\"1\":{\"416\":1}}],[\"新的aof文件和原有aof文件所保存的数据库状态一直\",{\"1\":{\"414\":1}}],[\"新写入操作会报错\",{\"1\":{\"328\":1}}],[\"新增加的一个数据结构\",{\"1\":{\"306\":1,\"388\":1}}],[\"新插入的数据\",{\"1\":{\"232\":1}}],[\"点赞量\",{\"1\":{\"304\":1}}],[\"点击跳转b站网课\",{\"1\":{\"135\":1}}],[\"机制\",{\"1\":{\"306\":1}}],[\"机制都用到了这种策略\",{\"1\":{\"304\":1}}],[\"机制来保证不出现幻读\",{\"1\":{\"282\":1}}],[\"理论上来说还是可能会出现数据不一致性的问题\",{\"1\":{\"302\":1}}],[\"理解\",{\"1\":{\"179\":1}}],[\"么\",{\"1\":{\"302\":1}}],[\"旁路缓存模式\",{\"0\":{\"302\":1},\"1\":{\"360\":1}}],[\"甚至最高能达到\",{\"1\":{\"300\":1}}],[\"核心\",{\"1\":{\"684\":1}}],[\"核心线程外的线程不会立即销毁\",{\"1\":{\"605\":1}}],[\"核心线程数为0\",{\"1\":{\"604\":1}}],[\"核心线程数为1\",{\"1\":{\"604\":1}}],[\"核心线程数为n\",{\"1\":{\"604\":2}}],[\"核心的中央处理器\",{\"1\":{\"457\":1}}],[\"核\",{\"1\":{\"300\":1}}],[\"qps\",{\"1\":{\"300\":2}}],[\"qualifier\",{\"1\":{\"444\":1}}],[\"quorum值最好超过sentinel实例数量的一半\",{\"1\":{\"425\":1}}],[\"query\",{\"1\":{\"300\":1}}],[\"queue因为容量问题导致操作失败后的处理方式不同分为两类方法\",{\"1\":{\"537\":1}}],[\"queue等\",{\"1\":{\"97\":1}}],[\"queue队列\",{\"0\":{\"92\":1}}],[\"queue\",{\"0\":{\"85\":1,\"529\":1,\"537\":1},\"1\":{\"85\":1,\"92\":1,\"102\":1,\"528\":1,\"529\":1,\"530\":1,\"537\":1,\"539\":1,\"540\":1,\"630\":1,\"631\":1}}],[\"queuing\",{\"1\":{\"9\":1,\"74\":1,\"78\":1,\"80\":1}}],[\"quicklist\",{\"1\":{\"382\":2}}],[\"quic\",{\"1\":{\"190\":2}}],[\"毕竟是从硬盘中读取的\",{\"1\":{\"300\":1}}],[\"毕竟公司的机器是有限的\",{\"1\":{\"103\":1}}],[\"假如在字符串常量池中存在字符串\",{\"1\":{\"671\":1}}],[\"假如不做任何措施的话\",{\"1\":{\"600\":1}}],[\"假如用户第一次访问数据库中的某些数据的话\",{\"1\":{\"300\":1}}],[\"假设有\",{\"1\":{\"624\":1}}],[\"假设数组长度n为16\",{\"1\":{\"548\":1}}],[\"假设不使用顺序节点的话\",{\"1\":{\"380\":1}}],[\"假设不同的班级学号有相同的\",{\"1\":{\"219\":1}}],[\"假设客户端\",{\"1\":{\"379\":1}}],[\"针对\",{\"1\":{\"663\":1}}],[\"针对不同系统有不同的实现\",{\"1\":{\"466\":1}}],[\"针对这个问题\",{\"1\":{\"378\":1}}],[\"针对热点数据提前预热\",{\"1\":{\"357\":1}}],[\"针对热点缓存失效的情况\",{\"1\":{\"355\":1}}],[\"针对redis服务不可用的情况\",{\"1\":{\"355\":1}}],[\"针对网络数据的读写引入了多线程\",{\"1\":{\"299\":1}}],[\"针对更复杂的路由功能\",{\"1\":{\"78\":1}}],[\"脚本是为了保证解锁操作的原子性\",{\"1\":{\"374\":1}}],[\"脚本通过\",{\"1\":{\"374\":1}}],[\"脚本的原子操作也无法保证了\",{\"1\":{\"334\":1}}],[\"脚本的方式来实现限流\",{\"1\":{\"306\":1}}],[\"脚本运行时出错并中途结束\",{\"1\":{\"334\":1}}],[\"脚本依然存在下面这些缺陷\",{\"1\":{\"334\":1}}],[\"脚本中进行处理\",{\"1\":{\"334\":1}}],[\"脚本中支持一些简单的逻辑处理比如使用命令读取值并在\",{\"1\":{\"334\":1}}],[\"脚本执行过程中不会有其他脚本或\",{\"1\":{\"334\":1}}],[\"脚本可以视作一条命令执行\",{\"1\":{\"334\":1}}],[\"脚本同样支持批量操作多条命令\",{\"1\":{\"334\":1}}],[\"脚本\",{\"1\":{\"297\":1,\"299\":1,\"334\":1}}],[\"许可\",{\"1\":{\"297\":1}}],[\"级别下实现可重复读\",{\"1\":{\"291\":1}}],[\"虽然经常说\",{\"1\":{\"324\":1}}],[\"虽然引入了多线程\",{\"1\":{\"323\":1}}],[\"虽然文件事件处理器以单线程方式运行\",{\"1\":{\"320\":1}}],[\"虽然\",{\"1\":{\"291\":1,\"416\":1,\"538\":1,\"684\":1}}],[\"虽然索引能带来查询上的效率\",{\"1\":{\"275\":1}}],[\"小于这个\",{\"1\":{\"288\":1}}],[\"回收策略等等\",{\"1\":{\"679\":1}}],[\"回收\",{\"1\":{\"600\":1}}],[\"回滚指针\",{\"1\":{\"287\":1}}],[\"回表\",{\"1\":{\"267\":1}}],[\"找出需要回收的对象\",{\"1\":{\"684\":1}}],[\"找出最优的查询方案\",{\"1\":{\"243\":1}}],[\"找到存放位置之后判断当前位置元素和要存入的元素hash值和key是否相同\",{\"1\":{\"546\":1}}],[\"找到\",{\"1\":{\"286\":1}}],[\"隐藏字段\",{\"0\":{\"287\":1},\"1\":{\"286\":1}}],[\"隐式转换\",{\"1\":{\"278\":1}}],[\"情况下\",{\"1\":{\"285\":1}}],[\"情况复杂\",{\"1\":{\"57\":1}}],[\"排队\",{\"1\":{\"529\":1}}],[\"排它锁\",{\"1\":{\"285\":1}}],[\"排他锁之前\",{\"1\":{\"240\":1}}],[\"排他锁\",{\"1\":{\"239\":1}}],[\"叫它快照读\",{\"1\":{\"284\":1}}],[\"×\",{\"1\":{\"282\":6}}],[\"√\",{\"1\":{\"282\":6}}],[\"时采用\",{\"1\":{\"550\":1}}],[\"时就已经存在\",{\"1\":{\"538\":1}}],[\"时必须重写\",{\"0\":{\"492\":1}}],[\"时机不同\",{\"1\":{\"291\":1}}],[\"时\",{\"1\":{\"285\":1,\"311\":1,\"369\":1,\"662\":1,\"706\":1}}],[\"时一定要养成良好的习惯\",{\"1\":{\"278\":1}}],[\"时间的比例\",{\"1\":{\"725\":1}}],[\"时间的比例不高于\",{\"1\":{\"350\":1}}],[\"时间的比例不低于\",{\"1\":{\"350\":1}}],[\"时间单位\",{\"1\":{\"605\":1}}],[\"时间复杂度的命令可能会导致阻塞之外\",{\"1\":{\"362\":1}}],[\"时间复杂度的命令\",{\"1\":{\"345\":1,\"362\":1}}],[\"时间复杂度\",{\"1\":{\"345\":1,\"362\":1}}],[\"时间复杂度为\",{\"1\":{\"311\":2,\"345\":2,\"362\":2}}],[\"时间后才进入\",{\"0\":{\"197\":1}}],[\"时间\",{\"1\":{\"8\":1}}],[\"字面量比较接近于\",{\"1\":{\"693\":1}}],[\"字面量和符号引用\",{\"1\":{\"693\":1}}],[\"字面量包括整数\",{\"1\":{\"646\":1}}],[\"字面量是源代码中的固定值的表示法\",{\"1\":{\"646\":1}}],[\"字段是否存在\",{\"1\":{\"703\":1}}],[\"字段包括类级变量以及实例变量\",{\"1\":{\"696\":1}}],[\"字段表\",{\"1\":{\"696\":1,\"698\":1}}],[\"字段表集合\",{\"0\":{\"696\":1}}],[\"字段的名称和描述符\",{\"1\":{\"693\":1}}],[\"字段符号引用\",{\"1\":{\"646\":1}}],[\"字段\",{\"1\":{\"646\":1,\"705\":1}}],[\"字段将其标记为已删除\",{\"1\":{\"287\":1}}],[\"字符串对象的引用指向堆中的字符串对象\",{\"1\":{\"647\":1}}],[\"字符串对象的引用\",{\"1\":{\"647\":1}}],[\"字符串常量池被从方法区拿到了堆中\",{\"1\":{\"671\":1}}],[\"字符串常量池和静态变量从永久代移动了\",{\"1\":{\"647\":1}}],[\"字符串常量池存放在永久代\",{\"1\":{\"647\":1}}],[\"字符串常量池\",{\"0\":{\"647\":1},\"1\":{\"647\":1}}],[\"字符串拼接用\",{\"0\":{\"496\":1}}],[\"字符串为\",{\"1\":{\"383\":1}}],[\"字符串无法正确保存\",{\"1\":{\"311\":1}}],[\"字符串时\",{\"1\":{\"311\":1}}],[\"字符串\",{\"0\":{\"383\":1},\"1\":{\"308\":1,\"382\":1,\"661\":1}}],[\"字符串转换为数值类型时\",{\"1\":{\"278\":1}}],[\"字节码可以使源程序\",{\"1\":{\"709\":1}}],[\"字节码验证\",{\"1\":{\"703\":1}}],[\"字节码语义检查\",{\"1\":{\"703\":1}}],[\"字节码\",{\"0\":{\"689\":1},\"1\":{\"706\":1}}],[\"字节码解决了传统解释语言运行效率低的问题\",{\"1\":{\"467\":1}}],[\"字节\",{\"1\":{\"188\":2}}],[\"字节的内存就成为了内部内存碎片\",{\"1\":{\"12\":1}}],[\"字节的内存\",{\"1\":{\"12\":1}}],[\"造成数据库宕机\",{\"1\":{\"356\":1}}],[\"造成误判的原因\",{\"1\":{\"353\":1}}],[\"造成全表扫描效率极低\",{\"1\":{\"278\":1}}],[\"造成一次请求连接耗时较长\",{\"1\":{\"57\":1}}],[\"类使用委托模型来搜索类和资源\",{\"1\":{\"713\":2}}],[\"类中的\",{\"1\":{\"712\":1,\"716\":1}}],[\"类有两个关键的方法\",{\"1\":{\"712\":1}}],[\"类有什么用\",{\"0\":{\"613\":1}}],[\"类卸载\",{\"0\":{\"707\":1}}],[\"类方法\",{\"1\":{\"705\":1}}],[\"类变量所使用的内存都应该在方法区中分配\",{\"1\":{\"704\":1}}],[\"类从被加载到虚拟机内存中开始到卸载出内存为止\",{\"1\":{\"700\":1}}],[\"类都有父类\",{\"1\":{\"695\":1}}],[\"类索引用于确定这个类的全限定名\",{\"1\":{\"695\":1}}],[\"类索引\",{\"1\":{\"695\":1}}],[\"类的正确性检查\",{\"1\":{\"703\":1}}],[\"类的生命周期\",{\"0\":{\"700\":1}}],[\"类的父类索引都不为\",{\"1\":{\"695\":1}}],[\"类的继承关系由类索引\",{\"1\":{\"695\":1}}],[\"类的所有可变操作\",{\"1\":{\"629\":1}}],[\"类和接口的全限定名\",{\"1\":{\"693\":1}}],[\"类文件结构\",{\"0\":{\"688\":1}}],[\"类需要同时满足下面\",{\"1\":{\"672\":1}}],[\"类需要实现initializingbean接口\",{\"1\":{\"439\":1}}],[\"类加载过程的第一步\",{\"1\":{\"702\":1}}],[\"类加载过程\",{\"0\":{\"699\":1,\"701\":1},\"1\":{\"700\":1}}],[\"类加载完成之后开始分配内存\",{\"1\":{\"650\":1}}],[\"类加载检查\",{\"0\":{\"649\":1}}],[\"类加载器在进行类加载的时候\",{\"1\":{\"714\":1,\"716\":1}}],[\"类加载器之间的父子关系一般不是以继承的关系来实现的\",{\"1\":{\"713\":1}}],[\"类加载器总结\",{\"0\":{\"711\":1}}],[\"类加载器的加载规则\",{\"0\":{\"710\":1}}],[\"类加载器的作用就是加载java类的字节码\",{\"1\":{\"709\":1}}],[\"类加载器是一个负责加载类的对象\",{\"1\":{\"709\":1}}],[\"类加载器\",{\"0\":{\"708\":1,\"709\":1},\"1\":{\"514\":1}}],[\"类\",{\"1\":{\"647\":1}}],[\"类可以解决future\",{\"1\":{\"613\":1}}],[\"类是异步思想的典型运用\",{\"1\":{\"611\":1}}],[\"类内部的\",{\"1\":{\"599\":1}}],[\"类上锁\",{\"1\":{\"588\":1}}],[\"类没有重写equals方法\",{\"1\":{\"490\":1}}],[\"类型\",{\"1\":{\"694\":1,\"726\":1}}],[\"类型是一种无序集合\",{\"1\":{\"392\":1}}],[\"类型的标志位\",{\"1\":{\"693\":1}}],[\"类型的\",{\"1\":{\"389\":1}}],[\"类型的整数\",{\"1\":{\"326\":1}}],[\"类型的底层实现并不是\",{\"1\":{\"311\":1}}],[\"类型的数据结构更加适合用来做消息队列\",{\"1\":{\"306\":1}}],[\"类型的数据\",{\"1\":{\"299\":1}}],[\"类型转换等操作\",{\"1\":{\"278\":1}}],[\"类似信号枪响\",{\"1\":{\"625\":1}}],[\"类似于版本号\",{\"1\":{\"420\":1}}],[\"类似于\",{\"1\":{\"389\":1,\"395\":1,\"405\":1,\"416\":1}}],[\"类似于网络中的namespace概念\",{\"1\":{\"97\":1}}],[\"类似aqs的实现方式\",{\"1\":{\"379\":1}}],[\"类似虚拟内存\",{\"1\":{\"368\":1}}],[\"类似\",{\"1\":{\"243\":1,\"396\":2}}],[\"类似vpn代理模式\",{\"1\":{\"142\":1}}],[\"函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘\",{\"1\":{\"324\":1}}],[\"函数\",{\"1\":{\"278\":1}}],[\"函数依赖\",{\"1\":{\"219\":1}}],[\"耗费的时间也是较多的\",{\"1\":{\"277\":1}}],[\"耗费更多服务器资源\",{\"1\":{\"180\":1}}],[\"被彻底移除了\",{\"1\":{\"721\":1}}],[\"被同一个虚拟机加载\",{\"1\":{\"714\":1}}],[\"被\",{\"1\":{\"706\":1}}],[\"被判断需要执行的对象将会被放在一个队列中进行第二次标记\",{\"1\":{\"669\":1}}],[\"被唤醒的线程会重新尝试去修改\",{\"1\":{\"624\":1}}],[\"被拒绝的任务\",{\"1\":{\"606\":1}}],[\"被广泛应用于各大框架中\",{\"1\":{\"583\":1}}],[\"被广泛应用于缓存方向\",{\"1\":{\"297\":1}}],[\"被拦截的方法\",{\"1\":{\"515\":1}}],[\"被代理的对象\",{\"1\":{\"515\":1}}],[\"被代理类实现的接口\",{\"1\":{\"514\":1}}],[\"被static修饰的变量\",{\"1\":{\"704\":1}}],[\"被static修饰的变量为类所共享的\",{\"1\":{\"477\":1}}],[\"被static修饰的方法能被再次声明\",{\"1\":{\"480\":1}}],[\"被捕获\",{\"1\":{\"448\":1}}],[\"被删除元素的数量\",{\"1\":{\"345\":1,\"362\":1}}],[\"被修改时\",{\"1\":{\"311\":1}}],[\"被频繁更新的字段应该慎重建立索引\",{\"0\":{\"275\":1}}],[\"被频繁查询的字段\",{\"1\":{\"274\":1}}],[\"被经常频繁用于连接的字段\",{\"1\":{\"274\":1}}],[\"被作为条件查询的字段\",{\"1\":{\"274\":1}}],[\"被点号\",{\"1\":{\"90\":1}}],[\"过滤掉不符合条件的记录\",{\"1\":{\"272\":1}}],[\"过期时间设置\",{\"1\":{\"375\":1}}],[\"过期时间为场次结束时间\",{\"1\":{\"158\":1}}],[\"过期字典的值是一个long\",{\"1\":{\"326\":1}}],[\"过期字典的键指向redis数据库中的某个key\",{\"1\":{\"326\":1}}],[\"过期数据的删除策略\",{\"0\":{\"327\":1}}],[\"过期数据的删除策略只用了惰性删除\",{\"1\":{\"299\":1}}],[\"过期数据删除\",{\"1\":{\"299\":1}}],[\"过期订单的解锁订单和解锁库存流程通过rabbitmq消息队列实现\",{\"1\":{\"136\":1}}],[\"跟例子1很像\",{\"1\":{\"271\":1}}],[\"跟聚簇索引一样\",{\"1\":{\"267\":1}}],[\"∞\",{\"1\":{\"271\":1}}],[\"于是在进行索引扫描的时候\",{\"1\":{\"271\":1}}],[\"哪一个字段用到了联合索引\",{\"1\":{\"271\":2}}],[\"例子二\",{\"1\":{\"271\":1}}],[\"例子一\",{\"1\":{\"271\":1}}],[\"例如使用一个static\",{\"1\":{\"729\":1}}],[\"例如使用异步将主数据库的数据同步到从数据库\",{\"1\":{\"115\":1}}],[\"例如integer对象头就已经占用16字节\",{\"1\":{\"729\":1}}],[\"例如自己写一个java\",{\"1\":{\"715\":1}}],[\"例如public\",{\"1\":{\"704\":1}}],[\"例如该类要使用的其他类\",{\"1\":{\"703\":1}}],[\"例如函数的参数类型是否正确\",{\"1\":{\"703\":1}}],[\"例如这个类是否有父类\",{\"1\":{\"703\":1}}],[\"例如这个对象是哪个类的实例\",{\"1\":{\"652\":1}}],[\"例如是否以魔数开头\",{\"1\":{\"703\":1}}],[\"例如在一个循环内对同一个对象进行加锁解锁\",{\"1\":{\"617\":1}}],[\"例如在秒杀场景下\",{\"1\":{\"357\":1}}],[\"例如堆主要用来存放对象实例\",{\"1\":{\"574\":1}}],[\"例如游戏中的每一个英雄都有血量\",{\"1\":{\"486\":1}}],[\"例如javac\",{\"1\":{\"466\":1}}],[\"例如不存在无参构造\",{\"1\":{\"443\":1}}],[\"例如写1\",{\"1\":{\"429\":1}}],[\"例如引用程序释放锁的逻辑挂掉\",{\"1\":{\"374\":1}}],[\"例如如果创建了一个\",{\"1\":{\"271\":1}}],[\"例如将10万条数据分成两个5万条数据\",{\"1\":{\"250\":1}}],[\"例如转账业务中\",{\"1\":{\"231\":1}}],[\"例如客户端只是需要某个对象的一部分\",{\"1\":{\"181\":1}}],[\"例如\",{\"1\":{\"174\":1,\"345\":1,\"362\":2,\"451\":1,\"725\":1,\"726\":1}}],[\"例如网关微服务只用来做请求转发\",{\"1\":{\"144\":1}}],[\"例如a能访问外网\",{\"1\":{\"142\":1}}],[\"例如支付宝\",{\"1\":{\"133\":1}}],[\"例如支付宝支付成功之后会向对应的接口发送异步通知\",{\"1\":{\"131\":1}}],[\"例如跨行转账\",{\"1\":{\"118\":1}}],[\"例如订单退款\",{\"1\":{\"117\":1}}],[\"例如yl\",{\"1\":{\"90\":1}}],[\"例如bindkey为\",{\"1\":{\"90\":1}}],[\"例如持久化\",{\"1\":{\"81\":1}}],[\"例如访问\",{\"1\":{\"66\":1}}],[\"例如请求\",{\"1\":{\"54\":1}}],[\"例如nginx\",{\"1\":{\"50\":1}}],[\"例如vpn\",{\"1\":{\"50\":1,\"142\":1}}],[\"联合使用\",{\"1\":{\"670\":1}}],[\"联合索引的最左匹配原则会一直向右匹配知道遇到范围查询就会停止匹配\",{\"1\":{\"271\":1}}],[\"联合索引就会失效\",{\"1\":{\"271\":1}}],[\"联合索引会失效\",{\"1\":{\"271\":1}}],[\"联合索引\",{\"0\":{\"270\":1},\"1\":{\"271\":3}}],[\"联合查询\",{\"1\":{\"243\":1}}],[\"叶子节点存储的是主键+列值\",{\"1\":{\"269\":1}}],[\"叶子节点也都是有序的\",{\"1\":{\"266\":1}}],[\"覆盖索引\",{\"0\":{\"269\":1}}],[\"覆盖索引和联合索引\",{\"0\":{\"268\":1}}],[\"辅助索引\",{\"1\":{\"267\":1}}],[\"辅助索引的data域存储响应记录主键的值而不是地址\",{\"1\":{\"262\":1}}],[\"库粗索引的查询速度很快\",{\"1\":{\"266\":1}}],[\"库存模块完成\",{\"1\":{\"155\":1}}],[\"库存模块负责库存解锁释放\",{\"1\":{\"71\":1}}],[\"库存预热快速扣减如何实现\",{\"0\":{\"161\":1}}],[\"库存预热快速扣减\",{\"0\":{\"160\":1},\"1\":{\"136\":1}}],[\"聚合操作\",{\"1\":{\"396\":1}}],[\"聚簇索引对于主键的排序查找和范围查找速度很快\",{\"1\":{\"266\":1}}],[\"聚簇索引少了一次读取数据的io操作\",{\"1\":{\"266\":1}}],[\"聚簇索引即索引结构和数据一起存放的索引\",{\"1\":{\"266\":1}}],[\"聚簇索引\",{\"0\":{\"266\":1}}],[\"聚簇索引与非聚簇索引\",{\"0\":{\"265\":1}}],[\"聚集索引\",{\"0\":{\"266\":1},\"1\":{\"262\":1}}],[\"普通索引的唯一作用就是为了快速查询数据\",{\"1\":{\"264\":1}}],[\"普通索引\",{\"1\":{\"264\":1}}],[\"普通模式\",{\"1\":{\"98\":1}}],[\"搜索是跳跃式的\",{\"1\":{\"635\":1}}],[\"搜索的时候如果找道对应的节点\",{\"1\":{\"262\":1}}],[\"搜索引擎通常会更青睐使用\",{\"1\":{\"180\":1}}],[\"搜索引擎优化\",{\"1\":{\"180\":1}}],[\"起到索引作用\",{\"1\":{\"262\":1}}],[\"次数的旋转操作\",{\"1\":{\"261\":1}}],[\"次数的旋转和变色操作\",{\"1\":{\"261\":1}}],[\"树\",{\"0\":{\"262\":1},\"1\":{\"262\":1}}],[\"树一样进行\",{\"1\":{\"261\":1}}],[\"树不同的是\",{\"1\":{\"261\":1}}],[\"树的叶节点data域保存了完整的数据记录\",{\"1\":{\"228\":1,\"262\":1}}],[\"反射获取class对象\",{\"0\":{\"509\":1}}],[\"反射的优缺点\",{\"0\":{\"508\":1}}],[\"反射的应用场景\",{\"0\":{\"507\":1}}],[\"反射可以获取任意一个类的所有属性和方法\",{\"1\":{\"506\":1}}],[\"反序列化的时候会检查serialversionuid是否和当前类的serialversionuid相同\",{\"1\":{\"505\":1}}],[\"反序列化\",{\"1\":{\"504\":1}}],[\"反之则不行\",{\"1\":{\"353\":1}}],[\"反之不一定\",{\"1\":{\"261\":1}}],[\"反而被经常修改\",{\"1\":{\"275\":1}}],[\"反向代理通过服务端代理转发请求例如nginx反向代理\",{\"1\":{\"142\":1}}],[\"反向代理通过在location里添加proxy\",{\"1\":{\"142\":1}}],[\"反向代理跟正向代理的区别是什么\",{\"0\":{\"142\":1}}],[\"反向代理和header\",{\"0\":{\"49\":1}}],[\"查看cms四个阶段中哪个阶段花的时间太长\",{\"1\":{\"735\":1}}],[\"查看fullgc前后的内存占用\",{\"1\":{\"729\":1}}],[\"查看任务是否执行完成以及获取任务执行结果的方法\",{\"1\":{\"612\":1}}],[\"查看指定哈希表中指定的字段是否存在\",{\"1\":{\"390\":1}}],[\"查看数据还有多久过期\",{\"1\":{\"326\":1}}],[\"查找18原本要遍历18次\",{\"1\":{\"635\":1}}],[\"查找时\",{\"1\":{\"635\":1}}],[\"查找实际的\",{\"1\":{\"456\":1}}],[\"查找附近商铺\",{\"1\":{\"406\":1}}],[\"查找大key\",{\"1\":{\"365\":1}}],[\"查找的时间复杂度是o\",{\"1\":{\"259\":1}}],[\"查询过多的数据\",{\"1\":{\"729\":1}}],[\"查询应该避免使用\",{\"1\":{\"729\":1}}],[\"查询队尾元素\",{\"1\":{\"537\":1}}],[\"查询队首元素\",{\"1\":{\"537\":2}}],[\"查询前都生成一个read\",{\"1\":{\"290\":1}}],[\"查询时\",{\"1\":{\"284\":1}}],[\"查询操作符左边为字符类型时发生了隐式转换\",{\"1\":{\"278\":1}}],[\"查询操作符左边为数值类型时发生了隐式转换\",{\"1\":{\"278\":1}}],[\"查询条件中使用\",{\"1\":{\"278\":1}}],[\"查询比如\",{\"1\":{\"278\":1}}],[\"查询速度非常快\",{\"1\":{\"266\":1}}],[\"查询效率非常高\",{\"1\":{\"243\":1}}],[\"查询遍历了整棵索引树\",{\"1\":{\"243\":1}}],[\"查询结果可能找到多个符合条件的行\",{\"1\":{\"243\":1}}],[\"查询执行的类型\",{\"1\":{\"243\":1}}],[\"查询中如果包含子查询或其他部分\",{\"1\":{\"243\":1}}],[\"查询优化器\",{\"1\":{\"243\":1}}],[\"查询优化器的优化会后\",{\"1\":{\"243\":1}}],[\"查询不命中的情况\",{\"1\":{\"229\":1}}],[\"查询缓存\",{\"1\":{\"226\":1}}],[\"查询sku信息保存至redis加速查询\",{\"1\":{\"158\":1}}],[\"查询近期的秒杀场次\",{\"1\":{\"158\":1}}],[\"查询空数据\",{\"1\":{\"153\":1}}],[\"查询权限信息封装\",{\"1\":{\"146\":1}}],[\"查询的字段是什么类型\",{\"1\":{\"278\":1}}],[\"查询的时间复杂度是o\",{\"1\":{\"259\":1}}],[\"查询的结果\",{\"1\":{\"243\":1}}],[\"查询的类型\",{\"1\":{\"243\":1}}],[\"查询的数据不是全部\",{\"1\":{\"34\":1}}],[\"查询的sql语句使用别名处理\",{\"1\":{\"33\":1}}],[\"查询内核数据是否准备就绪\",{\"1\":{\"22\":1}}],[\"左边\",{\"1\":{\"387\":1}}],[\"左右\",{\"1\":{\"300\":1}}],[\"左右子树也符合上述规则\",{\"1\":{\"259\":1}}],[\"左子树的所有节点值均小于根节点\",{\"1\":{\"259\":1}}],[\"哈希码\",{\"1\":{\"654\":1}}],[\"哈希\",{\"0\":{\"389\":1}}],[\"哈希表结构\",{\"1\":{\"599\":1}}],[\"哈希表\",{\"1\":{\"382\":1}}],[\"哈希表示键值对的集合\",{\"1\":{\"258\":1}}],[\"哈希槽\",{\"1\":{\"333\":1,\"334\":1}}],[\"哈希分片比较适合随机读写的场景\",{\"1\":{\"253\":1}}],[\"哈希分片\",{\"1\":{\"253\":1}}],[\"缺省\",{\"1\":{\"431\":1}}],[\"缺点2\",{\"1\":{\"302\":1}}],[\"缺点1\",{\"1\":{\"302\":1}}],[\"缺点\",{\"1\":{\"256\":1,\"266\":1,\"267\":1,\"408\":1,\"508\":1,\"683\":1}}],[\"缺一不可\",{\"1\":{\"194\":1}}],[\"灵活组合多种分片算法\",{\"1\":{\"253\":1}}],[\"灵活的路由\",{\"1\":{\"78\":1,\"81\":1}}],[\"融合算法\",{\"1\":{\"253\":1}}],[\"很难通过复制来解决这个问题\",{\"1\":{\"725\":1}}],[\"很快\",{\"1\":{\"416\":1}}],[\"很明显需要继承\",{\"1\":{\"712\":1}}],[\"很明显\",{\"1\":{\"304\":1}}],[\"很相似\",{\"1\":{\"304\":1}}],[\"很多newsql数据库都支持地理位置分片算法\",{\"1\":{\"253\":1}}],[\"很可能消息接收到但是业务处理出现异常\",{\"1\":{\"101\":1}}],[\"地理空间索引\",{\"1\":{\"404\":1}}],[\"地理位置\",{\"1\":{\"308\":1}}],[\"地理位置分片\",{\"1\":{\"253\":1}}],[\"地址冲突\",{\"1\":{\"353\":1}}],[\"地址映射关系\",{\"1\":{\"214\":1}}],[\"地址有一个特殊地址\",{\"1\":{\"213\":1}}],[\"地址也就可能发生改变\",{\"1\":{\"213\":1}}],[\"地址也有一些别称\",{\"1\":{\"213\":1}}],[\"地址不具有这些性质\",{\"1\":{\"213\":1}}],[\"地址具有可携带性\",{\"1\":{\"213\":1}}],[\"地址是邮政地址\",{\"1\":{\"213\":1}}],[\"地址是身份证号\",{\"1\":{\"213\":1}}],[\"地址是一个网络设备真正的身份证号\",{\"1\":{\"213\":1}}],[\"地址只是一种不重复的定位方式\",{\"1\":{\"213\":1}}],[\"地址唯一标识\",{\"1\":{\"213\":2}}],[\"地址资源短缺的问题\",{\"1\":{\"211\":1}}],[\"地址资源充足\",{\"1\":{\"210\":1}}],[\"地址访问互联网\",{\"1\":{\"211\":1}}],[\"地址耗尽的问题\",{\"1\":{\"210\":1}}],[\"地址来判断数据包的目的地\",{\"1\":{\"209\":1}}],[\"地址来标识该\",{\"1\":{\"174\":1}}],[\"地址上托管多个域名\",{\"1\":{\"181\":1}}],[\"地址\",{\"0\":{\"213\":1},\"1\":{\"174\":1,\"185\":3,\"191\":1,\"210\":1,\"211\":5,\"213\":4,\"214\":1}}],[\"地址的全称是\",{\"1\":{\"213\":1}}],[\"地址的一些问题\",{\"1\":{\"174\":1}}],[\"地址的映射问题\",{\"1\":{\"172\":1,\"184\":1}}],[\"地址转为地址显示即可\",{\"1\":{\"242\":1}}],[\"地址转为整型\",{\"1\":{\"242\":1}}],[\"地址转\",{\"1\":{\"174\":1}}],[\"地址才是物理地址\",{\"1\":{\"174\":1,\"214\":1}}],[\"地址属于逻辑地址\",{\"1\":{\"174\":1,\"214\":1}}],[\"地址解析协议\",{\"1\":{\"174\":1,\"214\":1}}],[\"范围的缓存数据\",{\"1\":{\"471\":1}}],[\"范围是beanname\",{\"1\":{\"435\":1}}],[\"范围内的其他元素\",{\"1\":{\"405\":1}}],[\"范围内的所有元素\",{\"1\":{\"345\":1,\"362\":1}}],[\"范围分片\",{\"1\":{\"253\":1}}],[\"范围请求的标识码\",{\"1\":{\"181\":1}}],[\"备份时间越来越长\",{\"1\":{\"252\":1}}],[\"吧一张行比较多的表拆分为多张表\",{\"1\":{\"251\":1}}],[\"水平分表\",{\"1\":{\"251\":1}}],[\"水平分库是把同一个表按一定规则拆分到不同的数据库中\",{\"1\":{\"250\":1}}],[\"垂直分表\",{\"1\":{\"251\":1}}],[\"垂直分库就是把单一数据库按照业务进行划分\",{\"1\":{\"250\":1}}],[\"到jvm中\",{\"1\":{\"709\":1}}],[\"到底多大的对象会被直接扔到老年代\",{\"0\":{\"686\":1}}],[\"到底是如何执行查询的\",{\"1\":{\"243\":1}}],[\"到了\",{\"1\":{\"550\":1}}],[\"到页面展示到底发生了什么\",{\"0\":{\"178\":1}}],[\"速度很快\",{\"1\":{\"683\":1,\"687\":1}}],[\"速度很慢的情况\",{\"1\":{\"57\":1}}],[\"速度非常慢\",{\"1\":{\"416\":1}}],[\"速度非常快\",{\"1\":{\"416\":1}}],[\"速度更快\",{\"1\":{\"243\":1,\"416\":1}}],[\"命中直接返回\",{\"1\":{\"360\":1}}],[\"命令追加\",{\"1\":{\"411\":1}}],[\"命令删除对应的\",{\"1\":{\"374\":1}}],[\"命令是可以帮助我们实现互斥\",{\"1\":{\"374\":1}}],[\"命令生成\",{\"1\":{\"363\":1}}],[\"命令同时执行\",{\"1\":{\"334\":1}}],[\"命令执行\",{\"1\":{\"331\":1,\"344\":1}}],[\"命令排队\",{\"1\":{\"331\":1,\"344\":1}}],[\"命令回复处理器\",{\"1\":{\"321\":1}}],[\"命令请求处理器\",{\"1\":{\"321\":1}}],[\"命令\",{\"0\":{\"362\":1},\"1\":{\"313\":1,\"363\":1,\"384\":1,\"387\":1,\"390\":1,\"393\":1,\"396\":1,\"399\":1,\"402\":1,\"405\":2}}],[\"命令可以实现一个最简易的分布式锁\",{\"1\":{\"309\":1,\"385\":1}}],[\"命令来分析\",{\"1\":{\"243\":1}}],[\"命名管道\",{\"1\":{\"9\":1}}],[\"显示数据时\",{\"1\":{\"242\":1}}],[\"共有\",{\"1\":{\"382\":1}}],[\"共有两种\",{\"1\":{\"240\":1}}],[\"共同的关注点\",{\"1\":{\"684\":1}}],[\"共同喜好等功能\",{\"1\":{\"392\":1}}],[\"共同关注\",{\"1\":{\"314\":1,\"394\":1}}],[\"共同粉丝\",{\"1\":{\"314\":1,\"392\":1,\"394\":1}}],[\"共同好友\",{\"1\":{\"314\":1,\"394\":1}}],[\"共同点\",{\"1\":{\"299\":1,\"487\":1}}],[\"共享\",{\"1\":{\"623\":1}}],[\"共享锁\",{\"1\":{\"239\":1,\"285\":1}}],[\"共享锁和排他锁区别\",{\"0\":{\"239\":1}}],[\"共享内存\",{\"1\":{\"9\":1}}],[\"独占\",{\"1\":{\"623\":1}}],[\"独占锁\",{\"1\":{\"239\":1}}],[\"独一无二\",{\"1\":{\"529\":1}}],[\"独立部署\",{\"0\":{\"157\":1,\"159\":1},\"1\":{\"136\":1}}],[\"行锁只能锁住已经存在的行\",{\"1\":{\"282\":1}}],[\"行锁默认使用的是\",{\"1\":{\"238\":1}}],[\"行级锁和存储引擎有关\",{\"1\":{\"237\":1}}],[\"行级锁能大大减少数据库操作的冲突\",{\"1\":{\"237\":1}}],[\"行级锁\",{\"1\":{\"237\":1}}],[\"行级锁的粒度更小\",{\"1\":{\"237\":1}}],[\"临时顺序\",{\"1\":{\"380\":1}}],[\"临时顺序节点\",{\"1\":{\"379\":1}}],[\"临时节点会话消失则对应的节点消失\",{\"1\":{\"380\":1}}],[\"临时节点相比持久节点\",{\"1\":{\"380\":1}}],[\"临时节点只能做叶子节点\",{\"1\":{\"380\":1}}],[\"临时节点的生命周期是与\",{\"1\":{\"380\":1}}],[\"临时\",{\"1\":{\"380\":1}}],[\"临时表\",{\"1\":{\"229\":1}}],[\"临键锁\",{\"1\":{\"238\":1,\"292\":1}}],[\"间隙锁\",{\"1\":{\"238\":1}}],[\"仅存在结点之间的关联关系\",{\"1\":{\"622\":1}}],[\"仅包含java应用程序运行时的必要环境\",{\"1\":{\"466\":1}}],[\"仅做个人学习\",{\"1\":{\"465\":1}}],[\"仅仅起占位作用\",{\"1\":{\"654\":1}}],[\"仅仅是追加命令到\",{\"1\":{\"416\":1}}],[\"仅仅支持表级锁\",{\"1\":{\"237\":1}}],[\"仅对相关的记录上锁即可\",{\"1\":{\"237\":1}}],[\"锁状态标志\",{\"1\":{\"654\":1}}],[\"锁是对自旋锁的一种改进\",{\"1\":{\"622\":1}}],[\"锁粗化\",{\"0\":{\"617\":1}}],[\"锁消除的主要判断依据来源于逃逸分析的数据支持\",{\"1\":{\"616\":1}}],[\"锁消除\",{\"0\":{\"616\":1}}],[\"锁主要存在四种状态\",{\"1\":{\"614\":1}}],[\"锁可以绑定多个条件\",{\"1\":{\"594\":1}}],[\"锁可以看做是悲观控制的模式\",{\"1\":{\"233\":1}}],[\"锁被释放之后\",{\"1\":{\"593\":2}}],[\"锁粒度更细\",{\"1\":{\"551\":1}}],[\"锁最终一定还是会被释放\",{\"1\":{\"372\":1}}],[\"锁服务是高可用的\",{\"1\":{\"372\":1}}],[\"锁只能被一个线程持有\",{\"1\":{\"372\":1}}],[\"锁则会被阻塞\",{\"1\":{\"285\":1}}],[\"锁不兼容\",{\"1\":{\"239\":1}}],[\"锁兼容\",{\"1\":{\"239\":1}}],[\"锁定它们的间隙\",{\"1\":{\"292\":1}}],[\"锁定读会对读取到的记录加锁\",{\"1\":{\"285\":1}}],[\"锁定读\",{\"0\":{\"285\":1}}],[\"锁定一个范围\",{\"1\":{\"238\":2,\"292\":1}}],[\"锁定库存\",{\"1\":{\"155\":1}}],[\"锁\",{\"0\":{\"236\":1},\"1\":{\"239\":2,\"240\":6,\"285\":4,\"618\":1}}],[\"锁和mvcc\",{\"1\":{\"233\":1}}],[\"幻读或不可重复读\",{\"1\":{\"282\":1}}],[\"幻读\",{\"1\":{\"232\":1,\"282\":1,\"292\":1}}],[\"脏读\",{\"1\":{\"232\":1,\"282\":1}}],[\"持久顺序\",{\"1\":{\"380\":1}}],[\"持久\",{\"1\":{\"380\":1}}],[\"持久性durability\",{\"1\":{\"231\":1}}],[\"持久化方式\",{\"1\":{\"416\":1}}],[\"持久化或者开启\",{\"1\":{\"416\":1}}],[\"持久化\",{\"1\":{\"98\":1,\"297\":1,\"299\":1}}],[\"性能较差一些\",{\"1\":{\"593\":1}}],[\"性能也很高效\",{\"1\":{\"374\":1}}],[\"性能的影响\",{\"1\":{\"350\":1}}],[\"性能非常高\",{\"1\":{\"298\":1}}],[\"性能更好\",{\"1\":{\"242\":1,\"593\":1}}],[\"性能太差\",{\"1\":{\"240\":1}}],[\"性能\",{\"1\":{\"228\":1}}],[\"性能极其好\",{\"1\":{\"79\":1}}],[\"索引集合\",{\"0\":{\"695\":1}}],[\"索引值为\",{\"1\":{\"693\":1}}],[\"索引失效是慢查询的主要原因之一\",{\"1\":{\"278\":1}}],[\"索引占用的空间也是很多的\",{\"1\":{\"277\":1}}],[\"索引过多\",{\"1\":{\"277\":1}}],[\"索引可以提高效率同样可以降低效率\",{\"1\":{\"276\":1}}],[\"索引并不是越多越好\",{\"1\":{\"276\":1}}],[\"索引下推是mysql\",{\"1\":{\"272\":1}}],[\"索引下推\",{\"0\":{\"272\":1}}],[\"索引a字段可以在联合索引的b+树中进行索引查询\",{\"1\":{\"271\":1}}],[\"索引就结束了\",{\"1\":{\"262\":1}}],[\"索引底层数据结构\",{\"0\":{\"257\":1}}],[\"索引需要占用一定的物理空间\",{\"1\":{\"256\":1}}],[\"索引是一种用于快速查询和检索数据的数据结构\",{\"1\":{\"256\":1}}],[\"索引\",{\"0\":{\"256\":1}}],[\"索引文件和数据文件是分离的\",{\"1\":{\"228\":1}}],[\"索引实现不同\",{\"1\":{\"228\":1}}],[\"优秀的地方\",{\"1\":{\"416\":2}}],[\"优缺点\",{\"1\":{\"302\":1}}],[\"优点\",{\"1\":{\"256\":1,\"266\":1,\"267\":1,\"508\":1,\"683\":1}}],[\"优化主从集群\",{\"0\":{\"422\":1}}],[\"优化改进得来\",{\"1\":{\"401\":1}}],[\"优化\",{\"1\":{\"243\":1}}],[\"优化器\",{\"1\":{\"226\":1}}],[\"优先选择回收价值最大的\",{\"1\":{\"684\":1}}],[\"优先选择距离当前磁头位置最近的请求进行服务\",{\"1\":{\"16\":1}}],[\"优先级越高\",{\"1\":{\"426\":1}}],[\"优先级任务队列\",{\"1\":{\"397\":1}}],[\"优先级最低\",{\"1\":{\"54\":1}}],[\"优先级最高\",{\"1\":{\"54\":1}}],[\"优先级第三\",{\"1\":{\"54\":2}}],[\"优先级第二\",{\"1\":{\"54\":1}}],[\"检查类的全名是否相同\",{\"1\":{\"714\":1}}],[\"检查该类是否已经加载过\",{\"1\":{\"714\":1}}],[\"检查语法是否正确\",{\"1\":{\"226\":1}}],[\"检验随机码是否正确\",{\"1\":{\"158\":1}}],[\"生成代理对象\",{\"1\":{\"440\":1}}],[\"生成\",{\"1\":{\"291\":1,\"416\":1}}],[\"生态完善\",{\"1\":{\"225\":1}}],[\"生产环境上\",{\"1\":{\"724\":1}}],[\"生产环境下的\",{\"1\":{\"378\":1}}],[\"生产消息的一方\",{\"1\":{\"83\":1}}],[\"生产者线程会向队列中添加数据\",{\"1\":{\"540\":1,\"631\":1}}],[\"生产者到rabbitmq\",{\"1\":{\"98\":1}}],[\"生产者将消息发送到交换器\",{\"1\":{\"92\":1}}],[\"生产者将消息发给交换器的时候需要指定一个routingkey\",{\"1\":{\"84\":1}}],[\"生产者把消息交由\",{\"1\":{\"83\":1}}],[\"生产者\",{\"0\":{\"83\":1},\"1\":{\"83\":1,\"84\":1}}],[\"社区活跃\",{\"1\":{\"225\":1}}],[\"兼容性好\",{\"1\":{\"225\":1}}],[\"兼容jms\",{\"1\":{\"74\":1}}],[\"文章信息\",{\"1\":{\"391\":1}}],[\"文章点赞\",{\"1\":{\"314\":1,\"394\":1}}],[\"文档丰富\",{\"1\":{\"225\":1}}],[\"文件格式验证\",{\"1\":{\"703\":1}}],[\"文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式\",{\"1\":{\"697\":1}}],[\"文件存储的是每一次写命令\",{\"1\":{\"416\":1}}],[\"文件存储的内容是经过压缩的二进制数据\",{\"1\":{\"416\":1}}],[\"文件版本号\",{\"0\":{\"692\":1}}],[\"文件体积很大\",{\"1\":{\"416\":1}}],[\"文件体积小\",{\"1\":{\"416\":1}}],[\"文件体积大于多少时执行重写\",{\"1\":{\"414\":1}}],[\"文件大小\",{\"1\":{\"416\":1}}],[\"文件大很多\",{\"1\":{\"416\":1}}],[\"文件没有被重写\",{\"1\":{\"416\":1}}],[\"文件来解决一些问题\",{\"1\":{\"416\":1}}],[\"文件进行分析\",{\"1\":{\"416\":1}}],[\"文件进行检查\",{\"1\":{\"415\":1}}],[\"文件是以特定的二进制格式保存的\",{\"1\":{\"416\":1}}],[\"文件是否完整\",{\"1\":{\"415\":1}}],[\"文件恢复数据\",{\"1\":{\"416\":1}}],[\"文件所保存的数据库状态一样\",{\"1\":{\"416\":1}}],[\"文件和原有的\",{\"1\":{\"416\":1}}],[\"文件很小\",{\"1\":{\"416\":1}}],[\"文件内容进行\",{\"1\":{\"415\":1}}],[\"文件替换旧的\",{\"1\":{\"414\":1}}],[\"文件保存的数据库状态与现有的数据库状态一致\",{\"1\":{\"414\":1}}],[\"文件的方法的数量\",{\"1\":{\"697\":1}}],[\"文件的字段的个数\",{\"1\":{\"696\":1}}],[\"文件的版本号\",{\"1\":{\"692\":1}}],[\"文件的头\",{\"1\":{\"691\":1}}],[\"文件的标志\",{\"1\":{\"691\":1}}],[\"文件的常量池里保存有大量的符号引用比如方法引用的符号引用\",{\"1\":{\"641\":1}}],[\"文件的工作不会阻塞主线程\",{\"1\":{\"416\":1}}],[\"文件的工作之后\",{\"1\":{\"414\":1}}],[\"文件的过程是比较繁重的\",{\"1\":{\"416\":1}}],[\"文件的末尾\",{\"1\":{\"414\":1}}],[\"文件的读\",{\"1\":{\"2\":1}}],[\"文件期间\",{\"1\":{\"414\":1}}],[\"文件重写操作\",{\"1\":{\"414\":1}}],[\"文件重写期间\",{\"1\":{\"414\":1}}],[\"文件重写\",{\"1\":{\"411\":1}}],[\"文件同步\",{\"1\":{\"411\":1}}],[\"文件写入\",{\"1\":{\"411\":1}}],[\"文件中其它的数据项目要求的顺序\",{\"1\":{\"698\":1}}],[\"文件中\",{\"1\":{\"346\":1}}],[\"文件中的变量占位符\",{\"1\":{\"29\":1}}],[\"文件\",{\"1\":{\"324\":1,\"414\":1,\"415\":1,\"416\":1,\"691\":1,\"698\":1}}],[\"文件事件派发器\",{\"1\":{\"321\":1}}],[\"文件事件处理器包含四个部分\",{\"1\":{\"321\":1}}],[\"文件事件处理器既实现了高性能的网络通信模型\",{\"1\":{\"320\":1}}],[\"文件事件处理器使用io多路复用程序来同时监听多个套接字\",{\"1\":{\"320\":1}}],[\"文件传输协议\",{\"1\":{\"172\":1,\"191\":1}}],[\"文件被删除\",{\"1\":{\"15\":1}}],[\"文件有相同的\",{\"1\":{\"15\":1}}],[\"文件系统\",{\"0\":{\"14\":1}}],[\"文件类型\",{\"1\":{\"8\":1}}],[\"文件加密等\",{\"1\":{\"2\":1}}],[\"文件管理\",{\"1\":{\"2\":1}}],[\"功能的实现\",{\"1\":{\"437\":1}}],[\"功能\",{\"1\":{\"306\":1}}],[\"功能完善\",{\"1\":{\"225\":1}}],[\"功能类似消息队列\",{\"1\":{\"77\":1}}],[\"成员变量\",{\"1\":{\"476\":1,\"622\":1}}],[\"成员包装类型不赋值就是null\",{\"1\":{\"470\":1}}],[\"成功获取锁的客户端在出现故障之后\",{\"1\":{\"379\":1}}],[\"成功获取锁的客户端在执行完业务流程之后\",{\"1\":{\"379\":1}}],[\"成功\",{\"1\":{\"375\":1}}],[\"成功消费后才会删除消息\",{\"1\":{\"360\":1}}],[\"成功消费之前不会丢失\",{\"1\":{\"360\":1}}],[\"成熟稳定\",{\"1\":{\"225\":1}}],[\"成为master节点\",{\"1\":{\"427\":1}}],[\"成为可选项\",{\"1\":{\"210\":1}}],[\"成为\",{\"1\":{\"48\":1}}],[\"结尾的对数据库操作的类\",{\"1\":{\"437\":1}}],[\"结尾的字符数组\",{\"1\":{\"311\":1}}],[\"结尾的文件都会在这个文件夹中寻找\",{\"1\":{\"53\":1}}],[\"结构的修改\",{\"1\":{\"222\":1}}],[\"语言层面的的常量概念\",{\"1\":{\"693\":1}}],[\"语言通过字节码的方式\",{\"1\":{\"689\":1}}],[\"语言\",{\"1\":{\"376\":1}}],[\"语言的单继承\",{\"1\":{\"695\":1}}],[\"语言的字符串是这样的\",{\"1\":{\"311\":1}}],[\"语言的最大区别是\",{\"1\":{\"222\":1}}],[\"语言中的字符串以空字符\",{\"1\":{\"311\":1}}],[\"语言中的字符串的长度通常是经过遍历计数来实现的\",{\"1\":{\"311\":1}}],[\"语言中的字符串被修改\",{\"1\":{\"311\":1}}],[\"语言中的字符串有如下提升\",{\"1\":{\"311\":1}}],[\"语言中的字符串\",{\"1\":{\"311\":1}}],[\"语言编写的\",{\"1\":{\"311\":1}}],[\"语言开发的开源数据库\",{\"1\":{\"297\":1}}],[\"语句中\",{\"1\":{\"243\":1}}],[\"语句在经过\",{\"1\":{\"243\":1}}],[\"语句\",{\"1\":{\"230\":1,\"239\":1,\"241\":1,\"284\":1}}],[\"语句更多的被数据库管理员\",{\"1\":{\"222\":1}}],[\"语句区别\",{\"0\":{\"222\":1}}],[\"语句和\",{\"0\":{\"222\":1}}],[\"语音\",{\"1\":{\"189\":1}}],[\"子加载器才会尝试自己加载\",{\"1\":{\"714\":1}}],[\"子线程2\",{\"1\":{\"625\":2}}],[\"子线程1\",{\"1\":{\"625\":2}}],[\"子类继承父类并不一定要重写父类方法\",{\"1\":{\"487\":1}}],[\"子类能对父类进行扩展\",{\"1\":{\"486\":1}}],[\"子类拥有父类的所有属性和方法\",{\"1\":{\"486\":1}}],[\"子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等\",{\"1\":{\"480\":1}}],[\"子类方法返回值类型比父类方法返回值类型更小或者是相等\",{\"1\":{\"480\":1}}],[\"子类抛出的异常应该小于或者等于父类\",{\"1\":{\"480\":1}}],[\"子节点的名称还具有顺序性\",{\"1\":{\"380\":2}}],[\"子节点删除就意味着锁被释放\",{\"1\":{\"379\":1}}],[\"子句进行条件过滤\",{\"1\":{\"243\":1}}],[\"子句和truncate\",{\"1\":{\"221\":1}}],[\"子查询中的第一个\",{\"1\":{\"243\":1}}],[\"子查询等复杂查询\",{\"1\":{\"243\":1}}],[\"子进程写入\",{\"1\":{\"416\":1}}],[\"子进程共享主进程的物理内存区域\",{\"1\":{\"409\":1}}],[\"子进程是fork主进程得到的\",{\"1\":{\"409\":1}}],[\"子进程执行\",{\"1\":{\"363\":1,\"409\":1}}],[\"子进程被称为\",{\"1\":{\"10\":1}}],[\"子进程已经终止\",{\"1\":{\"10\":1}}],[\"列表\",{\"0\":{\"386\":1},\"1\":{\"288\":1,\"290\":2,\"308\":1,\"382\":1}}],[\"列表示根据表统计信息及选用情况\",{\"1\":{\"243\":1}}],[\"列表示\",{\"1\":{\"243\":2}}],[\"列表示哪个索引被使用了\",{\"1\":{\"243\":1}}],[\"列也显示\",{\"1\":{\"243\":1}}],[\"列显示\",{\"1\":{\"243\":1}}],[\"列列出了使用到的索引\",{\"1\":{\"243\":1}}],[\"列名=值\",{\"1\":{\"221\":1}}],[\"列仍然可用\",{\"1\":{\"81\":1}}],[\"丢弃数据\",{\"1\":{\"221\":1}}],[\"删除队尾\",{\"1\":{\"537\":1}}],[\"删除队首\",{\"1\":{\"537\":2}}],[\"删除最新命令并重启即可恢复之前的状态\",{\"1\":{\"416\":1}}],[\"删除一个或多个哈希表字段\",{\"1\":{\"390\":1}}],[\"删除一个硬链接文件并不影响其他有相同inode\",{\"1\":{\"15\":1}}],[\"删除指定的\",{\"1\":{\"384\":1}}],[\"删除也是同样道理\",{\"1\":{\"366\":1}}],[\"删除大key\",{\"1\":{\"365\":1}}],[\"删除操作\",{\"1\":{\"342\":1}}],[\"删除\",{\"1\":{\"222\":1,\"532\":1}}],[\"删除和查询\",{\"1\":{\"222\":1}}],[\"删除某一行的数据\",{\"1\":{\"221\":1}}],[\"删除数据\",{\"1\":{\"221\":1}}],[\"删除异常的问题\",{\"1\":{\"220\":1}}],[\"插入时可能存在扩容过程\",{\"1\":{\"538\":1}}],[\"插入队列的对象必须是可比较大小的\",{\"1\":{\"634\":1}}],[\"插入队首\",{\"1\":{\"537\":1}}],[\"插入队尾\",{\"1\":{\"537\":2}}],[\"插入记录版本对当前事务并不可见\",{\"1\":{\"292\":1}}],[\"插入和删除在平均和最坏情况下的时间复杂度都是\",{\"1\":{\"260\":1}}],[\"插入数据前\",{\"1\":{\"242\":1}}],[\"插入异常\",{\"1\":{\"220\":1}}],[\"插件式存储引擎\",{\"1\":{\"226\":1}}],[\"插件机制\",{\"1\":{\"78\":1,\"81\":1}}],[\"→\",{\"1\":{\"219\":2,\"220\":2}}],[\"系主任\",{\"1\":{\"219\":2,\"220\":2}}],[\"系名\",{\"1\":{\"219\":3,\"220\":3}}],[\"系统变量所指定的路径下的所有类\",{\"1\":{\"711\":1}}],[\"系统会首先判断当前类是否被加载过\",{\"1\":{\"710\":1}}],[\"系统会切换到硬盘读写的中断处理程序中执行后续操作等\",{\"1\":{\"3\":1}}],[\"系统需要明确知道这个方法所处的位置\",{\"1\":{\"705\":1}}],[\"系统大部分时间用来io交互\",{\"1\":{\"609\":1}}],[\"系统占用资源\",{\"1\":{\"416\":1}}],[\"系统将写请求交给主数据库处理\",{\"1\":{\"247\":1}}],[\"系统复杂度提高\",{\"1\":{\"73\":1}}],[\"系统可用性降低\",{\"1\":{\"73\":1}}],[\"系统下\",{\"1\":{\"19\":1}}],[\"系统调用来回收子进程\",{\"1\":{\"10\":1}}],[\"系统调用\",{\"1\":{\"3\":1,\"18\":1}}],[\"∩z=空集合\",{\"1\":{\"219\":1}}],[\"班级内学号不能相同\",{\"1\":{\"219\":1}}],[\"班级\",{\"1\":{\"219\":4}}],[\"姓名\",{\"1\":{\"219\":9,\"220\":1}}],[\"学号\",{\"1\":{\"219\":10,\"220\":2}}],[\"必选\",{\"1\":{\"724\":1}}],[\"必不可少的\",{\"1\":{\"670\":1}}],[\"必须相等\",{\"1\":{\"492\":1}}],[\"必须实现对应的方法\",{\"1\":{\"487\":1}}],[\"必须向master声明自己的replication\",{\"1\":{\"420\":1}}],[\"必须包含相同数目的黑色节点\",{\"1\":{\"261\":1}}],[\"必定能确定属性y的值\",{\"1\":{\"219\":1}}],[\"必然行为\",{\"1\":{\"175\":1}}],[\"非空父类的类加载器无法找到相应的类\",{\"1\":{\"714\":1}}],[\"非公平模式\",{\"1\":{\"624\":1}}],[\"非公平锁\",{\"1\":{\"593\":1}}],[\"非常适合用于作为数据共享的通道\",{\"1\":{\"627\":1}}],[\"非常适合一些数据经常变化又对数据一致性要求没那么高的场景\",{\"1\":{\"304\":1}}],[\"非常不灵活\",{\"1\":{\"512\":1}}],[\"非静态方法属于实例对象\",{\"1\":{\"479\":1}}],[\"非商业用途\",{\"1\":{\"465\":1}}],[\"非阻塞算法来实现线程安全\",{\"1\":{\"630\":1}}],[\"非阻塞队列可以通过\",{\"1\":{\"630\":1}}],[\"非阻塞队列的典型例子是\",{\"1\":{\"630\":1}}],[\"非阻塞\",{\"1\":{\"299\":1}}],[\"非锁定一致性读\",{\"1\":{\"290\":1}}],[\"非数字开头的字符串会转化为0\",{\"1\":{\"278\":1}}],[\"非聚簇索引也依赖于有序的数据\",{\"1\":{\"267\":1}}],[\"非聚簇索引的叶子节点不是存放数据\",{\"1\":{\"267\":1}}],[\"非聚簇索引的叶子节点并不一定存放数据的指针\",{\"1\":{\"267\":1}}],[\"非聚簇索引即索引结构和数据分开存放的索引\",{\"1\":{\"267\":1}}],[\"非聚簇索引\",{\"0\":{\"267\":1}}],[\"非聚集索引\",{\"0\":{\"267\":1},\"1\":{\"262\":1}}],[\"非主属性都依赖于主键\",{\"1\":{\"219\":1}}],[\"非幂等\",{\"1\":{\"175\":1}}],[\"展示了第一范式到第二范式的过渡\",{\"1\":{\"219\":1}}],[\"典型值为\",{\"1\":{\"214\":1}}],[\"全屏障\",{\"1\":{\"579\":1}}],[\"全局作用域\",{\"1\":{\"451\":1}}],[\"全量同步和增量同步的区别\",{\"1\":{\"422\":1}}],[\"全量同步\",{\"0\":{\"420\":1},\"1\":{\"422\":1}}],[\"全文索引主要为了检索大文本数据中的关键字信息\",{\"1\":{\"264\":1}}],[\"全文索引\",{\"1\":{\"264\":1}}],[\"全表扫描\",{\"1\":{\"243\":1}}],[\"全称多路平衡查找树\",{\"1\":{\"262\":1}}],[\"全称\",{\"1\":{\"214\":1}}],[\"全称为\",{\"1\":{\"93\":1}}],[\"全\",{\"1\":{\"213\":1}}],[\"身份认证和权限相关\",{\"1\":{\"226\":1}}],[\"身份证号\",{\"1\":{\"219\":4}}],[\"身份证号永久地标识一个人的身份\",{\"1\":{\"213\":1}}],[\"身披\",{\"1\":{\"191\":1}}],[\"他们会随着竞争的激烈而逐渐升级\",{\"1\":{\"614\":1}}],[\"他们都是不安全的\",{\"1\":{\"175\":1}}],[\"他的身份证号才是他的\",{\"1\":{\"213\":1}}],[\"媒体访问控制地址\",{\"1\":{\"213\":1}}],[\"映射为公有\",{\"1\":{\"211\":1}}],[\"映射文件中\",{\"1\":{\"32\":1}}],[\"映射文件\",{\"1\":{\"30\":1}}],[\"路径\",{\"1\":{\"210\":1}}],[\"路由信息协议\",{\"1\":{\"174\":1}}],[\"路由键为order\",{\"1\":{\"158\":1}}],[\"路由键\",{\"1\":{\"83\":1,\"84\":1}}],[\"路由失效等连锁反应\",{\"1\":{\"60\":1}}],[\"除此之外\",{\"1\":{\"383\":1}}],[\"除非这个对象的引用链上的任何一个对象建立关联\",{\"1\":{\"669\":1}}],[\"除非数据是被本身事务自己所修改\",{\"1\":{\"282\":1}}],[\"除非出现网络故障或broker服务出现问题\",{\"1\":{\"97\":1}}],[\"除了追求低停顿外\",{\"1\":{\"684\":1}}],[\"除了使用多线程进行垃圾收集外\",{\"1\":{\"679\":1}}],[\"除了\",{\"1\":{\"624\":1,\"679\":1,\"695\":1,\"711\":1,\"712\":1}}],[\"除了提供了更为好用和强大的\",{\"1\":{\"613\":1}}],[\"除了抽象了线程和内存之间的关系之外\",{\"1\":{\"572\":1}}],[\"除了具备临时\",{\"1\":{\"380\":1}}],[\"除了具有持久\",{\"1\":{\"380\":1}}],[\"除了这些\",{\"1\":{\"362\":1}}],[\"除了这些时间复杂度为o\",{\"1\":{\"345\":1}}],[\"除了会消耗很多的内存和带宽\",{\"1\":{\"337\":1}}],[\"除了做缓存\",{\"0\":{\"306\":1}}],[\"除了意向共享锁\",{\"1\":{\"240\":1}}],[\"除了更大的地址空间之外\",{\"1\":{\"210\":1}}],[\"源ip地址用于标识数据包的发送来源\",{\"1\":{\"209\":1}}],[\"凡是接收窗口中的序号都接收并返回确认帧\",{\"1\":{\"205\":1}}],[\"凡位于发送窗口内的分组可以连续发送出去\",{\"1\":{\"204\":1}}],[\"表长时扩容\",{\"1\":{\"543\":1}}],[\"表明锁被释放\",{\"1\":{\"589\":1}}],[\"表明查询使用了\",{\"1\":{\"243\":1}}],[\"表明查询使用了覆盖索引\",{\"1\":{\"243\":1}}],[\"表明到这个分组为止的所有分组都已经正确收到了\",{\"1\":{\"204\":1}}],[\"表中最多只有一行匹配的记录\",{\"1\":{\"243\":1}}],[\"表级锁\",{\"1\":{\"237\":1}}],[\"表级锁和行级锁对比\",{\"1\":{\"237\":1}}],[\"表级锁和行级锁了解吗\",{\"0\":{\"237\":1}}],[\"表名作用类似\",{\"1\":{\"221\":1}}],[\"表名\",{\"1\":{\"221\":3,\"243\":1}}],[\"表记录了某些其他网络设备的\",{\"1\":{\"214\":1}}],[\"表\",{\"1\":{\"214\":1}}],[\"表示要写入文件的路径\",{\"1\":{\"725\":1}}],[\"表示方法表\",{\"1\":{\"697\":1}}],[\"表示方法的数量\",{\"1\":{\"697\":1}}],[\"表示阻塞队列\",{\"1\":{\"627\":1}}],[\"表示这是这一代最后一个线程到达栅栏\",{\"1\":{\"626\":1}}],[\"表示同步状态\",{\"1\":{\"622\":1}}],[\"表示线程运行完毕\",{\"1\":{\"561\":1}}],[\"表示一个对象具有多种状态\",{\"1\":{\"486\":1}}],[\"表示bean工厂\",{\"1\":{\"452\":1}}],[\"表示不再做从节点\",{\"1\":{\"427\":1}}],[\"表示扫描过程中每次扫描后休息的时间间隔为\",{\"1\":{\"338\":1}}],[\"表示最后一次插入或更新该行的事务\",{\"1\":{\"287\":1}}],[\"表示当被驱动表的没有使用索引的时候\",{\"1\":{\"243\":1}}],[\"表示查询优化器选择使用了索引条件下推这个特性\",{\"1\":{\"243\":1}}],[\"表示开启了\",{\"1\":{\"243\":1}}],[\"表示接收到了断开连接的请求\",{\"1\":{\"196\":1}}],[\"表示消费者收到消息后的确认方式\",{\"1\":{\"101\":1}}],[\"表示前面的转义出现0或者1次\",{\"1\":{\"66\":1}}],[\"表示前面的正则出现0或者多次\",{\"1\":{\"66\":1}}],[\"表示匹配任何字符\",{\"1\":{\"66\":1}}],[\"表示监听443端口即https\",{\"1\":{\"62\":1}}],[\"表示普通匹配字符\",{\"1\":{\"54\":1}}],[\"表示访问\",{\"1\":{\"48\":1}}],[\"连cas操作都不做了\",{\"1\":{\"619\":1}}],[\"连表查询的方式\",{\"1\":{\"243\":1}}],[\"连续\",{\"1\":{\"204\":1}}],[\"连接拒绝\",{\"1\":{\"370\":1}}],[\"连接应答处理器\",{\"1\":{\"321\":1}}],[\"连接器\",{\"1\":{\"226\":1}}],[\"连接的每一方都有固定大小的缓冲空间\",{\"1\":{\"199\":1}}],[\"连接上的所有流被阻塞\",{\"1\":{\"190\":1}}],[\"连接上使用了多路复用\",{\"1\":{\"190\":1}}],[\"连接传输的数据\",{\"1\":{\"188\":1}}],[\"连接方式\",{\"1\":{\"181\":1}}],[\"连接结束\",{\"1\":{\"178\":1}}],[\"连接\",{\"1\":{\"2\":1,\"97\":1,\"178\":1}}],[\"谢希仁\",{\"1\":{\"203\":1}}],[\"详见类文件结构\",{\"1\":{\"703\":1}}],[\"详见aqs抽象队列同步器\",{\"1\":{\"592\":1}}],[\"详见synchronized锁优化\",{\"1\":{\"587\":1}}],[\"详见\",{\"1\":{\"203\":1}}],[\"详见☀️rabbitmq\",{\"1\":{\"158\":1}}],[\"详见☀️缓存穿透\",{\"1\":{\"153\":1}}],[\"详见☀️15分钟学会jwt的使用\",{\"1\":{\"150\":1}}],[\"详见☀️正向代理和反向代理\",{\"1\":{\"142\":1}}],[\"详见☀️nginx负载均衡\",{\"1\":{\"140\":1}}],[\"较为消耗性能\",{\"1\":{\"420\":1}}],[\"较为空闲的服务器\",{\"1\":{\"60\":1}}],[\"较好的方法是先探测一下\",{\"1\":{\"201\":1}}],[\"经过编译而来\",{\"1\":{\"709\":1}}],[\"经过真正的宣告对象死亡\",{\"1\":{\"669\":1}}],[\"经过一段时间之后\",{\"1\":{\"120\":1}}],[\"经常会用到自旋操作来进行重试\",{\"1\":{\"585\":1}}],[\"经验表明\",{\"1\":{\"201\":1}}],[\"能让使用者明确指定在一个长度为\",{\"1\":{\"684\":1}}],[\"能充分利用\",{\"1\":{\"684\":1}}],[\"能轻易实现交集\",{\"1\":{\"392\":1}}],[\"能够在后台自动重写\",{\"1\":{\"416\":1}}],[\"能够唯一标示锁的随机字符串\",{\"1\":{\"375\":1}}],[\"能够提供更高的安全性和用户隐私保护\",{\"1\":{\"180\":1}}],[\"能返回所有key被访问的次数\",{\"1\":{\"342\":1}}],[\"能提示发送方降低发送的速率\",{\"1\":{\"199\":1}}],[\"再就是二者的回收过程不同\",{\"1\":{\"685\":1}}],[\"再清空旧region\",{\"1\":{\"684\":1}}],[\"再修改tams指针\",{\"1\":{\"684\":1}}],[\"再将修改完的副本替换原来的数据\",{\"1\":{\"629\":1}}],[\"再将缓存中对应的key删除\",{\"1\":{\"360\":1}}],[\"再做处理\",{\"1\":{\"507\":1}}],[\"再通过反射去调用方法\",{\"1\":{\"442\":1}}],[\"再通过data值作为地址读取相应的数据\",{\"1\":{\"262\":1}}],[\"再进行主从同步\",{\"1\":{\"431\":1}}],[\"再把\",{\"1\":{\"302\":1}}],[\"再把数据放到cache中\",{\"1\":{\"302\":1}}],[\"再按照b字段值进行排序\",{\"1\":{\"271\":1}}],[\"再走一遍主索引\",{\"1\":{\"262\":1}}],[\"再遍历被驱动表与驱动表进行查询\",{\"1\":{\"243\":1}}],[\"再插入数据的时候自增长\",{\"1\":{\"221\":1}}],[\"再传输给网络层\",{\"1\":{\"199\":1}}],[\"再由数据库创建订单\",{\"1\":{\"70\":1}}],[\"认为是线程私有的\",{\"1\":{\"616\":1}}],[\"认为共享资源总是会被其他线程修改了\",{\"1\":{\"582\":1}}],[\"认为刚才发送过的分组丢失了\",{\"1\":{\"203\":1}}],[\"认为最适合发送的数据块\",{\"1\":{\"199\":1}}],[\"认证成功之后通过userid生成jwt返回给前端\",{\"1\":{\"146\":1}}],[\"认证成功则返回authentication\",{\"1\":{\"146\":1}}],[\"认证整体流程\",{\"1\":{\"146\":1}}],[\"断开服务器到客户端的数据传送\",{\"1\":{\"196\":1}}],[\"断开连接\",{\"0\":{\"195\":1}}],[\"断开连接的操作只会在client端进行\",{\"1\":{\"97\":1}}],[\"合并到\",{\"1\":{\"402\":1}}],[\"合并起来\",{\"0\":{\"196\":1}}],[\"合法性校验通过之后进行占位\",{\"1\":{\"158\":1}}],[\"随着更多类的创建\",{\"1\":{\"721\":1}}],[\"随着线程的创建而创建\",{\"1\":{\"640\":1}}],[\"随着记录在repl\",{\"1\":{\"420\":1}}],[\"随着aof文件越来越大\",{\"1\":{\"411\":1}}],[\"随着\",{\"1\":{\"362\":1}}],[\"随后\",{\"1\":{\"195\":1}}],[\"随机获取集合中的元素\",{\"1\":{\"394\":1}}],[\"随机获取集合中的元素并移除\",{\"1\":{\"394\":1}}],[\"随机获取指定集合中指定数量的元素\",{\"1\":{\"315\":1,\"393\":1}}],[\"随机点名等场景\",{\"1\":{\"394\":1}}],[\"随机点名等等\",{\"1\":{\"314\":1}}],[\"随机移除并获取指定集合中一个或多个元素\",{\"1\":{\"315\":1,\"393\":1}}],[\"随机码校验\",{\"1\":{\"162\":1}}],[\"随机挑选n个服务器\",{\"1\":{\"60\":1}}],[\"随机方式\",{\"1\":{\"60\":1}}],[\"随机\",{\"1\":{\"60\":1,\"140\":1}}],[\"四个字节存储的是\",{\"1\":{\"692\":1}}],[\"四者的区别\",{\"0\":{\"529\":1}}],[\"四次挥手\",{\"0\":{\"195\":1}}],[\"四层代理写法\",{\"1\":{\"139\":1}}],[\"自定义加载器的话\",{\"1\":{\"716\":1}}],[\"自定义类加载器\",{\"0\":{\"712\":1}}],[\"自身的一部分之外\",{\"1\":{\"711\":1}}],[\"自身调用\",{\"1\":{\"448\":1}}],[\"自然受到方法区内存的限制\",{\"1\":{\"646\":1}}],[\"自旋\",{\"1\":{\"615\":1}}],[\"自旋锁重试次数是固定的\",{\"1\":{\"615\":1}}],[\"自旋锁与自适应自旋\",{\"0\":{\"615\":1}}],[\"自旋锁\",{\"1\":{\"377\":1}}],[\"自平衡的排序二叉树\",{\"1\":{\"530\":1}}],[\"自带了给缓存数据设置过期时间的功能\",{\"1\":{\"326\":1}}],[\"自带的\",{\"1\":{\"306\":1,\"707\":1}}],[\"自动拆装箱\",{\"0\":{\"472\":1}}],[\"自动加载适当的启动器\",{\"1\":{\"463\":1}}],[\"自动配置各种功能\",{\"1\":{\"463\":1}}],[\"自动故障恢复\",{\"1\":{\"424\":1}}],[\"自动续期机制\",{\"1\":{\"376\":3}}],[\"自动内存碎片清理机制可能会对\",{\"1\":{\"350\":1}}],[\"自动重传请求\",{\"1\":{\"203\":1}}],[\"自动确认\",{\"1\":{\"101\":1}}],[\"自己发送\",{\"1\":{\"194\":3}}],[\"自己接收正常\",{\"1\":{\"194\":2}}],[\"二级缓存就能解决普通对象的循环依赖问题\",{\"1\":{\"450\":1}}],[\"二级缓存\",{\"1\":{\"343\":1}}],[\"二级索引又称为辅助索引\",{\"1\":{\"264\":1}}],[\"二级索引\",{\"0\":{\"264\":1},\"1\":{\"267\":1}}],[\"二进制安全\",{\"1\":{\"311\":1}}],[\"二进制应用层协议\",{\"1\":{\"74\":1}}],[\"二叉查找树是一种基于二叉树的数据结构\",{\"1\":{\"259\":1}}],[\"二叉查找树\",{\"0\":{\"259\":1}}],[\"二次握手\",{\"1\":{\"193\":1}}],[\"建议同时开启\",{\"1\":{\"416\":1}}],[\"建议使用\",{\"1\":{\"374\":1}}],[\"建议单张表索引不超过\",{\"1\":{\"276\":1}}],[\"建议在传输敏感数据时使用更安全的协议\",{\"1\":{\"172\":1,\"191\":1}}],[\"建立大顶堆\",{\"1\":{\"539\":1}}],[\"建立唯一索引的目的大部分都是为了属性列的数据唯一性\",{\"1\":{\"264\":1}}],[\"建立连接\",{\"0\":{\"193\":1}}],[\"建立在可靠的传输协议\",{\"1\":{\"191\":1}}],[\"利用beandefinition创建bean就是bean的创建生命周期\",{\"1\":{\"453\":1}}],[\"利用redis\",{\"1\":{\"431\":1}}],[\"利用cluster\",{\"1\":{\"431\":1}}],[\"利用滑动窗口实现流量控制\",{\"1\":{\"199\":1,\"200\":1}}],[\"利用\",{\"1\":{\"191\":1,\"309\":1,\"385\":1}}],[\"零往返时间\",{\"1\":{\"190\":1}}],[\"个阶段\",{\"1\":{\"700\":1}}],[\"个字节称为魔数\",{\"1\":{\"691\":1}}],[\"个条件的无用类进行回收\",{\"1\":{\"672\":1}}],[\"个条件才能算是\",{\"1\":{\"672\":1}}],[\"个线程阻塞在一个地方\",{\"1\":{\"625\":1}}],[\"个线程能获取到共享资源\",{\"1\":{\"624\":1}}],[\"个线程中只有\",{\"1\":{\"624\":1}}],[\"个线程来获取\",{\"1\":{\"624\":1}}],[\"个最重要的参数\",{\"1\":{\"605\":1}}],[\"个插槽\",{\"1\":{\"430\":1}}],[\"个\",{\"1\":{\"190\":2,\"276\":1,\"398\":1}}],[\"受到\",{\"1\":{\"190\":1}}],[\"视图\",{\"1\":{\"457\":1}}],[\"视图解析器\",{\"1\":{\"457\":1}}],[\"视图渲染\",{\"1\":{\"456\":1}}],[\"视为主要数据存储\",{\"1\":{\"303\":1}}],[\"视为进程的大脑\",{\"1\":{\"8\":1}}],[\"视频\",{\"1\":{\"189\":1,\"311\":1}}],[\"什么时候执行增量同步\",{\"1\":{\"422\":1}}],[\"什么时候执行全量同步\",{\"1\":{\"422\":1}}],[\"什么时候选\",{\"0\":{\"189\":1}}],[\"什么时候选择\",{\"0\":{\"189\":1}}],[\"什么情况下需要分库分表\",{\"0\":{\"252\":1}}],[\"什么是线程池\",{\"0\":{\"602\":1}}],[\"什么是悲观锁\",{\"0\":{\"582\":1}}],[\"什么是乐观锁\",{\"0\":{\"581\":1}}],[\"什么是本地内存\",{\"0\":{\"573\":1}}],[\"什么是主内存\",{\"0\":{\"573\":1}}],[\"什么是java内存模型\",{\"0\":{\"572\":1}}],[\"什么是死锁\",{\"0\":{\"562\":1}}],[\"什么是死信路由\",{\"0\":{\"93\":1}}],[\"什么是字节码\",{\"0\":{\"467\":1}}],[\"什么是单例池\",{\"0\":{\"436\":1}}],[\"什么是分表\",{\"0\":{\"251\":1}}],[\"什么是分库\",{\"0\":{\"250\":1}}],[\"什么是关系型数据库\",{\"0\":{\"224\":1}}],[\"什么是\",{\"0\":{\"213\":1,\"297\":1}}],[\"什么是ip地址\",{\"0\":{\"209\":1}}],[\"什么是延迟队列\",{\"0\":{\"94\":1}}],[\"什么是内存碎片\",{\"0\":{\"12\":1}}],[\"什么是僵尸进程和孤儿进程\",{\"0\":{\"10\":1}}],[\"什么是进程和线程\",{\"0\":{\"5\":1}}],[\"什么是用户态和内核态\",{\"0\":{\"3\":1}}],[\"～\",{\"1\":{\"188\":1}}],[\"拥塞避免算法的思路是让拥塞窗口\",{\"1\":{\"201\":1}}],[\"拥塞避免\",{\"1\":{\"201\":1}}],[\"拥塞控制\",{\"1\":{\"199\":1}}],[\"拥塞控制的影响\",{\"1\":{\"190\":1}}],[\"拥塞控制机制\",{\"1\":{\"188\":1}}],[\"拥有分析操作类的能力\",{\"1\":{\"508\":1}}],[\"拥有非常高的权限\",{\"1\":{\"3\":1}}],[\"拥有较低的权限\",{\"1\":{\"3\":1}}],[\"窗口\",{\"1\":{\"188\":1}}],[\"层级结构\",{\"1\":{\"185\":1}}],[\"层次结构中\",{\"1\":{\"185\":1}}],[\"权限\",{\"1\":{\"185\":1}}],[\"权重参数\",{\"1\":{\"405\":1}}],[\"权重越大\",{\"1\":{\"60\":1}}],[\"权重方式\",{\"1\":{\"60\":1}}],[\"权重\",{\"1\":{\"60\":1,\"140\":1}}],[\"国家也有自己的顶级域\",{\"1\":{\"185\":1}}],[\"顶级域是指域名的后缀\",{\"1\":{\"185\":1}}],[\"顶级域\",{\"1\":{\"185\":1}}],[\"我并不修改原有内容\",{\"1\":{\"629\":1}}],[\"我国境内目前仍没有根服务器\",{\"1\":{\"185\":1}}],[\"我们不需要自己手动实现\",{\"1\":{\"377\":1}}],[\"我们可以更好地利用虚拟内存硬件资源\",{\"1\":{\"726\":1}}],[\"我们可以设置参数\",{\"1\":{\"725\":1}}],[\"我们可以很方便地完成很多复杂的业务场景比如通过\",{\"1\":{\"306\":1}}],[\"我们可以自己约定参数的写法\",{\"1\":{\"175\":1}}],[\"我们都是基于\",{\"1\":{\"306\":1}}],[\"我们也就提高了系统整体的并发\",{\"1\":{\"300\":1}}],[\"我们在写\",{\"1\":{\"278\":1}}],[\"我们知道\",{\"1\":{\"175\":1}}],[\"我们通常约定get\",{\"1\":{\"175\":1}}],[\"我们网页就是通过\",{\"1\":{\"172\":1,\"191\":1}}],[\"我们的参数是写在\",{\"1\":{\"175\":1}}],[\"我们的应用程序实际上只是发起了\",{\"1\":{\"18\":1}}],[\"我们的应用程序对操作系统的内核发起\",{\"1\":{\"18\":1}}],[\"我们的春夏秋冬\",{\"1\":{\"0\":1}}],[\"我们后面介绍的分段机制就会导致外部内存碎片\",{\"1\":{\"12\":1}}],[\"根节点枚举都是需要stw的\",{\"1\":{\"687\":1}}],[\"根节点总是黑色\",{\"1\":{\"261\":1}}],[\"根\",{\"1\":{\"185\":2}}],[\"根据类的二进制名称来查找类\",{\"1\":{\"712\":1}}],[\"根据均值\",{\"1\":{\"685\":1}}],[\"根据虚拟机当前运行状态的不同\",{\"1\":{\"652\":1}}],[\"根据数据的变化来确定同步代码块是否多个线程抢占共享变量\",{\"1\":{\"618\":1}}],[\"根据应用场景不同\",{\"1\":{\"536\":1}}],[\"根据应用程序的业务需求和领域知识来对服务进行划分\",{\"1\":{\"144\":1}}],[\"根据handler返回的逻辑视图\",{\"1\":{\"457\":1}}],[\"根据handlermapping找到的handler\",{\"1\":{\"457\":1}}],[\"根据uri去匹配查找能处理的handler\",{\"1\":{\"457\":1}}],[\"根据请求信息调用\",{\"1\":{\"456\":1}}],[\"根据是否需要aop决定最后放入单例池中的对象是普通对象还是代理对象\",{\"1\":{\"450\":1}}],[\"根据得到的hash值\",{\"1\":{\"353\":1}}],[\"根据\",{\"1\":{\"285\":1,\"456\":1}}],[\"根据主键再回表查询数据\",{\"1\":{\"267\":1}}],[\"根据主索引搜索时\",{\"1\":{\"262\":1}}],[\"根据用户名查询用户信息\",{\"1\":{\"146\":1}}],[\"根据异常情况确认\",{\"1\":{\"101\":1}}],[\"端口>\",{\"1\":{\"429\":4}}],[\"端口为53\",{\"1\":{\"184\":1}}],[\"端口号\",{\"1\":{\"180\":1}}],[\"头插法可能会导致链表中的节点指向错误的位置\",{\"1\":{\"549\":1}}],[\"头字段\",{\"1\":{\"181\":2}}],[\"头\",{\"1\":{\"181\":1}}],[\"头域\",{\"1\":{\"181\":1}}],[\"带来非常大的执行开销\",{\"1\":{\"585\":1}}],[\"带参数的方法中的局部变量\",{\"1\":{\"476\":1}}],[\"带参数时\",{\"1\":{\"175\":1}}],[\"带宽\",{\"1\":{\"181\":1}}],[\"里面存储的是卡表的索引号\",{\"1\":{\"687\":1}}],[\"里面有一个内部类\",{\"1\":{\"592\":1}}],[\"里面的\",{\"1\":{\"30\":1}}],[\"里的\",{\"1\":{\"181\":1}}],[\"资源敏感\",{\"1\":{\"683\":1}}],[\"资源的场合\",{\"1\":{\"682\":1}}],[\"资源有序分配\",{\"1\":{\"564\":1}}],[\"资源和内存资源产生影响\",{\"1\":{\"416\":1}}],[\"资源消耗快\",{\"1\":{\"237\":1}}],[\"资源已被永久转移\",{\"1\":{\"181\":1}}],[\"资源都是在root后拼接路径\",{\"1\":{\"54\":1}}],[\"光是错误响应状态码就新增了\",{\"1\":{\"181\":1}}],[\"状态\",{\"0\":{\"197\":1},\"1\":{\"193\":3,\"195\":5}}],[\"状态响应码\",{\"1\":{\"181\":1}}],[\"状态码再发送\",{\"1\":{\"175\":1}}],[\"区的\",{\"1\":{\"662\":1}}],[\"区后对象的初始年龄变为\",{\"1\":{\"662\":1}}],[\"区\",{\"1\":{\"662\":1}}],[\"区域分配\",{\"1\":{\"662\":1}}],[\"区没有足够空间进行分配时\",{\"1\":{\"660\":1}}],[\"区分配\",{\"1\":{\"660\":1}}],[\"区分大小写\",{\"1\":{\"54\":1}}],[\"区别是\",{\"1\":{\"642\":1}}],[\"区别\",{\"0\":{\"181\":1,\"221\":1,\"534\":1,\"544\":1},\"1\":{\"299\":1,\"566\":1}}],[\"产生影响\",{\"1\":{\"180\":1}}],[\"加上大括号\",{\"1\":{\"430\":1}}],[\"加快fork速度\",{\"1\":{\"409\":1}}],[\"加载过了会直接返回\",{\"1\":{\"714\":1}}],[\"加载指定二进制名称的类\",{\"1\":{\"712\":1}}],[\"加载的呢\",{\"1\":{\"711\":1}}],[\"加载的\",{\"1\":{\"711\":1}}],[\"加载的类是不会被卸载的\",{\"1\":{\"707\":1}}],[\"加载这一步通过类加载器完成的\",{\"1\":{\"702\":1}}],[\"加载该类的\",{\"1\":{\"672\":1}}],[\"加载主要配置类\",{\"1\":{\"463\":1}}],[\"加载\",{\"0\":{\"702\":1},\"1\":{\"303\":1,\"700\":3}}],[\"加排他锁之前必须先取得该表的\",{\"1\":{\"240\":1}}],[\"加共享锁前必须先取得该表的\",{\"1\":{\"240\":1}}],[\"加锁的锁名\",{\"1\":{\"375\":1}}],[\"加锁慢\",{\"1\":{\"237\":1}}],[\"加锁粒度最小\",{\"1\":{\"237\":1}}],[\"加\",{\"1\":{\"201\":1}}],[\"加倍\",{\"1\":{\"201\":1}}],[\"加密采用对称加密\",{\"1\":{\"180\":1}}],[\"加入消息队列之后\",{\"1\":{\"73\":1}}],[\"之外\",{\"1\":{\"695\":1}}],[\"之外最好的\",{\"1\":{\"243\":1}}],[\"之间的比例为\",{\"1\":{\"726\":1}}],[\"之间的元素\",{\"1\":{\"396\":2}}],[\"之间\",{\"1\":{\"387\":1}}],[\"之父\",{\"1\":{\"378\":1}}],[\"之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小\",{\"1\":{\"721\":1}}],[\"之前运行时常量池逻辑包含字符串常量池存放在方法区\",{\"1\":{\"671\":1}}],[\"之前的方法区实现\",{\"1\":{\"645\":1}}],[\"之前的\",{\"1\":{\"550\":1}}],[\"之前值为\",{\"1\":{\"399\":1}}],[\"之前\",{\"0\":{\"546\":1},\"1\":{\"306\":1,\"530\":1,\"647\":1,\"664\":1}}],[\"之前已经提交的修改和该事务本身做的修改\",{\"1\":{\"286\":1}}],[\"之前是基于\",{\"1\":{\"190\":1}}],[\"之上进行了封装\",{\"1\":{\"303\":1}}],[\"之上的\",{\"1\":{\"180\":1}}],[\"之上\",{\"1\":{\"180\":2,\"191\":1}}],[\"之后变成元空间使用操作系统的空间\",{\"1\":{\"736\":1}}],[\"之后没有任何机制再次对其设置值\",{\"1\":{\"625\":1}}],[\"之后对synchronized\",{\"1\":{\"587\":1}}],[\"之后又有一个线程将b改为a\",{\"1\":{\"584\":1}}],[\"之后复用\",{\"1\":{\"467\":1}}],[\"之后aservice也完成创建周期\",{\"1\":{\"450\":1}}],[\"之后将rdb文件发送给从节点\",{\"1\":{\"420\":1}}],[\"之后的操作不会进行\",{\"1\":{\"334\":1}}],[\"之后其它事务所做的更新\",{\"1\":{\"292\":1}}],[\"之后出现的\",{\"1\":{\"243\":1}}],[\"之后请求会自动再次发送\",{\"1\":{\"179\":1}}],[\"之后还能解决高并发下的连接积压问题\",{\"1\":{\"141\":1}}],[\"之后在6379端口运行\",{\"1\":{\"107\":1}}],[\"之后\",{\"0\":{\"547\":1},\"1\":{\"93\":1,\"227\":1}}],[\"授权了也没用\",{\"1\":{\"179\":1}}],[\"几乎所有的对象实例以及数组都在这里分配内存\",{\"1\":{\"644\":1}}],[\"几乎所有的浏览器都会把post改成get\",{\"1\":{\"179\":1}}],[\"几乎所有现代电子邮件客户端和服务器都支持\",{\"1\":{\"172\":1,\"191\":1}}],[\"首次请求的数据一定不在cache中\",{\"1\":{\"302\":1}}],[\"首部开销\",{\"1\":{\"188\":3}}],[\"首部location字段标示重定向的url\",{\"1\":{\"179\":1}}],[\"首先\",{\"1\":{\"687\":1,\"714\":1}}],[\"首先cms是老年代的收集器\",{\"1\":{\"685\":1}}],[\"首先标记出所有不需要回收的对象\",{\"1\":{\"674\":1}}],[\"首先两者都不是线程安全的实现\",{\"1\":{\"534\":1}}],[\"首先会加载这个配置类\",{\"1\":{\"463\":1}}],[\"首先判断slave节点与master断开的时间长短\",{\"1\":{\"426\":1}}],[\"首先我们要有一个持久节点\",{\"1\":{\"379\":1}}],[\"首先要找到查找的下限\",{\"1\":{\"262\":1}}],[\"首先说明一点\",{\"1\":{\"175\":1}}],[\"首先需要考虑用户的数据应该存储在哪\",{\"1\":{\"146\":1}}],[\"首先是简历部分\",{\"1\":{\"136\":1}}],[\"报文段最长寿命\",{\"0\":{\"197\":1}}],[\"报文后\",{\"1\":{\"188\":1}}],[\"报文\",{\"1\":{\"178\":1}}],[\"浏览器\",{\"1\":{\"456\":2}}],[\"浏览器解析渲染页面\",{\"1\":{\"178\":1}}],[\"浏览器原因就不说了\",{\"1\":{\"175\":1}}],[\"浏览器与\",{\"1\":{\"172\":1,\"191\":1}}],[\"限制一个master节点上的slave节点\",{\"1\":{\"422\":1}}],[\"限制每张表上的索引数量\",{\"0\":{\"276\":1}}],[\"限制的大多是浏览器和服务器的原因\",{\"1\":{\"175\":1}}],[\"限流熔断降级如何实现\",{\"0\":{\"165\":1}}],[\"限流\",{\"0\":{\"70\":1},\"1\":{\"165\":1,\"306\":1,\"355\":1}}],[\"然而\",{\"1\":{\"175\":1,\"726\":1}}],[\"然后cms在可达性分析的时候有两个步骤需要stw\",{\"1\":{\"687\":1}}],[\"然后根据用户的期望停顿时间制定回收计划\",{\"1\":{\"684\":1}}],[\"然后根据哈希值确定数据应被放置在哪个表中\",{\"1\":{\"253\":1}}],[\"然后再把使用的空间一次清理掉\",{\"1\":{\"675\":1}}],[\"然后当前线程被阻塞\",{\"1\":{\"626\":1}}],[\"然后主线程调用countdown\",{\"1\":{\"625\":1}}],[\"然后自动调用run\",{\"1\":{\"568\":1}}],[\"然后用对象执行方法的方式解决问题\",{\"1\":{\"483\":1}}],[\"然后用户\",{\"1\":{\"316\":1}}],[\"然后筛选出非懒加载的单例beandefinition进行创建bean\",{\"1\":{\"453\":1}}],[\"然后判断slave节点的slave\",{\"1\":{\"426\":1}}],[\"然后直接删除cache\",{\"1\":{\"302\":1,\"360\":1}}],[\"然后在a字段相同的情况下\",{\"1\":{\"271\":1}}],[\"然后沿着记录所在的链表向后扫描\",{\"1\":{\"271\":1}}],[\"然后对b树进行中序遍历\",{\"1\":{\"262\":1}}],[\"然后从存储引擎返回数据\",{\"1\":{\"226\":1}}],[\"然后\",{\"1\":{\"195\":3,\"303\":1,\"625\":1}}],[\"然后客户端和服务器端都进入established\",{\"1\":{\"193\":1}}],[\"然后客户端进入\",{\"1\":{\"193\":1}}],[\"然后服务端进入\",{\"1\":{\"193\":1}}],[\"然后过滤器将authentication提交至认证管理器\",{\"1\":{\"146\":1}}],[\"然后分发给底层不同的\",{\"1\":{\"102\":1}}],[\"然后这个\",{\"1\":{\"102\":1}}],[\"然后将引用指向新的string对象\",{\"1\":{\"494\":1}}],[\"然后将代理对象放入单例池中\",{\"1\":{\"450\":1}}],[\"然后将\",{\"1\":{\"30\":1}}],[\"然后回到磁盘起点\",{\"1\":{\"16\":1}}],[\"然后改变移动方向\",{\"1\":{\"16\":1}}],[\"解锁happens\",{\"1\":{\"576\":1}}],[\"解锁规则\",{\"1\":{\"576\":1}}],[\"解锁逻辑挂了又会影响性能\",{\"1\":{\"375\":1}}],[\"解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程\",{\"1\":{\"705\":1}}],[\"解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程\",{\"1\":{\"705\":1}}],[\"解析动作主要针对类或接口\",{\"1\":{\"705\":1}}],[\"解析和初始化\",{\"1\":{\"649\":1}}],[\"解析并渲染真正的视图\",{\"1\":{\"457\":1}}],[\"解析查询的额外信息\",{\"1\":{\"243\":1}}],[\"解析方式分为迭代查询和递归查询\",{\"1\":{\"185\":1}}],[\"解析\",{\"0\":{\"705\":1},\"1\":{\"178\":1,\"700\":1}}],[\"解析报文的过程是通过获取\",{\"1\":{\"175\":1}}],[\"解决aba问题就是添加版本号或者是时间戳\",{\"1\":{\"584\":1}}],[\"解决办法就是在aservice创建普通对象之后存入一个lamda表达式到三级缓存中\",{\"1\":{\"450\":1}}],[\"解决办法\",{\"0\":{\"353\":1,\"355\":1,\"357\":1},\"1\":{\"302\":2,\"335\":1}}],[\"解决了\",{\"1\":{\"306\":1}}],[\"解决了单表的存储和性能瓶颈的问题\",{\"1\":{\"250\":1}}],[\"解决了饥饿问题\",{\"1\":{\"16\":1}}],[\"解决\",{\"1\":{\"153\":3}}],[\"解决并发安全问题\",{\"1\":{\"136\":1}}],[\"解决思想不同\",{\"1\":{\"132\":1}}],[\"边界网关协议\",{\"1\":{\"174\":1}}],[\"边扫描边观察算法\",{\"1\":{\"16\":1}}],[\"延迟阻塞队列\",{\"1\":{\"607\":1}}],[\"延迟加载\",{\"1\":{\"523\":1}}],[\"延迟等因素来选择最佳路径\",{\"1\":{\"174\":1}}],[\"延时加载\",{\"1\":{\"524\":1}}],[\"延时释放\",{\"1\":{\"335\":1,\"339\":1}}],[\"延时关单如何实现的\",{\"0\":{\"156\":1}}],[\"延时队列指的是存储对应的延时消息\",{\"1\":{\"94\":1}}],[\"延时很低\",{\"1\":{\"79\":1}}],[\"考虑以下几个问题\",{\"1\":{\"729\":1}}],[\"考虑\",{\"1\":{\"175\":1}}],[\"考虑了链路的带宽\",{\"1\":{\"174\":1}}],[\"考虑使用队列最大长度限制\",{\"1\":{\"103\":1}}],[\"上下文切换更频繁\",{\"1\":{\"593\":1}}],[\"上分配\",{\"1\":{\"470\":1}}],[\"上面的原则都是正确的\",{\"1\":{\"617\":1}}],[\"上面介绍到的分布式锁的实现会存在一些问题\",{\"1\":{\"378\":1}}],[\"上面说了\",{\"1\":{\"285\":1}}],[\"上\",{\"1\":{\"245\":1,\"333\":1,\"334\":1}}],[\"上的位置\",{\"1\":{\"174\":1}}],[\"上述代码中创建对象\",{\"1\":{\"486\":1}}],[\"上述流程在分布式下有时候不能保持登录状态\",{\"1\":{\"146\":1}}],[\"上述商品系统管理如果要实现ca\",{\"1\":{\"119\":1}}],[\"各线程之间计数器互不影响\",{\"1\":{\"640\":1}}],[\"各种lock实现可见性\",{\"1\":{\"577\":1}}],[\"各种监听器就是使用观察者模式\",{\"1\":{\"437\":1}}],[\"各种排行榜比如直播间送礼物的排行榜\",{\"1\":{\"397\":1}}],[\"各并发事务之间的数据库是独立的\",{\"1\":{\"231\":1}}],[\"各主机使用的是同一个\",{\"1\":{\"174\":1}}],[\"各个微服务之间的耦合度应该尽可能的小\",{\"1\":{\"144\":1}}],[\"各个微服务之间的调用变得更加灵活\",{\"1\":{\"144\":1}}],[\"互斥\",{\"1\":{\"372\":1,\"563\":1}}],[\"互斥锁\",{\"1\":{\"7\":1}}],[\"互联网中每一个资源都由\",{\"1\":{\"213\":1}}],[\"互联网服务提供商\",{\"1\":{\"185\":1}}],[\"互联网控制报文协议\",{\"1\":{\"174\":1}}],[\"物理地址\",{\"1\":{\"213\":1}}],[\"物理上的下一个目的地\",{\"1\":{\"174\":1,\"214\":1}}],[\"物理分页就是对sql进行改造\",{\"1\":{\"34\":1}}],[\"物理分页\",{\"1\":{\"34\":1}}],[\"总空间不变的情况下\",{\"1\":{\"730\":1}}],[\"总活跃用户数\",{\"1\":{\"316\":1}}],[\"总是需要知道下一跳\",{\"1\":{\"174\":1,\"214\":1}}],[\"总结\",{\"0\":{\"130\":1},\"1\":{\"422\":1}}],[\"总结起来解决方案大体包括\",{\"1\":{\"103\":1}}],[\"另一种用途是作为\",{\"1\":{\"681\":1}}],[\"另一种是较新的\",{\"1\":{\"174\":1}}],[\"另一个比较常用的与之对应的方法是\",{\"1\":{\"624\":1}}],[\"另一个作用是\",{\"1\":{\"289\":1}}],[\"另外一部分是类型指针\",{\"1\":{\"654\":1}}],[\"另外一个仍然能工作\",{\"1\":{\"115\":1}}],[\"另外如果对于某个锁自旋很少成功获得\",{\"1\":{\"615\":1}}],[\"另外是new在堆中创建的对象\",{\"1\":{\"497\":1}}],[\"另外还继承了其他接口例如environmentcapable\",{\"1\":{\"452\":1}}],[\"另外还能使用threadlocal解决线程安全问题\",{\"1\":{\"451\":1}}],[\"另外还用到了jmeter进行压力测试\",{\"1\":{\"137\":1}}],[\"另外在停止等待协议中若收到重复分组\",{\"1\":{\"203\":1}}],[\"另外\",{\"1\":{\"190\":1,\"350\":1,\"362\":1,\"652\":1,\"713\":1}}],[\"目录下的\",{\"1\":{\"711\":1}}],[\"目录会去子目录html中寻找页面或资源\",{\"1\":{\"48\":1}}],[\"目的是保证对于提交的任务\",{\"1\":{\"607\":1}}],[\"目的是检测数据在传输过程中的任何变化\",{\"1\":{\"199\":1}}],[\"目的主要是简化多线程编程\",{\"1\":{\"574\":1}}],[\"目的ip地址用来表示数据包的接收方设备地址\",{\"1\":{\"209\":1}}],[\"目前是原生支持\",{\"1\":{\"299\":1}}],[\"目前出现过的最大的事务\",{\"1\":{\"288\":1}}],[\"目前世界上只有\",{\"1\":{\"185\":1}}],[\"目前这两种协议都在使用\",{\"1\":{\"174\":1}}],[\"目前\",{\"1\":{\"174\":1}}],[\"尽管这次\",{\"1\":{\"664\":1}}],[\"尽可能避免全量同步\",{\"1\":{\"422\":1}}],[\"尽可能的考虑建立联合索引而不是单列索引\",{\"0\":{\"277\":1}}],[\"尽最大努力\",{\"1\":{\"173\":1}}],[\"尽量使用异步取代同步\",{\"1\":{\"115\":1}}],[\"面对内存不足错误是非常常见的\",{\"1\":{\"725\":1}}],[\"面向用户的加载器\",{\"1\":{\"711\":1}}],[\"面向整堆进行收集\",{\"1\":{\"685\":1}}],[\"面向过程把解决问题的过程拆成一个个方法\",{\"1\":{\"483\":1}}],[\"面向对象的三个特征\",{\"0\":{\"486\":1}}],[\"面向对象会先抽象出对象\",{\"1\":{\"483\":1}}],[\"面向对象和面向过程的区别\",{\"0\":{\"483\":1}}],[\"面向对象\",{\"0\":{\"482\":1}}],[\"面向连接\",{\"1\":{\"173\":1}}],[\"面经\",{\"0\":{\"43\":1}}],[\"均摊性能相比更慢\",{\"1\":{\"538\":1}}],[\"均以明文形式发送\",{\"1\":{\"172\":1,\"191\":1}}],[\"均衡循环扫描算法\",{\"1\":{\"16\":1}}],[\"远远比并发标记阶段时间短\",{\"1\":{\"683\":1}}],[\"远远好于\",{\"1\":{\"627\":1}}],[\"远程登录等等\",{\"1\":{\"189\":1}}],[\"远程登陆协议\",{\"1\":{\"172\":1}}],[\"远地主机在收到\",{\"1\":{\"188\":1}}],[\"远离磁头的请求长时间得不到响应\",{\"1\":{\"16\":1}}],[\"归档等高级功能\",{\"1\":{\"172\":1,\"191\":1}}],[\"邮件接收协议\",{\"1\":{\"172\":1}}],[\"要求\",{\"1\":{\"703\":1}}],[\"要更新的变量值\",{\"1\":{\"583\":1}}],[\"要等锁释放\",{\"1\":{\"579\":1}}],[\"要么所有的操作都能全部执行不会收到任何外界因素干扰而中断\",{\"1\":{\"577\":1}}],[\"要么都不完成\",{\"1\":{\"231\":1}}],[\"要么都不执行\",{\"1\":{\"230\":1,\"577\":1}}],[\"要么都执行\",{\"1\":{\"230\":1}}],[\"要么都失败\",{\"1\":{\"126\":1}}],[\"要么都成功\",{\"1\":{\"126\":1}}],[\"要释放当前线程占有的对象锁并让其进入waiting状态\",{\"1\":{\"567\":1}}],[\"要实现动态代理\",{\"1\":{\"514\":1}}],[\"要大\",{\"1\":{\"188\":1}}],[\"要解决的是域名和\",{\"1\":{\"184\":1}}],[\"要消耗比较多的资源\",{\"1\":{\"175\":1}}],[\"要想安全传输\",{\"1\":{\"175\":1}}],[\"要从邮件服务器接收邮件\",{\"1\":{\"172\":1,\"191\":1}}],[\"⚠️\",{\"1\":{\"172\":2,\"191\":2}}],[\"协议用来ip地址转mac地址\",{\"1\":{\"214\":1}}],[\"协议内容\",{\"1\":{\"213\":1}}],[\"协议可提高信道利用率\",{\"1\":{\"204\":1}}],[\"协议可以有效防止远程管理过程中的信息泄露问题\",{\"1\":{\"191\":1}}],[\"协议之上的协议\",{\"1\":{\"191\":2}}],[\"协议运行在\",{\"1\":{\"180\":1}}],[\"协议没有\",{\"1\":{\"175\":1}}],[\"协议是基于\",{\"1\":{\"175\":1}}],[\"协议是比\",{\"1\":{\"172\":1,\"191\":1}}],[\"协议中的一种请求方法\",{\"1\":{\"176\":1}}],[\"协议中没有明确说明\",{\"1\":{\"175\":1}}],[\"协议中两种请求方式\",{\"1\":{\"175\":1}}],[\"协议中最重要的协议之一\",{\"1\":{\"174\":1}}],[\"协议的特性\",{\"1\":{\"190\":1}}],[\"协议的\",{\"1\":{\"190\":1}}],[\"协议的网站在搜索结果中可能会被优先显示\",{\"1\":{\"180\":1}}],[\"协议的网站\",{\"1\":{\"180\":1}}],[\"协议的应用场景如同它的名称\",{\"1\":{\"174\":1}}],[\"协议的最大缺点之一是所有数据\",{\"1\":{\"172\":1,\"191\":1}}],[\"协议来测试网络连通性\",{\"1\":{\"174\":1}}],[\"协议解决了什么问题\",{\"0\":{\"214\":1}}],[\"协议解决了\",{\"1\":{\"174\":1}}],[\"协议解决的是网络层地址和链路层地址之间的转换问题\",{\"1\":{\"174\":1}}],[\"协议主要分为两种\",{\"1\":{\"174\":1}}],[\"协议只负责邮件的发送\",{\"1\":{\"172\":1,\"191\":1}}],[\"协议\",{\"1\":{\"172\":10,\"180\":1,\"190\":1,\"191\":9,\"214\":1}}],[\"⭐龙凤头浪花\",{\"1\":{\"168\":1}}],[\"⭐北部湾生态长廊\",{\"1\":{\"168\":1}}],[\"⭐长江澳风车田\",{\"1\":{\"168\":1}}],[\"⭐环岛路旁\",{\"1\":{\"168\":1}}],[\"⭐去北线的路上\",{\"1\":{\"168\":1}}],[\"⭐猴研岛\",{\"1\":{\"168\":1}}],[\"今年四月又来看海了\",{\"1\":{\"168\":1}}],[\"世间浪漫海占一半\",{\"0\":{\"168\":1}}],[\"平潭四月\",{\"0\":{\"167\":1}}],[\"平均寻道时间较长\",{\"1\":{\"16\":1}}],[\"释放许可证成功之后\",{\"1\":{\"624\":1}}],[\"释放1个许可\",{\"1\":{\"624\":1}}],[\"释放锁\",{\"1\":{\"376\":1,\"379\":1}}],[\"释放锁时\",{\"1\":{\"374\":1}}],[\"释放锁的话\",{\"1\":{\"374\":1}}],[\"释放资源\",{\"1\":{\"165\":1}}],[\"释放子进程占用的资源\",{\"1\":{\"10\":1}}],[\"牺牲自己\",{\"1\":{\"165\":1}}],[\"请注意\",{\"1\":{\"726\":1}}],[\"请通过关系表实现\",{\"1\":{\"228\":1}}],[\"请稍后再试\",{\"1\":{\"165\":1}}],[\"请求高峰期发生fullgc\",{\"1\":{\"735\":1}}],[\"请求并保持\",{\"1\":{\"563\":1}}],[\"请求处理器\",{\"1\":{\"457\":1}}],[\"请求会被dispatcherservlet拦截\",{\"1\":{\"456\":1}}],[\"请求会在服务器上创建新的资源\",{\"1\":{\"176\":1}}],[\"请求完成之后失效\",{\"1\":{\"451\":1}}],[\"请求数据库写数据到缓存之前\",{\"1\":{\"357\":1}}],[\"请求数据不存在\",{\"0\":{\"352\":1}}],[\"请求的key对应的是热点数据\",{\"1\":{\"358\":1}}],[\"请求的key不存在于redis也不存在于数据库中\",{\"1\":{\"358\":1}}],[\"请求的key是热点数据\",{\"1\":{\"356\":1}}],[\"请求的结果应该相同\",{\"1\":{\"176\":1}}],[\"请求与当前资源的规定冲突\",{\"1\":{\"181\":1}}],[\"请求\",{\"1\":{\"178\":1,\"302\":5}}],[\"请求不具有幂等性\",{\"1\":{\"176\":1}}],[\"请求时\",{\"1\":{\"176\":1,\"185\":1}}],[\"请求是\",{\"1\":{\"176\":1}}],[\"请求具有幂等性\",{\"1\":{\"176\":1}}],[\"请求进行加载的\",{\"1\":{\"172\":1,\"191\":1}}],[\"请求携带这个uuid才是正确的请求参数\",{\"1\":{\"162\":1}}],[\"请求负载均衡\",{\"0\":{\"138\":1},\"1\":{\"136\":1}}],[\"请求才到的话\",{\"1\":{\"16\":1}}],[\"服务\",{\"1\":{\"642\":1}}],[\"服务不兼容新版本的\",{\"1\":{\"416\":1}}],[\"服务干宕机\",{\"1\":{\"416\":1}}],[\"服务通常是集群化部署的\",{\"1\":{\"378\":1}}],[\"服务可能就就挂掉了\",{\"1\":{\"304\":1}}],[\"服务来负责\",{\"1\":{\"304\":1}}],[\"服务自己来写入缓存的\",{\"1\":{\"303\":1}}],[\"服务自己更新\",{\"1\":{\"303\":1}}],[\"服务负责将此数据读取和写入\",{\"1\":{\"303\":1}}],[\"服务端同时维护db和cache\",{\"1\":{\"302\":1}}],[\"服务端就会重发\",{\"1\":{\"197\":1}}],[\"服务端在收到\",{\"1\":{\"195\":1}}],[\"服务端进入\",{\"1\":{\"195\":1}}],[\"服务端关闭与客户端的连接并发送一个\",{\"1\":{\"195\":1}}],[\"服务端发送带有\",{\"1\":{\"193\":1}}],[\"服务端\",{\"1\":{\"193\":2}}],[\"服务端允许请求访问资源\",{\"1\":{\"179\":1}}],[\"服务端返回\",{\"1\":{\"175\":1}}],[\"服务器用新的\",{\"1\":{\"414\":1}}],[\"服务器会将重写缓冲区中的所有内容追加到新\",{\"1\":{\"414\":1}}],[\"服务器会返回一个表示新资源的\",{\"1\":{\"176\":1}}],[\"服务器检测到执行时间超过\",{\"1\":{\"346\":1}}],[\"服务器每秒可以执行的查询次数\",{\"1\":{\"300\":1}}],[\"服务器收到这个\",{\"1\":{\"195\":1}}],[\"服务器的\",{\"1\":{\"185\":2}}],[\"服务器提供了权威\",{\"1\":{\"185\":1}}],[\"服务器提供\",{\"1\":{\"185\":1}}],[\"服务器\",{\"1\":{\"185\":7,\"210\":1}}],[\"服务器有哪些\",{\"0\":{\"185\":1}}],[\"服务器处理请求并返回\",{\"1\":{\"178\":1}}],[\"服务器根据数据进行处理\",{\"1\":{\"176\":1}}],[\"服务器是因为处理长\",{\"1\":{\"175\":1}}],[\"服务器之间的通信而设计的\",{\"1\":{\"172\":1,\"191\":1}}],[\"服务器压力剧增时\",{\"1\":{\"165\":1}}],[\"服务单一职责\",{\"0\":{\"159\":1},\"1\":{\"159\":1}}],[\"降级是全局考虑\",{\"1\":{\"165\":1}}],[\"降级\",{\"1\":{\"165\":1}}],[\"降低停顿时间是\",{\"1\":{\"684\":1}}],[\"降低资源消耗\",{\"1\":{\"603\":1}}],[\"降低了资源消耗\",{\"1\":{\"321\":1}}],[\"降低sql执行效率\",{\"1\":{\"256\":1}}],[\"降低锁冲突\",{\"1\":{\"124\":1}}],[\"降低耦合度\",{\"1\":{\"71\":1}}],[\"降低系统耦合性\",{\"0\":{\"71\":1}}],[\"熔断是服务故障触发系统主动规则\",{\"1\":{\"165\":1}}],[\"熔断\",{\"1\":{\"165\":1}}],[\"快速列表\",{\"1\":{\"382\":1}}],[\"快速创建秒杀单之后写回数据库使用消息队列\",{\"1\":{\"306\":1}}],[\"快速扣减使用semaphore完成\",{\"1\":{\"161\":1}}],[\"快照可以进行数据库备份\",{\"1\":{\"416\":1}}],[\"快照持久化是redis默认采用的持久化方式\",{\"1\":{\"408\":1}}],[\"快照文件的话\",{\"1\":{\"363\":1}}],[\"快照文件\",{\"1\":{\"363\":1}}],[\"快照\",{\"0\":{\"363\":1}}],[\"快照即记录的历史版本\",{\"1\":{\"241\":1}}],[\"快照读的方式读取数据\",{\"1\":{\"292\":1}}],[\"快照读的情况下\",{\"1\":{\"241\":1}}],[\"快照读总是读取本事务开始时的行数据版本\",{\"1\":{\"241\":1}}],[\"快照读总是读取被锁定行的最新一份快照数据\",{\"1\":{\"241\":1}}],[\"快照读\",{\"1\":{\"241\":1,\"282\":1}}],[\"快照读和当前读的区别\",{\"0\":{\"241\":1}}],[\"快恢复\",{\"1\":{\"201\":1}}],[\"快重传\",{\"1\":{\"201\":1}}],[\"快重传与快恢复\",{\"1\":{\"201\":1}}],[\"快捷方式\",{\"1\":{\"15\":1}}],[\"参数表示在重新标记之前先对新生代进行垃圾清理\",{\"1\":{\"735\":1}}],[\"参数\",{\"1\":{\"726\":2}}],[\"参数的设置值是否允许担保失败\",{\"1\":{\"664\":1}}],[\"参数的时间单位\",{\"1\":{\"605\":1}}],[\"参数来设置\",{\"1\":{\"647\":1}}],[\"参数列表必须相同\",{\"1\":{\"480\":1}}],[\"参数设置耗时命令的最大记录条数\",{\"1\":{\"346\":1}}],[\"参数设置耗时命令的阈值\",{\"1\":{\"346\":1}}],[\"参数为cron表达式\",{\"1\":{\"159\":1}}],[\"参数不同时\",{\"0\":{\"30\":1}}],[\"验证类的正确性\",{\"1\":{\"703\":1}}],[\"验证字节流是否符合class文件格式的规范\",{\"1\":{\"703\":1}}],[\"验证阶段主要由四个检验阶段组成\",{\"1\":{\"703\":1}}],[\"验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的\",{\"1\":{\"703\":1}}],[\"验证是连接中的第一步\",{\"1\":{\"703\":1}}],[\"验证\",{\"0\":{\"703\":1},\"1\":{\"700\":2}}],[\"验证数据是否被其他线程修改可通过版本号机制或者cas算法\",{\"1\":{\"581\":1}}],[\"验证购买数量是否超额\",{\"1\":{\"158\":1}}],[\"验证成功之后再次验证价格\",{\"1\":{\"155\":1}}],[\"登录的话进行合法性校验\",{\"1\":{\"158\":1}}],[\"登录状态续期可以通过给redis添加新的过期时间进行续期\",{\"1\":{\"147\":1}}],[\"价格\",{\"1\":{\"155\":2}}],[\"保存的是字符串\",{\"1\":{\"647\":1}}],[\"保存的数据丢失一些也没什么影响的话\",{\"1\":{\"416\":1}}],[\"保存了将要执行指令的地址\",{\"1\":{\"640\":1}}],[\"保存字符串的数组是final修饰的\",{\"1\":{\"495\":1}}],[\"保存着某个时间点的数据集\",{\"1\":{\"416\":1}}],[\"保存文件的频率有三种\",{\"1\":{\"412\":1}}],[\"保存至redis用于后续秒杀的时间和场次合法性校验\",{\"1\":{\"158\":1}}],[\"保存订单数据\",{\"1\":{\"155\":1}}],[\"保证这些信息被当做代码运行后不会危害虚拟机自身的安全\",{\"1\":{\"703\":1}}],[\"保证内存分配时的线程安全\",{\"1\":{\"650\":1}}],[\"保证可见性\",{\"1\":{\"579\":1}}],[\"保证读写都串行化\",{\"1\":{\"579\":1}}],[\"保证线程安全\",{\"1\":{\"551\":1}}],[\"保证在整个系统中\",{\"1\":{\"518\":1}}],[\"保证bean是单例\",{\"1\":{\"436\":1}}],[\"保证数据的持久化\",{\"1\":{\"411\":1}}],[\"保证只有一个请求落到数据库上\",{\"1\":{\"357\":1}}],[\"保证了java程序的稳定运行\",{\"1\":{\"715\":1}}],[\"保证了\",{\"1\":{\"684\":1}}],[\"保证了共享变量的\",{\"1\":{\"579\":1}}],[\"保证了操作不会被其他指令插入或打扰\",{\"1\":{\"334\":1}}],[\"保证了信道私有性\",{\"1\":{\"97\":1}}],[\"保证任何节点的左右子树高度差的绝对值不超过1\",{\"1\":{\"260\":1}}],[\"保证主数据库和从数据库之间的数据是实时同步的\",{\"1\":{\"247\":1}}],[\"保证接收方来得及接收\",{\"1\":{\"200\":1}}],[\"保证其余功能可用\",{\"1\":{\"120\":1}}],[\"保证其超高吞吐量\",{\"1\":{\"79\":1}}],[\"保证消息传递顺序等问题\",{\"1\":{\"73\":1}}],[\"令牌的key和memberid有关\",{\"1\":{\"155\":1}}],[\"布隆过滤器判断一个数据存在\",{\"1\":{\"353\":1}}],[\"布隆过滤器判断不存在的数据则一定不存在\",{\"1\":{\"353\":1}}],[\"布隆过滤器可以判断一个数据在redis中是否存在\",{\"1\":{\"353\":1}}],[\"布隆过滤器\",{\"1\":{\"153\":1,\"353\":2}}],[\"读屏障\",{\"1\":{\"579\":1}}],[\"读数据时先查找缓存\",{\"1\":{\"360\":1}}],[\"读数据\",{\"1\":{\"302\":1}}],[\"读到直接返回\",{\"1\":{\"302\":1}}],[\"读到了没有提交的数据\",{\"1\":{\"232\":1}}],[\"读\",{\"1\":{\"302\":1,\"303\":1}}],[\"读请求交给从数据库处理\",{\"1\":{\"247\":1}}],[\"读取是完全不用加锁的\",{\"1\":{\"628\":1}}],[\"读取不到的话\",{\"1\":{\"303\":1}}],[\"读取到就直接返回\",{\"1\":{\"303\":1}}],[\"读取到了一个原本没有的数据\",{\"1\":{\"232\":1}}],[\"读取的都是最新的数据\",{\"1\":{\"292\":1}}],[\"读取的是数据的最新版本\",{\"1\":{\"285\":1}}],[\"读取之前的版本数据\",{\"1\":{\"289\":1}}],[\"读取已提交\",{\"1\":{\"282\":1}}],[\"读取未提交\",{\"1\":{\"282\":1}}],[\"读取操作不会因此去等待记录上x锁的释放\",{\"1\":{\"241\":1}}],[\"读取条件相同的情况下得到的结果却是不一样的\",{\"1\":{\"232\":1}}],[\"读写穿透\",{\"0\":{\"303\":1}}],[\"读写速度非常快\",{\"1\":{\"297\":1}}],[\"读写互斥\",{\"1\":{\"239\":1}}],[\"读写分离对提升数据库的并发非常有效\",{\"1\":{\"246\":1}}],[\"读写分离会带来什么问题\",{\"0\":{\"246\":1}}],[\"读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点\",{\"1\":{\"245\":1}}],[\"读写分离和分库分表\",{\"0\":{\"244\":1}}],[\"读写分离\",{\"0\":{\"245\":1},\"1\":{\"225\":1,\"343\":1}}],[\"读写锁\",{\"1\":{\"7\":1,\"377\":1}}],[\"读读不需要添加锁\",{\"1\":{\"152\":1}}],[\"失效后还要销毁\",{\"1\":{\"229\":1}}],[\"失效模式下如果有三个进程\",{\"1\":{\"152\":1}}],[\"失效模式\",{\"1\":{\"152\":2}}],[\"失败原因\",{\"1\":{\"99\":1}}],[\"​\",{\"1\":{\"150\":1,\"165\":1,\"342\":2}}],[\"+cmsscavengebeforeremark\",{\"1\":{\"735\":1}}],[\"+optimizestringconcat\",{\"1\":{\"726\":1}}],[\"+heapdumponoutofmemoryerror\",{\"1\":{\"725\":1}}],[\"+printsafepointstatistics\",{\"1\":{\"724\":1}}],[\"+printgcapplicationstoppedtime\",{\"1\":{\"724\":1}}],[\"+printgcdatestamps\",{\"1\":{\"724\":1}}],[\"+printgcdetails\",{\"1\":{\"724\":1}}],[\"+printreferencegc\",{\"1\":{\"724\":1}}],[\"+printheapatgc\",{\"1\":{\"724\":1}}],[\"+printtenuringdistribution\",{\"1\":{\"724\":1}}],[\"+usecompressedstrings\",{\"1\":{\"726\":1}}],[\"+uselargepages\",{\"1\":{\"726\":1}}],[\"+uselwpsynchronization\",{\"1\":{\"726\":1}}],[\"+usestringcache\",{\"1\":{\"726\":1}}],[\"+usestringdeduplication\",{\"1\":{\"726\":1}}],[\"+useserialgc\",{\"1\":{\"723\":1}}],[\"+usegcoverheadlimit\",{\"1\":{\"725\":1}}],[\"+usegclogfilerotation\",{\"1\":{\"724\":1}}],[\"+useg1gc\",{\"1\":{\"723\":1}}],[\"+useparnewgc\",{\"1\":{\"723\":1}}],[\"+useparallelgc\",{\"1\":{\"723\":1}}],[\"+userid\",{\"1\":{\"146\":1,\"147\":2,\"149\":1}}],[\"+volatile和native方法来保证原子操作\",{\"1\":{\"581\":1}}],[\"++j\",{\"1\":{\"539\":1}}],[\"+和+=是java中唯二为string重载过的运算符\",{\"1\":{\"496\":1}}],[\"+这是一种最简易的\",{\"1\":{\"374\":1}}],[\"+m\",{\"1\":{\"345\":2,\"362\":2}}],[\"+skuid\",{\"1\":{\"158\":1}}],[\"+\",{\"0\":{\"496\":1},\"1\":{\"150\":2,\"155\":1,\"158\":1,\"271\":1,\"284\":1,\"306\":1,\"326\":1,\"376\":4,\"389\":1,\"459\":1,\"476\":1,\"499\":6,\"507\":2,\"530\":1,\"532\":1,\"550\":2,\"551\":2,\"575\":1}}],[\"载荷\",{\"1\":{\"150\":1}}],[\"携带了token通过jwt工具类进行解密获得userid\",{\"1\":{\"147\":1}}],[\"安全性等\",{\"1\":{\"463\":1}}],[\"安全性没有\",{\"1\":{\"180\":1}}],[\"安全性和资源消耗\",{\"1\":{\"180\":1}}],[\"安全\",{\"1\":{\"175\":1}}],[\"安全的网络传输协议\",{\"1\":{\"172\":1}}],[\"安全上下文容器将第2步填充了信息的\",{\"1\":{\"146\":1}}],[\"安全管理\",{\"1\":{\"2\":1}}],[\"封装是将一个对象的状态信息隐藏在内部\",{\"1\":{\"486\":1}}],[\"封装\",{\"1\":{\"486\":1}}],[\"封装用户部分数据保存到redis中\",{\"1\":{\"146\":1,\"147\":1}}],[\"封装为authentication\",{\"1\":{\"146\":1}}],[\"返回散列值也就是hashcode\",{\"1\":{\"546\":1}}],[\"返回特殊值\",{\"1\":{\"537\":2}}],[\"返回实例对象\",{\"1\":{\"520\":1}}],[\"返回aservice的创建过程就能进行bservice的依赖注入\",{\"1\":{\"450\":1}}],[\"返回两个给定元素之间的距离\",{\"1\":{\"405\":1}}],[\"返回给请求者\",{\"1\":{\"456\":1}}],[\"返回给定元素的经纬度信息\",{\"1\":{\"405\":1}}],[\"返回给客户端的数据首先在缓存中取\",{\"1\":{\"58\":1}}],[\"返回数据\",{\"1\":{\"360\":1}}],[\"返回指定\",{\"1\":{\"345\":1,\"362\":1}}],[\"返回\",{\"1\":{\"345\":1,\"362\":1,\"384\":1}}],[\"返回结果\",{\"1\":{\"331\":1,\"344\":1}}],[\"返回ordersn到前端\",{\"1\":{\"158\":1}}],[\"返回令牌到前端\",{\"1\":{\"155\":1}}],[\"返回新的token\",{\"1\":{\"149\":1}}],[\"返回值为实现接口userdetails的loginuser类\",{\"1\":{\"146\":1}}],[\"添加元素满了之后会自动扩容原来容量的\",{\"1\":{\"607\":1}}],[\"添加锁和释放锁的大部分操作实际上都是在\",{\"1\":{\"592\":1}}],[\"添加依赖\",{\"1\":{\"515\":1}}],[\"添加依赖之后将session存储方式改为redis\",{\"1\":{\"146\":1}}],[\"添加了\",{\"1\":{\"461\":1}}],[\"添加一个或多个元素对应的经纬度信息到\",{\"1\":{\"405\":1}}],[\"添加一个或多个元素\",{\"1\":{\"387\":2}}],[\"添加一个或多个元素到\",{\"1\":{\"317\":1,\"402\":1}}],[\"添加到\",{\"1\":{\"317\":1}}],[\"添加随机过期时间\",{\"1\":{\"153\":1}}],[\"添加onceperrequestfilter过滤器\",{\"1\":{\"147\":1}}],[\"添加数据库节点\",{\"1\":{\"115\":1}}],[\"单次暂停时间特别长\",{\"1\":{\"735\":1}}],[\"单例模式实现方式\",{\"0\":{\"519\":1}}],[\"单例模式\",{\"0\":{\"518\":1}}],[\"单例模式指的是在jvm中一个类只能构造出一个实例对象\",{\"1\":{\"435\":1}}],[\"单例设计模式\",{\"1\":{\"437\":1}}],[\"单例池可以看成是一个map\",{\"1\":{\"436\":1}}],[\"单例bean创建完成之后spring发布一个容器启动事件\",{\"1\":{\"453\":1}}],[\"单例bean通过多次getbean方法都会获得同一个实例\",{\"1\":{\"436\":1}}],[\"单例bean是单例设计模式吗\",{\"0\":{\"435\":1}}],[\"单机\",{\"1\":{\"376\":1}}],[\"单线程下大量数据使用stringbuilder\",{\"1\":{\"494\":1}}],[\"单线程变成容易并且易于维护\",{\"1\":{\"322\":1}}],[\"单线程如何监听大量的客户端连接\",{\"0\":{\"321\":1}}],[\"单表的数据达到千万级别以上\",{\"1\":{\"252\":1}}],[\"单点登录怎么实现的\",{\"0\":{\"146\":1}}],[\"单一职责原则\",{\"1\":{\"144\":1}}],[\"技术多样性\",{\"1\":{\"144\":1}}],[\"技术解决方向不同\",{\"1\":{\"132\":1}}],[\"业务需求低延时所以选择了cms\",{\"1\":{\"735\":1}}],[\"业务代码\",{\"1\":{\"613\":2,\"625\":4}}],[\"业务代码2\",{\"1\":{\"613\":1}}],[\"业务领域驱动划分\",{\"1\":{\"144\":1}}],[\"业务执行触发可以看成支付事务\",{\"1\":{\"133\":1}}],[\"修饰\",{\"1\":{\"622\":1}}],[\"修饰的方法并没有\",{\"1\":{\"589\":1}}],[\"修饰方法\",{\"1\":{\"589\":1}}],[\"修饰同步代码块\",{\"1\":{\"589\":1}}],[\"修饰符\",{\"0\":{\"54\":1}}],[\"修改失败采用重复尝试的办法\",{\"1\":{\"581\":1}}],[\"修改的代价很大\",{\"1\":{\"266\":1}}],[\"修改的操作语言\",{\"1\":{\"222\":1}}],[\"修改异常\",{\"1\":{\"220\":1}}],[\"修改为目标内部服务器的地址\",{\"1\":{\"139\":1}}],[\"原始快照就是将那些被删除的引用记录保存下来\",{\"1\":{\"687\":1}}],[\"原理\",{\"0\":{\"629\":1},\"1\":{\"624\":1}}],[\"原理就是基于反射获取到对应类上的注解\",{\"1\":{\"507\":1}}],[\"原理也比较简单\",{\"1\":{\"376\":1}}],[\"原因\",{\"0\":{\"345\":1}}],[\"原因同样是无法保证所有的\",{\"1\":{\"334\":1}}],[\"原生批量操作命令是redis服务器支持实现的\",{\"1\":{\"333\":1}}],[\"原生批量操作不可以\",{\"1\":{\"333\":1}}],[\"原生批量操作是原子操作\",{\"1\":{\"333\":1}}],[\"原生批量操作和pipeline的区别\",{\"1\":{\"333\":1}}],[\"原生批量操作\",{\"0\":{\"332\":1}}],[\"原子性\",{\"1\":{\"231\":1,\"577\":1}}],[\"原子性atomicity\",{\"1\":{\"231\":1}}],[\"原子操作\",{\"1\":{\"158\":1,\"334\":1}}],[\"原来为4层代理的ip地址\",{\"1\":{\"139\":1}}],[\"原有系统不会改变\",{\"1\":{\"71\":1}}],[\"七层代理写法\",{\"1\":{\"139\":1}}],[\"微服务架构允许使用不同的技术栈来实现不同的服务\",{\"1\":{\"144\":1}}],[\"微服务划分应该追求高内聚低耦合的原则\",{\"1\":{\"144\":1}}],[\"微服务之间使用openfeign调用\",{\"1\":{\"137\":1}}],[\"微信支付结果通知\",{\"1\":{\"133\":1}}],[\"哥们照抄的✨\",{\"1\":{\"136\":1}}],[\"前三个阶段可以统称为连接\",{\"1\":{\"700\":1}}],[\"前驱节点\",{\"1\":{\"622\":1}}],[\"前一个操作的结果应该对后一个操作是可见的\",{\"1\":{\"575\":1}}],[\"前一张表的行在当前这张表中只有一行与之对应\",{\"1\":{\"243\":1}}],[\"前的\",{\"1\":{\"389\":1}}],[\"前面说的事件监听器其实监听的就是这个子节点删除事件\",{\"1\":{\"379\":1}}],[\"前缀索引是对文本的前几个字符创建索引\",{\"1\":{\"264\":1}}],[\"前缀索引只适用于字符串类型的数据\",{\"1\":{\"264\":1}}],[\"前缀索引\",{\"1\":{\"264\":1}}],[\"前缀是\",{\"1\":{\"180\":2}}],[\"前缀\",{\"1\":{\"180\":1}}],[\"前缀匹配\",{\"1\":{\"54\":1}}],[\"前方拥堵\",{\"1\":{\"165\":1}}],[\"前端可以使用一个页面让用户选择收货地址\",{\"1\":{\"158\":1}}],[\"前端限流\",{\"1\":{\"136\":1}}],[\"●\",{\"1\":{\"136\":7}}],[\"流程\",{\"1\":{\"514\":1}}],[\"流水线\",{\"1\":{\"333\":1}}],[\"流量控制是为了控制发送方发送速率\",{\"1\":{\"200\":1}}],[\"流量控制\",{\"1\":{\"199\":1}}],[\"流量错峰\",{\"0\":{\"163\":1,\"164\":1},\"1\":{\"136\":1}}],[\"流式处理平台\",{\"1\":{\"77\":1}}],[\"恶意请求拦截体现在对请求的合法性校验上\",{\"1\":{\"162\":1}}],[\"恶意请求拦截如何实现\",{\"0\":{\"162\":1}}],[\"恶意请求拦截\",{\"0\":{\"160\":1},\"1\":{\"136\":1}}],[\"定义两种资源共享方式\",{\"1\":{\"623\":1}}],[\"定义了jvm在运行时如何分区存储数据\",{\"1\":{\"574\":1}}],[\"定义在object类中\",{\"1\":{\"491\":1}}],[\"定义连接池空闲连接的数量\",{\"1\":{\"63\":1}}],[\"定时对整个内存创建快照\",{\"1\":{\"416\":1}}],[\"定时上架使用\",{\"1\":{\"159\":1}}],[\"定时上架\",{\"0\":{\"157\":1,\"159\":1},\"1\":{\"136\":1}}],[\"定期删除\",{\"1\":{\"327\":1}}],[\"定位到索引的节点\",{\"1\":{\"266\":1}}],[\"购物车信息\",{\"1\":{\"391\":1}}],[\"购物车信息建议使用\",{\"1\":{\"312\":1}}],[\"购物车信息用\",{\"0\":{\"312\":1}}],[\"购物车\",{\"1\":{\"136\":1}}],[\"商城页面由nginx代理实现动静分离\",{\"0\":{\"138\":1},\"1\":{\"136\":1}}],[\"商品数量为\",{\"1\":{\"312\":1}}],[\"商品\",{\"1\":{\"312\":1}}],[\"商品编号\",{\"1\":{\"155\":1}}],[\"商品缓存快速查询\",{\"0\":{\"151\":1},\"1\":{\"136\":1}}],[\"商品信息\",{\"1\":{\"155\":1,\"391\":1}}],[\"商品信息满足分区容错性需要\",{\"1\":{\"115\":1}}],[\"商品信息满足可用性需要\",{\"1\":{\"114\":1}}],[\"商品信息要满足一致性需要\",{\"1\":{\"113\":1}}],[\"商品信息管理案例\",{\"1\":{\"112\":1}}],[\"商品服务请求从数据库读取商品信息\",{\"1\":{\"112\":1}}],[\"商品服务请求主数据库写入商品信息\",{\"1\":{\"112\":1}}],[\"恐龙商城\",{\"1\":{\"136\":1}}],[\"谷粒商城\",{\"0\":{\"136\":1}}],[\"三者的异同\",{\"0\":{\"536\":1}}],[\"三级缓存\",{\"1\":{\"450\":1}}],[\"三元组的形式存储\",{\"1\":{\"214\":1}}],[\"三次握手就能确认双方收发功能都正常\",{\"1\":{\"194\":1}}],[\"三次握手的目的是建立可靠的通信信道\",{\"1\":{\"194\":1}}],[\"三次握手的延迟\",{\"1\":{\"190\":1}}],[\"三次握手\",{\"1\":{\"193\":2}}],[\"三次握手和四次挥手\",{\"0\":{\"192\":1}}],[\"三次握手过程\",{\"1\":{\"190\":1}}],[\"三更博客\",{\"1\":{\"135\":1}}],[\"三个短语的缩写\",{\"1\":{\"120\":1}}],[\"黑马点评\",{\"1\":{\"135\":1}}],[\"完全服从\",{\"1\":{\"282\":1}}],[\"完全函数依赖\",{\"1\":{\"219\":1}}],[\"完成以下三件事情\",{\"1\":{\"702\":1}}],[\"完成对用户请求的处理后\",{\"1\":{\"456\":1}}],[\"完成创建周期后将bservice放入一级缓存中\",{\"1\":{\"450\":1}}],[\"完成\",{\"1\":{\"159\":1,\"193\":1}}],[\"完成设备\",{\"1\":{\"2\":1}}],[\"完了\",{\"1\":{\"135\":1}}],[\"抄\",{\"1\":{\"135\":1}}],[\"八股经历大约两个月终于是啃\",{\"1\":{\"135\":1}}],[\"第\",{\"1\":{\"692\":2}}],[\"第一级缓存\",{\"1\":{\"450\":1}}],[\"第一次select\",{\"1\":{\"290\":1}}],[\"第一次挥手\",{\"1\":{\"195\":1}}],[\"第一次握手\",{\"1\":{\"194\":1}}],[\"第二级缓存\",{\"1\":{\"450\":1}}],[\"第二范式在第一范式的基础上增加了一个列\",{\"1\":{\"219\":1}}],[\"第二次挥手\",{\"1\":{\"195\":1}}],[\"第二次握手\",{\"1\":{\"194\":1}}],[\"第二次会话时开启新的线程就会导致不能获取之前的用户数据\",{\"1\":{\"147\":1}}],[\"第四次挥手时\",{\"1\":{\"197\":1}}],[\"第四次挥手\",{\"1\":{\"195\":1}}],[\"第三级缓存\",{\"1\":{\"450\":1}}],[\"第三次挥手\",{\"1\":{\"195\":1}}],[\"第三次握手\",{\"1\":{\"194\":1}}],[\"第三方库\",{\"1\":{\"105\":1}}],[\"第5步骤的回查事务状态\",{\"1\":{\"129\":1}}],[\"致性方案的关键问题\",{\"1\":{\"126\":1}}],[\"否则才会尝试加载\",{\"1\":{\"710\":1,\"714\":1}}],[\"否则就会被回收\",{\"1\":{\"669\":1}}],[\"否则就丢弃消息\",{\"1\":{\"126\":1}}],[\"否则报\",{\"1\":{\"634\":1}}],[\"否则重新进入阻塞队列\",{\"1\":{\"624\":1}}],[\"否则新建一个线程来处理任务\",{\"1\":{\"607\":1}}],[\"否则通过链表法解决冲突\",{\"1\":{\"546\":1}}],[\"否则开启一个新的事务\",{\"1\":{\"447\":1}}],[\"否则以非事务模式运行\",{\"1\":{\"447\":1}}],[\"否则回滚conn\",{\"1\":{\"446\":1}}],[\"否则还是会存在数据丢失的风险\",{\"1\":{\"410\":1}}],[\"否则还会继续投递消息给消费者\",{\"1\":{\"360\":1}}],[\"否则加锁失败\",{\"1\":{\"378\":1}}],[\"否则取消续期操作\",{\"1\":{\"376\":1}}],[\"否则依然可能会出现锁无法被释放的问题\",{\"1\":{\"375\":1}}],[\"否则会造成索引失效触发全表扫描\",{\"1\":{\"278\":1}}],[\"否则\",{\"1\":{\"263\":1,\"379\":1}}],[\"否则需要使用dns系统\",{\"1\":{\"184\":1}}],[\"否则不会创建订单\",{\"1\":{\"155\":1}}],[\"否则返回空\",{\"1\":{\"146\":1}}],[\"否则启动会报错\",{\"1\":{\"30\":1}}],[\"预期值\",{\"1\":{\"583\":1}}],[\"预防死锁就是破坏四个必要条件中的任意一个\",{\"1\":{\"564\":1}}],[\"预热通过定时上架商品为redis信号量完成\",{\"1\":{\"161\":1}}],[\"预留资源释放\",{\"1\":{\"123\":1}}],[\"预处理try\",{\"1\":{\"123\":1}}],[\"需引入重试机制或人工处理\",{\"1\":{\"123\":2}}],[\"需要吞吐量使用\",{\"1\":{\"728\":1}}],[\"需要低延时使用\",{\"1\":{\"728\":1}}],[\"需要要找到一个合适的\",{\"1\":{\"724\":1}}],[\"需要继承\",{\"1\":{\"716\":1}}],[\"需要查找类或资源时\",{\"1\":{\"713\":1}}],[\"需要满足三个条件才能卸载\",{\"1\":{\"707\":1}}],[\"需要满足fifo使用linkedhashset\",{\"1\":{\"536\":1}}],[\"需要stw\",{\"1\":{\"684\":1}}],[\"需要被回收\",{\"1\":{\"667\":1}}],[\"需要被修改的时候\",{\"1\":{\"629\":1}}],[\"需要注意的是\",{\"1\":{\"663\":1}}],[\"需要注意一个订单只会释放一次库存\",{\"1\":{\"155\":1}}],[\"需要将常量池中指向方法的符号引用转化为其\",{\"1\":{\"641\":1}}],[\"需要将从数据库锁定\",{\"1\":{\"113\":1}}],[\"需要future1完成之后才能执行\",{\"1\":{\"613\":1}}],[\"需要别的线程调用同一个对象的notify\",{\"1\":{\"566\":1}}],[\"需要增强的对象\",{\"1\":{\"515\":1}}],[\"需要增加字符串时\",{\"1\":{\"311\":1}}],[\"需要自定义接口methodintercepter并重写intercept方法\",{\"1\":{\"515\":1}}],[\"需要通过类的实例对象去调用\",{\"1\":{\"479\":1}}],[\"需要通过业务逻辑实现\",{\"1\":{\"124\":1}}],[\"需要更新\",{\"1\":{\"420\":1}}],[\"需要定期对aof文件进行重写\",{\"1\":{\"411\":1}}],[\"需要管理使用地理空间数据的场景\",{\"1\":{\"406\":1}}],[\"需要保存状态信息\",{\"1\":{\"400\":1}}],[\"需要随机获取数据源中的元素根据某个权重进行排序的场景\",{\"1\":{\"397\":1}}],[\"需要随机获取数据源中的元素的场景\",{\"1\":{\"314\":1,\"394\":1}}],[\"需要存储的数据有优先级或者重要程度的场景\",{\"1\":{\"397\":1}}],[\"需要存储常规数据的场景\",{\"1\":{\"385\":1}}],[\"需要存放的数据不能重复的场景\",{\"1\":{\"394\":1}}],[\"需要计数的场景\",{\"1\":{\"385\":1}}],[\"需要才会执行续期\",{\"1\":{\"376\":1}}],[\"需要指定\",{\"1\":{\"338\":1}}],[\"需要获取多个数据源交集\",{\"1\":{\"314\":1,\"394\":1}}],[\"需要减少字符串时\",{\"1\":{\"311\":1}}],[\"需要依靠客户端来实现往集群中分片写入数据\",{\"1\":{\"299\":1}}],[\"需要依赖间隙锁\",{\"1\":{\"238\":1,\"282\":1,\"292\":1}}],[\"需要创建临时表来存储查询的结果\",{\"1\":{\"243\":1}}],[\"需要经过经典的\",{\"1\":{\"190\":1}}],[\"需要维持复杂的连接状态表\",{\"1\":{\"188\":1}}],[\"需要一个统一的\",{\"1\":{\"174\":1}}],[\"需要一个key作为秘钥\",{\"1\":{\"150\":1}}],[\"需要等待其他线程作出动作\",{\"1\":{\"561\":1}}],[\"需要等待锁释放\",{\"1\":{\"561\":1}}],[\"需要等待双方银行系统都完成整个事务才算完成\",{\"1\":{\"118\":1}}],[\"需要等到缓存失效之后才能得到最新的正确数据\",{\"1\":{\"152\":1}}],[\"需要重写dofilterinternal方法\",{\"1\":{\"147\":1}}],[\"需要完成事务参与方的方法幂等性\",{\"1\":{\"128\":1}}],[\"需要正确接收到消息\",{\"1\":{\"127\":1}}],[\"需要使用包装类\",{\"1\":{\"532\":1}}],[\"需要使用aspectj提供的编译器\",{\"1\":{\"449\":1}}],[\"需要使用\",{\"1\":{\"172\":1,\"191\":1}}],[\"需要使用死信交换机和消息存活的ttl\",{\"1\":{\"94\":1}}],[\"需要使用消息的时候\",{\"1\":{\"67\":1}}],[\"需要考虑消息重复消费\",{\"1\":{\"73\":1}}],[\"需要额外考虑消息队列服务出错的处理办法\",{\"1\":{\"73\":1}}],[\"需要优化一下该算法的实现\",{\"1\":{\"16\":1}}],[\"若所有线程均在工作\",{\"1\":{\"604\":1}}],[\"若多余一个任务被提交到该线程池\",{\"1\":{\"604\":1}}],[\"若没有\",{\"1\":{\"604\":1}}],[\"若无外力作用都无法向前推进\",{\"1\":{\"563\":1}}],[\"若该记录被其他事务占用或当前版本对该事务不可见\",{\"1\":{\"289\":1}}],[\"若某个非主属性数据项依赖于全部关键字称为完全函数依赖\",{\"1\":{\"219\":1}}],[\"若在一张表中\",{\"1\":{\"219\":1}}],[\"若cancel阶段真的出错了\",{\"1\":{\"123\":1}}],[\"若confirm阶段真的出错了\",{\"1\":{\"123\":1}}],[\"若被指向路径文件被重新创建\",{\"1\":{\"15\":1}}],[\"隔离级别只会在事务开启后的第一次查询生成\",{\"1\":{\"292\":1}}],[\"隔离级别下只在事务开始后\",{\"1\":{\"290\":1}}],[\"隔离级别下的\",{\"1\":{\"290\":1}}],[\"隔离级别下\",{\"0\":{\"290\":1},\"1\":{\"291\":1}}],[\"隔离级别其实是可以解决幻读问题发生的\",{\"1\":{\"282\":1}}],[\"隔离级别定义里\",{\"1\":{\"282\":1}}],[\"隔离级别\",{\"1\":{\"282\":1}}],[\"隔离级别是基于\",{\"1\":{\"234\":1}}],[\"隔离级别是可以解决幻读问题的\",{\"1\":{\"228\":1}}],[\"隔离性之后\",{\"1\":{\"231\":1}}],[\"隔离性isolation\",{\"1\":{\"231\":1}}],[\"隔离\",{\"1\":{\"123\":1}}],[\"隔离的\",{\"1\":{\"107\":1}}],[\"两值相等才会进行更新\",{\"1\":{\"583\":1}}],[\"两小\",{\"1\":{\"480\":1}}],[\"两同\",{\"1\":{\"480\":1}}],[\"两同两小一大\",{\"1\":{\"480\":1}}],[\"两次备份之间的操作会丢失\",{\"1\":{\"416\":1}}],[\"两个子类\",{\"1\":{\"592\":1}}],[\"两个方法都能暂停线程的执行\",{\"1\":{\"566\":1}}],[\"两个或者以上的线程因为竞争资源导致阻塞\",{\"1\":{\"563\":1}}],[\"两个不同对象的引用指向同一个对象\",{\"1\":{\"488\":1}}],[\"两个又有很大的不同\",{\"1\":{\"304\":1}}],[\"两个隔离级别下\",{\"1\":{\"284\":1}}],[\"两种典型用法\",{\"1\":{\"625\":1}}],[\"两种方式都会存在脏数据问题\",{\"1\":{\"152\":1}}],[\"两种\",{\"1\":{\"139\":1,\"650\":1}}],[\"两者本质都是对对象监视器monitor的获取\",{\"1\":{\"589\":1}}],[\"两者的性能都非常高\",{\"1\":{\"299\":1}}],[\"两者的业务场景不同\",{\"1\":{\"132\":1}}],[\"两者都是先进后出的数据结构\",{\"1\":{\"641\":1}}],[\"两者都是可重入锁\",{\"1\":{\"594\":1}}],[\"两者都是由\",{\"1\":{\"304\":1}}],[\"两者都是行级锁\",{\"1\":{\"239\":1}}],[\"两者都是负责邮件接收的协议\",{\"1\":{\"172\":1,\"191\":1}}],[\"两者通过消息队列实现通信\",{\"1\":{\"71\":1}}],[\"两阶段提交\",{\"1\":{\"122\":1}}],[\"柔性事务\",{\"1\":{\"120\":1}}],[\"放入堆中能加快回收频率\",{\"1\":{\"647\":1}}],[\"放入lambda表达式到三级缓存中\",{\"1\":{\"450\":1}}],[\"放入单例池\",{\"1\":{\"438\":1,\"450\":1}}],[\"放入缓存的数据应该是变化度不高的数据\",{\"1\":{\"152\":1}}],[\"放入缓冲区中\",{\"1\":{\"57\":1}}],[\"放入到nginx的html目录下\",{\"1\":{\"141\":1}}],[\"放弃了\",{\"1\":{\"551\":1}}],[\"放弃分区容错性\",{\"1\":{\"119\":1}}],[\"放弃可用性\",{\"1\":{\"118\":1}}],[\"放弃一致性\",{\"1\":{\"117\":1}}],[\"满足p的前提下c和a是不能共存的\",{\"1\":{\"115\":1}}],[\"采用标记\",{\"1\":{\"680\":1}}],[\"采用字节码的好处\",{\"0\":{\"467\":1}}],[\"采用两种方式计数\",{\"1\":{\"401\":1}}],[\"采用redis集群\",{\"1\":{\"355\":1}}],[\"采用合适的数据结构\",{\"1\":{\"339\":1}}],[\"采用的是插件式架构\",{\"1\":{\"226\":1}}],[\"采用nginx的hash一致性负载均衡算法\",{\"1\":{\"146\":1}}],[\"采用手动ack确保订单创建成功\",{\"1\":{\"136\":1}}],[\"采用icc则认为cancel阶段也是一定成功的\",{\"1\":{\"123\":1}}],[\"采用\",{\"1\":{\"123\":1,\"550\":1,\"551\":2}}],[\"采用读写分离的数据库集群模式\",{\"1\":{\"112\":1}}],[\"采用互斥对象机制\",{\"1\":{\"7\":1}}],[\"整理算法\",{\"1\":{\"678\":1,\"679\":1,\"680\":1}}],[\"整理\",{\"1\":{\"676\":1,\"682\":1,\"684\":1}}],[\"整堆收集\",{\"1\":{\"663\":1}}],[\"整数集合\",{\"1\":{\"382\":1}}],[\"整数\",{\"1\":{\"309\":1,\"383\":1}}],[\"整个加解锁过程其实就是一个新旧数据比对的过程\",{\"1\":{\"618\":1}}],[\"整个事务过程由事务管理器管理\",{\"1\":{\"122\":1}}],[\"整个过程就是一个分布式事务\",{\"1\":{\"110\":1}}],[\"整体流程为\",{\"1\":{\"700\":1}}],[\"整体执行过程\",{\"1\":{\"112\":1}}],[\"整体上是一个生产者与消费者模型\",{\"1\":{\"82\":1}}],[\"下图展示的各种类加载器之间的层次关系被称为类加载器的\",{\"1\":{\"713\":1}}],[\"下图展示了生产者将消息存入rabbitmq\",{\"1\":{\"86\":1}}],[\"下是数据类型的默认值\",{\"1\":{\"704\":1}}],[\"下面的代码表示同一时刻\",{\"1\":{\"624\":1}}],[\"下面两个表达式其实是等价的\",{\"1\":{\"499\":1}}],[\"下面逐句进行分析\",{\"1\":{\"136\":1}}],[\"下最小的子节点\",{\"1\":{\"379\":1}}],[\"下游从队列拉去消息\",{\"1\":{\"360\":1}}],[\"下\",{\"1\":{\"238\":1,\"284\":1,\"285\":1,\"290\":1,\"303\":1,\"304\":1,\"334\":1}}],[\"下的所有\",{\"1\":{\"711\":1}}],[\"下的\",{\"1\":{\"174\":1}}],[\"下单的同时请求库存微服务减少库存\",{\"1\":{\"110\":1}}],[\"young\",{\"0\":{\"720\":1},\"1\":{\"663\":1}}],[\"yes\",{\"1\":{\"350\":1,\"422\":1}}],[\"y\",{\"1\":{\"219\":5}}],[\"yml文件所在目录\",{\"1\":{\"109\":1}}],[\"yml文件\",{\"1\":{\"109\":1}}],[\"ylzhong\",{\"1\":{\"62\":5}}],[\"称为早期bean对象\",{\"1\":{\"450\":1}}],[\"称为消息的校对机制\",{\"1\":{\"131\":1}}],[\"称为消息重复机制\",{\"1\":{\"131\":1}}],[\"称为\",{\"1\":{\"120\":1,\"640\":1}}],[\"称为分区容错性\",{\"1\":{\"115\":1}}],[\"称为多路复用器\",{\"1\":{\"22\":1}}],[\"称之为容器\",{\"1\":{\"107\":1}}],[\"方式\",{\"1\":{\"243\":1}}],[\"方便传播和安装\",{\"1\":{\"107\":1}}],[\"方法即可\",{\"1\":{\"712\":1,\"716\":1}}],[\"方法解析该类\",{\"1\":{\"712\":1}}],[\"方法在内存中的指针或者偏移量\",{\"1\":{\"705\":1}}],[\"方法在队列为空的时候会阻塞\",{\"1\":{\"634\":1}}],[\"方法句柄和调用限定符进行引用\",{\"1\":{\"705\":1}}],[\"方法类型\",{\"1\":{\"705\":1}}],[\"方法表中都可以携带自己的属性表集合\",{\"1\":{\"698\":1}}],[\"方法表的结构如同字段表一样\",{\"1\":{\"697\":1}}],[\"方法表集合\",{\"0\":{\"697\":1}}],[\"方法符号引用\",{\"1\":{\"646\":1}}],[\"方法区中常量引用的对象\",{\"1\":{\"668\":1}}],[\"方法区中静态属性引用的变量\",{\"1\":{\"668\":1}}],[\"方法区内部\",{\"0\":{\"646\":1}}],[\"方法区属于是\",{\"1\":{\"645\":1}}],[\"方法区\",{\"0\":{\"645\":1},\"1\":{\"721\":3}}],[\"方法区用来存放已经被加载的类信息\",{\"1\":{\"560\":1}}],[\"方法服务\",{\"1\":{\"642\":1}}],[\"方法调用的数据需要通过栈进行传递\",{\"1\":{\"641\":1}}],[\"方法不会\",{\"1\":{\"634\":1}}],[\"方法不定义在thread中\",{\"0\":{\"567\":1}}],[\"方法来加载类\",{\"1\":{\"716\":1}}],[\"方法来指定元素排序规则\",{\"1\":{\"634\":1}}],[\"方法来获取默认值或将其值更改为当前线程所存的副本的值\",{\"1\":{\"598\":1}}],[\"方法告诉cyclicbarrier\",{\"1\":{\"626\":1}}],[\"方法之后的语句得到执行\",{\"1\":{\"625\":1}}],[\"方法之后的语句不会被执行\",{\"1\":{\"625\":1}}],[\"方法之外\",{\"1\":{\"624\":1}}],[\"方法就会一直阻塞\",{\"1\":{\"625\":1}}],[\"方法就会被转发到实现invocationhandler接口类的invoke方法来调用\",{\"1\":{\"514\":1}}],[\"方法时\",{\"1\":{\"625\":1}}],[\"方法为阻塞调用\",{\"1\":{\"613\":1}}],[\"方法返回地址\",{\"1\":{\"641\":1}}],[\"方法返回的其实就是\",{\"1\":{\"612\":1}}],[\"方法返回string对象\",{\"1\":{\"496\":1}}],[\"方法相结合可以实现等待\",{\"1\":{\"594\":1}}],[\"方法happens\",{\"1\":{\"576\":1}}],[\"方法方可启动线程并使线程进入就绪状态\",{\"1\":{\"568\":1}}],[\"方法当成普通方法执行\",{\"1\":{\"568\":1}}],[\"方法会创建一个新的线程并让其进入就绪状态\",{\"1\":{\"568\":1}}],[\"方法会产生两个\",{\"1\":{\"175\":1}}],[\"方法是让当前线程暂停执行\",{\"1\":{\"567\":1}}],[\"方法执行完成后\",{\"1\":{\"566\":1}}],[\"方法被调用之后\",{\"1\":{\"566\":1}}],[\"方法释放了锁\",{\"1\":{\"566\":1}}],[\"方法没有释放锁\",{\"1\":{\"566\":1}}],[\"方法对比\",{\"0\":{\"566\":1}}],[\"方法和\",{\"0\":{\"566\":1}}],[\"方法有三个参数\",{\"1\":{\"514\":2}}],[\"方法有什么作用\",{\"0\":{\"498\":1}}],[\"方法接收的直接是实参所引用对象在堆中的地址\",{\"1\":{\"502\":1}}],[\"方法接收的是实参的拷贝\",{\"1\":{\"502\":1}}],[\"方法可能会导致判断是相等的两个对象但是hashcode不等\",{\"1\":{\"492\":1}}],[\"方法用来获哈希码\",{\"1\":{\"491\":1}}],[\"方法名\",{\"1\":{\"480\":1}}],[\"方法异常没有抛出\",{\"1\":{\"448\":1}}],[\"方法实现锁的异步续期\",{\"1\":{\"376\":1}}],[\"方法的过程\",{\"1\":{\"706\":1}}],[\"方法的名称和描述符\",{\"1\":{\"693\":1}}],[\"方法的顺序就是获取许可证的顺序\",{\"1\":{\"624\":1}}],[\"方法的任务执行结果\",{\"1\":{\"612\":1}}],[\"方法的时候\",{\"1\":{\"600\":1,\"625\":1}}],[\"方法的话不会以多线程的方式执行\",{\"1\":{\"568\":1}}],[\"方法的重写要遵循\",{\"1\":{\"480\":1}}],[\"方法的长度限制是怎么回事\",{\"1\":{\"175\":1}}],[\"方法的参数应该放在\",{\"1\":{\"175\":1}}],[\"方法安全\",{\"1\":{\"175\":1}}],[\"方法比\",{\"1\":{\"175\":1}}],[\"方法参数\",{\"1\":{\"515\":1}}],[\"方法参数写法是固定的吗\",{\"1\":{\"175\":1}}],[\"方法参数应该放在\",{\"1\":{\"175\":1}}],[\"方法\",{\"0\":{\"478\":1,\"492\":1,\"653\":1},\"1\":{\"101\":1,\"146\":1,\"374\":1,\"376\":1,\"439\":1,\"496\":1,\"514\":1,\"566\":1,\"568\":2,\"594\":1,\"599\":1,\"608\":1,\"624\":1,\"642\":1,\"646\":1,\"653\":1,\"703\":1,\"712\":1,\"716\":1}}],[\"方法能重载吗\",{\"0\":{\"30\":1}}],[\"镜像\",{\"0\":{\"107\":1},\"1\":{\"107\":1}}],[\"镜像模式\",{\"1\":{\"98\":1}}],[\"确保数据都写入内存并清除缓存\",{\"1\":{\"579\":1}}],[\"确保了应用能在不同的机器上使用相同的环境运行\",{\"1\":{\"106\":1}}],[\"确定目标\",{\"0\":{\"728\":1}}],[\"确定程序语义是合法的\",{\"1\":{\"703\":1}}],[\"确定\",{\"1\":{\"219\":2}}],[\"确认confirm\",{\"1\":{\"123\":1}}],[\"确认\",{\"1\":{\"101\":1,\"188\":1}}],[\"软引用\",{\"1\":{\"670\":1,\"724\":1}}],[\"软状态\",{\"1\":{\"120\":3}}],[\"软件安装之后的状态\",{\"1\":{\"107\":1}}],[\"软件打包在一起成为一个安装包\",{\"1\":{\"105\":1}}],[\"软链接\",{\"1\":{\"15\":2}}],[\"打印safepoint信息\",{\"1\":{\"724\":1}}],[\"打印stw时间\",{\"1\":{\"724\":1}}],[\"打印reference处理信息\",{\"1\":{\"724\":1}}],[\"打印堆数据\",{\"1\":{\"724\":1}}],[\"打印对象分布\",{\"1\":{\"724\":1}}],[\"打印基本\",{\"1\":{\"724\":1}}],[\"打印技能1\",{\"1\":{\"486\":1}}],[\"打破双亲委派模型方法\",{\"0\":{\"716\":1}}],[\"打包\",{\"0\":{\"105\":1},\"1\":{\"105\":1}}],[\"打开模式等等\",{\"1\":{\"8\":1}}],[\"部分其他收集器原本需要停顿\",{\"1\":{\"684\":1}}],[\"部分收集\",{\"1\":{\"663\":1}}],[\"部分\",{\"1\":{\"285\":1}}],[\"部分函数依赖\",{\"1\":{\"219\":1}}],[\"部分组成\",{\"1\":{\"83\":1}}],[\"部署多台数据库\",{\"1\":{\"247\":1}}],[\"部署\",{\"0\":{\"105\":1},\"1\":{\"105\":1}}],[\"部署的工具\",{\"1\":{\"104\":1}}],[\"离线慢慢处理\",{\"1\":{\"103\":1}}],[\"记录rdb期间生成的新命令都会写入内存缓冲区repl\",{\"1\":{\"420\":1}}],[\"记录命令\",{\"1\":{\"416\":1}}],[\"记录每一次执行的命令\",{\"1\":{\"416\":1}}],[\"记录服务器执行的所有写命令\",{\"1\":{\"414\":1}}],[\"记录慢查询语句类似\",{\"1\":{\"346\":1}}],[\"记录下来\",{\"1\":{\"288\":1}}],[\"记录锁只能锁住已经存在的记录\",{\"1\":{\"238\":1,\"292\":1}}],[\"记录锁\",{\"1\":{\"238\":1}}],[\"记录\",{\"1\":{\"185\":1}}],[\"记录数据库\",{\"1\":{\"103\":1}}],[\"记录学习笔记\",{\"1\":{\"0\":1}}],[\"超文本传输协议\",{\"1\":{\"172\":1,\"191\":1}}],[\"超时\",{\"1\":{\"592\":1}}],[\"超时后线程会自动苏醒\",{\"1\":{\"566\":1}}],[\"超时等待状态\",{\"1\":{\"561\":1}}],[\"超时重传\",{\"1\":{\"199\":1}}],[\"超时之后检查订单是否是取消状态\",{\"1\":{\"155\":1}}],[\"超时就丢弃\",{\"1\":{\"103\":1}}],[\"超过就触发分割\",{\"1\":{\"724\":1}}],[\"超过之后从头文件开始写\",{\"1\":{\"724\":1}}],[\"超过这个值将会抛出\",{\"1\":{\"721\":1}}],[\"超过这个数就直接放入老年代\",{\"1\":{\"686\":1}}],[\"超过容量之后触发扩容\",{\"1\":{\"532\":1}}],[\"超过long\",{\"0\":{\"475\":1}}],[\"超过一半的sentinel都认为这个实例主观下线\",{\"1\":{\"425\":1}}],[\"超过该时间\",{\"1\":{\"214\":1}}],[\"超过该事件后旧事件将被丢弃\",{\"1\":{\"85\":1}}],[\"超过了指定大小\",{\"1\":{\"57\":1}}],[\"给对象添加一个计数器\",{\"1\":{\"666\":1}}],[\"给spring容器进行加载\",{\"1\":{\"461\":1}}],[\"给指定\",{\"1\":{\"384\":1}}],[\"给key设置随机过期时间\",{\"1\":{\"335\":1}}],[\"给消息设置年龄\",{\"1\":{\"103\":1}}],[\"给多个消费者进行处理\",{\"1\":{\"92\":1}}],[\"说明新生代占整个内存的1\",{\"1\":{\"720\":1}}],[\"说明slave数据落后于master\",{\"1\":{\"420\":1}}],[\"说说arraylist\",{\"0\":{\"532\":1}}],[\"说说\",{\"0\":{\"529\":1}}],[\"说说broker服务节点\",{\"0\":{\"92\":1}}],[\"说一下\",{\"0\":{\"299\":1}}],[\"说白了就是增加机器\",{\"1\":{\"103\":1}}],[\"把内存化整为零\",{\"1\":{\"684\":1}}],[\"把内存中的所有数据都记录到磁盘中\",{\"1\":{\"408\":1}}],[\"把这个虚引用加入到与之关联的引用队列中\",{\"1\":{\"670\":1}}],[\"把对象按照程序员的意愿进行初始化\",{\"1\":{\"653\":1}}],[\"把缓存中的数据刷入内存中\",{\"1\":{\"579\":1}}],[\"把返回的\",{\"1\":{\"456\":1}}],[\"把数据全部存在内存之中\",{\"1\":{\"299\":1}}],[\"把一张列比较多的表拆分成多张表\",{\"1\":{\"251\":1}}],[\"把\",{\"1\":{\"242\":1,\"456\":1}}],[\"把整型的\",{\"1\":{\"242\":2}}],[\"把ip转化为无符号整数\",{\"1\":{\"242\":1}}],[\"把软件运行需要的依赖\",{\"1\":{\"105\":1}}],[\"把服务器内存耗尽\",{\"1\":{\"103\":1}}],[\"把amqp的基本组件划分到一个虚拟的分组中\",{\"1\":{\"97\":1}}],[\"来标识常量的类型\",{\"1\":{\"693\":1}}],[\"来缩短\",{\"1\":{\"684\":1}}],[\"来了解被引用的对象是否将要被垃圾回收\",{\"1\":{\"670\":1}}],[\"来设置老年代与新生代内存的比值\",{\"1\":{\"720\":1}}],[\"来设置\",{\"1\":{\"662\":2}}],[\"来指定排序规则\",{\"1\":{\"634\":1}}],[\"来替代\",{\"1\":{\"630\":1}}],[\"来完成获取资源线程的排队工作\",{\"1\":{\"622\":1}}],[\"来创建\",{\"1\":{\"604\":1}}],[\"来保证并发安全\",{\"1\":{\"550\":1}}],[\"来保存数据过期的时间\",{\"1\":{\"326\":1}}],[\"来管理和组织组件\",{\"1\":{\"463\":1}}],[\"来判断\",{\"1\":{\"374\":1}}],[\"来判断数据的可见性\",{\"1\":{\"286\":1}}],[\"来作为底层实现\",{\"1\":{\"311\":1}}],[\"来实现锁的分配\",{\"1\":{\"622\":1}}],[\"来实现这个机制\",{\"1\":{\"594\":1}}],[\"来实现\",{\"1\":{\"306\":1}}],[\"来实现分布式锁\",{\"1\":{\"306\":1}}],[\"来做消息队列\",{\"1\":{\"306\":1}}],[\"来做消息队列的话\",{\"1\":{\"306\":1}}],[\"来做分布式锁是一种比较常见的方式\",{\"1\":{\"306\":1}}],[\"来做为缓存判断的标准\",{\"1\":{\"181\":1}}],[\"来读取快照数据\",{\"1\":{\"291\":1}}],[\"来生成聚簇索引\",{\"1\":{\"287\":1}}],[\"来防止其它事务在间隙间插入数据\",{\"1\":{\"285\":1}}],[\"来攻击\",{\"1\":{\"175\":1}}],[\"来处理\",{\"1\":{\"102\":1,\"611\":1}}],[\"来自定义类加载器\",{\"1\":{\"714\":1}}],[\"来自同一个ip的请求会分发到同一台服务器\",{\"1\":{\"60\":1}}],[\"来自后端服务器响应的第一部分存储在单独的缓冲区中\",{\"1\":{\"57\":1}}],[\"让新生代的对象晋升时间更长\",{\"1\":{\"734\":1}}],[\"让长时间存活的对象尽快晋升\",{\"1\":{\"731\":1}}],[\"让所有线程继续执行下去\",{\"1\":{\"626\":1}}],[\"让所有来源相同的请求定位到同一个服务器\",{\"1\":{\"146\":1}}],[\"让代码更加灵活\",{\"1\":{\"508\":1}}],[\"让bean在初始化前进行增强\",{\"1\":{\"442\":1}}],[\"让其余节点变成这个节点的从节点\",{\"1\":{\"427\":1}}],[\"让其自动重新发送消息\",{\"1\":{\"101\":1}}],[\"让程序自动决定触发时机\",{\"1\":{\"414\":1}}],[\"让它去获取锁\",{\"1\":{\"381\":1}}],[\"让缓存数据的过期时间变短\",{\"1\":{\"360\":1}}],[\"让redis采用异步方式延时释放key使用的内训\",{\"1\":{\"339\":1}}],[\"让redis采用异步方式延时释放key使用的内存\",{\"1\":{\"335\":1}}],[\"让一个用户只能对同一个商品秒杀一次\",{\"1\":{\"158\":1}}],[\"让消息在一定时间之后成为死信交给死信交换机\",{\"1\":{\"156\":1}}],[\"让用户态变成内核态\",{\"1\":{\"3\":1}}],[\"手动故障转移\",{\"1\":{\"431\":1}}],[\"手动给锁设置过期时间\",{\"1\":{\"376\":1}}],[\"手动清理\",{\"1\":{\"339\":1}}],[\"手动签收\",{\"1\":{\"101\":1}}],[\"手动确认\",{\"1\":{\"101\":1}}],[\"v操作\",{\"1\":{\"624\":1}}],[\"verification\",{\"1\":{\"700\":1}}],[\"version\",{\"0\":{\"692\":1},\"1\":{\"692\":2}}],[\"version>\",{\"1\":{\"515\":1}}],[\"vector是list的古老实现类\",{\"1\":{\"533\":1}}],[\"vector\",{\"1\":{\"530\":1,\"627\":1}}],[\"vm\",{\"1\":{\"466\":1,\"663\":1,\"725\":1,\"726\":1}}],[\"value是一个集合\",{\"1\":{\"687\":1}}],[\"value是无序的\",{\"1\":{\"529\":1}}],[\"valueof\",{\"1\":{\"472\":1}}],[\"value2\",{\"1\":{\"384\":1,\"387\":2,\"390\":1}}],[\"value1\",{\"1\":{\"384\":1,\"387\":2,\"390\":1}}],[\"value\",{\"1\":{\"153\":1,\"165\":1,\"309\":1,\"312\":1,\"326\":1,\"332\":1,\"374\":2,\"384\":2,\"385\":1,\"387\":2,\"389\":1,\"390\":3,\"399\":1,\"495\":1,\"599\":3,\"600\":3,\"604\":5,\"607\":3,\"633\":1,\"647\":1,\"704\":1}}],[\"var\",{\"1\":{\"108\":1,\"583\":1}}],[\"viewresolver\",{\"1\":{\"456\":1,\"457\":1}}],[\"view时\",{\"1\":{\"288\":1}}],[\"view\",{\"1\":{\"285\":2,\"286\":3,\"288\":2,\"290\":3,\"291\":4,\"292\":2,\"456\":6}}],[\"visualvm查看堆内存情况\",{\"1\":{\"137\":1}}],[\"virtual\",{\"1\":{\"97\":1}}],[\"volatile性能肯定比synchronized关键字要好\",{\"1\":{\"590\":1}}],[\"volatile是\",{\"1\":{\"579\":1}}],[\"volatile修饰的singleton\",{\"1\":{\"579\":1}}],[\"volatile如何禁止指令重排序\",{\"0\":{\"579\":1}}],[\"volatile关键字主要用于解决变量在多个线程之间的可见性\",{\"1\":{\"590\":1}}],[\"volatile关键字\",{\"0\":{\"578\":1}}],[\"volatile变量规则\",{\"1\":{\"576\":1}}],[\"volatile\",{\"0\":{\"590\":1},\"1\":{\"328\":4,\"342\":1,\"523\":1,\"577\":1,\"578\":3,\"579\":1,\"590\":3,\"622\":1}}],[\"volumes\",{\"1\":{\"109\":1}}],[\"vo\",{\"1\":{\"155\":1}}],[\"void\",{\"1\":{\"100\":1,\"436\":1,\"439\":1,\"442\":1,\"446\":1,\"448\":1,\"458\":1,\"476\":2,\"480\":2,\"501\":1,\"503\":2,\"539\":2,\"599\":1}}],[\"v表示挂载目录\",{\"1\":{\"108\":1}}],[\"v\",{\"1\":{\"108\":3,\"299\":2,\"583\":1}}],[\"防止内存溢出\",{\"1\":{\"670\":1}}],[\"防止其他线程修改\",{\"1\":{\"582\":1}}],[\"防止其它事务在查询范围内插入数据\",{\"1\":{\"292\":1}}],[\"防止当前系统进入不安全状态\",{\"1\":{\"565\":1}}],[\"防止了部分幻读\",{\"1\":{\"285\":1}}],[\"防止包丢失\",{\"1\":{\"199\":1}}],[\"防止\",{\"1\":{\"197\":1}}],[\"防止恶意构造长\",{\"1\":{\"175\":1}}],[\"防止整体崩溃\",{\"1\":{\"165\":1}}],[\"防止大量请求同时到达数据库\",{\"1\":{\"164\":1}}],[\"防止一个用户并发秒杀\",{\"1\":{\"158\":1}}],[\"防止请求查询到旧数据\",{\"1\":{\"113\":1}}],[\"防止发送途中mq宕机\",{\"1\":{\"99\":1}}],[\"防止消息丢失\",{\"0\":{\"98\":1}}],[\"事务不会生效\",{\"1\":{\"448\":1}}],[\"事务包含以下的转播机制\",{\"1\":{\"447\":1}}],[\"事务管理器新建一个数据库连接conn\",{\"1\":{\"446\":1}}],[\"事务transactional本质也是通过代理对象调用普通对象的方法\",{\"1\":{\"446\":1}}],[\"事务实现原理\",{\"0\":{\"446\":1}}],[\"事务等功能\",{\"1\":{\"299\":1}}],[\"事务隔离级别\",{\"0\":{\"282\":1}}],[\"事务隔离级别和mvcc\",{\"0\":{\"281\":1}}],[\"事务问题\",{\"1\":{\"254\":1}}],[\"事务有意向对表中的某些记录加排他锁\",{\"1\":{\"240\":1}}],[\"事务有意向对表中的某些记录加共享锁\",{\"1\":{\"240\":1}}],[\"事务在第一次查询开始的时候会生成一个read\",{\"1\":{\"291\":1}}],[\"事务在每次查询开始时都会生成并设置新的\",{\"1\":{\"291\":1}}],[\"事务在修改记录的时候获取排他锁\",{\"1\":{\"239\":1}}],[\"事务在读取记录的时候获取共享锁\",{\"1\":{\"239\":1}}],[\"事务的原子性确保动作要么都完成\",{\"1\":{\"231\":1}}],[\"事务的confirm机制\",{\"1\":{\"98\":1}}],[\"事务是通过代理对象调用才能生效\",{\"1\":{\"448\":1}}],[\"事务是最小的执行单位\",{\"1\":{\"231\":1}}],[\"事务是逻辑上的一组操作\",{\"1\":{\"230\":1}}],[\"事务\",{\"0\":{\"230\":1}}],[\"事务支持优秀\",{\"1\":{\"225\":1}}],[\"事务消息设计主要是为了解决producer端发送消息与本地事务执行的原子性问题\",{\"1\":{\"129\":1}}],[\"事务参与方\",{\"1\":{\"127\":1}}],[\"事务参与方接收消息的可靠性问题\",{\"1\":{\"130\":1}}],[\"事务参与方接收消息的可靠性\",{\"0\":{\"127\":1}}],[\"事务参与方一定能接受消息并处理事务成功\",{\"1\":{\"125\":1}}],[\"事务和confirm机制不能同时存在\",{\"1\":{\"98\":1}}],[\"事件监听器\",{\"1\":{\"379\":1}}],[\"事件处理器\",{\"1\":{\"321\":1}}],[\"事件在使用后不会被删除\",{\"1\":{\"85\":1}}],[\"事件就是该文件夹中的文件\",{\"1\":{\"85\":1}}],[\"事件被组织并持久地存储在topic中\",{\"1\":{\"85\":1}}],[\"事件\",{\"1\":{\"7\":1}}],[\"渠道\",{\"1\":{\"97\":1}}],[\"支付结果通过发起通知方发送到消息队列中\",{\"1\":{\"133\":1}}],[\"支付宝就会将时间间隔变大进行异步通知\",{\"1\":{\"131\":1}}],[\"支付宝中采用最大努力交付\",{\"1\":{\"96\":1}}],[\"支持三种模式\",{\"1\":{\"431\":1}}],[\"支持秒级数据丢失\",{\"1\":{\"416\":1}}],[\"支持修改\",{\"1\":{\"376\":1}}],[\"支持多个客户端连接的关键\",{\"1\":{\"321\":1}}],[\"支持多种协议\",{\"1\":{\"78\":1}}],[\"支持手动释放\",{\"1\":{\"311\":1}}],[\"支持\",{\"1\":{\"306\":1,\"405\":1,\"538\":1}}],[\"支持消息持久化以及\",{\"1\":{\"306\":1}}],[\"支持发布订阅模型\",{\"1\":{\"299\":1}}],[\"支持数据的持久化\",{\"1\":{\"299\":1}}],[\"支持更多的编程语言\",{\"1\":{\"299\":1}}],[\"支持更复杂的应用场景\",{\"1\":{\"299\":1}}],[\"支持更丰富的数据类型\",{\"1\":{\"299\":1}}],[\"支持的数据类型\",{\"1\":{\"299\":1}}],[\"支持innodb\",{\"1\":{\"226\":1}}],[\"支持分库分表\",{\"1\":{\"225\":1}}],[\"支持一对一\",{\"1\":{\"188\":1}}],[\"支持长连接\",{\"1\":{\"181\":1}}],[\"支持邮件搜索\",{\"1\":{\"172\":1,\"191\":1}}],[\"支持可扩展\",{\"1\":{\"80\":1}}],[\"支持高并发\",{\"1\":{\"80\":1}}],[\"支持面向缓冲\",{\"1\":{\"22\":1}}],[\"接受了\",{\"1\":{\"179\":1}}],[\"接收窗口>1\",{\"1\":{\"205\":1}}],[\"接收窗口每收到一个序号就会发送一个确认帧\",{\"1\":{\"204\":1}}],[\"接收窗口=1\",{\"1\":{\"204\":1}}],[\"接收方一般采用累计确认\",{\"1\":{\"204\":1}}],[\"接收方则可以看成我们自己\",{\"1\":{\"133\":1}}],[\"接收端实体对已成功收到的包发回一个相应的确认信息\",{\"1\":{\"199\":1}}],[\"接收正常\",{\"1\":{\"194\":6}}],[\"接收和分发消息的应用\",{\"1\":{\"97\":1}}],[\"接着转发到解锁库存的队列中\",{\"1\":{\"96\":1}}],[\"接口索引集合用来描述这个类实现了那些接口\",{\"1\":{\"695\":1}}],[\"接口方法\",{\"1\":{\"705\":1}}],[\"接口方法符号\",{\"1\":{\"646\":1}}],[\"接口方法内的参数\",{\"1\":{\"30\":1}}],[\"接口等描述信息\",{\"1\":{\"646\":1}}],[\"接口让\",{\"1\":{\"544\":1}}],[\"接口中的成员变量只能是public\",{\"1\":{\"487\":1}}],[\"接口强调行为的约束\",{\"1\":{\"487\":1}}],[\"接口和抽象类的共同点\",{\"0\":{\"487\":1}}],[\"接口生成代理\",{\"1\":{\"30\":1}}],[\"接口可以有多个重载方法\",{\"1\":{\"30\":1}}],[\"接口的有界队列实现类\",{\"1\":{\"632\":1}}],[\"接口的基本实现\",{\"1\":{\"612\":1}}],[\"接口的实现类\",{\"1\":{\"536\":1}}],[\"接口的工作原理是\",{\"1\":{\"30\":1}}],[\"接口的工作原理是什么\",{\"0\":{\"30\":1}}],[\"接口的方法名\",{\"1\":{\"30\":1}}],[\"接口的全限名\",{\"1\":{\"30\":1}}],[\"接口\",{\"0\":{\"695\":1},\"1\":{\"30\":1,\"544\":1,\"592\":1,\"695\":1}}],[\"接口就是人们常说的\",{\"1\":{\"30\":1}}],[\"接口与之对应\",{\"1\":{\"30\":1}}],[\"接口里的方法可以重载\",{\"1\":{\"30\":1}}],[\"接口里的方法\",{\"0\":{\"30\":1}}],[\"信息\",{\"1\":{\"724\":1}}],[\"信息流展示\",{\"1\":{\"388\":1}}],[\"信息过期的时候表明订单也就过期了\",{\"1\":{\"96\":1}}],[\"信道是建立在\",{\"1\":{\"97\":1}}],[\"信道\",{\"1\":{\"97\":1}}],[\"信号驱动\",{\"1\":{\"19\":1}}],[\"信号是一种比较复杂的通信方式\",{\"1\":{\"9\":1}}],[\"信号\",{\"1\":{\"9\":1}}],[\"信号量semaphore实现库存的快速扣减\",{\"1\":{\"136\":1}}],[\"信号量的意图在于进程间同步\",{\"1\":{\"9\":1}}],[\"信号量是一个计数器\",{\"1\":{\"9\":1}}],[\"信号量\",{\"0\":{\"624\":1},\"1\":{\"7\":1,\"9\":1,\"624\":1}}],[\"模板方法模式\",{\"1\":{\"437\":1}}],[\"模式的\",{\"1\":{\"299\":1}}],[\"模式设计开发了一套高效的事件处理模型\",{\"1\":{\"298\":1}}],[\"模块\",{\"1\":{\"137\":1}}],[\"模拟订单过期解锁库存\",{\"0\":{\"96\":1}}],[\"模型更像是一种交换器模型\",{\"1\":{\"82\":1}}],[\"模型一共有\",{\"1\":{\"19\":1}}],[\"模型\",{\"0\":{\"19\":1,\"20\":1},\"1\":{\"21\":1,\"23\":1}}],[\"无用的类\",{\"1\":{\"672\":2}}],[\"无锁状态\",{\"1\":{\"614\":1}}],[\"无界队列\",{\"1\":{\"607\":1}}],[\"无效\",{\"1\":{\"585\":1}}],[\"无符号右移\",{\"1\":{\"546\":1}}],[\"无序\",{\"1\":{\"530\":1}}],[\"无状态表示这个实例没有属性对象\",{\"1\":{\"451\":1}}],[\"无状态地址自动配置\",{\"1\":{\"210\":1}}],[\"无差错\",{\"1\":{\"188\":1}}],[\"无法被父类加载器加载的类最终会通过这个方法被加载\",{\"1\":{\"712\":1,\"716\":1}}],[\"无法处理浮动垃圾\",{\"1\":{\"683\":1}}],[\"无法在任何地方通过反射访问该类的方法\",{\"1\":{\"672\":1}}],[\"无法通知gc回收器回收它们\",{\"1\":{\"666\":1}}],[\"无法访问其他线程的本地内存\",{\"1\":{\"573\":1}}],[\"无法实现虚拟主机\",{\"1\":{\"181\":1}}],[\"无法再添加\",{\"1\":{\"93\":1}}],[\"无论这两个操作是不是在同一个线程里\",{\"1\":{\"575\":1}}],[\"无论创建了多少个类实例\",{\"1\":{\"477\":1}}],[\"无论事务是否成功\",{\"1\":{\"231\":1}}],[\"无论\",{\"1\":{\"175\":1}}],[\"无连接\",{\"1\":{\"173\":1}}],[\"无名管道\",{\"1\":{\"9\":1}}],[\"队列锁中\",{\"1\":{\"622\":1}}],[\"队列锁的一个结点\",{\"1\":{\"622\":1}}],[\"队列满足fifo性质\",{\"1\":{\"537\":1}}],[\"队列满了\",{\"1\":{\"93\":1}}],[\"队列削峰如何实现\",{\"0\":{\"164\":1}}],[\"队列削峰\",{\"0\":{\"163\":1},\"1\":{\"136\":1}}],[\"队列可以在集群中的机器上设置镜像\",{\"1\":{\"78\":1,\"81\":1}}],[\"死亡对象的回收代价是零\",{\"1\":{\"730\":1}}],[\"死亡对象的判断方法\",{\"0\":{\"665\":1}}],[\"死锁的四个必要条件\",{\"1\":{\"563\":1}}],[\"死锁\",{\"0\":{\"563\":1}}],[\"死信队列\",{\"1\":{\"98\":1}}],[\"死信邮箱\",{\"1\":{\"93\":1}}],[\"死信交换器\",{\"1\":{\"93\":1}}],[\"死链接可恢复为正常的软链接\",{\"1\":{\"15\":1}}],[\"轮询\",{\"1\":{\"92\":1}}],[\"轮训机制\",{\"1\":{\"60\":1}}],[\"轮训\",{\"1\":{\"60\":1,\"140\":1}}],[\"且之后每次\",{\"1\":{\"721\":1}}],[\"且其它事务不能加任何锁\",{\"1\":{\"285\":1}}],[\"且\",{\"1\":{\"278\":1}}],[\"且修改索引时\",{\"1\":{\"277\":1}}],[\"且表中只有一行记录的情况下\",{\"1\":{\"243\":1}}],[\"且有\",{\"1\":{\"219\":1}}],[\"且可缓存\",{\"1\":{\"175\":1}}],[\"且不会出现响应超时或者错误\",{\"1\":{\"114\":1}}],[\"且每条tcp链接上的信道数量没有限制\",{\"1\":{\"97\":1}}],[\"且并发数受系统资源限制\",{\"1\":{\"97\":1}}],[\"且requeue\",{\"1\":{\"93\":1}}],[\"且最后一个单词是com才会匹配\",{\"1\":{\"90\":1}}],[\"且父进程没有调用\",{\"1\":{\"10\":1}}],[\"其余的类加载器都应有自己的父类加载器\",{\"1\":{\"713\":1}}],[\"其余的三个验证阶段都是基于方法区的存储结构上进行\",{\"1\":{\"703\":1}}],[\"其余的意向锁和共享或者排他锁都互斥\",{\"1\":{\"240\":1}}],[\"其余行为\",{\"1\":{\"679\":1}}],[\"其并发控制采用可重入锁\",{\"1\":{\"632\":1}}],[\"其与\",{\"1\":{\"539\":1}}],[\"其它和\",{\"1\":{\"396\":2}}],[\"其它事务也可以加s\",{\"1\":{\"285\":1}}],[\"其实准确分类只有两大种\",{\"1\":{\"663\":1}}],[\"其实使用了tryreleaseshared方法以\",{\"1\":{\"625\":1}}],[\"其实已经修改了两次\",{\"1\":{\"584\":1}}],[\"其实就是链表数据结构的实现\",{\"1\":{\"386\":1}}],[\"其实这两个是差不多的意思\",{\"1\":{\"164\":1}}],[\"其底层实现主要依赖这\",{\"1\":{\"382\":1}}],[\"其内置了多种类型的锁比如可重入锁\",{\"1\":{\"377\":1}}],[\"其提供了一个专门用来监控和续期锁的\",{\"1\":{\"376\":1}}],[\"其本质可以看成是一种排序好的数据结构\",{\"1\":{\"256\":1}}],[\"其查询结果也不会被缓存\",{\"1\":{\"229\":1}}],[\"其表数据文件本身就是按b+tree阻止的一个索引结构\",{\"1\":{\"228\":1}}],[\"其数据文件本身就是索引文件\",{\"1\":{\"228\":1}}],[\"其重传时间应比数据在分组传输的平均往返时间更长一些\",{\"1\":{\"203\":1}}],[\"其一个节点挂掉不影响另外一个节点对外服务\",{\"1\":{\"115\":1}}],[\"其他类加载器均由\",{\"1\":{\"712\":1}}],[\"其他所有的类加载器都是在\",{\"1\":{\"711\":1}}],[\"其他阻塞的线程才能获取到\",{\"1\":{\"624\":1}}],[\"其他线程都会阻塞\",{\"1\":{\"624\":1}}],[\"其他线程可以尝试获取锁\",{\"1\":{\"589\":1}}],[\"其他的诸如\",{\"1\":{\"620\":1}}],[\"其他的一台或者多台作为从数据库\",{\"1\":{\"247\":1}}],[\"其他\",{\"0\":{\"726\":1},\"1\":{\"519\":1}}],[\"其他操作\",{\"1\":{\"450\":1}}],[\"其他命令都会被阻塞\",{\"1\":{\"409\":1}}],[\"其他方法都需要依靠expire命令来设置过期时间\",{\"1\":{\"326\":1}}],[\"其他节点只存放key\",{\"1\":{\"262\":1}}],[\"其他不互斥\",{\"1\":{\"239\":1}}],[\"其他都一样\",{\"1\":{\"175\":1}}],[\"其他同理\",{\"1\":{\"108\":1}}],[\"其他用户可以轻松获取\",{\"1\":{\"105\":1}}],[\"其中连接过程分为\",{\"1\":{\"700\":1}}],[\"其中阻塞队列的典型例子是\",{\"1\":{\"630\":1}}],[\"其中的method就是反射类\",{\"1\":{\"507\":1}}],[\"其中的broker与producer端的双向通信能力使得broker天生可以作为一个事务的协调者存在\",{\"1\":{\"129\":1}}],[\"其中编译的是热点代码\",{\"1\":{\"467\":1}}],[\"其中aop发生在初始化后这个步骤\",{\"1\":{\"453\":1}}],[\"其中写在前面的2个实例是master\",{\"1\":{\"429\":1}}],[\"其中登录的密码查询是需要自己去实现接口userdetailsservice\",{\"1\":{\"146\":1}}],[\"其中一个挂掉\",{\"1\":{\"115\":1}}],[\"其中自动确认是指一旦消息被consumer收到\",{\"1\":{\"101\":1}}],[\"其中\",{\"1\":{\"90\":1,\"214\":1,\"331\":1,\"589\":2,\"700\":1}}],[\"其每个子元素会被解析为\",{\"1\":{\"32\":2}}],[\"广播转移结果\",{\"1\":{\"431\":1}}],[\"广播\",{\"0\":{\"88\":1}}],[\"大表\",{\"1\":{\"729\":1}}],[\"大部分对象用过即死\",{\"1\":{\"730\":1}}],[\"大部分类在具体用到的时候才会去加载\",{\"1\":{\"710\":1}}],[\"大部分情况\",{\"1\":{\"662\":1}}],[\"大部分情况下\",{\"1\":{\"617\":1}}],[\"大对象就是需要大量连续内存空间的对象\",{\"1\":{\"661\":1}}],[\"大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率\",{\"1\":{\"661\":1}}],[\"大对象直接进入老年代\",{\"0\":{\"661\":1}}],[\"大多数情况下\",{\"1\":{\"660\":1}}],[\"大多数情况下也可以将一个rabbitmq\",{\"1\":{\"86\":1}}],[\"大类\",{\"1\":{\"380\":1}}],[\"大key\",{\"0\":{\"365\":1}}],[\"大致可以分为初始标记\",{\"1\":{\"685\":1}}],[\"大致标准\",{\"1\":{\"336\":1}}],[\"大致估算出找到所需的记录或所需读取的行数\",{\"1\":{\"243\":1}}],[\"大量阻塞线程会导致系统的上下文切换\",{\"1\":{\"582\":1}}],[\"大量cpu和内存消耗\",{\"1\":{\"416\":1}}],[\"大量key同时失效\",{\"0\":{\"354\":1}}],[\"大量key集中过期问题\",{\"0\":{\"335\":1}}],[\"大量请求的key是不合法的\",{\"1\":{\"352\":1}}],[\"大量请求落入数据库\",{\"1\":{\"341\":1}}],[\"大量的key失效\",{\"1\":{\"153\":1}}],[\"大幅减少rtt\",{\"1\":{\"331\":1}}],[\"大幅度提升读性能\",{\"1\":{\"245\":1}}],[\"大概都在\",{\"1\":{\"300\":1}}],[\"大于等于这个\",{\"1\":{\"288\":1}}],[\"大小通过proxy\",{\"1\":{\"57\":1}}],[\"大小的内存\",{\"1\":{\"12\":1}}],[\"与用户线程并发执行\",{\"1\":{\"684\":1}}],[\"与软引用的区别在于\",{\"1\":{\"670\":1}}],[\"与可创建的最大线程数不是一个意思\",{\"1\":{\"604\":1}}],[\"与此线程有关的inheritablethreadlocal值\",{\"1\":{\"599\":1}}],[\"与此线程有关的threadlocal值\",{\"1\":{\"599\":1}}],[\"与代理类对象调用的方法相对应\",{\"1\":{\"514\":1}}],[\"与快照持久化相比\",{\"1\":{\"410\":1}}],[\"与传统数据库不同的是\",{\"1\":{\"297\":1}}],[\"与传统的消息中间件不同\",{\"1\":{\"85\":1}}],[\"与b=2无关\",{\"1\":{\"271\":1}}],[\"与存储引擎无关\",{\"1\":{\"237\":1}}],[\"与http模块并列\",{\"1\":{\"139\":1}}],[\"与\",{\"0\":{\"187\":1,\"188\":1,\"221\":1,\"534\":1,\"538\":1},\"1\":{\"103\":1,\"243\":2,\"375\":1,\"416\":1,\"633\":1,\"684\":1,\"698\":1}}],[\"与管道\",{\"1\":{\"9\":1}}],[\"主版本号是否在当前虚拟机的处理范围内\",{\"1\":{\"703\":1}}],[\"主版本号都会加1\",{\"1\":{\"692\":1}}],[\"主内存\",{\"1\":{\"573\":1}}],[\"主动放出已经保持的资源\",{\"1\":{\"564\":1}}],[\"主进程执行写的时候\",{\"1\":{\"409\":1}}],[\"主进程进行读的时候\",{\"1\":{\"409\":1}}],[\"主线程继续工作\",{\"1\":{\"625\":1}}],[\"主线程调用\",{\"1\":{\"412\":3}}],[\"主线程\",{\"1\":{\"363\":2,\"625\":2}}],[\"主节点master用来写\",{\"1\":{\"418\":1}}],[\"主节点依然可以获取锁\",{\"1\":{\"378\":1}}],[\"主节点宕机了\",{\"1\":{\"378\":1}}],[\"主节点获取到锁后\",{\"1\":{\"378\":1}}],[\"主节点处理写请求\",{\"1\":{\"343\":1}}],[\"主节点写\",{\"1\":{\"245\":1}}],[\"主键索引\",{\"0\":{\"263\":1}}],[\"主库会创建一个\",{\"1\":{\"248\":1}}],[\"主库将数据库中数据的变化写入到\",{\"1\":{\"248\":1}}],[\"主从解决了高并发读\",{\"1\":{\"428\":1}}],[\"主从集群\",{\"0\":{\"418\":1}}],[\"主从复制的原理是什么\",{\"0\":{\"248\":1}}],[\"主从同步延迟\",{\"1\":{\"246\":1}}],[\"主机可以直接通过根据接口标识和网络前缀生成全局唯一的\",{\"1\":{\"210\":1}}],[\"主作用是定义数据包的格式\",{\"1\":{\"208\":1}}],[\"主数据库向从数据库同步失败不影响读写操作\",{\"1\":{\"115\":1}}],[\"主数据库向商品服务响应写入成功\",{\"1\":{\"112\":1}}],[\"主题\",{\"1\":{\"85\":1}}],[\"主要目的是保证输入的字节流能正确的解析并存储于方法区内\",{\"1\":{\"703\":1}}],[\"主要目的是为了避免字符串的重复创建\",{\"1\":{\"647\":1}}],[\"主要目的是为了简化编程\",{\"1\":{\"572\":1}}],[\"主要目的是为了解决幻读问题\",{\"1\":{\"238\":1,\"292\":1}}],[\"主要针对配备多颗处理器及大容量内存的机器\",{\"1\":{\"684\":1}}],[\"主要服务一个方法需要调用其他方法的场景\",{\"1\":{\"641\":1}}],[\"主要作为方法调用的中转站使用\",{\"1\":{\"641\":1}}],[\"主要作用是定义数据包的格式\",{\"1\":{\"174\":1}}],[\"主要存放了编译期可知的各种数据类型\",{\"1\":{\"641\":1}}],[\"主要使用\",{\"1\":{\"630\":1}}],[\"主要解决的是多个线程之间访问资源的同步性\",{\"1\":{\"587\":1}}],[\"主要逻辑是单线程完成的\",{\"1\":{\"324\":1}}],[\"主要在于内存和网络\",{\"1\":{\"322\":1}}],[\"主要需要用到下面这两个命令\",{\"1\":{\"317\":1}}],[\"主要是磁盘io资源\",{\"1\":{\"416\":1}}],[\"主要是单线程事件循环和\",{\"1\":{\"298\":1}}],[\"主要是为\",{\"1\":{\"172\":1,\"191\":1}}],[\"主要有两个作用\",{\"1\":{\"289\":1}}],[\"主要有以下字段\",{\"1\":{\"288\":1}}],[\"主要有下面两种情况\",{\"1\":{\"282\":1}}],[\"主要负责加载\",{\"1\":{\"711\":1}}],[\"主要负责数据的存储和读取\",{\"1\":{\"226\":1}}],[\"主要负责接收\",{\"1\":{\"82\":1}}],[\"主要包括表记录的插入\",{\"1\":{\"222\":1}}],[\"主要包含下面几部分的内容\",{\"1\":{\"8\":1}}],[\"主要用来加载\",{\"1\":{\"711\":1}}],[\"主要用来构建锁和同步器\",{\"1\":{\"620\":1}}],[\"主要用在一些需要执行耗时任务的场景\",{\"1\":{\"611\":1}}],[\"主要用在秒杀部分\",{\"1\":{\"137\":1}}],[\"主要用于存储地理位置信息\",{\"1\":{\"404\":1}}],[\"主要用于在不同网络之间转换\",{\"1\":{\"211\":1}}],[\"主要用于区分普通查询\",{\"1\":{\"243\":1}}],[\"主要用于区分\",{\"1\":{\"48\":1}}],[\"绑定的\",{\"1\":{\"380\":1}}],[\"绑定dlx的队列就称之为死信队列\",{\"1\":{\"93\":1}}],[\"绑定键\",{\"1\":{\"84\":1}}],[\"绑定\",{\"1\":{\"84\":1}}],[\"指示\",{\"1\":{\"725\":1}}],[\"指针碰撞\",{\"1\":{\"650\":2}}],[\"指令之后会接着执行\",{\"1\":{\"653\":1}}],[\"指令和\",{\"1\":{\"589\":1}}],[\"指令后\",{\"1\":{\"589\":1}}],[\"指令来释放锁\",{\"1\":{\"589\":1}}],[\"指令则指明同步代码块的结束位置\",{\"1\":{\"589\":2}}],[\"指令指向同步代码块的开始位置\",{\"1\":{\"589\":2}}],[\"指令\",{\"1\":{\"589\":3}}],[\"指令流水线数据相关\",{\"1\":{\"575\":1}}],[\"指令重排可能会导致问题\",{\"1\":{\"571\":1}}],[\"指令重排序可以保证串行语义的一致\",{\"1\":{\"571\":1}}],[\"指令重排序\",{\"0\":{\"571\":1}}],[\"指令并行重排\",{\"1\":{\"571\":1}}],[\"指令计数器\",{\"1\":{\"8\":1}}],[\"指向的是堆中不同的对象\",{\"1\":{\"498\":1}}],[\"指向的是堆中的同一个对象\",{\"1\":{\"498\":2}}],[\"指向该行的\",{\"1\":{\"287\":1}}],[\"指的是子类方法的访问权限应比父类方法的访问权限更大或相等\",{\"1\":{\"480\":1}}],[\"指的是子类方法返回值类型应比父类方法返回值类型更小或相等\",{\"1\":{\"480\":1}}],[\"指定永久代\",{\"0\":{\"721\":1}}],[\"指定新生代内存\",{\"0\":{\"720\":1}}],[\"指定堆内存\",{\"0\":{\"719\":1}}],[\"指定名称\",{\"1\":{\"444\":1}}],[\"指定\",{\"1\":{\"345\":1,\"362\":1,\"720\":1}}],[\"指定元素排名\",{\"1\":{\"313\":1,\"397\":2}}],[\"指明了响应的routingkey应该投递到哪个队列\",{\"1\":{\"84\":1}}],[\"指出该消息可能需要持久性存储\",{\"1\":{\"83\":1}}],[\"消耗在垃圾收集上的时间不得超过\",{\"1\":{\"684\":1}}],[\"消耗的内存约是\",{\"1\":{\"310\":1}}],[\"消除了非主属性对于码的传递函数依赖\",{\"1\":{\"220\":1}}],[\"消除了非主属性对于码的部分函数依赖\",{\"1\":{\"219\":1}}],[\"消费不过来\",{\"1\":{\"103\":1}}],[\"消费消息的一方\",{\"1\":{\"83\":1}}],[\"消费者模型中\",{\"1\":{\"540\":1,\"631\":1}}],[\"消费者方\",{\"1\":{\"127\":1}}],[\"消费者与rabbitmq通信的渠道\",{\"1\":{\"97\":1}}],[\"消费者\",{\"0\":{\"83\":1},\"1\":{\"83\":2,\"102\":2}}],[\"消息持久化\",{\"1\":{\"306\":1}}],[\"消息也只能被消费一次\",{\"1\":{\"306\":1}}],[\"消息还是处于不能消费的状态\",{\"1\":{\"129\":1}}],[\"消息重复消费问题\",{\"0\":{\"128\":1}}],[\"消息生产太快\",{\"1\":{\"103\":1}}],[\"消息的可靠性关键由发起通知方来保证\",{\"1\":{\"132\":1}}],[\"消息的校对机制\",{\"1\":{\"131\":1}}],[\"消息的顺序性\",{\"0\":{\"102\":1}}],[\"消息的ttl\",{\"0\":{\"95\":1}}],[\"消息从exchange\",{\"1\":{\"100\":1}}],[\"消息从producer\",{\"1\":{\"99\":1}}],[\"消息补偿机制\",{\"1\":{\"98\":1}}],[\"消息怎么传输\",{\"0\":{\"97\":1}}],[\"消息被发送给队列之后\",{\"1\":{\"94\":1}}],[\"消息被拒\",{\"1\":{\"93\":1}}],[\"消息ttl过期\",{\"1\":{\"93\":1}}],[\"消息中间件的服务节点\",{\"0\":{\"86\":1}}],[\"消息并不是直接投递到queue\",{\"1\":{\"84\":1}}],[\"消息体是不透明的\",{\"1\":{\"83\":1}}],[\"消息体也可以称为\",{\"1\":{\"83\":1}}],[\"消息体\",{\"1\":{\"83\":1}}],[\"消息头和\",{\"1\":{\"83\":1}}],[\"消息一般由\",{\"1\":{\"83\":1}}],[\"消息服务\",{\"1\":{\"74\":1}}],[\"消息丢失\",{\"1\":{\"73\":1}}],[\"消息不一定要以先进先出的次序读取\",{\"1\":{\"9\":1}}],[\"消息队列保证消息的成功投递\",{\"1\":{\"360\":1}}],[\"消息队列保证可靠性\",{\"1\":{\"360\":1}}],[\"消息队列删除缓存\",{\"1\":{\"360\":1}}],[\"消息队列需要把消息存储起来\",{\"1\":{\"75\":1}}],[\"消息队列主要用来降低系统耦合性\",{\"1\":{\"75\":1}}],[\"消息队列有什么用\",{\"0\":{\"68\":1}}],[\"消息队列允许应用程序异步的发送和接收消息\",{\"1\":{\"67\":1}}],[\"消息队列是单向引入中间载体的网络通讯\",{\"1\":{\"75\":1}}],[\"消息队列是一种用于在应用程序之间传递消息的通信方式\",{\"1\":{\"67\":1}}],[\"消息队列是消息的链表\",{\"1\":{\"9\":1}}],[\"消息队列克服了信号承载信息量少\",{\"1\":{\"9\":1}}],[\"消息队列可以实现消息的随机查询\",{\"1\":{\"9\":1}}],[\"消息队列\",{\"0\":{\"85\":1},\"1\":{\"9\":1,\"77\":1,\"84\":1,\"85\":1,\"102\":1,\"306\":1,\"388\":1}}],[\"己的插件\",{\"1\":{\"81\":1}}],[\"己经提供了一些内置的交换器来实现\",{\"1\":{\"78\":1}}],[\"群中的节点等\",{\"1\":{\"81\":1}}],[\"集合框架底层数据结构\",{\"0\":{\"530\":1}}],[\"集合中包含元素的个数\",{\"1\":{\"401\":1}}],[\"集合中的元素没有先后顺序但都唯一\",{\"1\":{\"314\":1,\"392\":1}}],[\"集合\",{\"0\":{\"392\":1,\"528\":1,\"552\":1},\"1\":{\"308\":1,\"382\":1}}],[\"集群宕机\",{\"1\":{\"380\":1}}],[\"集群主从切换导致的锁丢失问题\",{\"1\":{\"378\":1}}],[\"集群操作的\",{\"1\":{\"378\":1}}],[\"集群数据同步到各个节点时是异步的\",{\"1\":{\"378\":1}}],[\"集群下\",{\"1\":{\"378\":1}}],[\"集群扩容\",{\"0\":{\"367\":1}}],[\"集群模式下不能保证所有的key都在同一个hash\",{\"1\":{\"333\":1}}],[\"集群的话会更高\",{\"1\":{\"300\":1}}],[\"集群支持\",{\"1\":{\"299\":1}}],[\"集群\",{\"1\":{\"98\":1}}],[\"集群中有多个master\",{\"1\":{\"429\":1}}],[\"集群中有半数以上的\",{\"1\":{\"378\":1}}],[\"集群中的多个独立的\",{\"1\":{\"378\":1}}],[\"集群中的节点等\",{\"1\":{\"78\":1}}],[\"集群中节点越多\",{\"1\":{\"430\":1}}],[\"集群中节点\",{\"1\":{\"81\":1}}],[\"集\",{\"1\":{\"81\":1}}],[\"管理着任务执行的情况\",{\"1\":{\"612\":1}}],[\"管理界面\",{\"1\":{\"81\":1}}],[\"管道只能承载无格式字\",{\"1\":{\"9\":1}}],[\"管道和消息队列的通信数据都是先进先出的原则\",{\"1\":{\"9\":1}}],[\"管道\",{\"1\":{\"9\":1}}],[\"更强大\",{\"1\":{\"592\":1}}],[\"更灵活\",{\"1\":{\"592\":1}}],[\"更快的重启以及解决\",{\"1\":{\"416\":1}}],[\"更适合做消息队列一些\",{\"1\":{\"388\":1}}],[\"更适合于企业级的开发\",{\"1\":{\"80\":1}}],[\"更方便操作\",{\"1\":{\"386\":1}}],[\"更不会涉及到其他对象\",{\"1\":{\"222\":1}}],[\"更新region的统计数据\",{\"1\":{\"684\":1}}],[\"更新db的时候同样更新cache\",{\"1\":{\"302\":1}}],[\"更新db的时候同时更新cache\",{\"1\":{\"302\":1}}],[\"更新代价比聚簇索引小\",{\"1\":{\"267\":2}}],[\"更新代价大\",{\"1\":{\"266\":1}}],[\"更新\",{\"1\":{\"222\":1,\"302\":1}}],[\"更新的协议\",{\"1\":{\"172\":1,\"191\":1}}],[\"更加简化和高效\",{\"1\":{\"210\":1}}],[\"更安全的超文本传输协议\",{\"1\":{\"191\":1}}],[\"更有优势\",{\"1\":{\"9\":1}}],[\"本类内部创建对象实例\",{\"1\":{\"520\":1}}],[\"本身会极大的节省储存空间\",{\"1\":{\"398\":1}}],[\"本身支持很多的协议\",{\"1\":{\"80\":1}}],[\"本章的所有知识都属于计算机统考408计算机学科专业基础中的知识点\",{\"1\":{\"205\":1}}],[\"本地内存是jmm抽象出的概念\",{\"1\":{\"573\":1}}],[\"本地内存\",{\"1\":{\"573\":1,\"645\":1}}],[\"本地方法栈中的对象\",{\"1\":{\"668\":1}}],[\"本地方法栈和虚拟机栈发挥的作用类似\",{\"1\":{\"559\":1}}],[\"本地方法栈用于存放native方法\",{\"1\":{\"559\":1}}],[\"本地方法栈\",{\"0\":{\"642\":1},\"1\":{\"556\":1,\"557\":1}}],[\"本地\",{\"1\":{\"185\":1}}],[\"本地锁\",{\"1\":{\"153\":1}}],[\"本地事务成功后通知mq\",{\"1\":{\"129\":1}}],[\"本地事务与消息发送的原子性问题\",{\"1\":{\"130\":1}}],[\"本地事务与消息发送的原子性问题是实现可靠消息最终\",{\"1\":{\"126\":1}}],[\"本地事务与消息发送的原子性问题即事务发起方在本地事务执行成功后消息必须发出去\",{\"1\":{\"126\":1}}],[\"本地事务与消息发送的原子性\",{\"0\":{\"126\":1}}],[\"本项目使用redis进行用户数据统一存储\",{\"1\":{\"146\":1}}],[\"本机的6379端口映射到docker中的6379端口\",{\"1\":{\"107\":1}}],[\"本质不是同一个文件\",{\"1\":{\"15\":1}}],[\"本质是同一个文件\",{\"1\":{\"15\":1}}],[\"本质区别\",{\"1\":{\"15\":1}}],[\"数统计\",{\"1\":{\"403\":1}}],[\"数量\",{\"1\":{\"405\":1}}],[\"数量量巨大\",{\"1\":{\"403\":1}}],[\"数量即可\",{\"1\":{\"79\":1}}],[\"数组来优化堆内存\",{\"1\":{\"726\":1}}],[\"数组来实现二叉堆\",{\"1\":{\"530\":1}}],[\"数组类不是通过classloader创建的\",{\"1\":{\"709\":1}}],[\"数组等方式实现了这个接口\",{\"1\":{\"627\":1}}],[\"数组+链表\",{\"1\":{\"550\":1}}],[\"数组+链表组成的\",{\"1\":{\"530\":1}}],[\"数组长度大于等于64的时候就会触发树化\",{\"1\":{\"547\":1}}],[\"数组长度大于等于64的时候会进行树化\",{\"1\":{\"530\":1}}],[\"数组容量扩为\",{\"1\":{\"532\":1}}],[\"数组是\",{\"1\":{\"530\":2,\"550\":1}}],[\"数组\",{\"1\":{\"389\":1,\"530\":3,\"661\":1}}],[\"数值越小越好\",{\"1\":{\"243\":1}}],[\"数据表示是否太臃肿\",{\"1\":{\"729\":1}}],[\"数据表的主键列使用的就是主键索引\",{\"1\":{\"263\":1}}],[\"数据是不是太多\",{\"1\":{\"729\":1}}],[\"数据迁移\",{\"1\":{\"431\":1}}],[\"数据key不是与节点绑定而是与插槽绑定\",{\"1\":{\"430\":1}}],[\"数据同步原理\",{\"0\":{\"419\":1}}],[\"数据恢复优先级\",{\"1\":{\"416\":1}}],[\"数据完整性更高\",{\"1\":{\"416\":1}}],[\"数据完整性\",{\"1\":{\"416\":1}}],[\"数据的可靠性\",{\"1\":{\"415\":1}}],[\"数据在\",{\"1\":{\"326\":2}}],[\"数据量巨大的场景还是\",{\"1\":{\"314\":1,\"394\":1}}],[\"数据结构散列表中除留余数法\",{\"1\":{\"548\":1}}],[\"数据结构散列表\",{\"1\":{\"491\":1}}],[\"数据结构可以用来做消息队列\",{\"1\":{\"388\":1}}],[\"数据结构可以作为一个简单的队列使用\",{\"1\":{\"306\":1}}],[\"数据结构实际使用的内存\",{\"1\":{\"350\":1}}],[\"数据结构\",{\"0\":{\"307\":1}}],[\"数据可能还没异步更新\",{\"1\":{\"304\":1}}],[\"数据更新\",{\"1\":{\"302\":1}}],[\"数据更新之后对缓存如何操作\",{\"0\":{\"152\":1}}],[\"数据删除\",{\"1\":{\"302\":1}}],[\"数据类型\",{\"1\":{\"299\":1}}],[\"数据前生成一个read\",{\"1\":{\"290\":1}}],[\"数据文件本身就是索引文件\",{\"1\":{\"262\":1}}],[\"数据遍布在不同服务器上的数据库\",{\"1\":{\"254\":1}}],[\"数据应该放在哪个表的问题\",{\"1\":{\"253\":1}}],[\"数据保持一致\",{\"1\":{\"231\":1}}],[\"数据块被称为报文段或段\",{\"1\":{\"199\":1}}],[\"数据传送结束后要释放连接\",{\"1\":{\"188\":1}}],[\"数据包包含了源ip地址和目的ip地址\",{\"1\":{\"209\":1}}],[\"数据包\",{\"1\":{\"175\":2}}],[\"数据\",{\"1\":{\"175\":1,\"538\":1}}],[\"数据报在物理上传输的过程中\",{\"1\":{\"174\":1,\"214\":1}}],[\"数据自治原则\",{\"1\":{\"144\":1}}],[\"数据库查询需要什么字段就返回对应字段\",{\"1\":{\"729\":1}}],[\"数据库不支持事务\",{\"1\":{\"448\":1}}],[\"数据库和缓存数据强一致性场景\",{\"1\":{\"302\":1}}],[\"数据库的自增主键已经没办法满足生成唯一主键\",{\"1\":{\"254\":1}}],[\"数据库的数据占用的空间越来越大\",{\"1\":{\"252\":1}}],[\"数据库的三大范式\",{\"0\":{\"217\":1}}],[\"数据库读写速度比较缓慢\",{\"1\":{\"252\":1}}],[\"数据库重新启动的时候会保证数据库恢复到崩溃前的状态\",{\"1\":{\"228\":1}}],[\"数据库基础\",{\"0\":{\"216\":1}}],[\"数据库\",{\"0\":{\"26\":1,\"39\":1}}],[\"数据从内核空间\",{\"1\":{\"22\":1}}],[\"极高的可用性以及可靠性\",{\"1\":{\"79\":1}}],[\"易用的管理界面\",{\"1\":{\"78\":1}}],[\"传入\",{\"1\":{\"612\":1}}],[\"传入类路径获取\",{\"1\":{\"509\":1}}],[\"传入类的全路径名\",{\"1\":{\"509\":1}}],[\"传递规则\",{\"1\":{\"576\":1}}],[\"传递函数依赖会导致数据冗余和异常\",{\"1\":{\"219\":1}}],[\"传递函数依赖于\",{\"1\":{\"219\":1}}],[\"传递函数依赖\",{\"1\":{\"219\":1}}],[\"传给\",{\"1\":{\"456\":1}}],[\"传输可靠性保障\",{\"0\":{\"198\":1}}],[\"传输形式\",{\"1\":{\"188\":1}}],[\"传输效率就会越高\",{\"1\":{\"430\":1}}],[\"传输效率\",{\"1\":{\"188\":1}}],[\"传输是有状态的\",{\"1\":{\"188\":1}}],[\"传输控制协议\",{\"1\":{\"173\":1}}],[\"传输层\",{\"0\":{\"173\":1,\"192\":1,\"198\":1},\"1\":{\"139\":1}}],[\"传输确认以及发布确认\",{\"1\":{\"81\":1}}],[\"传输确认及发布确认等\",{\"1\":{\"78\":1}}],[\"传统的bio模型是无能为力的\",{\"1\":{\"21\":1}}],[\"容纳的话\",{\"1\":{\"662\":1}}],[\"容量等于\",{\"1\":{\"633\":1}}],[\"容量迅速增\",{\"1\":{\"633\":1}}],[\"容量不能改变\",{\"1\":{\"632\":1}}],[\"容量为\",{\"1\":{\"607\":1,\"647\":1}}],[\"容易篡改\",{\"1\":{\"146\":1}}],[\"容器中仅存在一个实例\",{\"1\":{\"451\":1}}],[\"容器的名称为redis\",{\"1\":{\"107\":1}}],[\"容器\",{\"0\":{\"107\":1},\"1\":{\"107\":1,\"463\":2}}],[\"容错的持久方式存储记录消息流\",{\"1\":{\"77\":1}}],[\"容灾恢复\",{\"1\":{\"299\":1}}],[\"容灾\",{\"1\":{\"59\":1}}],[\"发布\",{\"1\":{\"306\":1}}],[\"发布和订阅消息流\",{\"1\":{\"77\":1}}],[\"发现一二级缓存都没有\",{\"1\":{\"450\":1}}],[\"发现有多个则根据名称注入\",{\"1\":{\"444\":1}}],[\"发现userservice类型的bean只有一个则直接注入\",{\"1\":{\"444\":1}}],[\"发现slave宕机之后尽快实现故障恢复\",{\"1\":{\"422\":1}}],[\"发现等功能的改进\",{\"1\":{\"210\":1}}],[\"发现\",{\"1\":{\"175\":1}}],[\"发生fullgc\",{\"1\":{\"736\":1}}],[\"发生在类加载阶段的解析阶段\",{\"1\":{\"703\":1}}],[\"发生在请求2更新数据之前则会出现数据不一致\",{\"1\":{\"302\":1}}],[\"发生读请求的时候\",{\"1\":{\"303\":1}}],[\"发生隐式转换\",{\"1\":{\"278\":1}}],[\"发生异常则能本地回滚\",{\"1\":{\"155\":1}}],[\"发生了某些事先不可知的异常\",{\"1\":{\"3\":1}}],[\"发起通知方\",{\"1\":{\"133\":1}}],[\"发起通知方尽最大努力将业务处理结果通知接收通知方\",{\"1\":{\"132\":1}}],[\"发起通知方需要保证将消息发送出去\",{\"1\":{\"132\":1}}],[\"发起通知方通过一定机制最大努力将业务处理结果通知到接收方\",{\"1\":{\"131\":1}}],[\"发送请求\",{\"1\":{\"456\":1}}],[\"发送心跳信息的消息头是16384\",{\"1\":{\"430\":1}}],[\"发送心跳信息的消息头是65536\",{\"1\":{\"430\":1}}],[\"发送给slave\",{\"1\":{\"422\":1}}],[\"发送命令\",{\"1\":{\"331\":1,\"344\":1}}],[\"发送方能将发送窗口内的所有序号发送\",{\"1\":{\"204\":1}}],[\"发送方维持一个发送窗口\",{\"1\":{\"204\":1}}],[\"发送窗口>1\",{\"1\":{\"204\":1,\"205\":1}}],[\"发送窗口=接收窗口=1\",{\"1\":{\"203\":1}}],[\"发送和接收邮件\",{\"1\":{\"189\":1}}],[\"发送\",{\"1\":{\"178\":1}}],[\"发送次数变多仍然没有收到确认之后\",{\"1\":{\"131\":1}}],[\"发送者发送流量太大上线更多的消费者\",{\"1\":{\"103\":1}}],[\"kb\",{\"1\":{\"726\":1}}],[\"km\",{\"1\":{\"405\":1}}],[\"k\",{\"1\":{\"299\":2}}],[\"kv\",{\"1\":{\"297\":1}}],[\"kafka的性能在数据大小方面实际上是恒定的\",{\"1\":{\"85\":1}}],[\"kafka的特点其实很明显\",{\"1\":{\"79\":1}}],[\"kafka中的topic始终是多生产者和多订阅者\",{\"1\":{\"85\":1}}],[\"kafka将消息存储在topic\",{\"1\":{\"85\":1}}],[\"kafka唯一的一点劣势是有可能消息重复消费\",{\"1\":{\"79\":1}}],[\"kafka提供了一个完整的流式处理类库\",{\"1\":{\"77\":1}}],[\"kafka会把消息持久化到磁盘\",{\"1\":{\"77\":1}}],[\"kafka是linkedin开源的一个分布式流式处理平台\",{\"1\":{\"77\":1}}],[\"kafka仅做介绍\",{\"1\":{\"77\":1}}],[\"kafka\",{\"0\":{\"77\":1},\"1\":{\"306\":1}}],[\"keepalivetime才会被回收销毁\",{\"1\":{\"605\":1}}],[\"keepalivetime\",{\"1\":{\"605\":3}}],[\"keepalive\",{\"1\":{\"63\":1}}],[\"key是别的region的起始地址\",{\"1\":{\"687\":1}}],[\"key是无序的\",{\"1\":{\"529\":1}}],[\"key和value\",{\"1\":{\"543\":1}}],[\"key2\",{\"1\":{\"317\":1,\"384\":2,\"393\":6,\"396\":3,\"399\":1,\"402\":1}}],[\"key1\",{\"1\":{\"317\":1,\"384\":2,\"393\":6,\"396\":3,\"399\":1,\"402\":1}}],[\"key为userid+\",{\"1\":{\"158\":1}}],[\"key\",{\"0\":{\"263\":1,\"292\":1,\"340\":1},\"1\":{\"62\":2,\"83\":1,\"153\":1,\"155\":1,\"228\":1,\"232\":1,\"238\":3,\"243\":8,\"262\":1,\"282\":2,\"285\":1,\"292\":3,\"309\":1,\"312\":1,\"315\":3,\"316\":2,\"317\":1,\"326\":3,\"328\":2,\"332\":2,\"334\":1,\"345\":1,\"362\":1,\"374\":5,\"375\":1,\"384\":21,\"385\":1,\"387\":7,\"390\":10,\"393\":6,\"396\":6,\"398\":1,\"399\":3,\"402\":1,\"405\":5,\"544\":1,\"546\":4,\"600\":4,\"647\":1}}],[\"key可以是配对的源ip地址和端口\",{\"1\":{\"60\":1}}],[\"keys\",{\"1\":{\"58\":1,\"155\":2,\"345\":1,\"362\":1,\"374\":2,\"376\":2}}],[\"跨代引用一般是使用记忆集解决\",{\"1\":{\"687\":1}}],[\"跨语言\",{\"1\":{\"81\":1}}],[\"跨语言特性\",{\"1\":{\"74\":1}}],[\"跨多个应用程序实例的负载均衡是一种常用的技术\",{\"1\":{\"59\":1}}],[\"为新生代分配256mb内存\",{\"1\":{\"720\":1}}],[\"为jvm堆内存分配最大5gb\",{\"1\":{\"719\":1}}],[\"为类的二进制名称\",{\"1\":{\"712\":1}}],[\"为null就是\",{\"1\":{\"711\":1}}],[\"为null的话\",{\"1\":{\"711\":1}}],[\"为各种框架提供开箱即用的便利\",{\"1\":{\"508\":1}}],[\"为形参\",{\"1\":{\"501\":1}}],[\"为实参\",{\"1\":{\"501\":1}}],[\"为每个region设置两个tams指针\",{\"1\":{\"684\":1}}],[\"为每个request创建实例\",{\"1\":{\"451\":1}}],[\"为每个bean请求创建实例\",{\"1\":{\"451\":1}}],[\"为集合数量\",{\"1\":{\"396\":1}}],[\"为例来说明如何使用\",{\"1\":{\"376\":1}}],[\"为何会出现\",{\"0\":{\"348\":1}}],[\"为返回的元素数量\",{\"1\":{\"345\":1,\"362\":1}}],[\"为所有元素的数量\",{\"1\":{\"345\":2,\"362\":2}}],[\"为\",{\"1\":{\"288\":1,\"312\":2,\"316\":1,\"600\":3,\"625\":1,\"714\":1}}],[\"为空\",{\"1\":{\"288\":1}}],[\"为该映射关系的生存周期\",{\"1\":{\"214\":1}}],[\"为什么需要java内存模型\",{\"0\":{\"572\":1}}],[\"为什么wait\",{\"0\":{\"567\":1}}],[\"为什么重写\",{\"0\":{\"492\":1}}],[\"为什么是\",{\"1\":{\"430\":1}}],[\"为什么\",{\"1\":{\"413\":1}}],[\"为什么要设置对前一个节点的监听\",{\"0\":{\"381\":1}}],[\"为什么要用线程池\",{\"0\":{\"603\":1}}],[\"为什么要用临时顺序节点\",{\"0\":{\"380\":1}}],[\"为什么要用缓存\",{\"0\":{\"300\":1}}],[\"为什么要用\",{\"0\":{\"300\":1}}],[\"为什么要三次握手\",{\"0\":{\"194\":1}}],[\"为什么这么快\",{\"0\":{\"298\":1}}],[\"为什么第四次挥手客户端需要等待\",{\"0\":{\"197\":1}}],[\"为什么不能把服务器发送的\",{\"0\":{\"196\":1}}],[\"为什么叫做恐龙商城\",{\"1\":{\"136\":1}}],[\"为此\",{\"1\":{\"188\":1}}],[\"为短连接\",{\"1\":{\"181\":1}}],[\"为未消费状态\",{\"1\":{\"158\":1}}],[\"为单位进行传输的\",{\"1\":{\"86\":1}}],[\"为面向消息的中间件设计\",{\"1\":{\"74\":1}}],[\"为了提升性能和减少内存消耗针对字符串\",{\"1\":{\"647\":1}}],[\"为了线程切换之后能恢复到正确的执行位置\",{\"1\":{\"640\":1}}],[\"为了将读取的性能发挥到极致\",{\"1\":{\"628\":1}}],[\"为了调用private方法取消安全检查\",{\"1\":{\"510\":1}}],[\"为了防止\",{\"1\":{\"633\":1}}],[\"为了防止误删到其他的锁\",{\"1\":{\"374\":1}}],[\"为了防止库存锁定之后订单服务出现问题\",{\"1\":{\"155\":1}}],[\"为了降低对redis的影响\",{\"1\":{\"338\":1}}],[\"为了满足不同的业务场景\",{\"1\":{\"297\":1}}],[\"为了避免对\",{\"1\":{\"414\":1}}],[\"为了避免单点故障\",{\"1\":{\"378\":1}}],[\"为了避免锁无法被释放\",{\"1\":{\"375\":1}}],[\"为了避免修改\",{\"1\":{\"311\":1}}],[\"为了避免插入新行\",{\"1\":{\"282\":1}}],[\"为了避免插入新记录\",{\"1\":{\"238\":1,\"292\":1}}],[\"为了避免孤儿进程占用系统资源\",{\"1\":{\"10\":1}}],[\"为了解决标记\",{\"1\":{\"675\":1}}],[\"为了解决这个问题\",{\"1\":{\"515\":1}}],[\"为了解决\",{\"1\":{\"210\":1}}],[\"为了保证不发生丢包\",{\"1\":{\"199\":1}}],[\"为了保证数据一致性会对资源进行锁定\",{\"1\":{\"113\":1}}],[\"为了性能和安全\",{\"1\":{\"175\":1}}],[\"为了强一致性牺牲可用性不划算\",{\"1\":{\"152\":1}}],[\"为了实现可靠消息最终一致性需要解决以下几个问题\",{\"1\":{\"125\":1}}],[\"为了克服这个缺点\",{\"1\":{\"9\":1}}],[\"高版本的jvm能运行低版本编译器生成的\",{\"1\":{\"692\":1}}],[\"高效利用cpu\",{\"1\":{\"680\":1}}],[\"高效的并发队列\",{\"1\":{\"627\":1}}],[\"高并发的场景下\",{\"1\":{\"582\":1}}],[\"高并发的应用\",{\"1\":{\"22\":1}}],[\"高并发写问题\",{\"1\":{\"428\":1}}],[\"高并发\",{\"1\":{\"300\":1}}],[\"高性能\",{\"1\":{\"300\":1}}],[\"高级功能\",{\"1\":{\"299\":1}}],[\"高级消息队列协议\",{\"1\":{\"74\":1,\"78\":1}}],[\"高可用的问题\",{\"1\":{\"428\":1}}],[\"高可用\",{\"1\":{\"225\":1,\"372\":1}}],[\"高可用性\",{\"1\":{\"78\":1,\"81\":1}}],[\"高\",{\"1\":{\"180\":1,\"416\":2}}],[\"高内聚低耦合\",{\"1\":{\"144\":1}}],[\"创建新线程的时候会用到\",{\"1\":{\"605\":1}}],[\"创建代理对象调用方法\",{\"1\":{\"514\":1}}],[\"创建string类型的对象\",{\"1\":{\"490\":1}}],[\"创建servlet\",{\"1\":{\"458\":1}}],[\"创建spring容器时会先进行扫描\",{\"1\":{\"453\":1}}],[\"创建dispatcherservlet\",{\"1\":{\"458\":1}}],[\"创建docker\",{\"1\":{\"109\":1}}],[\"创建容器\",{\"1\":{\"458\":1}}],[\"创建容器之后获取userservice得到的是同一个实例\",{\"1\":{\"436\":1}}],[\"创建bservice普通对象\",{\"1\":{\"450\":1}}],[\"创建bean的过程\",{\"1\":{\"442\":1}}],[\"创建aservice普通对象\",{\"1\":{\"450\":1}}],[\"创建aservice普通对象之后放入二级缓存\",{\"1\":{\"450\":1}}],[\"创建普通对象\",{\"1\":{\"450\":1}}],[\"创建一个新的事务\",{\"1\":{\"447\":1}}],[\"创建命令\",{\"1\":{\"429\":1}}],[\"创建快照时\",{\"1\":{\"416\":1}}],[\"创建成功之后\",{\"1\":{\"379\":1}}],[\"创建了\",{\"1\":{\"379\":1}}],[\"创建了组合索引\",{\"1\":{\"278\":1}}],[\"创建该\",{\"1\":{\"288\":1}}],[\"创建\",{\"0\":{\"363\":1},\"1\":{\"288\":1,\"437\":1,\"463\":1}}],[\"创建时其他未提交的活跃事务\",{\"1\":{\"288\":1}}],[\"创建索引和维护索引需要耗费许多时间\",{\"1\":{\"256\":1}}],[\"创建订单任务先放入消息队列中\",{\"1\":{\"70\":1}}],[\"创建及删除等\",{\"1\":{\"2\":1}}],[\"削峰\",{\"0\":{\"70\":1}}],[\"直至\",{\"1\":{\"625\":1}}],[\"直至所有线程的任务都执行完毕\",{\"1\":{\"625\":1}}],[\"直播等等\",{\"1\":{\"189\":1}}],[\"直接引用是可以直接指向目标的指针\",{\"1\":{\"705\":1}}],[\"直接就会在准备阶段赋值\",{\"1\":{\"704\":1}}],[\"直接指针\",{\"0\":{\"656\":1}}],[\"直接进行栈上分配\",{\"1\":{\"644\":1}}],[\"直接丢弃掉\",{\"1\":{\"606\":1}}],[\"直接执行\",{\"1\":{\"568\":1}}],[\"直接调用run\",{\"0\":{\"568\":1}}],[\"直接返回字符串常量池中字符串对象\",{\"1\":{\"498\":2}}],[\"直接返回降级数据\",{\"1\":{\"165\":1}}],[\"直接使用stringbuilder进行拼接就能解决这个问题\",{\"1\":{\"496\":1}}],[\"直接使用类也能完成配置文件中类似的配置\",{\"1\":{\"458\":1}}],[\"直接使用下面这几个命令就可以了\",{\"1\":{\"315\":1}}],[\"直接从线程池中获取线程来处理\",{\"1\":{\"602\":1}}],[\"直接从5开始执行\",{\"1\":{\"431\":1}}],[\"直接从容器中取出消息供自己使用即可\",{\"1\":{\"67\":1}}],[\"直接标记自己为master并广播结果\",{\"1\":{\"431\":1}}],[\"直接将数据发送给slave\",{\"1\":{\"422\":1}}],[\"直接将表都删除掉\",{\"1\":{\"221\":1}}],[\"直接解析还原数据即可\",{\"1\":{\"416\":1}}],[\"直接利用临时节点的特性即可\",{\"1\":{\"380\":1}}],[\"直接通过\",{\"1\":{\"374\":1}}],[\"直接更新\",{\"1\":{\"303\":1}}],[\"直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的\",{\"1\":{\"300\":1}}],[\"直接找到key所在的节点即可取出数据\",{\"1\":{\"262\":1}}],[\"直接放行\",{\"1\":{\"147\":1}}],[\"直到它收集结束\",{\"1\":{\"678\":1}}],[\"直到等待的时间超过了\",{\"1\":{\"605\":1}}],[\"直到有有元素\",{\"1\":{\"540\":1,\"631\":1}}],[\"直到将其删除\",{\"1\":{\"380\":1}}],[\"直到某条记录不符合a>1条件位置\",{\"1\":{\"271\":1}}],[\"直到找到查找的上限\",{\"1\":{\"262\":1}}],[\"直到在内核把数据拷贝到用户空间\",{\"1\":{\"22\":1}}],[\"直到到达磁盘边界\",{\"1\":{\"16\":1}}],[\"直到到达磁盘的边界\",{\"1\":{\"16\":1}}],[\"直到所有线程都到达屏障后\",{\"1\":{\"7\":1}}],[\"开头的\",{\"1\":{\"278\":1}}],[\"开头的字符串或者是空串\",{\"1\":{\"66\":1}}],[\"开源免费\",{\"1\":{\"225\":1}}],[\"开始的第一位是一个\",{\"1\":{\"693\":1}}],[\"开始计数的\",{\"1\":{\"693\":1}}],[\"开始从新的master节点上同步数据\",{\"1\":{\"427\":1}}],[\"开始\",{\"1\":{\"221\":1,\"585\":1,\"721\":1}}],[\"开始秒杀时创建秒杀订单具有很大的峰值\",{\"1\":{\"70\":1}}],[\"开放式最短路径优先\",{\"1\":{\"174\":1}}],[\"开启日志文件分割\",{\"1\":{\"724\":1}}],[\"开启用户线程\",{\"1\":{\"683\":1}}],[\"开启主从\",{\"1\":{\"418\":1}}],[\"开启aof持久化后没执行一条会更改redis中的数据的命令\",{\"1\":{\"410\":1}}],[\"开启lazy\",{\"1\":{\"335\":1,\"339\":1}}],[\"开启一个事务\",{\"1\":{\"230\":1}}],[\"开启nginx缓冲\",{\"1\":{\"141\":1}}],[\"开启代理缓冲之后\",{\"1\":{\"57\":1}}],[\"^表示正则开始\",{\"1\":{\"66\":1}}],[\"^\",{\"1\":{\"66\":2,\"546\":2}}],[\"^~\",{\"1\":{\"54\":2}}],[\"转储到物理文件中\",{\"1\":{\"725\":1}}],[\"转到本地内存的原因\",{\"1\":{\"645\":1}}],[\"转化为红黑树加快查找\",{\"1\":{\"530\":1}}],[\"转而去创建bservice对象\",{\"1\":{\"450\":1}}],[\"转而执行\",{\"1\":{\"30\":1}}],[\"转为地址\",{\"1\":{\"242\":1}}],[\"转账者和收款人的总额应该是不变的\",{\"1\":{\"231\":1}}],[\"转发是服务端行为\",{\"1\":{\"65\":1}}],[\"gb\",{\"1\":{\"726\":1}}],[\"gbn\",{\"0\":{\"204\":1}}],[\"g1的记忆集和cms的不一样\",{\"1\":{\"687\":1}}],[\"g1宏观上采用标记清除\",{\"1\":{\"685\":1}}],[\"g1存在着很多问题\",{\"1\":{\"684\":1}}],[\"g1也是遵循分代收集理论设计的\",{\"1\":{\"684\":1}}],[\"g1\",{\"0\":{\"684\":1},\"1\":{\"684\":11,\"685\":3,\"687\":2,\"723\":1,\"728\":1}}],[\"gc时老年代内存占用\",{\"1\":{\"732\":1}}],[\"gc的概率就更大\",{\"1\":{\"730\":1}}],[\"gc的时间远低于full\",{\"1\":{\"730\":1}}],[\"gc的时候同步完成\",{\"1\":{\"684\":1}}],[\"gc调优\",{\"0\":{\"727\":1}}],[\"gclogfilesize=50m\",{\"1\":{\"724\":1}}],[\"gc日志输出的文件路径\",{\"1\":{\"724\":1}}],[\"gc区域\",{\"0\":{\"663\":1}}],[\"gc分代年龄\",{\"1\":{\"654\":1}}],[\"gc\",{\"0\":{\"668\":1,\"724\":1},\"1\":{\"600\":1,\"652\":1,\"660\":1,\"662\":1,\"663\":9,\"664\":5,\"667\":2,\"683\":3,\"684\":3,\"685\":1,\"721\":2,\"723\":1,\"724\":5,\"725\":1,\"726\":1,\"730\":1}}],[\"gcm\",{\"1\":{\"62\":1}}],[\"globalexceptionhandler\",{\"1\":{\"459\":1}}],[\"global\",{\"1\":{\"451\":1}}],[\"generation\",{\"0\":{\"720\":1}}],[\"geohash\",{\"1\":{\"405\":1}}],[\"georadiusbymember\",{\"1\":{\"405\":1,\"406\":1}}],[\"georadius\",{\"1\":{\"405\":2,\"406\":1}}],[\"geodist\",{\"1\":{\"405\":1}}],[\"geopos\",{\"1\":{\"405\":1}}],[\"geoadd\",{\"1\":{\"405\":1,\"406\":1}}],[\"geospatial\",{\"0\":{\"404\":1},\"1\":{\"308\":1,\"404\":1}}],[\"geo\",{\"1\":{\"297\":1,\"404\":2,\"405\":3}}],[\"getfindclasses\",{\"1\":{\"714\":1}}],[\"getfindclasstime\",{\"1\":{\"714\":1}}],[\"getfirst\",{\"1\":{\"537\":1}}],[\"getmap\",{\"1\":{\"599\":2}}],[\"getteachernum\",{\"1\":{\"575\":1}}],[\"getusernum\",{\"1\":{\"575\":1}}],[\"getusername\",{\"1\":{\"146\":2}}],[\"getlast\",{\"1\":{\"537\":1}}],[\"getlock\",{\"1\":{\"376\":1}}],[\"getlockname\",{\"1\":{\"376\":1}}],[\"getlockwatchdogtimeout\",{\"1\":{\"376\":2}}],[\"getdeclaredmethod\",{\"1\":{\"510\":1}}],[\"getdeclaredmethods\",{\"1\":{\"442\":1}}],[\"getstatic\",{\"1\":{\"706\":1}}],[\"getsystemclassloader\",{\"1\":{\"509\":1}}],[\"getseckillcount\",{\"1\":{\"158\":1}}],[\"getclassloadinglock\",{\"1\":{\"714\":1}}],[\"getclass\",{\"1\":{\"442\":1,\"509\":1}}],[\"getcontext\",{\"1\":{\"146\":1}}],[\"getbyid\",{\"1\":{\"613\":1}}],[\"getbean\",{\"1\":{\"436\":2}}],[\"getbit\",{\"1\":{\"399\":1,\"400\":1}}],[\"getrawname\",{\"1\":{\"376\":2}}],[\"get和post的区别\",{\"0\":{\"175\":1}}],[\"getinstance\",{\"1\":{\"520\":1,\"521\":1,\"522\":1,\"523\":1,\"524\":1,\"579\":1}}],[\"getid\",{\"1\":{\"155\":1}}],[\"getitem\",{\"1\":{\"29\":1}}],[\"getordertoken\",{\"1\":{\"155\":1}}],[\"get\",{\"1\":{\"155\":1,\"175\":7,\"374\":1,\"384\":1,\"385\":2,\"598\":1,\"600\":1,\"613\":2}}],[\"getparentdelegationtime\",{\"1\":{\"714\":1}}],[\"getpassword\",{\"1\":{\"146\":1}}],[\"getprincipal从authentication中获取用户数据\",{\"1\":{\"146\":1}}],[\"getallstu\",{\"1\":{\"30\":1}}],[\"getname\",{\"1\":{\"29\":1,\"507\":2}}],[\"groupid>\",{\"1\":{\"515\":1}}],[\"group\",{\"1\":{\"243\":1}}],[\"garbage\",{\"1\":{\"684\":2}}],[\"gap\",{\"1\":{\"238\":1,\"282\":1}}],[\"gateway\",{\"1\":{\"174\":3,\"179\":2}}],[\"gone\",{\"1\":{\"181\":1}}],[\"gulimall\",{\"1\":{\"165\":1}}],[\"证书私钥文件路径\",{\"1\":{\"62\":1}}],[\"证书文件路径\",{\"1\":{\"62\":1}}],[\"后的接口顺序从左到右排列在接口索引集合中\",{\"1\":{\"695\":1}}],[\"后仍然能够存活\",{\"1\":{\"662\":1}}],[\"后继节点\",{\"1\":{\"622\":1}}],[\"后申请的线程可能会先获取到锁\",{\"1\":{\"593\":1}}],[\"后过期\",{\"1\":{\"326\":2}}],[\"后台线程每秒调用fsync保存aof文件\",{\"1\":{\"412\":1}}],[\"后台线程调用fsync保存aof文件到磁盘\",{\"1\":{\"412\":1}}],[\"后台线程调用\",{\"1\":{\"324\":1}}],[\"后台线程来释放\",{\"1\":{\"324\":1}}],[\"后返回响应\",{\"1\":{\"303\":1}}],[\"后删除\",{\"1\":{\"302\":1}}],[\"后更新\",{\"1\":{\"302\":1}}],[\"后退n帧协议\",{\"0\":{\"204\":1}}],[\"后依然没有收到回复\",{\"1\":{\"195\":1}}],[\"后面\",{\"1\":{\"175\":1}}],[\"后面才慢慢发展成了一款功能全面的高性能消息队列\",{\"1\":{\"77\":1}}],[\"后续命令保存至repl\",{\"1\":{\"422\":1}}],[\"后续复用这个read\",{\"1\":{\"291\":1}}],[\"后续即使它们修改了记录行的值\",{\"1\":{\"288\":1}}],[\"后续可进行库存释放操作\",{\"1\":{\"156\":1}}],[\"后续改为springsecurity框架实现认证授权功能\",{\"1\":{\"146\":1}}],[\"后续的周期不再分发请求给这个服务器\",{\"1\":{\"61\":1}}],[\"后\",{\"1\":{\"83\":1,\"726\":1}}],[\"后端从数据库中获取对应的令牌\",{\"1\":{\"155\":1}}],[\"后端tomcat服务器应该用来处理请求而不是返回这些静态数据\",{\"1\":{\"141\":1}}],[\"后端验证登录\",{\"1\":{\"136\":1}}],[\"后端限流在本项目中使用sentinel框架实现限流熔断降级\",{\"1\":{\"165\":1}}],[\"后端限流\",{\"0\":{\"163\":1},\"1\":{\"136\":1}}],[\"后端server可能会出现大量的连接积压\",{\"1\":{\"57\":1}}],[\"后端无法获取用户的真实ip\",{\"1\":{\"52\":1}}],[\"健康检查\",{\"0\":{\"61\":1}}],[\"允许\",{\"1\":{\"625\":1}}],[\"允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发\",{\"1\":{\"434\":1}}],[\"允许读取并发事务已经提交的数据\",{\"1\":{\"282\":1}}],[\"允许读取尚未提交的数据变更\",{\"1\":{\"282\":1}}],[\"允许多个事务同时获取\",{\"1\":{\"239\":1}}],[\"允许多个线程同时读取共享资源\",{\"1\":{\"7\":1}}],[\"允许在\",{\"1\":{\"210\":1}}],[\"允许在第一次连接时发送数据\",{\"1\":{\"190\":1}}],[\"允许在同一\",{\"1\":{\"181\":1}}],[\"允许损失部分可用功能\",{\"1\":{\"120\":1}}],[\"允许数据库在一段时间内不一致\",{\"1\":{\"120\":1}}],[\"允许用户自定义hash\",{\"1\":{\"60\":1}}],[\"一定会配置上打印\",{\"1\":{\"724\":1}}],[\"一定要保证设置指定key的值和过期时间是一个原子操作\",{\"1\":{\"375\":1}}],[\"一共有两种指定新生代内存大小的办法\",{\"1\":{\"720\":1}}],[\"一半作为to\",{\"1\":{\"675\":1}}],[\"一半作为from区\",{\"1\":{\"675\":1}}],[\"一部分用于存储对象自身的运行时数据\",{\"1\":{\"654\":1}}],[\"一块很小的内存区域\",{\"1\":{\"640\":1}}],[\"一直等到队列可以放入新元素时再放入\",{\"1\":{\"540\":1,\"631\":1}}],[\"一大\",{\"1\":{\"480\":1}}],[\"一切就从这里开始吧\",{\"1\":{\"465\":1}}],[\"一切就绪后\",{\"1\":{\"463\":1}}],[\"一起封装\",{\"1\":{\"456\":1}}],[\"一旦发现被查找的元素处于两个元素值的区间\",{\"1\":{\"635\":1}}],[\"一旦发现master故障\",{\"1\":{\"426\":1}}],[\"一旦创建\",{\"1\":{\"632\":1}}],[\"一旦创建就一直存在即使\",{\"1\":{\"380\":1}}],[\"一旦线程申请了锁\",{\"1\":{\"595\":1}}],[\"一旦没有分配足够长度的内存空间\",{\"1\":{\"311\":1}}],[\"一些特殊的场景可能会需要使用可重入的分布式锁\",{\"1\":{\"377\":1}}],[\"一些概念\",{\"1\":{\"219\":1}}],[\"一段时间之后\",{\"1\":{\"611\":1}}],[\"一段\",{\"1\":{\"334\":2}}],[\"一样\",{\"1\":{\"303\":1}}],[\"一张表允许创建多个普通索引\",{\"1\":{\"264\":1}}],[\"一张表允许创建多个唯一索引\",{\"1\":{\"264\":1}}],[\"一张表只能有一个主键\",{\"1\":{\"263\":1}}],[\"一次操作或者多次操作\",{\"1\":{\"577\":1}}],[\"一次性分配所需要的所有资源\",{\"1\":{\"564\":1}}],[\"一次编译\",{\"1\":{\"467\":1}}],[\"一次查询就可以找到\",{\"1\":{\"243\":1}}],[\"一次握手\",{\"1\":{\"193\":1}}],[\"一行一行遍历肯定是不行\",{\"1\":{\"240\":1}}],[\"一锁就锁整张表\",{\"1\":{\"237\":1}}],[\"一对一\",{\"1\":{\"224\":1}}],[\"一对多\",{\"1\":{\"188\":1,\"224\":1}}],[\"一般配合parnew使用\",{\"1\":{\"685\":1}}],[\"一般将\",{\"1\":{\"676\":1}}],[\"一般情况很难出现碰撞\",{\"1\":{\"548\":1}}],[\"一般情况下一个broker可以看做一个rabbitmq服务器\",{\"1\":{\"92\":1}}],[\"一般像\",{\"1\":{\"300\":1}}],[\"一般都用来当做缓存使用\",{\"1\":{\"299\":1}}],[\"一般在没有使用到索引的时候会出现\",{\"1\":{\"243\":1}}],[\"一般的开发人员很少使用\",{\"1\":{\"222\":1}}],[\"一般是通过\",{\"1\":{\"306\":1}}],[\"一般是\",{\"1\":{\"190\":1}}],[\"一般用于即时通信\",{\"1\":{\"189\":1}}],[\"一种建立在关系模型基础上的数据库\",{\"1\":{\"224\":1}}],[\"一种用途是在\",{\"1\":{\"681\":1}}],[\"一种用来在路由选择域之间交换网络层可达性信息\",{\"1\":{\"174\":1}}],[\"一种用于传输网络状态和错误消息的协议\",{\"1\":{\"174\":1}}],[\"一种内部网关协议\",{\"1\":{\"174\":2}}],[\"一种是过去的\",{\"1\":{\"174\":1}}],[\"一人一单的秒杀幂等性问题\",{\"1\":{\"162\":1}}],[\"一键运行\",{\"1\":{\"109\":1}}],[\"一个类可以有个多个方法\",{\"1\":{\"697\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"695\":1}}],[\"一个类会可以有个字段\",{\"1\":{\"696\":1}}],[\"一个类只能extends一个类\",{\"1\":{\"487\":1}}],[\"一个是自己写的\",{\"1\":{\"715\":1}}],[\"一个是jre里面的\",{\"1\":{\"715\":1}}],[\"一个是最终标记\",{\"1\":{\"687\":1}}],[\"一个是重新标记\",{\"1\":{\"687\":1}}],[\"一个是初始标记\",{\"1\":{\"687\":2}}],[\"一个是原始快照\",{\"1\":{\"685\":1}}],[\"一个是增量更新\",{\"1\":{\"685\":1}}],[\"一个是在字符串常量池中创建的\",{\"1\":{\"497\":1}}],[\"一个时刻同时执行\",{\"1\":{\"679\":1}}],[\"一个时间段内同时执行\",{\"1\":{\"679\":1}}],[\"一个节点表示一个线程\",{\"1\":{\"622\":1}}],[\"一个节点获取了锁之后\",{\"1\":{\"372\":1}}],[\"一个线程内\",{\"1\":{\"576\":1}}],[\"一个注重内部属性\",{\"1\":{\"483\":1}}],[\"一个注重过程\",{\"1\":{\"483\":1}}],[\"一个beanname对应同一个bean对象\",{\"1\":{\"435\":1}}],[\"一个最基本的分布式锁需要满足\",{\"1\":{\"372\":1}}],[\"一个region复制到另外一个region\",{\"1\":{\"684\":1}}],[\"一个redis命令的执行可以简化为以下4步\",{\"1\":{\"331\":1}}],[\"一个rabbitmq\",{\"1\":{\"86\":1}}],[\"一个事务被提交之后\",{\"1\":{\"231\":1}}],[\"一个用户的事物不被其他事务所干扰\",{\"1\":{\"231\":1}}],[\"一个一个运行命令很麻烦\",{\"1\":{\"109\":1}}],[\"一个\",{\"1\":{\"102\":1}}],[\"一个或多个消费者订阅这些事件\",{\"1\":{\"85\":1}}],[\"一个或多个生产者向其写入事件\",{\"1\":{\"85\":1}}],[\"一个topic可以有零个\",{\"1\":{\"85\":1}}],[\"一个消息可以投入一个或者多个队列中\",{\"1\":{\"85\":1}}],[\"一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则\",{\"1\":{\"84\":1}}],[\"一个提供统一消息服务的应用层标准\",{\"1\":{\"74\":1}}],[\"一个进程只需要\",{\"1\":{\"12\":1}}],[\"一个进程的父进程已经终止或者不存在\",{\"1\":{\"10\":1}}],[\"一个进程能有很多个线程\",{\"1\":{\"557\":1}}],[\"一个进程能在运行的时候产生多个线程\",{\"1\":{\"556\":1}}],[\"一个进程能创建多个线程\",{\"1\":{\"6\":1}}],[\"一个进程能拥有很多个线程\",{\"1\":{\"5\":1}}],[\"一致性锁定读\",{\"1\":{\"241\":1}}],[\"一致性非锁定读和锁定读\",{\"0\":{\"283\":1}}],[\"一致性非锁定读\",{\"0\":{\"284\":1},\"1\":{\"241\":1,\"284\":1}}],[\"一致性才能得到保障\",{\"1\":{\"231\":1}}],[\"一致性consistency\",{\"1\":{\"231\":1}}],[\"一致性\",{\"0\":{\"113\":1},\"1\":{\"123\":1}}],[\"一致性问题\",{\"1\":{\"73\":1}}],[\"一致性hash算法\",{\"1\":{\"60\":1}}],[\"引发的full\",{\"1\":{\"730\":1}}],[\"引发缓存失效\",{\"1\":{\"60\":1}}],[\"引用的目标并不一定是已经加载到虚拟机内存中的内容\",{\"1\":{\"705\":1}}],[\"引用类型总结\",{\"0\":{\"670\":1}}],[\"引用类型变量发出的方法调用到底是哪个类中的方法\",{\"1\":{\"486\":1}}],[\"引用失效\",{\"1\":{\"666\":1}}],[\"引用计数法\",{\"0\":{\"666\":1}}],[\"引用传递值得是\",{\"1\":{\"503\":1}}],[\"引用传递\",{\"0\":{\"502\":1},\"1\":{\"502\":1}}],[\"引用拷贝\",{\"0\":{\"488\":1},\"1\":{\"488\":1}}],[\"引用相等是指向的内存地址是否相等\",{\"1\":{\"484\":1}}],[\"引擎错误\",{\"1\":{\"416\":1}}],[\"引入了这个\",{\"1\":{\"726\":1}}],[\"引入了发布订阅\",{\"1\":{\"306\":1}}],[\"引入了\",{\"1\":{\"181\":1}}],[\"引入消息机制后\",{\"1\":{\"130\":1}}],[\"引入线程之后\",{\"1\":{\"5\":1,\"556\":1}}],[\"客户端请求可以访问集群任意节点\",{\"1\":{\"429\":1}}],[\"客户端会话\",{\"1\":{\"380\":1}}],[\"客户端获取锁就是在locks下创建临时顺序节点\",{\"1\":{\"379\":1}}],[\"客户端连接\",{\"1\":{\"321\":1}}],[\"客户端和服务端就可以继续传输数据\",{\"1\":{\"195\":1}}],[\"客户端和服务器端都无法验证对方的身份\",{\"1\":{\"180\":1}}],[\"客户端也可以关闭连接了\",{\"1\":{\"195\":1}}],[\"客户端进入\",{\"1\":{\"195\":2}}],[\"客户端发送给服务器的\",{\"1\":{\"197\":1}}],[\"客户端发送\",{\"1\":{\"195\":1}}],[\"客户端发送一个\",{\"1\":{\"195\":1}}],[\"客户端发送带有\",{\"1\":{\"193\":2}}],[\"客户端\",{\"1\":{\"193\":1,\"376\":1,\"379\":1,\"456\":1}}],[\"客户端可以只发送部分资源内容\",{\"1\":{\"176\":1}}],[\"客户端将数据提交到服务器\",{\"1\":{\"176\":1}}],[\"客户端需要发送完整的资源内容\",{\"1\":{\"176\":1}}],[\"客户端需要将整个资源的新版本发送到服务器\",{\"1\":{\"176\":1}}],[\"客户端的ip地址将计算哈希键\",{\"1\":{\"60\":1}}],[\"客户端往往是用户网络\",{\"1\":{\"57\":1}}],[\"默认实现是空方法\",{\"1\":{\"712\":1}}],[\"默认认为这些新对象不是垃圾\",{\"1\":{\"684\":1}}],[\"默认模式\",{\"1\":{\"624\":1}}],[\"默认8\",{\"1\":{\"547\":1}}],[\"默认扫描路径就是这个类所在的包路径\",{\"1\":{\"461\":1}}],[\"默认都是单例的\",{\"1\":{\"437\":1}}],[\"默认流程\",{\"1\":{\"431\":1}}],[\"默认值是\",{\"1\":{\"662\":1}}],[\"默认值64mb\",{\"1\":{\"414\":1}}],[\"默认值100\",{\"1\":{\"414\":1}}],[\"默认配置会使用\",{\"1\":{\"363\":1}}],[\"默认情况下元素采用自然顺序进行排序\",{\"1\":{\"634\":1}}],[\"默认情况下redis没有开启aof方式的持久化\",{\"1\":{\"410\":1}}],[\"默认情况下\",{\"1\":{\"363\":1,\"376\":1}}],[\"默认选项\",{\"1\":{\"363\":1,\"409\":1}}],[\"默认的隔离级别\",{\"1\":{\"238\":1}}],[\"默认的负载均衡策略\",{\"1\":{\"60\":1}}],[\"默认会丢失消息\",{\"1\":{\"100\":1}}],[\"默认\",{\"1\":{\"84\":1,\"376\":2,\"447\":1}}],[\"默认是不公平实现的\",{\"1\":{\"632\":1}}],[\"默认是16\",{\"1\":{\"551\":1}}],[\"默认是1次\",{\"1\":{\"61\":1}}],[\"默认是按\",{\"1\":{\"544\":1}}],[\"默认是singleton但是对于开发中大部分的bean是无状态的\",{\"1\":{\"451\":1}}],[\"默认是\",{\"1\":{\"180\":2}}],[\"默认是没有加锁的\",{\"1\":{\"153\":1}}],[\"默认是连接数最小的机器\",{\"1\":{\"60\":1}}],[\"默认为8\",{\"1\":{\"530\":1}}],[\"默认为\",{\"1\":{\"376\":1,\"662\":1}}],[\"默认为行级锁\",{\"1\":{\"228\":1,\"237\":1}}],[\"默认为10秒\",{\"1\":{\"61\":1}}],[\"默认为on\",{\"1\":{\"57\":1}}],[\"zgc\",{\"1\":{\"728\":1}}],[\"zdiffstore\",{\"1\":{\"396\":1}}],[\"zunionstore\",{\"1\":{\"396\":1}}],[\"zinterstore\",{\"1\":{\"396\":3}}],[\"ziplist\",{\"1\":{\"382\":5}}],[\"zipkin用作链路追踪\",{\"1\":{\"137\":1}}],[\"zcard\",{\"1\":{\"396\":1}}],[\"zadd\",{\"1\":{\"396\":1}}],[\"znode\",{\"1\":{\"380\":2}}],[\"zscore\",{\"1\":{\"396\":1}}],[\"zscan\",{\"1\":{\"362\":1}}],[\"zset\",{\"1\":{\"299\":1,\"308\":1,\"382\":2}}],[\"zremrangebyscore\",{\"1\":{\"345\":1,\"362\":1}}],[\"zremrangebyrank\",{\"1\":{\"345\":1,\"362\":1}}],[\"zrevrank\",{\"1\":{\"313\":1,\"396\":1,\"397\":2}}],[\"zrevrange\",{\"1\":{\"313\":1,\"345\":1,\"362\":1,\"396\":1,\"397\":2}}],[\"zrange\",{\"1\":{\"313\":1,\"345\":1,\"362\":1,\"396\":1,\"397\":2}}],[\"z\",{\"1\":{\"219\":3}}],[\"zyl\",{\"1\":{\"150\":1,\"436\":1,\"509\":2}}],[\"zookeeper通过临时节点解决释放锁逻辑失效问题\",{\"1\":{\"380\":1}}],[\"zookeeper\",{\"0\":{\"379\":1},\"1\":{\"379\":2,\"380\":4}}],[\"zookeeper其实就是追求强一致性\",{\"1\":{\"118\":1}}],[\"zone=mycache\",{\"1\":{\"58\":1}}],[\"zhong\",{\"1\":{\"90\":1}}],[\"zh\",{\"1\":{\"52\":2}}],[\"缓刑\",{\"1\":{\"669\":1}}],[\"缓慢增大\",{\"1\":{\"201\":1}}],[\"缓存永远不会失效\",{\"1\":{\"355\":1}}],[\"缓存空对象\",{\"1\":{\"353\":1}}],[\"缓存空数据并添加过期时间\",{\"1\":{\"153\":1}}],[\"缓存无效key\",{\"1\":{\"353\":1}}],[\"缓存相同数量的对象数据\",{\"1\":{\"310\":1}}],[\"缓存失效时间变短\",{\"1\":{\"360\":1}}],[\"缓存失效\",{\"1\":{\"302\":1}}],[\"缓存之后很容易达到\",{\"1\":{\"300\":1}}],[\"缓存虽然能提升数据库的查询能力\",{\"1\":{\"229\":1}}],[\"缓存建立之后\",{\"1\":{\"229\":1}}],[\"缓存机制\",{\"1\":{\"181\":1}}],[\"缓存击穿导致的原因是某个热点数据不存在于缓存中\",{\"1\":{\"359\":1}}],[\"缓存击穿中\",{\"1\":{\"358\":1}}],[\"缓存击穿\",{\"0\":{\"356\":1},\"1\":{\"153\":2}}],[\"缓存击穿问题\",{\"0\":{\"153\":1}}],[\"缓存雪崩导致的原因是缓存中的大量数据失效\",{\"1\":{\"359\":1}}],[\"缓存雪崩和缓存击穿有什么区别\",{\"0\":{\"359\":1}}],[\"缓存雪崩\",{\"0\":{\"153\":1,\"354\":1},\"1\":{\"153\":2,\"335\":1}}],[\"缓存穿透中\",{\"1\":{\"358\":1}}],[\"缓存穿透和缓存击穿的区别\",{\"0\":{\"358\":1}}],[\"缓存穿透\",{\"0\":{\"153\":1,\"351\":1,\"352\":1},\"1\":{\"153\":1}}],[\"缓存只要保证最终一致性不需要强一致性\",{\"1\":{\"152\":1}}],[\"缓存一致性的解决方案有\",{\"1\":{\"152\":1}}],[\"缓存一致性解决办法\",{\"0\":{\"152\":1}}],[\"缓存区可以被多个server共享\",{\"1\":{\"58\":1}}],[\"缓存\",{\"0\":{\"58\":1},\"1\":{\"385\":1}}],[\"缓冲一般放在内存中\",{\"1\":{\"57\":1}}],[\"缓冲\",{\"0\":{\"57\":1}}],[\"缓冲与缓存\",{\"0\":{\"56\":1}}],[\"此参数默认用于\",{\"1\":{\"726\":1}}],[\"此类的属性表中的属性数\",{\"1\":{\"698\":1}}],[\"此内存区域的唯一目的就是存放对象实例\",{\"1\":{\"644\":1}}],[\"此策略将丢弃最早的未处理的任务请求\",{\"1\":{\"606\":1}}],[\"此注解内部有\",{\"1\":{\"461\":1}}],[\"此外\",{\"1\":{\"287\":1}}],[\"此外服务器可以通过支付宝给的接口主动去查询支付结果\",{\"1\":{\"131\":1}}],[\"此变化解决了\",{\"1\":{\"190\":1}}],[\"此部分通过base64加密之后得到第一个部分\",{\"1\":{\"150\":1}}],[\"此部分通常是相对较小的headers\",{\"1\":{\"57\":1}}],[\"此时与用户线程并发执行\",{\"1\":{\"687\":1}}],[\"此时才会将栅栏放开\",{\"1\":{\"626\":1}}],[\"此时调用内存中不存在的非静态成员不合法\",{\"1\":{\"479\":1}}],[\"此时本类已经完成创建周期\",{\"1\":{\"450\":1}}],[\"此时并没有同步到磁盘\",{\"1\":{\"411\":1}}],[\"此时会创建一个\",{\"1\":{\"624\":1}}],[\"此时会阻塞主进程\",{\"1\":{\"409\":1}}],[\"此时会以\",{\"1\":{\"292\":1}}],[\"此时新的\",{\"1\":{\"378\":1}}],[\"此时缓存中无数据\",{\"1\":{\"302\":1}}],[\"此时缓存中为旧数据\",{\"1\":{\"152\":1}}],[\"此时执行计划中的\",{\"1\":{\"243\":1}}],[\"此时\",{\"1\":{\"195\":1,\"671\":1}}],[\"此时服务端进入\",{\"1\":{\"195\":1}}],[\"此时可以发送订单已支付消息到队列中修改订单状态\",{\"1\":{\"155\":1}}],[\"此时可以增加消费端的消费能力\",{\"1\":{\"103\":1}}],[\"此时前端提交订单的时候就会将令牌进行提交\",{\"1\":{\"155\":1}}],[\"此时需要通过接口查询业务处理结果\",{\"1\":{\"132\":1}}],[\"此时订阅方可消费\",{\"1\":{\"129\":1}}],[\"此方案主要用于外部应用之间的通知\",{\"1\":{\"133\":1}}],[\"此方案强调的是只要消息发给事务参与放最终事务要达到一致\",{\"1\":{\"125\":1}}],[\"此方法主要用于在客户端和服务器之间通过网络进行通信\",{\"1\":{\"9\":1}}],[\"此阶段仅是一个初步操作\",{\"1\":{\"123\":1}}],[\"进一步让老年代fullgc不再频繁\",{\"1\":{\"734\":1}}],[\"进一步提高程序的运行性能\",{\"1\":{\"619\":1}}],[\"进入\",{\"1\":{\"724\":1}}],[\"进入死信路由dlx\",{\"1\":{\"96\":1}}],[\"进而使得查询元素的操作陷入死循环无法结束\",{\"1\":{\"549\":1}}],[\"进而保证锁不会因为超时而被释放\",{\"1\":{\"376\":1}}],[\"进而造成共享资源无法再被其他线程\",{\"1\":{\"374\":1}}],[\"进而\",{\"1\":{\"300\":1}}],[\"进而将一个数据库的压力分担到多个数据库\",{\"1\":{\"250\":1}}],[\"进而导致后端server也只能以同样较慢的速度传递响应给nginx\",{\"1\":{\"57\":1}}],[\"进行fullgc\",{\"1\":{\"684\":1}}],[\"进行了封装\",{\"1\":{\"612\":1}}],[\"进行访问\",{\"1\":{\"477\":1}}],[\"进行比较\",{\"1\":{\"470\":1}}],[\"进行aop\",{\"1\":{\"438\":1}}],[\"进行运算\",{\"1\":{\"399\":1}}],[\"进行有序排列\",{\"1\":{\"395\":1}}],[\"进行优化\",{\"1\":{\"238\":1}}],[\"进行传输的时候多了连接\",{\"1\":{\"188\":1}}],[\"进行加锁来保证不出现幻读\",{\"1\":{\"282\":1}}],[\"进行加锁\",{\"1\":{\"153\":1}}],[\"进行认证authenticationmanager\",{\"1\":{\"146\":1}}],[\"进程是程序的一次执行过程\",{\"1\":{\"555\":1}}],[\"进程访问\",{\"1\":{\"374\":1}}],[\"进程所分配的内存可能会比其实际所需要的大\",{\"1\":{\"12\":1}}],[\"进程来回收孤儿进程的资源\",{\"1\":{\"10\":1}}],[\"进程号为\",{\"1\":{\"10\":1}}],[\"进程间的通信方式有哪些\",{\"0\":{\"9\":1}}],[\"进程间的通信等\",{\"1\":{\"2\":1}}],[\"进程打开的文件信息\",{\"1\":{\"8\":1}}],[\"进程对资源的需求情况\",{\"1\":{\"8\":1}}],[\"进程优先级\",{\"1\":{\"8\":1}}],[\"进程状态\",{\"1\":{\"8\":1}}],[\"进程的调度信息\",{\"1\":{\"8\":1}}],[\"进程的描述信息\",{\"1\":{\"8\":1}}],[\"进程的创建\",{\"1\":{\"2\":1}}],[\"进程切换的成本大于线程切换\",{\"1\":{\"6\":1}}],[\"进程\",{\"0\":{\"555\":1},\"1\":{\"5\":1,\"10\":1}}],[\"进程和线程\",{\"0\":{\"4\":1,\"554\":1}}],[\"进程和线程的管理\",{\"1\":{\"2\":1}}],[\"响应将同步发送给客户端\",{\"1\":{\"57\":1}}],[\"响应不了其他请求\",{\"1\":{\"21\":1}}],[\"处理并发阶段结束后仍遗留下来的少量satb记录\",{\"1\":{\"684\":1}}],[\"处理原始快照在并发时变动的对象\",{\"1\":{\"684\":1}}],[\"处理完之后线程并不会立即被销毁\",{\"1\":{\"602\":1}}],[\"处理实际请求的处理器\",{\"1\":{\"457\":1}}],[\"处理器可以改变语句对应机器指令的执行顺序\",{\"1\":{\"571\":1}}],[\"处理器适配器\",{\"1\":{\"457\":1}}],[\"处理器映射器\",{\"1\":{\"457\":1}}],[\"处理initializing接口\",{\"1\":{\"438\":1}}],[\"处理hotkey会占用大量的cpu和带宽\",{\"1\":{\"341\":1}}],[\"处理\",{\"0\":{\"725\":1},\"1\":{\"181\":1,\"438\":1}}],[\"处理像css\",{\"1\":{\"55\":1}}],[\"处理机的状态信息\",{\"1\":{\"8\":1}}],[\"正常情况是在属性注入之后进行aop\",{\"1\":{\"450\":1}}],[\"正常代码执行\",{\"1\":{\"448\":1}}],[\"正常处理命令请求造成影响\",{\"1\":{\"414\":1}}],[\"正数为加\",{\"1\":{\"390\":1}}],[\"正在内存中\",{\"1\":{\"288\":1}}],[\"正因如此\",{\"1\":{\"261\":1}}],[\"正向代理通过客户端代理转发请求\",{\"1\":{\"142\":1}}],[\"正向代理与反向代理\",{\"0\":{\"50\":1}}],[\"正则匹配\",{\"1\":{\"54\":2}}],[\"将老年代内存预设调大1\",{\"1\":{\"732\":1}}],[\"将附加到文件名中\",{\"1\":{\"725\":1}}],[\"将搜索类或资源的任务委托给其父类加载器\",{\"1\":{\"713\":2}}],[\"将字节流所代表的静态存储结构转化为方法区的运行时数据结构\",{\"1\":{\"702\":1}}],[\"将字符串对象\",{\"1\":{\"498\":1}}],[\"将第\",{\"1\":{\"693\":1}}],[\"将计数器\",{\"1\":{\"666\":1}}],[\"将尝试进行一次\",{\"1\":{\"664\":1}}],[\"将被移动到\",{\"1\":{\"662\":1}}],[\"将被标记为\",{\"1\":{\"243\":1}}],[\"将用过的内存整理到一边\",{\"1\":{\"650\":1}}],[\"将修改的内容写入副本\",{\"1\":{\"629\":1}}],[\"将state值变为0\",{\"1\":{\"625\":1}}],[\"将state值\",{\"1\":{\"625\":2}}],[\"将socket关联到相应的事件处理器\",{\"1\":{\"321\":1}}],[\"将每条请求共享资源的线程封装成一个\",{\"1\":{\"622\":1}}],[\"将返回线程池进行复用\",{\"1\":{\"604\":1}}],[\"将返回的对象放入二级缓存中\",{\"1\":{\"450\":1}}],[\"将需要存储的值放入到这个哈希表中\",{\"1\":{\"599\":1}}],[\"将锁计数器设为\",{\"1\":{\"589\":1}}],[\"将锁的超时时间设置为\",{\"1\":{\"376\":1}}],[\"将链表转化为红黑树\",{\"1\":{\"547\":1}}],[\"将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程\",{\"1\":{\"504\":1}}],[\"将数组的第一个元素变为0\",{\"1\":{\"503\":1}}],[\"将数据结构或对象转换成二进制字节流的过程\",{\"1\":{\"504\":1}}],[\"将数据\",{\"1\":{\"302\":1}}],[\"将原本对象内部的所有属性都单独复制一份\",{\"1\":{\"488\":1}}],[\"将二级缓存中的aservice对象或者aservice代理对象注入到bservice中\",{\"1\":{\"450\":1}}],[\"将简单的配置组件组合成复杂的应用\",{\"1\":{\"434\":1}}],[\"将商品类型key\",{\"1\":{\"430\":1}}],[\"将aof缓冲区的数据写入到aof文件中\",{\"1\":{\"411\":1}}],[\"将多个\",{\"1\":{\"402\":1}}],[\"将给定所有有序集合的交集存储在\",{\"1\":{\"396\":1}}],[\"将给定所有集合的差集存储在\",{\"1\":{\"393\":1}}],[\"将给定所有集合的并集存储在\",{\"1\":{\"393\":1}}],[\"将给定所有集合的交集存储在\",{\"1\":{\"393\":1}}],[\"将指定列表索引\",{\"1\":{\"387\":1}}],[\"将\",{\"1\":{\"384\":2,\"414\":1}}],[\"将严重影响\",{\"1\":{\"369\":1}}],[\"将其所有粉丝存在一个集合\",{\"1\":{\"392\":1}}],[\"将其存入缓存中并设置合理的过期时间\",{\"1\":{\"357\":1}}],[\"将其降级为\",{\"1\":{\"238\":1}}],[\"将过滤器添加到查询缓存之前\",{\"1\":{\"353\":1}}],[\"将hotkey存放一份到jvm本地内存中\",{\"1\":{\"343\":1}}],[\"将热点数据分散存储在多个redis节点上\",{\"1\":{\"343\":1}}],[\"将热点数据提前放入cache中\",{\"1\":{\"302\":1}}],[\"将一个元素放入布隆过滤器中\",{\"1\":{\"353\":1}}],[\"将一个bigkey分割为多个小key\",{\"1\":{\"339\":1}}],[\"将一批redis命令封装成一组\",{\"1\":{\"333\":1}}],[\"将该操作交给单独的子线程处理\",{\"1\":{\"335\":1,\"339\":1}}],[\"将访问指定页面的每个用户\",{\"1\":{\"317\":1}}],[\"将当前未提交事务\",{\"1\":{\"288\":1}}],[\"将当前可见的版本号与对应记录的版本号进行比对\",{\"1\":{\"284\":1}}],[\"将会自动创建一个\",{\"1\":{\"263\":1}}],[\"将丢弃这个报文段和不确认收到此报文段\",{\"1\":{\"199\":1}}],[\"将保持它首部和数据的检验和\",{\"1\":{\"199\":1}}],[\"将弃用\",{\"1\":{\"190\":1}}],[\"将ordersn\",{\"1\":{\"158\":1}}],[\"将队列添加x\",{\"1\":{\"156\":1}}],[\"将事物变成两个阶段\",{\"1\":{\"122\":1}}],[\"将目录\",{\"1\":{\"108\":1}}],[\"将消息删除\",{\"1\":{\"129\":1}}],[\"将消息先批量取出来\",{\"1\":{\"103\":1}}],[\"将消息返回给生产者\",{\"1\":{\"100\":1}}],[\"将exchange与queue关联起来\",{\"1\":{\"84\":1}}],[\"将下一个请求分配给最小连接的服务器\",{\"1\":{\"60\":1}}],[\"将静态资源放入nginx服务器的static目录中\",{\"1\":{\"53\":1}}],[\"将所有\",{\"1\":{\"32\":1}}],[\"u1\",{\"1\":{\"693\":1}}],[\"u2\",{\"1\":{\"692\":2,\"693\":1,\"694\":1,\"695\":4,\"696\":1,\"697\":1,\"698\":1}}],[\"u4\",{\"1\":{\"691\":1}}],[\"uv\",{\"0\":{\"317\":1},\"1\":{\"314\":1,\"317\":4,\"394\":1,\"403\":1}}],[\"u\",{\"1\":{\"219\":2}}],[\"unloading\",{\"1\":{\"700\":1}}],[\"unlock\",{\"1\":{\"376\":1}}],[\"undo\",{\"0\":{\"289\":1},\"1\":{\"286\":2,\"287\":1,\"289\":2}}],[\"uncommitted\",{\"1\":{\"232\":3,\"282\":2}}],[\"unit\",{\"1\":{\"605\":2,\"719\":2,\"720\":1}}],[\"uniquevalue\",{\"1\":{\"374\":2,\"375\":2}}],[\"unique\",{\"1\":{\"243\":1}}],[\"union\",{\"1\":{\"243\":6}}],[\"uniform\",{\"1\":{\"182\":2}}],[\"unix\",{\"1\":{\"19\":1}}],[\"unmodified\",{\"1\":{\"181\":1}}],[\"url\",{\"0\":{\"178\":1,\"182\":1},\"1\":{\"175\":6,\"180\":3,\"182\":2}}],[\"uri\",{\"0\":{\"182\":1},\"1\":{\"60\":1,\"176\":2,\"182\":2,\"456\":1}}],[\"udp\",{\"0\":{\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"191\":1},\"1\":{\"172\":2,\"173\":1,\"188\":7,\"189\":1,\"190\":1,\"191\":1}}],[\"udp协议\",{\"1\":{\"139\":1}}],[\"usegcoverheadlimit\",{\"1\":{\"725\":1}}],[\"used\",{\"1\":{\"328\":4}}],[\"userserviceproxy\",{\"1\":{\"446\":1}}],[\"userservice类\",{\"1\":{\"442\":1}}],[\"userservice2\",{\"1\":{\"436\":2,\"444\":4}}],[\"userservice1\",{\"1\":{\"436\":2,\"442\":2,\"444\":2}}],[\"userservice\",{\"1\":{\"436\":3,\"439\":1,\"442\":1,\"444\":6,\"446\":2}}],[\"usernum\",{\"1\":{\"575\":2}}],[\"usern\",{\"1\":{\"317\":1}}],[\"usernamepasswordauthenticationfilter用来做用户认证\",{\"1\":{\"148\":1}}],[\"usernamepasswordauthenticationfilter过滤器获取到\",{\"1\":{\"146\":1}}],[\"usernamepasswordauthenticationtoken\",{\"1\":{\"146\":2}}],[\"usernamenotfoundexception\",{\"1\":{\"146\":1}}],[\"username\",{\"1\":{\"146\":2}}],[\"user2\",{\"1\":{\"317\":1}}],[\"user1\",{\"1\":{\"317\":1}}],[\"userid\",{\"1\":{\"158\":1}}],[\"user\",{\"1\":{\"146\":7,\"155\":1,\"173\":1,\"439\":1,\"442\":1}}],[\"usermapper\",{\"1\":{\"146\":3}}],[\"userdetails的实现类\",{\"1\":{\"146\":1}}],[\"userdetails\",{\"1\":{\"146\":1}}],[\"userdetailsservice\",{\"1\":{\"146\":1}}],[\"userdetailserviceimpl\",{\"1\":{\"146\":1}}],[\"using\",{\"1\":{\"243\":6,\"700\":1}}],[\"usr\",{\"1\":{\"53\":1,\"62\":2,\"108\":2}}],[\"up\",{\"1\":{\"288\":2}}],[\"update\",{\"1\":{\"241\":3,\"284\":2,\"285\":4,\"292\":2}}],[\"up就能运行安装\",{\"1\":{\"109\":1}}],[\"upstream使用的是七层代理的配置方法\",{\"1\":{\"139\":1}}],[\"upstream\",{\"1\":{\"59\":1,\"60\":4,\"61\":1,\"63\":1,\"139\":2,\"142\":1}}],[\"util\",{\"1\":{\"90\":1,\"581\":1,\"620\":1,\"627\":1}}],[\"~\",{\"1\":{\"53\":1,\"54\":2}}],[\"动作\",{\"1\":{\"684\":1}}],[\"动静分离的好处\",{\"0\":{\"55\":1}}],[\"动静分离\",{\"0\":{\"53\":1}}],[\"动态链接的作用就是为了将符号引用转换为调用方法的直接引用\",{\"1\":{\"641\":1}}],[\"动态链接\",{\"1\":{\"641\":3}}],[\"动态生成的代理类\",{\"1\":{\"514\":1}}],[\"动态点赞等场景\",{\"1\":{\"394\":1}}],[\"动态点赞等等\",{\"1\":{\"314\":1}}],[\"动态配置\",{\"1\":{\"191\":1}}],[\"动态主机配置协议\",{\"1\":{\"191\":1}}],[\"动态代理主要有两种\",{\"1\":{\"513\":1}}],[\"动态代理属于运行时动态生成类字节码\",{\"1\":{\"513\":1}}],[\"动态代理更加灵活\",{\"1\":{\"513\":1,\"517\":1}}],[\"动态代理就是依赖反射\",{\"1\":{\"507\":1}}],[\"动态代理为\",{\"1\":{\"30\":1}}],[\"动态代理\",{\"0\":{\"513\":1},\"1\":{\"30\":1}}],[\"动态分区分配\",{\"1\":{\"12\":1}}],[\"常量\",{\"1\":{\"560\":1}}],[\"常量池主要存放两大常量\",{\"1\":{\"693\":1}}],[\"常量池计数器是从\",{\"1\":{\"693\":1}}],[\"常量池的数量是\",{\"1\":{\"693\":1}}],[\"常量池的数量\",{\"1\":{\"693\":1}}],[\"常量池\",{\"0\":{\"693\":1},\"1\":{\"693\":1}}],[\"常量池表会在类加载后存放到方法区的运行时常量池中\",{\"1\":{\"646\":1}}],[\"常量池等信息\",{\"1\":{\"559\":1}}],[\"常量池中每一项常量都是一个表\",{\"1\":{\"693\":1}}],[\"常量池中的对象\",{\"1\":{\"499\":2}}],[\"常量池中创建的对象\",{\"1\":{\"499\":1}}],[\"常规数据\",{\"1\":{\"309\":1}}],[\"常规数据使用springcache可以满足大部分要求\",{\"1\":{\"153\":1}}],[\"常见规则\",{\"0\":{\"576\":1}}],[\"常见于\",{\"1\":{\"243\":1}}],[\"常见的符号引用包括类符号引用\",{\"1\":{\"646\":1}}],[\"常见的阻塞队列\",{\"1\":{\"607\":1}}],[\"常见的缓存读写策略\",{\"0\":{\"301\":1}}],[\"常见的导致索引失效的情况\",{\"1\":{\"278\":1}}],[\"常见的分片算法有哪些\",{\"0\":{\"253\":1}}],[\"常见的值如下\",{\"1\":{\"243\":1}}],[\"常见的网络协议\",{\"0\":{\"171\":1}}],[\"常见的消息队列\",{\"0\":{\"76\":1}}],[\"常见的磁盘调度算法有哪些\",{\"0\":{\"16\":1}}],[\"常用来封装\",{\"1\":{\"612\":1}}],[\"常用命令\",{\"0\":{\"384\":1,\"387\":1,\"390\":1,\"393\":1,\"396\":1,\"399\":1,\"402\":1,\"405\":1}}],[\"常用\",{\"1\":{\"360\":1}}],[\"常用的为hotspot\",{\"1\":{\"466\":1}}],[\"常用的过期数据的删除策略就两个\",{\"1\":{\"327\":1}}],[\"常用的数据结构有哪些\",{\"0\":{\"308\":1}}],[\"常用的变量值\",{\"1\":{\"52\":1}}],[\"常用于生产者\",{\"1\":{\"540\":1,\"631\":1}}],[\"常用于使用主键或唯一索引的所有字段作为连表条件\",{\"1\":{\"243\":1}}],[\"常用于使用主键或唯一索引的所有字段作为查询条件\",{\"1\":{\"243\":1}}],[\"常用于网络诊断和故障排除\",{\"1\":{\"174\":1}}],[\"设计了redlock\",{\"1\":{\"378\":1}}],[\"设\",{\"1\":{\"219\":1}}],[\"设置每个\",{\"1\":{\"726\":1}}],[\"设置用于\",{\"1\":{\"726\":1}}],[\"设置基于\",{\"1\":{\"726\":1}}],[\"设置\",{\"1\":{\"721\":2,\"726\":1}}],[\"设置不允许冒险\",{\"1\":{\"664\":1}}],[\"设置对象头\",{\"0\":{\"652\":1}}],[\"设置对应sku信号量的许可证数量\",{\"1\":{\"158\":1}}],[\"设置为0表示禁用自动重写\",{\"1\":{\"414\":1}}],[\"设置为true\",{\"1\":{\"100\":1}}],[\"设置多个字段的值\",{\"1\":{\"391\":1}}],[\"设置单个字段的值\",{\"1\":{\"391\":1}}],[\"设置过期时间\",{\"1\":{\"384\":1}}],[\"设置指定哈希表中指定字段的值\",{\"1\":{\"390\":1}}],[\"设置指定\",{\"1\":{\"384\":1,\"399\":1}}],[\"设置时间过长\",{\"1\":{\"375\":1}}],[\"设置热点数据永远不过期或者过期时间比较长\",{\"1\":{\"357\":1}}],[\"设置二级缓存\",{\"1\":{\"355\":1}}],[\"设置一个或多个指定\",{\"1\":{\"332\":1,\"384\":1}}],[\"设置到其中\",{\"1\":{\"146\":1}}],[\"设置交换机处理失败消息的模式\",{\"1\":{\"100\":1}}],[\"设置代理请求headers\",{\"0\":{\"52\":1}}],[\"设备准备好数据\",{\"1\":{\"18\":1}}],[\"设备等等\",{\"1\":{\"8\":1}}],[\"设备管理\",{\"1\":{\"2\":1}}],[\"访问标志\",{\"0\":{\"694\":1}}],[\"访问标志来辨别一个方法是否声明为同步方法\",{\"1\":{\"589\":1}}],[\"访问修饰符范围大于等于父类\",{\"1\":{\"480\":1}}],[\"访问共享内存\",{\"1\":{\"409\":1}}],[\"访问方法是\",{\"1\":{\"243\":1}}],[\"访问http\",{\"1\":{\"52\":2}}],[\"访问80端口会被路由到本机的8080端口\",{\"1\":{\"51\":1}}],[\"访问控制\",{\"1\":{\"2\":1}}],[\"配置类等\",{\"1\":{\"462\":1}}],[\"配置反向代理\",{\"0\":{\"51\":1}}],[\"配置信息都封装到\",{\"1\":{\"32\":1}}],[\"hprof格式\",{\"1\":{\"725\":1}}],[\"hprof\",{\"1\":{\"725\":1}}],[\"h\",{\"1\":{\"514\":2,\"546\":3}}],[\"hlen\",{\"1\":{\"390\":1}}],[\"hdel\",{\"1\":{\"390\":1}}],[\"hget\",{\"1\":{\"390\":1,\"391\":1}}],[\"hgetall\",{\"1\":{\"345\":1,\"362\":1,\"390\":1}}],[\"heap\",{\"1\":{\"725\":1}}],[\"heapdumppath\",{\"1\":{\"725\":1}}],[\"heapdumppath=\",{\"1\":{\"725\":1}}],[\"heapdumponoutofmemoryerror\",{\"1\":{\"725\":1}}],[\"headsort\",{\"1\":{\"539\":1}}],[\"headers类型的交换器不依赖于路由键的匹配规则来路由消息\",{\"1\":{\"91\":1}}],[\"headers\",{\"0\":{\"91\":1},\"1\":{\"210\":1}}],[\"header\",{\"1\":{\"52\":5,\"150\":2,\"175\":5,\"181\":2,\"287\":1}}],[\"hero1\",{\"1\":{\"486\":1}}],[\"hero\",{\"1\":{\"486\":3}}],[\"hexists\",{\"1\":{\"376\":1,\"390\":1}}],[\"hsetnx\",{\"1\":{\"390\":1}}],[\"hset\",{\"1\":{\"390\":1,\"391\":1}}],[\"hscan\",{\"1\":{\"362\":1}}],[\"hs256\",{\"1\":{\"150\":1}}],[\"hmset\",{\"1\":{\"332\":1,\"390\":1,\"391\":1}}],[\"hmget\",{\"1\":{\"332\":1,\"390\":1,\"391\":1}}],[\"hmacsha256\",{\"1\":{\"150\":1}}],[\"hyperloglog更适合一些\",{\"1\":{\"314\":1,\"394\":1}}],[\"hyperloglogs\",{\"1\":{\"308\":1}}],[\"hyperloglog\",{\"0\":{\"317\":1,\"401\":1},\"1\":{\"297\":1,\"317\":4,\"401\":4,\"402\":3}}],[\"hypertext\",{\"1\":{\"172\":1,\"191\":2}}],[\"hibernatetemplate\",{\"1\":{\"437\":1}}],[\"hincrby\",{\"1\":{\"390\":1}}],[\"hidden\",{\"1\":{\"90\":1}}],[\"high\",{\"1\":{\"62\":1,\"539\":2}}],[\"happens\",{\"0\":{\"575\":1,\"576\":1},\"1\":{\"576\":3}}],[\"handle\",{\"1\":{\"664\":1}}],[\"handlepromotionfailure\",{\"1\":{\"664\":2}}],[\"handleappexception\",{\"1\":{\"459\":1}}],[\"handleresourcenotfoundexception\",{\"1\":{\"459\":1}}],[\"handleradapter\",{\"1\":{\"457\":1}}],[\"handleradapter适配器执行\",{\"1\":{\"456\":1}}],[\"handler其实就是controller\",{\"1\":{\"457\":1}}],[\"handler\",{\"1\":{\"456\":4,\"457\":1,\"605\":2}}],[\"handlermapping\",{\"1\":{\"456\":2,\"457\":1}}],[\"hash解决碰撞办法\",{\"1\":{\"551\":1}}],[\"hashentry数组+链表\",{\"1\":{\"550\":2}}],[\"hash值为0111\",{\"1\":{\"548\":1}}],[\"hash值的取值为32位补码的取值范围\",{\"1\":{\"548\":1}}],[\"hash计算元素存放的位置\",{\"1\":{\"546\":1}}],[\"hashtable使用同一个锁进行并发控制\",{\"1\":{\"550\":1}}],[\"hashtable则没有转化为红黑树的机制\",{\"1\":{\"543\":1}}],[\"hashtable默认初始大小是11\",{\"1\":{\"543\":1}}],[\"hashtable不能有nullkey和value\",{\"1\":{\"543\":1}}],[\"hashtable是线程安全的\",{\"1\":{\"543\":1}}],[\"hashtable\",{\"0\":{\"543\":1,\"550\":1},\"1\":{\"530\":2,\"550\":2}}],[\"hashcode\",{\"0\":{\"491\":1,\"492\":1},\"1\":{\"491\":3,\"546\":2}}],[\"hash数据结构添加需要三个参数\",{\"1\":{\"390\":1}}],[\"hashmap默认大小是16\",{\"1\":{\"543\":1}}],[\"hashmap能存储null的key和value\",{\"1\":{\"543\":1}}],[\"hashmap的效率要稍微好点\",{\"1\":{\"543\":1}}],[\"hashmap是非线程安全的\",{\"1\":{\"543\":1}}],[\"hashmap通过计算hash值使得查找元素的时间复杂度为1\",{\"1\":{\"491\":1}}],[\"hashmap\",{\"0\":{\"543\":1,\"544\":1,\"545\":1,\"548\":1,\"549\":1},\"1\":{\"389\":1,\"395\":1,\"530\":4,\"549\":1,\"550\":2,\"627\":1}}],[\"hashset底层是哈希表\",{\"1\":{\"536\":1}}],[\"hashset\",{\"0\":{\"536\":1},\"1\":{\"314\":1,\"392\":1,\"530\":1,\"536\":1}}],[\"hash表\",{\"0\":{\"258\":1}}],[\"hash\",{\"0\":{\"310\":1,\"312\":1,\"389\":1},\"1\":{\"60\":5,\"140\":2,\"297\":1,\"299\":1,\"308\":1,\"310\":3,\"312\":1,\"334\":1,\"345\":1,\"362\":1,\"382\":4,\"385\":1,\"389\":3,\"546\":1,\"548\":2}}],[\"hard\",{\"1\":{\"15\":1}}],[\"hotspot为什么要分代\",{\"0\":{\"676\":1}}],[\"hotspot\",{\"1\":{\"647\":1,\"654\":1,\"662\":1,\"663\":1,\"671\":3,\"683\":1,\"704\":1,\"721\":1,\"726\":1}}],[\"hotkey采用二级缓存的方式进行处理\",{\"1\":{\"343\":1}}],[\"hotkeys参数来查找\",{\"1\":{\"342\":1}}],[\"hotkey出现的原因是某个热点数据的访问量保证\",{\"1\":{\"340\":1}}],[\"hotkey\",{\"0\":{\"340\":1}}],[\"home\",{\"1\":{\"53\":1,\"711\":2}}],[\"host\",{\"1\":{\"52\":6,\"54\":2,\"97\":1,\"181\":4,\"210\":1}}],[\"http状态码\",{\"0\":{\"179\":1}}],[\"httpservletrequest\",{\"1\":{\"459\":2}}],[\"https与http的区别\",{\"0\":{\"180\":1}}],[\"https\",{\"1\":{\"65\":1,\"175\":1,\"180\":9,\"191\":2}}],[\"https配置\",{\"0\":{\"62\":1}}],[\"http反向代理使用http模块\",{\"1\":{\"63\":1}}],[\"http\",{\"0\":{\"177\":1,\"181\":2,\"190\":1},\"1\":{\"51\":1,\"52\":3,\"57\":1,\"58\":2,\"59\":3,\"60\":10,\"61\":2,\"63\":1,\"139\":2,\"142\":2,\"172\":2,\"175\":5,\"176\":1,\"178\":2,\"180\":7,\"181\":9,\"190\":6,\"191\":4}}],[\"htm\",{\"1\":{\"48\":2,\"53\":1,\"62\":1,\"139\":1,\"142\":1}}],[\"html中添加文件\",{\"1\":{\"108\":1}}],[\"html映射到\",{\"1\":{\"108\":1}}],[\"html会被代理到http\",{\"1\":{\"52\":2}}],[\"html\",{\"1\":{\"48\":6,\"52\":2,\"53\":4,\"62\":5,\"108\":3,\"139\":2,\"142\":2}}],[\"rpop\",{\"1\":{\"387\":1}}],[\"rpush\",{\"1\":{\"387\":1}}],[\"rpc则没有这个要求\",{\"1\":{\"75\":1}}],[\"rpc是双向直接网络通讯\",{\"1\":{\"75\":1}}],[\"rpc主要解决两个服务的远程通信问题\",{\"1\":{\"75\":1}}],[\"rpc和消息队列都是分布式系统中重要的组件之一\",{\"1\":{\"75\":1}}],[\"rpc和消息队列的区别\",{\"0\":{\"75\":1}}],[\"rlock\",{\"1\":{\"376\":2}}],[\"rdb创建快照的时候会阻塞主线程吗\",{\"0\":{\"409\":1}}],[\"rdb持久化\",{\"0\":{\"408\":1}}],[\"rdb\",{\"0\":{\"363\":1,\"416\":1},\"1\":{\"306\":1,\"324\":1,\"363\":2,\"416\":17}}],[\"rr\",{\"0\":{\"290\":1},\"1\":{\"290\":2,\"291\":2,\"292\":1}}],[\"rc3版本之后自带了内存整理\",{\"1\":{\"350\":1}}],[\"rc\",{\"0\":{\"290\":1},\"1\":{\"290\":2,\"291\":2}}],[\"rc4\",{\"1\":{\"62\":1}}],[\"r\",{\"1\":{\"219\":6,\"220\":1,\"539\":15,\"725\":1}}],[\"rt\",{\"1\":{\"711\":1}}],[\"rtt\",{\"1\":{\"190\":2,\"199\":1,\"201\":1}}],[\"rtp\",{\"1\":{\"172\":1}}],[\"rip\",{\"1\":{\"174\":1}}],[\"runnable\",{\"1\":{\"561\":1,\"599\":1,\"612\":3}}],[\"runtimeexception\",{\"1\":{\"146\":1}}],[\"run\",{\"1\":{\"107\":1,\"108\":1,\"568\":1,\"606\":1}}],[\"ruby\",{\"1\":{\"78\":1,\"81\":1}}],[\"radius\",{\"1\":{\"405\":2}}],[\"range\",{\"1\":{\"179\":1,\"181\":1,\"243\":2}}],[\"random\",{\"1\":{\"60\":1,\"328\":2}}],[\"rabbittemplage\",{\"1\":{\"100\":1}}],[\"rabbittemplate\",{\"1\":{\"100\":2}}],[\"rabbitmq用来队列削峰\",{\"1\":{\"137\":1}}],[\"rabbitmq延时队列模拟订单过期\",{\"1\":{\"136\":1}}],[\"rabbitmq完成秒杀订单创建\",{\"1\":{\"136\":1}}],[\"rabbitmq消息积压如何处理\",{\"0\":{\"103\":1}}],[\"rabbitmq到消费者\",{\"1\":{\"98\":1}}],[\"rabbitmq自身\",{\"1\":{\"98\":1}}],[\"rabbitmq可以对队列和消息分别设置ttl\",{\"1\":{\"95\":1}}],[\"rabbitmq本身没有延时队列\",{\"1\":{\"94\":1}}],[\"rabbitmq的内部对象\",{\"1\":{\"92\":1}}],[\"rabbitmq的exchange有4种类型\",{\"1\":{\"84\":1}}],[\"rabbitmq中消息只能存储在队列中\",{\"1\":{\"85\":1}}],[\"rabbitmq组成\",{\"0\":{\"82\":1}}],[\"rabbitmq使用一些机制保证可靠性\",{\"1\":{\"81\":1}}],[\"rabbitmq使用一些机制来保证消息的可靠性\",{\"1\":{\"78\":1}}],[\"rabbitmq特点\",{\"0\":{\"81\":1}}],[\"rabbitmq是使用erlang编写的一个开源的消息队列\",{\"1\":{\"80\":1}}],[\"rabbitmq是一个在amqp\",{\"1\":{\"80\":1}}],[\"rabbitmq是采用erlang语言实现amqp\",{\"1\":{\"78\":1}}],[\"rabbitmq在吞吐量方面虽然稍逊于kafka\",{\"1\":{\"79\":1}}],[\"rabbitmq和kafka区别\",{\"0\":{\"79\":1}}],[\"rabbitmq提供了许多插件\",{\"1\":{\"78\":1,\"81\":1}}],[\"rabbitmq提供了一个易用的用户界面\",{\"1\":{\"78\":1,\"81\":1}}],[\"rabbitmq几乎支持所有常用语言\",{\"1\":{\"78\":1,\"81\":1}}],[\"rabbitmq除了原生支持amqp协议\",{\"1\":{\"78\":1,\"81\":1}}],[\"rabbitmq\",{\"0\":{\"67\":1,\"78\":1,\"94\":1,\"97\":1,\"102\":1},\"1\":{\"77\":1,\"78\":1,\"82\":2,\"83\":2,\"84\":3,\"90\":1,\"103\":1,\"136\":1,\"137\":1}}],[\"ra\",{\"1\":{\"66\":1}}],[\"rsa\",{\"1\":{\"62\":1}}],[\"rollback\",{\"1\":{\"446\":1}}],[\"roll\",{\"1\":{\"286\":1,\"287\":1}}],[\"rows\",{\"1\":{\"243\":2}}],[\"row\",{\"1\":{\"237\":1,\"287\":1}}],[\"rocketmq主要解决了分布式事务中的两个问题\",{\"1\":{\"130\":1}}],[\"rocketmq本身也为事务消息提供了持久化能力\",{\"1\":{\"129\":1}}],[\"rocketmq是来自阿里巴巴的分布式消息中间件\",{\"1\":{\"129\":1}}],[\"rocketmq事务消息方案\",{\"0\":{\"129\":1}}],[\"routingkey\",{\"1\":{\"100\":1}}],[\"routingkey为一个点号\",{\"1\":{\"90\":1}}],[\"routing\",{\"1\":{\"80\":1,\"83\":1,\"174\":1}}],[\"round\",{\"1\":{\"60\":1}}],[\"robin\",{\"1\":{\"60\":1}}],[\"roots直接引用的对象标记一遍\",{\"1\":{\"687\":1}}],[\"roots能直接关联到的对象\",{\"1\":{\"684\":1}}],[\"roots\",{\"0\":{\"668\":1},\"1\":{\"667\":2}}],[\"root\",{\"1\":{\"48\":2,\"53\":2,\"54\":1,\"62\":2,\"139\":1,\"142\":1,\"153\":1,\"683\":1}}],[\"region\",{\"1\":{\"684\":2}}],[\"region中还有一类特殊的humongous区域\",{\"1\":{\"684\":1}}],[\"registration\",{\"1\":{\"458\":2}}],[\"register\",{\"1\":{\"458\":1}}],[\"release\",{\"1\":{\"624\":2}}],[\"relay\",{\"1\":{\"248\":2}}],[\"removelast\",{\"1\":{\"537\":1}}],[\"removefirst\",{\"1\":{\"537\":1}}],[\"remove\",{\"1\":{\"537\":1,\"600\":1}}],[\"required\",{\"1\":{\"447\":2}}],[\"request\",{\"1\":{\"202\":1,\"451\":1,\"459\":2}}],[\"request代表客户端的请求服务器理解不了\",{\"1\":{\"179\":1}}],[\"redlock\",{\"1\":{\"377\":1,\"378\":2}}],[\"redis主节点的哈希槽信息是通过bitmap存储的\",{\"1\":{\"430\":1}}],[\"redis的集群主节点数量一般不会超过1000个\",{\"1\":{\"430\":1}}],[\"redis的性能瓶颈不再cpu\",{\"1\":{\"322\":1}}],[\"redis会根据key的有效部分计算插槽\",{\"1\":{\"430\":1}}],[\"redis会把每一个master节点映射到0~16383\",{\"1\":{\"430\":1}}],[\"redis分片集群具备自动的主从切换\",{\"1\":{\"431\":1}}],[\"redis分片集群\",{\"0\":{\"428\":1}}],[\"redis哨兵sentinel\",{\"0\":{\"423\":1}}],[\"redis单节点的内存占用不要太大\",{\"1\":{\"422\":1}}],[\"redis单线程了解吗\",{\"0\":{\"320\":1}}],[\"redis能在后台自动重写aof产生一个新的aof文件\",{\"1\":{\"414\":1}}],[\"redis就会将命令写入到aof缓冲区中\",{\"1\":{\"410\":1}}],[\"redis处理的每一个命令都会记录在aof文件中\",{\"1\":{\"410\":1}}],[\"redis提供了两个命令来生成rdb快照文件\",{\"1\":{\"409\":1}}],[\"redis停机时会自动执行一次rdb\",{\"1\":{\"408\":1}}],[\"redis自己构建了一种\",{\"1\":{\"383\":1}}],[\"rediscommands\",{\"1\":{\"376\":1}}],[\"redis集群\",{\"0\":{\"371\":1,\"417\":1}}],[\"redis阻塞的常见原因\",{\"0\":{\"361\":1}}],[\"redis存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间\",{\"1\":{\"348\":1}}],[\"redis存储token\",{\"1\":{\"136\":1}}],[\"redis慢查询统计的是命令执行这一步的耗时\",{\"1\":{\"344\":1}}],[\"redis命令的执行简化为以下四步\",{\"1\":{\"344\":1}}],[\"redis中的大部分命令都是\",{\"1\":{\"345\":1}}],[\"redis中有两种lfu算法\",{\"1\":{\"342\":1}}],[\"redis中除了字符串类型有自己独有设置过期时间的命令setex外\",{\"1\":{\"326\":1}}],[\"redis采用的是定期删除+惰性删除策略\",{\"1\":{\"335\":1}}],[\"redis性能优化\",{\"0\":{\"330\":1}}],[\"redis内存碎片\",{\"0\":{\"347\":1}}],[\"redis内存淘汰机制\",{\"0\":{\"328\":1}}],[\"redis内存管理\",{\"0\":{\"325\":1}}],[\"redis通过过期字典\",{\"1\":{\"326\":1}}],[\"redis通过io多路复用程序来监听来自客户端的大量连接\",{\"1\":{\"321\":1}}],[\"redis是如何判断数据是否过期的\",{\"1\":{\"326\":1}}],[\"redis给缓存数据设置过期时间有啥用\",{\"0\":{\"326\":1}}],[\"redis后台线程了解吗\",{\"0\":{\"324\":1}}],[\"redis基础二\",{\"0\":{\"329\":1}}],[\"redis基础一\",{\"0\":{\"295\":1}}],[\"redis基于reactor模式设计开发了一套高效的事件处理模型\",{\"1\":{\"320\":1}}],[\"redis一直是单线程模型\",{\"1\":{\"319\":1}}],[\"redis读写单线程\",{\"1\":{\"319\":1}}],[\"redis线程模型\",{\"0\":{\"319\":1}}],[\"redis持久化\",{\"0\":{\"318\":1,\"407\":1},\"1\":{\"318\":1}}],[\"redis数据结构\",{\"0\":{\"382\":1},\"1\":{\"307\":1}}],[\"redis数据的key是\",{\"1\":{\"146\":1,\"147\":1}}],[\"redisson\",{\"1\":{\"306\":2,\"376\":6,\"377\":1}}],[\"redis作为缓存\",{\"1\":{\"137\":1}}],[\"redis验证秒杀中的一人一单\",{\"1\":{\"136\":1}}],[\"redis\",{\"0\":{\"297\":1,\"298\":1,\"299\":1,\"300\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"313\":1,\"322\":1,\"323\":1,\"336\":1,\"340\":1,\"373\":1,\"374\":2,\"378\":1,\"432\":1},\"1\":{\"107\":2,\"109\":3,\"136\":1,\"137\":1,\"155\":2,\"297\":7,\"298\":4,\"299\":11,\"300\":3,\"306\":10,\"309\":1,\"311\":4,\"313\":2,\"314\":1,\"319\":1,\"320\":1,\"323\":1,\"324\":1,\"326\":1,\"328\":1,\"334\":2,\"338\":1,\"339\":2,\"342\":1,\"346\":3,\"350\":4,\"362\":1,\"363\":4,\"366\":1,\"369\":2,\"370\":1,\"374\":4,\"376\":6,\"378\":15,\"379\":1,\"380\":1,\"382\":2,\"383\":3,\"386\":2,\"388\":2,\"389\":2,\"392\":1,\"401\":4,\"408\":1,\"414\":3,\"415\":4,\"416\":5,\"429\":1}}],[\"redis等\",{\"1\":{\"63\":1}}],[\"reentrantreadwritelock\",{\"1\":{\"620\":1}}],[\"reentrant\",{\"1\":{\"377\":1}}],[\"reentrantlock也可以实现\",{\"1\":{\"594\":1}}],[\"reentrantlock可以指定是公平锁还是非公平锁\",{\"1\":{\"594\":1}}],[\"reentrantlock提供了一种能够中断等待锁的线程的机制\",{\"1\":{\"594\":1}}],[\"reentrantlock\",{\"0\":{\"591\":1,\"592\":1,\"594\":1},\"1\":{\"377\":1,\"551\":1,\"592\":3,\"594\":2,\"595\":1,\"620\":1,\"624\":1,\"632\":1}}],[\"renewexpirationasync\",{\"1\":{\"376\":2}}],[\"referencequeue\",{\"1\":{\"670\":1}}],[\"reference\",{\"1\":{\"656\":1,\"657\":1}}],[\"reflect包的方法对类进行反射调用时如果类没有初始化\",{\"1\":{\"706\":1}}],[\"reflect\",{\"1\":{\"515\":1}}],[\"ref\",{\"1\":{\"243\":5}}],[\"recently\",{\"1\":{\"328\":2}}],[\"record\",{\"1\":{\"238\":3,\"282\":1,\"287\":1,\"292\":1}}],[\"recv\",{\"1\":{\"193\":1}}],[\"replicas\",{\"1\":{\"429\":2}}],[\"replication\",{\"1\":{\"420\":2}}],[\"replytext\",{\"1\":{\"100\":1}}],[\"replycode\",{\"1\":{\"100\":1}}],[\"repeatable\",{\"1\":{\"232\":1,\"234\":1,\"235\":1,\"238\":1,\"282\":5,\"284\":2,\"285\":1}}],[\"repeat\",{\"1\":{\"202\":1}}],[\"rejectedexecution\",{\"1\":{\"608\":1}}],[\"rejectedexecutionexception来拒绝新任务的处理\",{\"1\":{\"606\":1}}],[\"rejectedexecutionhandler\",{\"1\":{\"605\":1}}],[\"reject\",{\"1\":{\"93\":1}}],[\"rewrite之后停止后续正则匹配处理\",{\"1\":{\"66\":2}}],[\"rewrite\",{\"0\":{\"66\":1},\"1\":{\"66\":2,\"411\":1,\"414\":2}}],[\"resove\",{\"1\":{\"712\":1}}],[\"resolveclass\",{\"1\":{\"712\":1,\"714\":1}}],[\"resolve\",{\"1\":{\"712\":1,\"714\":2}}],[\"resolution\",{\"1\":{\"174\":1,\"214\":1,\"700\":1}}],[\"resources\",{\"1\":{\"711\":1}}],[\"resourcenotfoundexception\",{\"1\":{\"459\":2}}],[\"resource\",{\"1\":{\"182\":2}}],[\"responseentity<errorreponse>\",{\"1\":{\"459\":1}}],[\"responseentity<\",{\"1\":{\"459\":1}}],[\"responsebody\",{\"1\":{\"459\":1}}],[\"response\",{\"1\":{\"57\":1}}],[\"resultset\",{\"1\":{\"729\":1}}],[\"result\",{\"1\":{\"243\":1,\"507\":2}}],[\"resultmap>\",{\"1\":{\"33\":1}}],[\"resultmapping\",{\"1\":{\"32\":1}}],[\"resultmap\",{\"1\":{\"32\":1}}],[\"resulttype=\",{\"1\":{\"30\":1}}],[\"reactor\",{\"1\":{\"298\":1}}],[\"reachability\",{\"1\":{\"174\":1}}],[\"real\",{\"1\":{\"52\":1,\"172\":1}}],[\"readwritelock\",{\"1\":{\"377\":1}}],[\"readview\",{\"0\":{\"288\":1}}],[\"read调用的过程\",{\"1\":{\"22\":1}}],[\"read\",{\"0\":{\"303\":1},\"1\":{\"7\":1,\"228\":1,\"232\":6,\"234\":2,\"235\":1,\"238\":1,\"282\":9,\"284\":4,\"285\":5,\"286\":3,\"288\":3,\"290\":1,\"291\":2,\"292\":2,\"303\":5,\"304\":2}}],[\"reuseexecutor\",{\"1\":{\"35\":1}}],[\"returnmessage\",{\"1\":{\"100\":1}}],[\"returncallback\",{\"0\":{\"100\":1},\"1\":{\"100\":1}}],[\"return\",{\"0\":{\"65\":1},\"1\":{\"34\":1,\"65\":1,\"100\":1,\"146\":2,\"155\":2,\"374\":2,\"376\":5,\"444\":2,\"507\":1,\"520\":1,\"521\":1,\"522\":1,\"523\":1,\"524\":1,\"546\":1,\"579\":1,\"599\":1,\"613\":1,\"714\":1}}],[\"8u20\",{\"1\":{\"726\":1}}],[\"8的默认收集器\",{\"1\":{\"680\":1}}],[\"8最大并发度是node的个数\",{\"1\":{\"551\":1}}],[\"8采用拉链法+红黑树\",{\"1\":{\"551\":1}}],[\"8中的扰动函数源码\",{\"1\":{\"546\":1}}],[\"8之前hashmap底层是数组和链表集合一起\",{\"1\":{\"546\":1}}],[\"8之后通过尾插法解决上述问题\",{\"1\":{\"549\":1}}],[\"8之后hashmap使用数组+链表\",{\"1\":{\"547\":1}}],[\"8之后hashmap底层使用数组+链表\",{\"1\":{\"543\":1}}],[\"8之后的元空间\",{\"1\":{\"5\":1,\"557\":1}}],[\"8以无参数构造方法创建arraylist时\",{\"1\":{\"532\":1}}],[\"8位补码的表示范围\",{\"1\":{\"471\":1}}],[\"8k\",{\"1\":{\"430\":1}}],[\"8g\",{\"1\":{\"300\":1}}],[\"8\",{\"0\":{\"546\":1,\"547\":1,\"551\":1},\"1\":{\"63\":1,\"136\":1,\"188\":1,\"226\":1,\"382\":1,\"389\":1,\"398\":1,\"430\":2,\"530\":2,\"550\":3,\"551\":1,\"599\":1,\"613\":1,\"645\":2,\"671\":1,\"692\":1,\"721\":3}}],[\"81\",{\"1\":{\"53\":1,\"401\":1}}],[\"8082\",{\"1\":{\"60\":1}}],[\"8081\",{\"1\":{\"59\":1,\"60\":4,\"61\":1}}],[\"8080\",{\"1\":{\"48\":3,\"51\":1,\"52\":6,\"57\":1,\"59\":1,\"60\":5,\"61\":1,\"139\":2}}],[\"8000\",{\"1\":{\"58\":1,\"65\":1}}],[\"80\",{\"1\":{\"48\":1,\"51\":1,\"59\":1,\"108\":2,\"139\":3,\"142\":3,\"180\":1}}],[\"拍拍\",{\"0\":{\"44\":1,\"169\":1}}],[\"笔记\",{\"0\":{\"42\":1,\"166\":1}}],[\"笔记来源网络\",{\"1\":{\"465\":1}}],[\"笔记来源\",{\"1\":{\"0\":1}}],[\"欢迎\",{\"0\":{\"36\":1}}],[\"可选\",{\"1\":{\"724\":1}}],[\"可选的扩展头\",{\"1\":{\"210\":1}}],[\"可预测的停顿\",{\"1\":{\"684\":1}}],[\"可有可无的\",{\"1\":{\"670\":2}}],[\"可达性分析中不可达的对象被第一次标记并且进行一次筛选\",{\"1\":{\"669\":1}}],[\"可达性分析\",{\"0\":{\"667\":1}}],[\"可传入\",{\"1\":{\"612\":1}}],[\"可创建的最大线程数\",{\"1\":{\"604\":1}}],[\"可中断锁\",{\"1\":{\"595\":1}}],[\"可中断锁和不可中断锁有什么区别\",{\"0\":{\"595\":1}}],[\"可实现选择性通知\",{\"1\":{\"594\":1}}],[\"可实现公平锁\",{\"1\":{\"594\":1}}],[\"可见性\",{\"1\":{\"577\":1,\"579\":1}}],[\"可用内存缩小为原来的一半\",{\"1\":{\"675\":1}}],[\"可用内存变小\",{\"1\":{\"675\":1}}],[\"可用运算符有\",{\"1\":{\"399\":1}}],[\"可用性\",{\"1\":{\"112\":1}}],[\"可串行化\",{\"1\":{\"282\":1}}],[\"可重复\",{\"1\":{\"532\":1}}],[\"可重复的\",{\"1\":{\"529\":2}}],[\"可重复读\",{\"1\":{\"228\":1,\"282\":2}}],[\"可重入\",{\"1\":{\"372\":1}}],[\"可重读\",{\"1\":{\"235\":1,\"282\":1}}],[\"可将redis作为分布式下用户数据的存储介质\",{\"1\":{\"147\":1}}],[\"可靠\",{\"1\":{\"173\":1}}],[\"可靠消息一致性要解决消息从发出到接收的一致性\",{\"1\":{\"132\":1}}],[\"可靠消息一致性关注的是交易过程的事务一致\",{\"1\":{\"132\":1}}],[\"可靠消息一致性\",{\"1\":{\"132\":1}}],[\"可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景\",{\"1\":{\"130\":1}}],[\"可靠消息最终一致性指的是事务发起方执行完本地事务之后发出一条消息\",{\"1\":{\"125\":1}}],[\"可靠消息最终一致性\",{\"0\":{\"125\":1}}],[\"可靠性\",{\"1\":{\"78\":1,\"81\":1}}],[\"可能存在所有的新生代对象都在这次gc之后晋升至老年代\",{\"1\":{\"664\":1}}],[\"可能存在数据丢失的风险\",{\"1\":{\"408\":1}}],[\"可能1\",{\"1\":{\"575\":1}}],[\"可能aservice会进行aop操作\",{\"1\":{\"450\":1}}],[\"可能误判\",{\"1\":{\"353\":1}}],[\"可能会崩溃\",{\"1\":{\"726\":1}}],[\"可能会受到本机内存的限制\",{\"1\":{\"645\":1}}],[\"可能会创建大量线程\",{\"1\":{\"607\":1}}],[\"可能会阻塞后续其他命令的执行\",{\"1\":{\"413\":1}}],[\"可能会影响redis处理其他请求\",{\"1\":{\"341\":1}}],[\"可能会影响性能\",{\"1\":{\"322\":1}}],[\"可能会导致锁无法被释放\",{\"1\":{\"374\":1}}],[\"可能会导致redis宕机\",{\"1\":{\"341\":1}}],[\"可能会导致脏读\",{\"1\":{\"282\":1}}],[\"可能会导致树的高度较高\",{\"1\":{\"261\":1}}],[\"可能会二次查询\",{\"1\":{\"267\":1}}],[\"可能还没有到达叶子节点\",{\"1\":{\"262\":1}}],[\"可能还有一些数据没有发完\",{\"1\":{\"196\":1}}],[\"可能匹配的队列有多个\",{\"1\":{\"89\":1}}],[\"可能出现网络不稳定\",{\"1\":{\"57\":1}}],[\"可复用的企业消息系统\",{\"1\":{\"80\":1}}],[\"可执行批处理任务的执行器\",{\"1\":{\"35\":1}}],[\"可以有效防止恶意代码的执行\",{\"1\":{\"703\":1}}],[\"可以有效防止sql注入问题\",{\"1\":{\"29\":1}}],[\"可以理解的代码就叫做字节码\",{\"1\":{\"689\":1}}],[\"可以理解为线程数是可以无限扩展的\",{\"1\":{\"607\":1}}],[\"可以理解为\",{\"1\":{\"213\":1}}],[\"可以理解为软件安装包\",{\"1\":{\"107\":1}}],[\"可以不需要其他收集器配合就能独立管理整个\",{\"1\":{\"684\":1}}],[\"可以\",{\"1\":{\"672\":1}}],[\"可以维护系统的运行安全\",{\"1\":{\"670\":1}}],[\"可以作为\",{\"0\":{\"668\":1}}],[\"可以确保是安全的\",{\"1\":{\"664\":1}}],[\"可以简单理解为一个固定大小的hashtable\",{\"1\":{\"647\":1}}],[\"可以简单理解为每个索引都对应着一颗\",{\"1\":{\"277\":1}}],[\"可以当做无界队列也可以当做有界队列来使用\",{\"1\":{\"633\":1}}],[\"可以分为阻塞队列和非阻塞队列\",{\"1\":{\"630\":1}}],[\"可以从顶级链表开始找\",{\"1\":{\"635\":1}}],[\"可以从\",{\"1\":{\"611\":1}}],[\"可以保证每次出队的任务都是当前队列中执行时间最靠前的\",{\"1\":{\"607\":1}}],[\"可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行\",{\"1\":{\"587\":1}}],[\"可以保证数据库表中每一行数据的唯一性\",{\"1\":{\"256\":1}}],[\"可以随机访问\",{\"1\":{\"534\":1}}],[\"可以随便起\",{\"1\":{\"48\":1}}],[\"可以重复\",{\"1\":{\"529\":1}}],[\"可以快速启动特定类型的应用\",{\"1\":{\"463\":1}}],[\"可以生成和维护bean\",{\"1\":{\"452\":1}}],[\"可以采用主\",{\"1\":{\"422\":1}}],[\"可以减少rdb导致的过多io\",{\"1\":{\"422\":1}}],[\"可以容忍数据部分不完整\",{\"1\":{\"416\":1}}],[\"可以选择使用\",{\"1\":{\"416\":1}}],[\"可以轻松地导出\",{\"1\":{\"416\":1}}],[\"可以轻松实现两个位置距离的计算\",{\"1\":{\"404\":1}}],[\"可以加载aof文件进行数据恢复\",{\"1\":{\"411\":1}}],[\"可以组成一个\",{\"1\":{\"398\":1}}],[\"可以非常方便的实现如共同关注\",{\"1\":{\"392\":1}}],[\"可以给出任何文件名\",{\"1\":{\"725\":1}}],[\"可以给锁添加一个过期时间\",{\"1\":{\"375\":1}}],[\"可以给全球每个设备一个独立的地址\",{\"1\":{\"210\":1}}],[\"可以用于临时监控redis实例的操作情况\",{\"1\":{\"342\":1}}],[\"可以用来控制同时访问特定资源的线程数量\",{\"1\":{\"624\":1}}],[\"可以用来存储任何类型的数据比如字符串\",{\"1\":{\"309\":1,\"383\":1}}],[\"可以用来标识一个资源\",{\"1\":{\"182\":1}}],[\"可以用来负载均衡连接mysql\",{\"1\":{\"63\":1}}],[\"可以利用pipeline\",{\"1\":{\"333\":1}}],[\"可以获取部分字段的信息\",{\"1\":{\"310\":1}}],[\"可以短暂地允许数据库和缓存数据不一致的场景\",{\"1\":{\"302\":1}}],[\"可以先删除\",{\"1\":{\"302\":1}}],[\"可以阻止脏读和不可重复读\",{\"1\":{\"282\":1}}],[\"可以阻止脏读\",{\"1\":{\"282\":1}}],[\"可以定位到符合a>1条件的第一条记录\",{\"1\":{\"271\":1}}],[\"可以解决单一表数据量过大的问题\",{\"1\":{\"251\":1}}],[\"可以是垂直拆分\",{\"1\":{\"251\":1}}],[\"可以垂直分库\",{\"1\":{\"250\":1}}],[\"可以更准确的理解\",{\"1\":{\"243\":1}}],[\"可以更新整个资源\",{\"1\":{\"176\":1}}],[\"可以避免类的重复加载\",{\"1\":{\"715\":1}}],[\"可以避免内存碎片率过大的问题\",{\"1\":{\"350\":1}}],[\"可以避免缓冲区溢出\",{\"1\":{\"311\":1}}],[\"可以避免\",{\"1\":{\"190\":1}}],[\"可以避免打开频繁的打开和关闭连接\",{\"1\":{\"63\":1}}],[\"可以唯一标识一个资源\",{\"1\":{\"182\":1}}],[\"可以创建新的资源或提交数据到服务器进行处理\",{\"1\":{\"176\":1}}],[\"可以屏蔽操作系统和文件存储方式\",{\"1\":{\"172\":1,\"191\":1}}],[\"可以进行降级\",{\"1\":{\"165\":1}}],[\"可以将多个异步任务串联起来\",{\"1\":{\"613\":1}}],[\"可以将多个交换器绑定在一起\",{\"1\":{\"78\":1}}],[\"可以将threadlocal类形象的比喻成存放数据的盒子\",{\"1\":{\"598\":1}}],[\"可以将不用的数据放到磁盘上\",{\"1\":{\"299\":1}}],[\"可以将内存中的数据保持在磁盘中\",{\"1\":{\"299\":1}}],[\"可以将ip地址转换成整形数据存储\",{\"1\":{\"242\":1}}],[\"可以将用户数据保存至redis中\",{\"1\":{\"146\":1}}],[\"可以看成常量\",{\"1\":{\"494\":1}}],[\"可以看成支付宝管理的部分\",{\"1\":{\"133\":1}}],[\"可以看出\",{\"1\":{\"380\":1}}],[\"可以看作是\",{\"1\":{\"334\":1}}],[\"可以看做一个线程安全的\",{\"1\":{\"627\":1}}],[\"可以看做是命令日志文件\",{\"1\":{\"410\":1}}],[\"可以看做是hash表\",{\"1\":{\"326\":1}}],[\"可以看做是不同主机之间的进程进行双向通信的端点\",{\"1\":{\"9\":1}}],[\"可以看做rabbitmq的服务节点\",{\"1\":{\"92\":1}}],[\"可以使用以下参数声明这些实现\",{\"1\":{\"723\":1}}],[\"可以使用cglib动态代理\",{\"1\":{\"515\":1}}],[\"可以使用日期\",{\"1\":{\"316\":1}}],[\"可以使用\",{\"1\":{\"243\":1,\"343\":1,\"346\":1,\"443\":1,\"444\":1,\"598\":1}}],[\"可以使用队列进行削峰填谷\",{\"1\":{\"164\":1}}],[\"可以使用docker\",{\"1\":{\"109\":1}}],[\"可以使用$hostname配置成主机名\",{\"1\":{\"48\":1}}],[\"可以把多个变量放在一个对象里来进行\",{\"1\":{\"585\":1}}],[\"可以把打包好的文件上传到一个镜像仓库\",{\"1\":{\"105\":1}}],[\"可以把它理解为一个轻量级的虚拟机\",{\"1\":{\"104\":1}}],[\"可以把消息队列看作是一个存放消息的容器\",{\"1\":{\"67\":1}}],[\"可以划分出多个vhost\",{\"1\":{\"97\":1}}],[\"可以通过getparent\",{\"1\":{\"711\":1}}],[\"可以通过参数\",{\"1\":{\"662\":1}}],[\"可以通过\",{\"1\":{\"647\":1,\"662\":1}}],[\"可以通过下面两个参数来减少对\",{\"1\":{\"350\":1}}],[\"可以通过本身的队列特性\",{\"1\":{\"94\":1}}],[\"可以通过配置来定义kafka中每个topic应该保留事件的时间\",{\"1\":{\"85\":1}}],[\"可以提高\",{\"1\":{\"415\":1}}],[\"可以提高系统访问速度\",{\"1\":{\"55\":1}}],[\"可以提供该资源的路径\",{\"1\":{\"182\":1}}],[\"可以提升服务器性能\",{\"1\":{\"59\":1}}],[\"可以在重新标记前进行一次垃圾回收\",{\"1\":{\"735\":1}}],[\"可以在等待一段时间之后自行返回\",{\"1\":{\"561\":1}}],[\"可以在子类中被重新定义\",{\"1\":{\"487\":1}}],[\"可以在非聚簇索引遍历啊过程中\",{\"1\":{\"272\":1}}],[\"可以在并发读写\",{\"1\":{\"152\":1}}],[\"可以在\",{\"1\":{\"34\":1}}],[\"可以说这是最有用的进程间通信方式\",{\"1\":{\"9\":1}}],[\"可以实现本机任意两个进程通信\",{\"1\":{\"9\":1}}],[\"实例的父类加载器\",{\"1\":{\"713\":1}}],[\"实例会在试图亲自查找类或资源之前\",{\"1\":{\"713\":2}}],[\"实例都有一个相关的父类加载器\",{\"1\":{\"713\":1}}],[\"实例变量会在对象实例化的时候随着对象一块分配在java堆中\",{\"1\":{\"704\":1}}],[\"实例数据部分是对象真正存储的有效信息\",{\"1\":{\"654\":1}}],[\"实例数据和对齐填充\",{\"1\":{\"654\":1}}],[\"实例化\",{\"1\":{\"438\":1,\"453\":1}}],[\"实例依次请求申请加锁\",{\"1\":{\"378\":1}}],[\"实时传输协议\",{\"1\":{\"172\":1}}],[\"实现且全部继承自java\",{\"1\":{\"712\":1}}],[\"实现中已经考虑了这种情况\",{\"1\":{\"600\":1}}],[\"实现有什么不同\",{\"0\":{\"551\":1}}],[\"实现线程安全的方式\",{\"1\":{\"550\":1}}],[\"实现sortedmap接口让\",{\"1\":{\"544\":1}}],[\"实现可见性\",{\"1\":{\"523\":1}}],[\"实现某个接口就相当于有某个责任\",{\"1\":{\"487\":1}}],[\"实现关系\",{\"1\":{\"486\":1}}],[\"实现类\",{\"1\":{\"449\":1,\"512\":1,\"517\":1}}],[\"实现类为providermanager\",{\"1\":{\"146\":1}}],[\"实现无感知的数据迁移\",{\"1\":{\"431\":1}}],[\"实现分布式锁的时候\",{\"1\":{\"380\":1}}],[\"实现分布式锁可靠性更高\",{\"1\":{\"379\":1}}],[\"实现分布式锁性能较高\",{\"1\":{\"379\":1}}],[\"实现分布式锁\",{\"0\":{\"373\":1,\"379\":1},\"1\":{\"376\":1}}],[\"实现分布式事务\",{\"0\":{\"72\":1}}],[\"实现一个最简易的分布式锁\",{\"0\":{\"374\":1}}],[\"实现一个最简易的分布式锁如何基于\",{\"0\":{\"374\":1}}],[\"实现一个简单的抽奖系统的话\",{\"1\":{\"315\":1}}],[\"实现一个排行榜怎么做\",{\"0\":{\"313\":1}}],[\"实现抽奖系统怎么做\",{\"0\":{\"315\":1}}],[\"实现消息队列没有广播机制的问题\",{\"1\":{\"306\":1}}],[\"实现消息队列功能太简单\",{\"1\":{\"306\":1}}],[\"实现简单\",{\"1\":{\"237\":1}}],[\"实现的类加载器在\",{\"1\":{\"711\":1}}],[\"实现的\",{\"1\":{\"234\":1,\"282\":1,\"379\":1,\"581\":1}}],[\"实现了双亲委派机制\",{\"1\":{\"712\":1}}],[\"实现了\",{\"1\":{\"592\":1}}],[\"实现了访问顺序相关逻辑\",{\"1\":{\"530\":1}}],[\"实现了invocationhandler接口的对象\",{\"1\":{\"514\":1}}],[\"实现了空间预分配和惰性空间释放两种优化策略\",{\"1\":{\"311\":1}}],[\"实现了可重复读和防止快照读下的\",{\"1\":{\"292\":1}}],[\"实现了可重复读和防止部分幻读\",{\"1\":{\"284\":1}}],[\"实现了水平扩展\",{\"1\":{\"250\":1}}],[\"实现了sql标准定义的四个隔离级别\",{\"1\":{\"228\":1}}],[\"实现了对statement对象的复用\",{\"1\":{\"35\":1}}],[\"实现\",{\"1\":{\"172\":1,\"404\":1,\"514\":1,\"515\":1,\"544\":1,\"550\":2,\"711\":1,\"723\":1}}],[\"实现方式比较简单\",{\"1\":{\"374\":1}}],[\"实现方式\",{\"1\":{\"262\":1}}],[\"实现方式为从购物车页面点击确认订单的时候会在后端生成一个防重令牌\",{\"1\":{\"155\":1}}],[\"实现方案\",{\"1\":{\"122\":1}}],[\"实现队列削峰\",{\"1\":{\"136\":1}}],[\"实现单点登录\",{\"0\":{\"145\":1},\"1\":{\"136\":1}}],[\"实现难度也大\",{\"1\":{\"124\":1}}],[\"实现任务异步\",{\"1\":{\"75\":1}}],[\"实际上\",{\"1\":{\"612\":1}}],[\"实际上初始化赋值的是一个空数组\",{\"1\":{\"532\":1}}],[\"实际上是修改了请求头中的目标ip和端口\",{\"1\":{\"139\":1}}],[\"实际调用的是methodinterceptor中的intercept方法\",{\"1\":{\"515\":1}}],[\"实际就是通过stringbuilder调用append\",{\"1\":{\"496\":1}}],[\"实际只是在\",{\"1\":{\"303\":1}}],[\"实际使用的索引的最大长度\",{\"1\":{\"243\":1}}],[\"实际使用到的索引\",{\"1\":{\"243\":1}}],[\"实际给人的感觉区别也不大\",{\"1\":{\"189\":1}}],[\"实际查询的仍然是所有的数据\",{\"1\":{\"34\":1}}],[\"实际应用中\",{\"1\":{\"16\":1}}],[\"xloggc\",{\"1\":{\"724\":1}}],[\"xbootclasspath参数指定的路径下的所有类\",{\"1\":{\"711\":1}}],[\"xx\",{\"1\":{\"647\":1,\"662\":2,\"664\":2,\"686\":1,\"720\":6,\"721\":5,\"723\":4,\"724\":11,\"725\":5,\"726\":10,\"731\":2,\"732\":1,\"735\":1}}],[\"xxx\",{\"1\":{\"34\":2}}],[\"xor\",{\"1\":{\"399\":1}}],[\"x∪y\",{\"1\":{\"219\":1}}],[\"xa\",{\"1\":{\"122\":1}}],[\"xmn256m\",{\"1\":{\"720\":1}}],[\"xmn<young\",{\"1\":{\"720\":1}}],[\"xmx5g\",{\"1\":{\"719\":1}}],[\"xmx<heap\",{\"1\":{\"719\":1}}],[\"xmx\",{\"0\":{\"719\":1}}],[\"xms2g\",{\"1\":{\"719\":1}}],[\"xms<heap\",{\"1\":{\"719\":1}}],[\"xms\",{\"0\":{\"719\":1}}],[\"xmpp\",{\"1\":{\"80\":1}}],[\"xml\",{\"1\":{\"30\":2,\"32\":2}}],[\"x\",{\"1\":{\"52\":3,\"219\":5,\"239\":1,\"240\":1,\"285\":3}}],[\"而在请求高峰期会产生很多新生代对象\",{\"1\":{\"735\":1}}],[\"而在处理io的时候不会占用cpu资源\",{\"1\":{\"609\":1}}],[\"而符号引用则属于编译原理方面的概念\",{\"1\":{\"693\":1}}],[\"而cms的卡表比较简单\",{\"1\":{\"687\":1}}],[\"而g1通过衰减均值来建立可预测的停顿模型\",{\"1\":{\"685\":1}}],[\"而老年代中对象存活的久\",{\"1\":{\"676\":1}}],[\"而并不是和对象一样不使用了就会必然被回收\",{\"1\":{\"672\":1}}],[\"而要判定一个类是否是\",{\"1\":{\"672\":1}}],[\"而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息\",{\"1\":{\"657\":1}}],[\"而本地方法栈则为虚拟机使用到的\",{\"1\":{\"642\":1}}],[\"而每个栈帧中都拥有\",{\"1\":{\"641\":1}}],[\"而每一个栈帧就对应着一个java方法\",{\"1\":{\"559\":1}}],[\"而threadlocalmap存储以threadlocal为key\",{\"1\":{\"599\":1}}],[\"而tcc则是在应用层面处理\",{\"1\":{\"124\":1}}],[\"而wait\",{\"1\":{\"566\":1}}],[\"而main函数所在的线程称为主线程\",{\"1\":{\"555\":1}}],[\"而消费者线程会从队列中取出数据进行处理\",{\"1\":{\"540\":1,\"631\":1}}],[\"而消息头则由一系列的可选属性组成\",{\"1\":{\"83\":1}}],[\"而linkedlist\",{\"1\":{\"538\":1}}],[\"而动态代理是在运行时产生class文件\",{\"1\":{\"517\":1}}],[\"而包装类型通过equals\",{\"1\":{\"470\":1}}],[\"而包装类型属于对象类型\",{\"1\":{\"470\":1}}],[\"而基本类型有默认值并且不是null\",{\"1\":{\"470\":1}}],[\"而基本类型不可以\",{\"1\":{\"470\":1}}],[\"而applicationcontext继承了beanfactory\",{\"1\":{\"452\":1}}],[\"而初始化就是调用afterpropertiesset\",{\"1\":{\"439\":1}}],[\"而这个实例就是放入单例池中\",{\"1\":{\"436\":1}}],[\"而这个routingkey需要与交换器类型和绑定键bindingkey联合使用才能生效\",{\"1\":{\"84\":1}}],[\"而semaphore\",{\"1\":{\"624\":1}}],[\"而synchronized只能是非公平锁\",{\"1\":{\"594\":1}}],[\"而springaop是采用动态代理的方式实现aop\",{\"1\":{\"449\":1}}],[\"而spring中的单例bean也是一种单例模式\",{\"1\":{\"435\":1}}],[\"而string类型是两个参数\",{\"1\":{\"390\":1}}],[\"而redis\",{\"1\":{\"413\":1}}],[\"而无需重新获得锁\",{\"1\":{\"377\":1}}],[\"而无需依赖\",{\"1\":{\"210\":1}}],[\"而删除缓存失败的话\",{\"1\":{\"360\":1}}],[\"而pipeline需要服务端和客户端共同实现\",{\"1\":{\"333\":1}}],[\"而覆盖搜因就是要查询出的列和索引是对应的\",{\"1\":{\"269\":1}}],[\"而其余的索引都成为辅助索引\",{\"1\":{\"262\":1}}],[\"而b+树的范围查询\",{\"1\":{\"262\":1}}],[\"而b+树任何查找都是根节点到叶子节点的过程\",{\"1\":{\"262\":1}}],[\"而b+树只有叶子节点存放key和data\",{\"1\":{\"262\":1}}],[\"而索引一般在内存中\",{\"1\":{\"243\":1}}],[\"而innodb支持\",{\"1\":{\"228\":2}}],[\"而innodb支持行级锁和表级锁\",{\"1\":{\"228\":1}}],[\"而不需要像\",{\"1\":{\"261\":1}}],[\"而不需要等待对方确认\",{\"1\":{\"204\":1}}],[\"而不涉及到表的定义\",{\"1\":{\"222\":1}}],[\"而不断重发\",{\"1\":{\"197\":1}}],[\"而不是基于线程的同步\",{\"1\":{\"726\":1}}],[\"而不是像waiting一样一直等待\",{\"1\":{\"561\":1}}],[\"而不是为了查询效率\",{\"1\":{\"264\":1}}],[\"而不是范围\",{\"1\":{\"238\":1}}],[\"而不是gbn中的当前帧和后续的所有帧\",{\"1\":{\"205\":1}}],[\"而不是接收\",{\"1\":{\"172\":1,\"191\":1}}],[\"而不是skuid\",{\"1\":{\"162\":1}}],[\"而不是每个消费者都收到所有的消息并处理\",{\"1\":{\"85\":1}}],[\"而不是服务器中\",{\"1\":{\"65\":1}}],[\"而服务器却将整个对象送过来了\",{\"1\":{\"181\":1}}],[\"而\",{\"1\":{\"174\":1,\"175\":1,\"181\":1,\"188\":2,\"190\":1,\"213\":1,\"214\":1,\"299\":3,\"303\":1,\"304\":1,\"380\":1,\"416\":1,\"538\":1,\"590\":1,\"594\":1,\"600\":2,\"697\":1}}],[\"而且\",{\"1\":{\"689\":1}}],[\"而且还能防止反序列化重新创建新的对象\",{\"1\":{\"525\":1}}],[\"而且还指明了如何\",{\"1\":{\"182\":1}}],[\"而且聚簇索引的叶子节点还存放着数据\",{\"1\":{\"266\":1}}],[\"而且在数据传递时\",{\"1\":{\"188\":1}}],[\"而且没有任何已知的转发地址\",{\"1\":{\"181\":1}}],[\"而且实际测试\",{\"1\":{\"175\":1}}],[\"而且可以在多个设备之间同步邮件状态\",{\"1\":{\"172\":1,\"191\":1}}],[\"而且分布式可以任意扩展\",{\"1\":{\"79\":1}}],[\"而流量错峰可以使用验证码机制或者是添加购物车让大量请求不在同一个时间点到达\",{\"1\":{\"164\":1}}],[\"而4层代理是写在stream模块中\",{\"1\":{\"139\":1}}],[\"而普通的虚拟机则是一个完整而庞大的系统\",{\"1\":{\"104\":1}}],[\"而是把请求委派给父类加载器去完成\",{\"1\":{\"714\":1,\"716\":1}}],[\"而是把连续的java堆划分为多个大小相等的独立区域\",{\"1\":{\"684\":1}}],[\"而是通常使用组合关系来复用父加载器的代码\",{\"1\":{\"713\":1}}],[\"而是通过一定的概率统计方法预估基数值\",{\"1\":{\"401\":1}}],[\"而是通过\",{\"1\":{\"243\":1}}],[\"而是根据需要去动态加载\",{\"1\":{\"710\":1}}],[\"而是根据发送的消息内容中的headers属性进行匹配\",{\"1\":{\"91\":1}}],[\"而是处于\",{\"1\":{\"669\":1}}],[\"而是对原有数据进行一次复制\",{\"1\":{\"629\":1}}],[\"而是采用忙循环\",{\"1\":{\"615\":1}}],[\"而是会按照延迟的时间长短对任务进行排序\",{\"1\":{\"607\":1}}],[\"而是会等待\",{\"1\":{\"605\":1}}],[\"而是会去读取行的一个快照\",{\"1\":{\"241\":1}}],[\"而是等待下一个任务\",{\"1\":{\"602\":1}}],[\"而是等待一段时间之后才会消费消息\",{\"1\":{\"94\":1}}],[\"而是每次循环都创建一个stringbuilder\",{\"1\":{\"496\":1}}],[\"而是每次获取的时候才会创建\",{\"1\":{\"453\":1}}],[\"而是自己处理了\",{\"1\":{\"448\":1}}],[\"而是自己编写了\",{\"1\":{\"311\":1}}],[\"而是在前一个节点比如\",{\"1\":{\"379\":1}}],[\"而是改为异步批量的方式来更新\",{\"1\":{\"304\":1}}],[\"而是数据对应的地址\",{\"1\":{\"267\":1}}],[\"而是大致的平衡\",{\"1\":{\"261\":1}}],[\"而是直接设置为ssthresh阈值的一半\",{\"1\":{\"201\":1}}],[\"而是使用一种称为\",{\"1\":{\"172\":1,\"191\":1}}],[\"而相对应的队列逻辑只是topic实际存储文件中的位移标识\",{\"1\":{\"85\":1}}],[\"而nginx和后端server一般处于同一个机房或者区域\",{\"1\":{\"57\":1}}],[\"而非物理分页\",{\"1\":{\"34\":1}}],[\"而进程只能在一个时间干一件事\",{\"1\":{\"6\":1}}],[\"使的它变的非常重量级\",{\"1\":{\"80\":1}}],[\"使得上面的结构可以保持键值对的插入顺序\",{\"1\":{\"530\":1}}],[\"使得对springboot的扩展的变得很容易\",{\"1\":{\"462\":1}}],[\"使得新的\",{\"1\":{\"414\":1}}],[\"使得集合中的元素能够按\",{\"1\":{\"395\":1}}],[\"使得树始终平衡\",{\"1\":{\"261\":1}}],[\"使得外部网络无法直接访问内部网络中的设备\",{\"1\":{\"211\":1}}],[\"使得请求不会超过服务器能接受的最大压力\",{\"1\":{\"165\":1}}],[\"使得来自同一个主域名的不同请求分发到对应的微服务\",{\"1\":{\"136\":1}}],[\"使得在部分节点出现问题的情况下队\",{\"1\":{\"81\":1}}],[\"使得在部分节点出现问题的情况下队列仍然可用\",{\"1\":{\"78\":1}}],[\"使得用户可以监控和管理消息\",{\"1\":{\"78\":1,\"81\":1}}],[\"使得多个进程可以访问同一块内存空间\",{\"1\":{\"9\":1}}],[\"使用双亲委派通过启动类加载器bootstrapclassloader发现这个类已经加载了\",{\"1\":{\"715\":1}}],[\"使用这两个调用就要先使用findstaticvarhandle来初始化要调用的类\",{\"1\":{\"706\":1}}],[\"使用这些命令就会使用主线程之外的其他线程来异步处理\",{\"1\":{\"322\":1}}],[\"使用java\",{\"1\":{\"706\":1}}],[\"使用jjwt生成jwt\",{\"1\":{\"150\":1}}],[\"使用多个\",{\"1\":{\"684\":1}}],[\"使用多线程和\",{\"1\":{\"682\":1}}],[\"使用软引用的情况较多\",{\"1\":{\"670\":1}}],[\"使用空闲列表的gc收集器\",{\"1\":{\"650\":1}}],[\"使用指针碰撞分配方式的gc收集器\",{\"1\":{\"650\":1}}],[\"使用链表作为其数据结构\",{\"1\":{\"630\":1}}],[\"使用链表实现\",{\"1\":{\"627\":1}}],[\"使用跳表的数据结构进行快速查找\",{\"1\":{\"627\":1}}],[\"使用await\",{\"1\":{\"626\":1}}],[\"使用完毕后\",{\"1\":{\"625\":1}}],[\"使用线程池的好处\",{\"1\":{\"603\":1}}],[\"使用volatile关键字可以禁止指令进行重排序优化\",{\"1\":{\"577\":1}}],[\"使用二叉堆实现结构\",{\"1\":{\"539\":1}}],[\"使用键值对存储\",{\"1\":{\"529\":1}}],[\"使用动态代理类调用方法的时候\",{\"1\":{\"514\":1}}],[\"使用代理对象来代替真实对象的访问\",{\"1\":{\"511\":1}}],[\"使用final修饰则看成常量\",{\"1\":{\"499\":1}}],[\"使用bigdecimal类进行浮点数运算\",{\"1\":{\"474\":1}}],[\"使用bgrewriteaof可以手动让aof文件执行重写功能\",{\"1\":{\"414\":1}}],[\"使用到\",{\"1\":{\"459\":1}}],[\"使用到了适配器模式\",{\"1\":{\"437\":1}}],[\"使用工厂模式通过\",{\"1\":{\"437\":1}}],[\"使用分片集群解决海量存储问题和高并发写问题\",{\"1\":{\"429\":1}}],[\"使用分片集群\",{\"0\":{\"429\":1}}],[\"使用分布式锁可以解决缓存击穿问题\",{\"1\":{\"164\":1}}],[\"使用场景\",{\"1\":{\"416\":1}}],[\"使用顺序节点之后\",{\"1\":{\"380\":1}}],[\"使用起来非常简单\",{\"1\":{\"376\":1}}],[\"使用布隆过滤器中的哈希函数对元素值进行计算\",{\"1\":{\"353\":1}}],[\"使用info\",{\"1\":{\"349\":1}}],[\"使用innodb的数据库在异常崩溃之后\",{\"1\":{\"228\":1}}],[\"使用monitor命令\",{\"1\":{\"342\":1}}],[\"使用前提是redis\",{\"1\":{\"342\":1}}],[\"使用批量操作可以减少网络传输次数\",{\"1\":{\"331\":1}}],[\"使用批量操作减少网络传输\",{\"0\":{\"331\":1}}],[\"使用单线程的多路\",{\"1\":{\"299\":1}}],[\"使用索引的建议\",{\"0\":{\"273\":1}}],[\"使用索引可以大大加快数据的检索速度\",{\"1\":{\"256\":1}}],[\"使用联合索引时存在最左匹配原则\",{\"1\":{\"271\":1}}],[\"使用表中的多个字段创建搜因\",{\"1\":{\"270\":1}}],[\"使用表中的多个字段创建索引\",{\"1\":{\"270\":1}}],[\"使用普通索引作为查询条件\",{\"1\":{\"243\":1}}],[\"使用的都是非聚簇索引\",{\"1\":{\"267\":1}}],[\"使用的流量控制协议是可变大小的滑动窗口协议\",{\"1\":{\"199\":1}}],[\"使用的第一个重要协议\",{\"1\":{\"184\":1}}],[\"使用put请求时\",{\"1\":{\"176\":1}}],[\"使用proxy\",{\"1\":{\"58\":1}}],[\"使用固定的跳数作为度量标准\",{\"1\":{\"174\":1}}],[\"使用redis\",{\"1\":{\"343\":1}}],[\"使用redis自带的\",{\"1\":{\"338\":1,\"342\":1}}],[\"使用rabbitmq的死信队列实现\",{\"1\":{\"156\":1}}],[\"使用rowbounds对象进行分页\",{\"1\":{\"34\":1}}],[\"使用setnx进行占位\",{\"1\":{\"158\":1}}],[\"使用sync=true\",{\"1\":{\"153\":1}}],[\"使用springsecurity框架实现\",{\"1\":{\"146\":1}}],[\"使用springcloud\",{\"1\":{\"137\":1}}],[\"使用同步锁控制只能有一个线程去数据库中查询数据并更新缓存\",{\"1\":{\"153\":1}}],[\"使用\",{\"0\":{\"191\":2,\"313\":1,\"315\":1,\"316\":1,\"317\":1},\"1\":{\"151\":1,\"176\":1,\"180\":1,\"242\":1,\"282\":1,\"292\":1,\"311\":1,\"317\":1,\"380\":1,\"405\":1,\"416\":1,\"448\":1,\"463\":1,\"622\":1,\"624\":1,\"700\":1}}],[\"使用安装包就能通过一个命令运行应用\",{\"1\":{\"105\":1}}],[\"使用信道的方式来传输数据\",{\"1\":{\"97\":1}}],[\"使用消息队列会带来哪些问题\",{\"0\":{\"73\":1}}],[\"使用重写后的路径\",{\"1\":{\"66\":2}}],[\"使用轮训或者最小连接会让每一个客户端的请求分发到不同的服务器上\",{\"1\":{\"60\":1}}],[\"从局部上来看是基于\",{\"1\":{\"684\":1}}],[\"从整体来看是基于\",{\"1\":{\"684\":1}}],[\"从这些节点开始向下搜索\",{\"1\":{\"667\":1}}],[\"从内存分布图中可以看出永久代是\",{\"1\":{\"645\":1}}],[\"从内存中读取数据\",{\"1\":{\"579\":1}}],[\"从方法调用到执行完成的过程\",{\"1\":{\"559\":1}}],[\"从jvm层面来说\",{\"1\":{\"512\":1}}],[\"从来不使用事务\",{\"1\":{\"447\":1}}],[\"从大小和开销两方面而言spring是轻量级的\",{\"1\":{\"434\":1}}],[\"从大到小排序\",{\"1\":{\"313\":1,\"396\":1,\"397\":2}}],[\"从链式结构\",{\"1\":{\"422\":1}}],[\"从磁盘中读取快照文件\",{\"1\":{\"408\":1}}],[\"从高到底\",{\"1\":{\"396\":1}}],[\"从低到高\",{\"1\":{\"396\":1}}],[\"从节点用来读\",{\"1\":{\"418\":1}}],[\"从节点处理读请求\",{\"1\":{\"343\":1}}],[\"从节点读\",{\"1\":{\"245\":1}}],[\"从已设置过期时间的数据集中挑选最不经常使用的数据淘汰\",{\"1\":{\"342\":1}}],[\"从已设置过期时间的数据集\",{\"1\":{\"328\":4}}],[\"从小到大排序\",{\"1\":{\"313\":1,\"397\":2}}],[\"从中读取数据并将数据写入其中\",{\"1\":{\"303\":1}}],[\"从\",{\"0\":{\"557\":1},\"1\":{\"302\":2,\"303\":1,\"422\":1,\"721\":1}}],[\"从cache中读取数据\",{\"1\":{\"302\":1}}],[\"从根节点到叶节点或空子节点的每一条路径\",{\"1\":{\"261\":1}}],[\"从库的\",{\"1\":{\"248\":2}}],[\"从库中的\",{\"1\":{\"248\":1}}],[\"从库会创建一个\",{\"1\":{\"248\":1}}],[\"从库连接主库\",{\"1\":{\"248\":1}}],[\"从上往下一次执行\",{\"1\":{\"243\":1}}],[\"从而方法才能被调用\",{\"1\":{\"705\":1}}],[\"从而执行相应的同步调用\",{\"1\":{\"589\":1}}],[\"从而避免了线程安全问题\",{\"1\":{\"598\":1}}],[\"从而避免synchronized的高开销\",{\"1\":{\"581\":1}}],[\"从而避免子类破坏string的不变性\",{\"1\":{\"495\":1}}],[\"从而形成一个环形链表\",{\"1\":{\"549\":1}}],[\"从而向spring容器中去添加各种spring\",{\"1\":{\"462\":1}}],[\"从而得到解析\",{\"1\":{\"461\":1}}],[\"从而让applicationcontext具有beanfactory不具备的功能\",{\"1\":{\"452\":1}}],[\"从而判断\",{\"1\":{\"415\":1}}],[\"从而导致\",{\"1\":{\"607\":1}}],[\"从而导致客户端阻塞\",{\"1\":{\"362\":1}}],[\"从而导致数据库崩溃\",{\"1\":{\"341\":1}}],[\"从而有效减少网络开销\",{\"1\":{\"331\":1}}],[\"从而减少内存的使用\",{\"1\":{\"311\":1}}],[\"从而减轻了应用程序的职责\",{\"1\":{\"303\":1}}],[\"从而在\",{\"1\":{\"291\":1}}],[\"从而实现局域网内的多个设备通过单一公有\",{\"1\":{\"211\":1}}],[\"从而实现了设备间的通信\",{\"1\":{\"209\":1}}],[\"从而提高了内部网络的安全性\",{\"1\":{\"211\":1}}],[\"从而提升了网络的可靠性和性能\",{\"1\":{\"210\":1}}],[\"从而提取参数\",{\"1\":{\"175\":1}}],[\"从而支持虚拟主机的功能\",{\"1\":{\"181\":1}}],[\"从而对\",{\"1\":{\"180\":1}}],[\"从输入\",{\"0\":{\"178\":1}}],[\"从传输的角度来说\",{\"1\":{\"175\":1}}],[\"从mq\",{\"1\":{\"129\":1}}],[\"从数据集\",{\"1\":{\"328\":1}}],[\"从数据库也要返回结果\",{\"1\":{\"114\":1}}],[\"从数据库不允许出现响应超时或者错误\",{\"1\":{\"114\":1}}],[\"从数据库接收到数据查询的请求则能立即响应数据查询结果\",{\"1\":{\"114\":1}}],[\"从数据查询的时候就进行分页\",{\"1\":{\"34\":1}}],[\"从计算机术语层面来说\",{\"1\":{\"82\":1}}],[\"从请求处理的时效性来看\",{\"1\":{\"75\":1}}],[\"从架构上来看\",{\"1\":{\"75\":1}}],[\"从通信方式来看\",{\"1\":{\"75\":1}}],[\"从用途来看\",{\"1\":{\"75\":1}}],[\"从应用程序的视角来看的话\",{\"1\":{\"18\":1}}],[\"逻辑分页\",{\"1\":{\"34\":1}}],[\"分代收集\",{\"1\":{\"684\":1}}],[\"分代收集算法\",{\"0\":{\"676\":1}}],[\"分代年龄等信息\",{\"1\":{\"652\":1}}],[\"分配内存\",{\"0\":{\"650\":1}}],[\"分配好内存\",{\"1\":{\"311\":1}}],[\"分段锁的设计\",{\"1\":{\"551\":1}}],[\"分段锁来保证安全\",{\"1\":{\"551\":1}}],[\"分段的segment\",{\"1\":{\"550\":2}}],[\"分段分页\",{\"0\":{\"13\":1}}],[\"分为\",{\"1\":{\"380\":1}}],[\"分布锁直接失效\",{\"1\":{\"375\":1}}],[\"分布式id分库之后\",{\"1\":{\"254\":1}}],[\"分布式下的用户登录状态保持\",{\"0\":{\"147\":1}}],[\"分布式锁是基于\",{\"1\":{\"379\":1}}],[\"分布式锁服务就是正常的\",{\"1\":{\"378\":1}}],[\"分布式锁实现\",{\"1\":{\"374\":1}}],[\"分布式锁\",{\"0\":{\"372\":1},\"1\":{\"137\":1,\"306\":2,\"309\":1,\"385\":1}}],[\"分布式系统出现故障时\",{\"1\":{\"120\":1}}],[\"分布式系统分区容错性的特点\",{\"1\":{\"115\":1}}],[\"分布式系统部署在不同的子网\",{\"1\":{\"115\":1}}],[\"分布式系统可用性特点\",{\"1\":{\"114\":1}}],[\"分布式系统一致性的特点\",{\"1\":{\"113\":1}}],[\"分布式基础理论\",{\"0\":{\"111\":1}}],[\"分布式事务解决方案\",{\"0\":{\"121\":1}}],[\"分布式事务\",{\"0\":{\"110\":1}}],[\"分布式事务的解决办法之一就是mq事务\",{\"1\":{\"72\":1}}],[\"分片算法主要解决了数据被水平分片之后\",{\"1\":{\"253\":1}}],[\"分表\",{\"1\":{\"251\":1}}],[\"分库就是将数据库中的数据分散到不同的数据库上\",{\"1\":{\"250\":1}}],[\"分库分表会带来什么问题呢\",{\"0\":{\"254\":1}}],[\"分库分表\",{\"0\":{\"249\":1}}],[\"分析explain结果\",{\"1\":{\"243\":1}}],[\"分析sql语句操作\",{\"1\":{\"226\":1}}],[\"分析器\",{\"1\":{\"226\":1}}],[\"分析请求到每个模块的运行耗时\",{\"1\":{\"137\":1}}],[\"分钟\",{\"1\":{\"214\":1}}],[\"分开发送是部分浏览器或框架的请求方法\",{\"1\":{\"175\":1}}],[\"分开发送\",{\"1\":{\"175\":1}}],[\"分割bigkey\",{\"1\":{\"339\":1}}],[\"分割\",{\"1\":{\"175\":1}}],[\"分类\",{\"1\":{\"172\":1,\"191\":1}}],[\"分别是list\",{\"1\":{\"528\":1}}],[\"分别是用来存放单一元素的collection和用来存放键值对的map接口\",{\"1\":{\"528\":1}}],[\"分别是hash的key\",{\"1\":{\"390\":1}}],[\"分别是\",{\"1\":{\"155\":1}}],[\"分别表示一致性\",{\"1\":{\"112\":1}}],[\"分微服务的原则是什么\",{\"0\":{\"144\":1}}],[\"分区容错性是分布式系统最基本的能力\",{\"1\":{\"115\":1}}],[\"分区容错性\",{\"1\":{\"112\":1}}],[\"分发\",{\"0\":{\"105\":1},\"1\":{\"104\":1,\"105\":1,\"457\":1}}],[\"分隔开的每一段独立的字符串称为一个单词\",{\"1\":{\"90\":1}}],[\"分隔的字符串\",{\"1\":{\"90\":2}}],[\"分得请求的概率越大\",{\"1\":{\"60\":1}}],[\"分页分为逻辑分页和物理分页两种\",{\"1\":{\"34\":1}}],[\"重点关注吞吐量\",{\"1\":{\"680\":1}}],[\"重试的次数默认是10次\",{\"1\":{\"615\":1}}],[\"重量级\",{\"1\":{\"618\":1}}],[\"重量级锁状态\",{\"1\":{\"614\":1}}],[\"重量级对象\",{\"1\":{\"32\":1}}],[\"重载\",{\"1\":{\"480\":1}}],[\"重载就是对同一个方法根据输入的不同作出不同的方法处理\",{\"1\":{\"480\":1}}],[\"重载和重写\",{\"0\":{\"480\":1}}],[\"重启加载\",{\"1\":{\"411\":1}}],[\"重启节点可以做到内存碎片重新整理\",{\"1\":{\"350\":1}}],[\"重启的时候可以再次加载进行使用\",{\"1\":{\"299\":1}}],[\"重启docker\",{\"1\":{\"109\":1}}],[\"重要\",{\"0\":{\"523\":1,\"524\":1},\"1\":{\"243\":3,\"519\":2,\"539\":1,\"550\":1}}],[\"重传等机制\",{\"1\":{\"188\":1}}],[\"重传\",{\"1\":{\"188\":1}}],[\"重复的库存释放消息只会执行一次\",{\"1\":{\"155\":1}}],[\"重新标记花的时间就少了\",{\"1\":{\"735\":1}}],[\"重新标记会扫描所有新生代对象\",{\"1\":{\"735\":1}}],[\"重新标记阶段会花费很长的时间\",{\"1\":{\"735\":1}}],[\"重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录\",{\"1\":{\"683\":1}}],[\"重新标记和清除\",{\"1\":{\"685\":1}}],[\"重新标记和并发清理\",{\"1\":{\"685\":1}}],[\"重新标记\",{\"1\":{\"683\":1}}],[\"重新安排语句执行顺序\",{\"1\":{\"571\":1}}],[\"重新赋值\",{\"1\":{\"487\":1}}],[\"重新搜索location\",{\"1\":{\"66\":1}}],[\"重新开始循环\",{\"1\":{\"16\":1}}],[\"重定向的地址如果写成localhost会造成重定向错误\",{\"1\":{\"65\":1}}],[\"重定向是客户端行为\",{\"1\":{\"65\":1}}],[\"重写loadclass方法\",{\"1\":{\"714\":1}}],[\"重写equals\",{\"1\":{\"492\":1}}],[\"重写了equals方法\",{\"1\":{\"490\":1}}],[\"重写发生在运行时\",{\"1\":{\"480\":1}}],[\"重写一般在子类继承父类\",{\"1\":{\"480\":1}}],[\"重写缓冲区\",{\"1\":{\"414\":1}}],[\"重写程序放到子进程里执行\",{\"1\":{\"414\":1}}],[\"重写会进行大量的写入操作\",{\"1\":{\"414\":1}}],[\"重写阻塞\",{\"1\":{\"364\":1}}],[\"重写confirm方法有3个参数\",{\"1\":{\"99\":1}}],[\"重写\",{\"0\":{\"64\":1,\"65\":1,\"66\":1},\"1\":{\"480\":1}}],[\"则占用的内存比基本数据类型大很多\",{\"1\":{\"729\":1}}],[\"则使用大页面内存\",{\"1\":{\"726\":1}}],[\"则使用空闲线程来处理\",{\"1\":{\"607\":1}}],[\"则当前进程的进程\",{\"1\":{\"725\":1}}],[\"则抛出异常\",{\"1\":{\"714\":1}}],[\"则调用findclass方法来加载该类\",{\"1\":{\"714\":1}}],[\"则调用启动类加载器来加载该类\",{\"1\":{\"714\":1}}],[\"则调用channel\",{\"1\":{\"101\":1}}],[\"则说明该类没有被加载过\",{\"1\":{\"714\":1}}],[\"则说明有其他的客户端已经成功获取锁\",{\"1\":{\"379\":1}}],[\"则引用目标必定在虚拟机的内存中\",{\"1\":{\"705\":1}}],[\"则引入了更多的缓存控制策略例如\",{\"1\":{\"181\":1}}],[\"则采用的是原始快照\",{\"1\":{\"687\":1}}],[\"则和没有任何引用一样\",{\"1\":{\"670\":1}}],[\"则证明此对象是不可用的\",{\"1\":{\"667\":1}}],[\"则虚拟机会先查看\",{\"1\":{\"664\":1}}],[\"则虚拟机会把加锁的范围扩展\",{\"1\":{\"617\":1}}],[\"则获取令牌成功\",{\"1\":{\"624\":1}}],[\"则获取锁成功\",{\"1\":{\"379\":1}}],[\"则持有偏向锁的线程将永远不需要再进行同步\",{\"1\":{\"619\":1}}],[\"则以后在获取锁失败之后很可能会省略自旋的过程\",{\"1\":{\"615\":1}}],[\"则新的任务会被暂存在一个任务队列中\",{\"1\":{\"604\":1}}],[\"则立即执行\",{\"1\":{\"604\":1}}],[\"则第三个线程采用cas进行修改的时候发现预期值a正确\",{\"1\":{\"584\":1}}],[\"则对这个变量读写的时候会添加上特定的读写屏障保证可见性\",{\"1\":{\"579\":1}}],[\"则对象不一定相等\",{\"1\":{\"492\":1}}],[\"则这种情况属于永久代内存不足导致fullgc\",{\"1\":{\"736\":1}}],[\"则这两个类不同\",{\"1\":{\"714\":1}}],[\"则这两个操作就没有顺序保障\",{\"1\":{\"576\":1}}],[\"则这个key就可以看做是hotkey\",{\"1\":{\"340\":1}}],[\"则a\",{\"1\":{\"576\":1}}],[\"则目标类和代理类都要修改\",{\"1\":{\"517\":1}}],[\"则不会在编译期间确定结果\",{\"1\":{\"499\":1}}],[\"则返回引用\",{\"1\":{\"498\":1}}],[\"则执行的是子类中的方法\",{\"1\":{\"486\":1}}],[\"则可能通过标量替换来实现栈\",{\"1\":{\"470\":1}}],[\"则可以看成常量\",{\"1\":{\"704\":1}}],[\"则可以通过继承复用减少开发难度\",{\"1\":{\"486\":1}}],[\"则可以通过\",{\"1\":{\"289\":1}}],[\"则可以通过正向代理将请求代理转发给a进行外网访问\",{\"1\":{\"142\":1}}],[\"则可以将b直接断路\",{\"1\":{\"165\":1}}],[\"则可以作为key\",{\"1\":{\"147\":1}}],[\"则可以使用一个数据库\",{\"1\":{\"119\":1}}],[\"则可以使用相同的id\",{\"1\":{\"31\":1}}],[\"则通过父类的loadclass来加载该类\",{\"1\":{\"714\":1}}],[\"则通过链表来实现\",{\"1\":{\"538\":1}}],[\"则通过equals比较两个对象的时候等价于==\",{\"1\":{\"490\":1}}],[\"则通过cglib来生成当前类的一个代理对象\",{\"1\":{\"449\":1}}],[\"则通过数据行的\",{\"1\":{\"286\":1}}],[\"则4个实例中有2个是master\",{\"1\":{\"429\":1}}],[\"则判断slave节点的offset\",{\"1\":{\"426\":1}}],[\"则该实例客观下线\",{\"1\":{\"425\":1}}],[\"则该线程可以直接执行调用的方法即可重入\",{\"1\":{\"377\":1}}],[\"则认为没有逃逸\",{\"1\":{\"644\":1}}],[\"则认为此次的自旋也有较大概率获得锁\",{\"1\":{\"615\":1}}],[\"则认为变量没有被修改\",{\"1\":{\"584\":1}}],[\"则认为实例下线\",{\"1\":{\"425\":1}}],[\"则认为前面需要的数据在接收端都受到了\",{\"1\":{\"204\":1}}],[\"则无法基于repl\",{\"1\":{\"421\":1}}],[\"则重写\",{\"1\":{\"414\":1}}],[\"则隔一段时间进行重试\",{\"1\":{\"360\":1}}],[\"则就算删除缓存失败\",{\"1\":{\"360\":1}}],[\"则元素肯定不在布隆过滤器中\",{\"1\":{\"353\":1}}],[\"则有可能不存在于redis中\",{\"1\":{\"353\":1}}],[\"则先扩展至所需大小再进行修改操作\",{\"1\":{\"311\":1}}],[\"则先更新\",{\"1\":{\"303\":1}}],[\"则是通过调用线程来运行的\",{\"1\":{\"568\":1}}],[\"则是object类的本地方法\",{\"1\":{\"566\":1}}],[\"则是比较两个对象内部的属性是否相等\",{\"1\":{\"490\":1}}],[\"则是只更新缓存\",{\"1\":{\"304\":1}}],[\"则是\",{\"1\":{\"303\":1}}],[\"则为空\",{\"1\":{\"287\":1}}],[\"则表示许可证数量不足\",{\"1\":{\"624\":1}}],[\"则表示可以获取成功\",{\"1\":{\"624\":1}}],[\"则表示锁可以被获取\",{\"1\":{\"589\":1}}],[\"则表示一个master对应一个slave\",{\"1\":{\"429\":1}}],[\"则表示该记录可见\",{\"1\":{\"284\":1}}],[\"则表示未用到索引\",{\"1\":{\"243\":1}}],[\"则选择该字段为默认的主键\",{\"1\":{\"263\":1}}],[\"则需要先初始化父类\",{\"1\":{\"706\":1}}],[\"则需要先进行初始化\",{\"1\":{\"706\":1}}],[\"则需要先取出主键的值\",{\"1\":{\"262\":1}}],[\"则需要一套线程阻塞等待以及被唤醒分配的机制\",{\"1\":{\"622\":1}}],[\"则需要依次执行每个写命令\",{\"1\":{\"416\":1}}],[\"则需要重新登录并将用户数据保存至redis\",{\"1\":{\"149\":1}}],[\"则它的子节点必须是黑色\",{\"1\":{\"261\":1}}],[\"则\",{\"1\":{\"243\":1,\"288\":1}}],[\"则称为覆盖索引\",{\"1\":{\"269\":1}}],[\"则称\",{\"1\":{\"219\":1}}],[\"则y对x部分函数依赖\",{\"1\":{\"219\":1}}],[\"则将当前请求资源的线程设置为有效的工作线程\",{\"1\":{\"622\":1}}],[\"则将该事务挂起\",{\"1\":{\"447\":1}}],[\"则将此确认帧还有之后已经发送的序号全部重发\",{\"1\":{\"204\":1}}],[\"则将其中的一部分保存至磁盘的临时文件中\",{\"1\":{\"57\":1}}],[\"则直接进行解析\",{\"1\":{\"184\":1}}],[\"则用客户端提交的新版本替换原有的资源\",{\"1\":{\"176\":1}}],[\"则支付宝会进行异步回调\",{\"1\":{\"155\":1}}],[\"则数据会丢失\",{\"1\":{\"146\":1}}],[\"则过一段时间之后支付宝会再次发送通知\",{\"1\":{\"131\":1}}],[\"则mq\",{\"1\":{\"129\":1}}],[\"则向从数据库查询新数据也失败\",{\"1\":{\"113\":1}}],[\"则向从数据库查询新数据也成功\",{\"1\":{\"113\":1}}],[\"则在请求头引入了\",{\"1\":{\"181\":1}}],[\"则在业务处理成功后\",{\"1\":{\"101\":1}}],[\"则在客户端从代理服务器接收响应时\",{\"1\":{\"57\":1}}],[\"则自动确认收到\",{\"1\":{\"101\":1}}],[\"则会直接返回\",{\"1\":{\"715\":1}}],[\"则会丢弃该任务\",{\"1\":{\"606\":1}}],[\"则会创建新的线程处理任务\",{\"1\":{\"604\":1}}],[\"则会创建一个新的资源\",{\"1\":{\"176\":1}}],[\"则会优先使用可复用的线程\",{\"1\":{\"604\":1}}],[\"则会浪费内存\",{\"1\":{\"521\":1}}],[\"则会在堆中创建1个字符串对象\",{\"1\":{\"497\":1}}],[\"则会在堆中创建2个字符串对象\",{\"1\":{\"497\":1}}],[\"则会排除该slave节点\",{\"1\":{\"426\":1}}],[\"则会覆盖之前的数据\",{\"1\":{\"421\":1}}],[\"则会拷贝一份数据\",{\"1\":{\"409\":1}}],[\"则会导致锁提前释放\",{\"1\":{\"375\":1}}],[\"则会对读取的记录使用\",{\"1\":{\"285\":1}}],[\"则会使用\",{\"1\":{\"284\":1}}],[\"则会将节点的data值拿出\",{\"1\":{\"262\":1}}],[\"则会将响应临时写入磁盘中\",{\"1\":{\"57\":1}}],[\"则会向mq\",{\"1\":{\"129\":1}}],[\"则会去调用本地事务\",{\"1\":{\"129\":1}}],[\"则会执行returnmessage方法\",{\"1\":{\"100\":1}}],[\"则路由键必须有三个单词\",{\"1\":{\"90\":1}}],[\"则所有以com结尾的路由键消息都会匹配\",{\"1\":{\"90\":1}}],[\"则所有以\",{\"1\":{\"53\":1}}],[\"则相关软连接被称为死链接\",{\"1\":{\"15\":1}}],[\"所需要的内存大小在类加载完成之后就能确定\",{\"1\":{\"650\":1}}],[\"所储存的字符串值的长度\",{\"1\":{\"384\":1}}],[\"所谓可重入锁指的是在一个线程中可以多次获取同一把锁\",{\"1\":{\"377\":1}}],[\"所不具备的\",{\"1\":{\"334\":2}}],[\"所使用\",{\"1\":{\"222\":1}}],[\"所有\",{\"1\":{\"695\":1}}],[\"所有被同步锁持有的对象\",{\"1\":{\"668\":1}}],[\"所有线程在当前任务执行完毕后\",{\"1\":{\"604\":1}}],[\"所有线程创建的对象实例都放在主内存中\",{\"1\":{\"573\":1}}],[\"所有的new操作的内存分配非常廉价\",{\"1\":{\"730\":1}}],[\"所有的\",{\"1\":{\"695\":1}}],[\"所有的写命令会追加到aof缓冲区中\",{\"1\":{\"411\":1}}],[\"所有的事务依次逐个执行\",{\"1\":{\"282\":1}}],[\"所有尝试获取锁的客户端都会对持有锁的子节点加监听器\",{\"1\":{\"380\":1}}],[\"所有值的顺序从最优到最差排序为system\",{\"1\":{\"243\":1}}],[\"所有传输的内容都经过加密\",{\"1\":{\"180\":1}}],[\"所有传输的内容都是明文\",{\"1\":{\"180\":1}}],[\"所有节点的数据都会达到一致性\",{\"1\":{\"120\":1}}],[\"所有请求都有响应\",{\"1\":{\"114\":1}}],[\"所以同时也解决了并发问题\",{\"1\":{\"730\":1}}],[\"所以能使用基本数据类型的情况下不要使用包装类型\",{\"1\":{\"729\":1}}],[\"所以拿到的结果是\",{\"1\":{\"711\":1}}],[\"所以父类索引只有一个\",{\"1\":{\"695\":1}}],[\"所以降低了内存碎片的产生数量\",{\"1\":{\"685\":1}}],[\"所以这个算法里会跟踪记录这些发生引用更新的地方\",{\"1\":{\"683\":1}}],[\"所以选择\",{\"1\":{\"676\":1}}],[\"所以最多只能创建核心线程数的线程\",{\"1\":{\"607\":1}}],[\"所以定义在thread类中\",{\"1\":{\"567\":1}}],[\"所以程序计数器的作用就是线程切换之后能恢复到正确的位置\",{\"1\":{\"558\":1}}],[\"所以线程之间的切换开销远远小于进程\",{\"1\":{\"556\":1}}],[\"所以是线程不安全的\",{\"1\":{\"494\":1}}],[\"所以所有的对象都有这个方法\",{\"1\":{\"491\":1}}],[\"所以java也是编译与解释共存的语言\",{\"1\":{\"467\":1}}],[\"所以spring\",{\"1\":{\"462\":1}}],[\"所以applicationcontext拥有beanfactory的所有特点\",{\"1\":{\"452\":1}}],[\"所以a字段在where中的顺序并不重要\",{\"1\":{\"271\":1}}],[\"所以存在老版本的\",{\"1\":{\"416\":1}}],[\"所以存在非主属性系主任对于学号的传递函数依赖\",{\"1\":{\"219\":1,\"220\":1}}],[\"所以多个应用服务就可以同时获取到锁\",{\"1\":{\"378\":1}}],[\"所以即使使用了\",{\"1\":{\"334\":1}}],[\"所以一般说redis是单线程模型\",{\"1\":{\"320\":1}}],[\"所以一般反向代理都会设置以下header信息\",{\"1\":{\"52\":1}}],[\"所以我们可以考虑把数据库中的部分数据转移到缓存中去\",{\"1\":{\"300\":1}}],[\"所以速度相当快\",{\"1\":{\"300\":1}}],[\"所以导致不可重复读\",{\"1\":{\"291\":1}}],[\"所以对于这个查询ab都用到了联合索引进行查询\",{\"1\":{\"271\":1}}],[\"所以对于并发写入操作来说\",{\"1\":{\"237\":1}}],[\"所以在jvm生命周期内\",{\"1\":{\"707\":1}}],[\"所以在访问资源的时候采取加锁的方案\",{\"1\":{\"582\":1}}],[\"所以在生成\",{\"1\":{\"292\":1}}],[\"所以在执行查询的时候\",{\"1\":{\"271\":1}}],[\"所以在传输上\",{\"1\":{\"175\":1}}],[\"所以符合a>1条件的二级索引记录是肯定相邻的\",{\"1\":{\"271\":1}}],[\"所以mysql没有使用其作为索引的数据结构\",{\"1\":{\"258\":1}}],[\"所以需要意向锁来快速判断是否可以对某个表使用表锁\",{\"1\":{\"240\":1}}],[\"所以该表的设计\",{\"1\":{\"220\":1}}],[\"所以姓名完全函数依赖与\",{\"1\":{\"219\":1}}],[\"所以姓名部分函数依赖与\",{\"1\":{\"219\":1}}],[\"所以说\",{\"1\":{\"180\":1}}],[\"所以\",{\"1\":{\"175\":1,\"188\":1,\"285\":1,\"398\":1,\"590\":1,\"600\":1,\"683\":1,\"689\":1}}],[\"所以使用lua脚本实现\",{\"1\":{\"155\":1}}],[\"所以没有解决缓存击穿问题\",{\"1\":{\"153\":1}}],[\"所以channel之间是完全隔离的\",{\"1\":{\"97\":1}}],[\"所以rabbitmq\",{\"1\":{\"97\":1}}],[\"所以fanout类型是所有的交换器类型里面速度最快的\",{\"1\":{\"88\":1}}],[\"所以可以采用\",{\"1\":{\"676\":1}}],[\"所以可以将交换器理解成一个由绑定构成的路由表\",{\"1\":{\"84\":1}}],[\"所以可以保证公共资源不会被多个线程同时访问\",{\"1\":{\"7\":1}}],[\"所以并发能力很强\",{\"1\":{\"79\":1}}],[\"所以消费消息时也是按照顺序来消费的\",{\"1\":{\"67\":1}}],[\"所代表的\",{\"1\":{\"30\":1}}],[\"=2\",{\"1\":{\"539\":1}}],[\"==和equals区别\",{\"0\":{\"490\":1}}],[\"==\",{\"1\":{\"155\":1,\"374\":1,\"376\":1,\"484\":3,\"498\":3,\"499\":1,\"522\":1,\"523\":2,\"546\":1,\"625\":2,\"714\":2}}],[\"=\",{\"0\":{\"497\":1},\"1\":{\"30\":2,\"34\":1,\"53\":1,\"54\":1,\"62\":1,\"93\":1,\"146\":4,\"150\":2,\"153\":3,\"155\":3,\"158\":1,\"159\":1,\"165\":2,\"271\":1,\"376\":3,\"430\":3,\"436\":3,\"439\":1,\"444\":1,\"448\":1,\"458\":3,\"472\":3,\"476\":2,\"484\":3,\"486\":1,\"497\":2,\"498\":4,\"499\":11,\"501\":1,\"503\":2,\"505\":1,\"507\":2,\"509\":4,\"510\":1,\"520\":1,\"521\":1,\"522\":1,\"523\":1,\"524\":1,\"532\":1,\"539\":11,\"546\":1,\"575\":3,\"599\":5,\"613\":5,\"624\":1,\"704\":1,\"714\":7,\"729\":1}}],[\">验证\",{\"1\":{\"700\":1}}],[\">解析\",{\"1\":{\"700\":2}}],[\">准备\",{\"1\":{\"700\":2}}],[\">连接\",{\"1\":{\"700\":1}}],[\">survivor\",{\"1\":{\"662\":1}}],[\">>>\",{\"1\":{\"546\":2}}],[\">>\",{\"1\":{\"532\":1}}],[\">bean对象\",{\"1\":{\"442\":1}}],[\">放入map单例池\",{\"1\":{\"442\":1}}],[\">初始化后\",{\"1\":{\"442\":1}}],[\">初始化\",{\"1\":{\"442\":1,\"700\":2}}],[\">初始化前\",{\"1\":{\"442\":1}}],[\">依赖注入\",{\"1\":{\"442\":1}}],[\">admin\",{\"1\":{\"439\":1,\"442\":1}}],[\">user对象\",{\"1\":{\"439\":1,\"442\":1}}],[\">管理员的信息\",{\"1\":{\"439\":1,\"442\":1}}],[\">对象\",{\"1\":{\"439\":1,\"442\":1}}],[\">无参构造方法\",{\"1\":{\"439\":1,\"442\":1}}],[\">请求\",{\"1\":{\"302\":1}}],[\">=\",{\"1\":{\"271\":1,\"539\":2,\"624\":1}}],[\">y\",{\"1\":{\"219\":3}}],[\">客户端请求关闭连接\",{\"1\":{\"195\":1}}],[\">客户端\",{\"1\":{\"195\":1}}],[\">服务端并且进入time\",{\"1\":{\"195\":1}}],[\">服务端\",{\"1\":{\"195\":1}}],[\">queue\",{\"1\":{\"100\":1}}],[\">exchange\",{\"1\":{\"99\":1}}],[\">\",{\"1\":{\"30\":2,\"33\":3,\"34\":1,\"193\":3,\"219\":6,\"243\":11,\"302\":3,\"316\":7,\"374\":3,\"459\":1,\"514\":1,\"613\":4,\"712\":1,\"714\":1,\"725\":2}}],[\">用户空间\",{\"1\":{\"22\":1}}],[\"标准差\",{\"1\":{\"685\":1}}],[\"标准误差为\",{\"1\":{\"401\":1}}],[\"标准的\",{\"1\":{\"282\":1}}],[\"标示这个锁有一个\",{\"1\":{\"375\":1}}],[\"标头中添加不同的扩展头\",{\"1\":{\"210\":1}}],[\"标头结构相较于\",{\"1\":{\"210\":1}}],[\"标志的数据包后进入\",{\"1\":{\"195\":1}}],[\"标志的数据包\",{\"1\":{\"193\":3,\"195\":5}}],[\"标记复制算法\",{\"1\":{\"730\":1}}],[\"标记一下gc\",{\"1\":{\"684\":1}}],[\"标记清除后会产生大量不连续的内存碎片\",{\"1\":{\"674\":1}}],[\"标记和清除两个过程效率都不高\",{\"1\":{\"674\":1}}],[\"标记自己为master\",{\"1\":{\"431\":1}}],[\"标记\",{\"0\":{\"674\":1},\"1\":{\"172\":1,\"191\":1,\"674\":2,\"676\":3,\"682\":1,\"683\":2,\"684\":3,\"725\":1}}],[\"标签内的\",{\"1\":{\"32\":1}}],[\"标签均会被解析为\",{\"1\":{\"32\":1}}],[\"标签会被解析为\",{\"1\":{\"32\":2}}],[\"标签\",{\"1\":{\"30\":1}}],[\"标识\",{\"1\":{\"589\":1}}],[\"标识进程的重要程度\",{\"1\":{\"8\":1}}],[\"标识符等等\",{\"1\":{\"8\":1}}],[\"<pid>\",{\"1\":{\"725\":1}}],[\"<parametermap>\",{\"1\":{\"32\":1}}],[\"<clinit>\",{\"1\":{\"706\":1}}],[\"<version>3\",{\"1\":{\"515\":1}}],[\"<artifactid>cglib<\",{\"1\":{\"515\":1}}],[\"<groupid>cglib<\",{\"1\":{\"515\":1}}],[\"<dependency>\",{\"1\":{\"515\":1}}],[\"<delete>\",{\"1\":{\"30\":1,\"32\":1}}],[\"<master\",{\"1\":{\"418\":1,\"427\":1}}],[\"<result\",{\"1\":{\"33\":2}}],[\"<resultmap\",{\"1\":{\"33\":1}}],[\"<resultmap>\",{\"1\":{\"32\":1}}],[\"<\",{\"1\":{\"30\":3,\"33\":1,\"515\":1,\"539\":3,\"725\":2}}],[\"<init>\",{\"1\":{\"653\":1}}],[\"<insert>\",{\"1\":{\"30\":1,\"32\":1}}],[\"<ip\",{\"1\":{\"214\":1,\"429\":4}}],[\"<if\",{\"1\":{\"30\":1}}],[\"<where>\",{\"1\":{\"30\":1}}],[\"<select\",{\"1\":{\"30\":1}}],[\"<select>\",{\"1\":{\"30\":1,\"32\":1}}],[\"<update>\",{\"1\":{\"30\":1,\"32\":1}}],[\"每当一个类加载器接收到加载请求的时候\",{\"1\":{\"714\":1}}],[\"每当一个线程到了栅栏这里了\",{\"1\":{\"626\":1}}],[\"每当java发布大版本的时候\",{\"1\":{\"692\":1}}],[\"每上面一层链表都是下面一层的子集\",{\"1\":{\"635\":1}}],[\"每一次方法调用都会有一个对应的栈帧被压入栈中\",{\"1\":{\"641\":1}}],[\"每一把锁锁住一个segment\",{\"1\":{\"550\":1}}],[\"每一个java类都有一个引用指向加载它的classloader\",{\"1\":{\"709\":1}}],[\"每一个region都可以根据需要扮演eden空间\",{\"1\":{\"684\":1}}],[\"每一个方法调用结束后\",{\"1\":{\"641\":1}}],[\"每一个object都有对象锁\",{\"1\":{\"567\":1}}],[\"每一个线程都有一个tlab\",{\"1\":{\"650\":1}}],[\"每一个线程都需要一个程序计数器\",{\"1\":{\"640\":1}}],[\"每一个线程拥有自己的虚拟机栈\",{\"1\":{\"557\":1}}],[\"每一个线程有自己的程序计数器\",{\"1\":{\"556\":1}}],[\"每一个线程共享进程的堆和方法区\",{\"1\":{\"556\":1}}],[\"每一个master都可以有多个slave节点\",{\"1\":{\"429\":1}}],[\"每一个master都有唯一的replid\",{\"1\":{\"420\":1}}],[\"每一个master保存不同的数据\",{\"1\":{\"429\":1}}],[\"每一个微服务都对自己所属的数据库架构有完全控制权\",{\"1\":{\"144\":1}}],[\"每一个微服务需要做的业务清晰明了\",{\"1\":{\"144\":1}}],[\"每一个执行器都是在sqlsession执行的生命周期内拿到的\",{\"1\":{\"35\":1}}],[\"每一个\",{\"1\":{\"30\":1,\"32\":1}}],[\"每秒向集群内的每一个实例发送ping命令\",{\"1\":{\"425\":1}}],[\"每秒的并发数\",{\"1\":{\"165\":1}}],[\"每月访问\",{\"1\":{\"403\":1}}],[\"每周\",{\"1\":{\"403\":1}}],[\"每过\",{\"1\":{\"376\":1}}],[\"每隔一段时间抽取一批key执行删除过期key操作\",{\"1\":{\"327\":1}}],[\"每行记录可能存在多个历史版本\",{\"1\":{\"241\":1}}],[\"每经过一个传播轮次\",{\"1\":{\"201\":1}}],[\"每次根据允许的收集时间\",{\"1\":{\"684\":1}}],[\"每次收集都有大量对象死去\",{\"1\":{\"676\":1}}],[\"每次使用其中的一块\",{\"1\":{\"675\":1}}],[\"每次使用它都到主存中进行读取\",{\"1\":{\"578\":1}}],[\"每次扩容变为原来的两倍\",{\"1\":{\"543\":1}}],[\"每次对string类型进行修改的时候\",{\"1\":{\"494\":1}}],[\"每次session才会创建实例\",{\"1\":{\"451\":1}}],[\"每次select\",{\"1\":{\"290\":1}}],[\"每次都需要重新分配内存\",{\"1\":{\"311\":1}}],[\"每次读取的都是最新数据\",{\"1\":{\"285\":1}}],[\"每次磁盘io只能读取一个节点的数据\",{\"1\":{\"260\":1}}],[\"每次查询后都要做一次缓存操作\",{\"1\":{\"229\":1}}],[\"每次请求都会被拦截\",{\"1\":{\"147\":1}}],[\"每次请求都会拦截\",{\"1\":{\"146\":1}}],[\"每次从队列中获取的消息数量\",{\"1\":{\"103\":1}}],[\"每次执行操作都会开启一个新的statement对象\",{\"1\":{\"35\":1}}],[\"每个文件上限大小\",{\"1\":{\"724\":1}}],[\"每个thread中都具备一个threadlocalmap\",{\"1\":{\"599\":1}}],[\"每个线程都有私有的本地内存来存储共享变量的副本\",{\"1\":{\"573\":1}}],[\"每个数据节点在\",{\"1\":{\"380\":1}}],[\"每个事务读到的数据版本可能是不一样的\",{\"1\":{\"286\":1}}],[\"每个叶子节点都是黑色的空节点\",{\"1\":{\"261\":1}}],[\"每个节点不是红色就是黑色\",{\"1\":{\"261\":1}}],[\"每个树节点仅存储一个数据\",{\"1\":{\"260\":1}}],[\"每个库可以位于不同的数据库上\",{\"1\":{\"250\":1}}],[\"每个网络设备都自己维护了一个\",{\"1\":{\"214\":1}}],[\"每个连入互联网的设备或域都被分配一个ip地址\",{\"1\":{\"209\":1}}],[\"每个\",{\"1\":{\"185\":1,\"691\":1,\"711\":1,\"713\":1}}],[\"每个微服务应该对其所使用的数据有完全的控制权\",{\"1\":{\"144\":1}}],[\"每个微服务应该只负责一个特定的业务功能\",{\"1\":{\"144\":1}}],[\"每个软件在docker中的运行环境都是独立的\",{\"1\":{\"107\":1}}],[\"每个用户在自己的vhost创建exchange\",{\"1\":{\"97\":1}}],[\"每个信道对应一个线程使用\",{\"1\":{\"97\":1}}],[\"每个信道在rabbitmq都有唯一的\",{\"1\":{\"97\":1}}],[\"每个进程都对应着一个独立的\",{\"1\":{\"8\":1}}],[\"值减少为单个全局\",{\"1\":{\"726\":1}}],[\"值为\",{\"1\":{\"624\":1,\"625\":1,\"626\":1}}],[\"值为随机生成的uuid\",{\"1\":{\"155\":1}}],[\"值是实参的地址\",{\"1\":{\"503\":1}}],[\"值是否相等\",{\"1\":{\"374\":1}}],[\"值传递\",{\"0\":{\"502\":1},\"1\":{\"502\":1}}],[\"值进行\",{\"1\":{\"396\":1}}],[\"值不存在的时候才能\",{\"1\":{\"375\":1}}],[\"值的字段\",{\"1\":{\"263\":1}}],[\"值\",{\"1\":{\"30\":1,\"390\":2,\"396\":1,\"634\":1}}],[\"值得是计算机中正在运行的程序实例\",{\"1\":{\"5\":1}}],[\"都需要获取到锁才能进行操作\",{\"1\":{\"632\":1}}],[\"都继承自abstractmap\",{\"1\":{\"544\":1}}],[\"都能保证元素唯一\",{\"1\":{\"536\":1}}],[\"都可以优先考虑\",{\"1\":{\"682\":1}}],[\"都可以有默认的实现方法\",{\"1\":{\"487\":1}}],[\"都可以包含抽象方法\",{\"1\":{\"487\":1}}],[\"都不能被实例化\",{\"1\":{\"487\":1}}],[\"都支持封装继承多态\",{\"1\":{\"468\":1}}],[\"都属于可重入锁\",{\"1\":{\"377\":1}}],[\"都在同一个\",{\"1\":{\"334\":1}}],[\"都有过期策略\",{\"1\":{\"299\":1}}],[\"都有一个自己的本地\",{\"1\":{\"185\":1}}],[\"都是通过创建底层数组的新副本来实现的\",{\"1\":{\"629\":1}}],[\"都是一次只允许一个线程访问某个资源\",{\"1\":{\"624\":1}}],[\"都是\",{\"1\":{\"536\":1}}],[\"都是基于内存的数据库\",{\"1\":{\"299\":1}}],[\"都是这种机制\",{\"1\":{\"7\":1}}],[\"都通过\",{\"1\":{\"291\":1}}],[\"都会有一个栈帧被弹出\",{\"1\":{\"641\":1}}],[\"都会新生成一个string类型\",{\"1\":{\"494\":1}}],[\"都会被解析为一个\",{\"1\":{\"30\":1}}],[\"都会写一个\",{\"1\":{\"30\":1}}],[\"相连的对象\",{\"1\":{\"683\":1}}],[\"相同二进制名称的类只会被加载一次\",{\"1\":{\"710\":1}}],[\"相同则直接覆盖\",{\"1\":{\"546\":1}}],[\"相同情况下使用stringbuilder会带来一点性能提升\",{\"1\":{\"494\":1}}],[\"相当大时\",{\"1\":{\"345\":2,\"362\":2}}],[\"相当于v操作\",{\"1\":{\"624\":1}}],[\"相当于p操作\",{\"1\":{\"624\":1}}],[\"相当于注解\",{\"1\":{\"461\":1}}],[\"相当于添加了\",{\"1\":{\"461\":1}}],[\"相当于定位到了数据\",{\"1\":{\"266\":1}}],[\"相当于线程池里的核心线程数\",{\"1\":{\"63\":1}}],[\"相当于\",{\"1\":{\"29\":1}}],[\"相比起来具有更高的吞吐量\",{\"1\":{\"633\":1}}],[\"相比\",{\"1\":{\"395\":1,\"416\":1}}],[\"相比较于\",{\"1\":{\"385\":1}}],[\"相比于\",{\"1\":{\"311\":1,\"383\":1}}],[\"相比于非聚簇索引\",{\"1\":{\"266\":1}}],[\"相比于同步阻塞io模型\",{\"1\":{\"22\":1}}],[\"相比普通索引建立的数据更小\",{\"1\":{\"264\":1}}],[\"相比myisam\",{\"1\":{\"228\":1}}],[\"相较于\",{\"1\":{\"210\":1}}],[\"相关的方法\",{\"1\":{\"724\":1}}],[\"相关的问题\",{\"1\":{\"724\":1}}],[\"相关的一些\",{\"1\":{\"313\":1}}],[\"相关命令\",{\"1\":{\"385\":2,\"388\":1,\"391\":1,\"394\":3,\"397\":2,\"400\":1,\"403\":1,\"406\":1}}],[\"相关信息\",{\"1\":{\"205\":1,\"238\":1,\"302\":1,\"496\":1}}],[\"相关配置信息\",{\"1\":{\"99\":1}}],[\"相对偏移量或者是一个能定位到目标的句柄\",{\"1\":{\"705\":1}}],[\"相对于\",{\"1\":{\"684\":1}}],[\"相对于静态代理\",{\"1\":{\"513\":1}}],[\"相对于其他消息的优先权\",{\"1\":{\"83\":1}}],[\"相对完整\",{\"1\":{\"416\":1}}],[\"相对来说\",{\"1\":{\"388\":1}}],[\"相对应\",{\"1\":{\"188\":1}}],[\"相反地\",{\"1\":{\"284\":1}}],[\"相反\",{\"1\":{\"85\":1}}],[\"属性表集合的限制稍微宽松一些\",{\"1\":{\"698\":1}}],[\"属性表集合\",{\"0\":{\"698\":1},\"1\":{\"698\":1}}],[\"属性表集合几项\",{\"1\":{\"697\":1}}],[\"属性的初始化值\",{\"1\":{\"626\":1}}],[\"属性填充\",{\"1\":{\"453\":1}}],[\"属性判断字符串是否结束\",{\"1\":{\"311\":1}}],[\"属性即可\",{\"1\":{\"311\":1}}],[\"属性检查空间大小是否满足要求\",{\"1\":{\"311\":1}}],[\"属性\",{\"1\":{\"218\":1}}],[\"属性名和字段名不一致如何解决\",{\"0\":{\"33\":1}}],[\"属性值\",{\"1\":{\"29\":1}}],[\"属于重量级锁\",{\"1\":{\"587\":1}}],[\"属于单个行记录上的锁\",{\"1\":{\"238\":1}}],[\"属于网络层的协议\",{\"1\":{\"174\":1,\"208\":1}}],[\"属于静态文本替换\",{\"1\":{\"29\":1}}],[\"属于同步阻塞\",{\"1\":{\"21\":1}}],[\"0111\",{\"1\":{\"548\":1}}],[\"000\",{\"1\":{\"548\":1}}],[\"0000\",{\"1\":{\"548\":19}}],[\"0<\",{\"1\":{\"515\":1}}],[\"0表示永远不会参加选举\",{\"1\":{\"426\":1}}],[\"0开始引入的\",{\"1\":{\"339\":1}}],[\"0以下可以考虑使用scan命令结合del命令来分批次删除\",{\"1\":{\"339\":1}}],[\"0+可以使用unlink命令来异步删除一个或者多个指定的key\",{\"1\":{\"339\":1}}],[\"0引入的\",{\"1\":{\"335\":1}}],[\"0引入多线程主要是为了提高网络io读写性能\",{\"1\":{\"323\":1}}],[\"0之后为何引入了多线程\",{\"0\":{\"323\":1}}],[\"0之后的版本中就已经加入了对多线程的支持\",{\"1\":{\"322\":1}}],[\"0之后引入了多线程来处理网络请求\",{\"1\":{\"319\":1}}],[\"0之前为什么不使用多线程\",{\"0\":{\"322\":1}}],[\"0版本之后引入了多线程来执行一些大键值对的异步删除操作\",{\"1\":{\"319\":1}}],[\"0版本之后缓存被移除\",{\"1\":{\"229\":1}}],[\"0版本后移除\",{\"1\":{\"226\":1}}],[\"0\",{\"0\":{\"181\":1},\"1\":{\"29\":1,\"34\":1,\"48\":2,\"65\":2,\"139\":4,\"155\":1,\"159\":1,\"181\":4,\"190\":5,\"299\":1,\"306\":4,\"311\":2,\"316\":4,\"326\":6,\"328\":1,\"342\":1,\"350\":1,\"374\":2,\"375\":2,\"376\":1,\"388\":1,\"398\":1,\"400\":1,\"401\":1,\"448\":1,\"471\":1,\"476\":1,\"503\":5,\"546\":1,\"589\":2,\"604\":1,\"624\":1,\"625\":4,\"626\":1,\"693\":2,\"695\":1}}],[\"按先入先出的顺序执行队列中的任务\",{\"1\":{\"604\":1}}],[\"按位异或\",{\"1\":{\"546\":1}}],[\"按特定的排队规则确定元素先后顺序\",{\"1\":{\"529\":1}}],[\"按照年龄从小到大对其所占用的大小进行累积\",{\"1\":{\"662\":1}}],[\"按照消费者组进行消费\",{\"1\":{\"306\":1}}],[\"按照特性的范围区间来分配数据\",{\"1\":{\"253\":1}}],[\"按照mysql认为最优的方案去执行\",{\"1\":{\"226\":1}}],[\"按照网上大部分文章的解释\",{\"1\":{\"175\":1}}],[\"按照请求到达磁盘调度器的顺序进行处理\",{\"1\":{\"16\":1}}],[\"按序给\",{\"1\":{\"29\":1}}],[\"执行效率太低\",{\"1\":{\"611\":1}}],[\"执行效率大为提升\",{\"1\":{\"581\":1}}],[\"执行的结果看子类hero1\",{\"1\":{\"486\":1}}],[\"执行结果看右边\",{\"1\":{\"486\":1}}],[\"执行结果返回\",{\"1\":{\"30\":1}}],[\"执行启动器\",{\"1\":{\"463\":1}}],[\"执行自动配置\",{\"1\":{\"463\":1}}],[\"执行三级缓存中的lambda表达式返回aservice普通对象或者代理对象\",{\"1\":{\"450\":1}}],[\"执行数据库操作\",{\"1\":{\"446\":1}}],[\"执行cluster\",{\"1\":{\"431\":1}}],[\"执行写操作后将数据写入aof缓冲区\",{\"1\":{\"412\":1}}],[\"执行写操作后\",{\"1\":{\"412\":2}}],[\"执行写操作\",{\"1\":{\"409\":1}}],[\"执行间隔很长\",{\"1\":{\"408\":1}}],[\"执行业务逻辑等\",{\"1\":{\"463\":1}}],[\"执行业务\",{\"1\":{\"376\":1}}],[\"执行耗时也会越长\",{\"1\":{\"362\":1}}],[\"执行命令仍然是单线程顺序执行\",{\"1\":{\"323\":1}}],[\"执行\",{\"0\":{\"653\":1},\"1\":{\"292\":1,\"653\":1}}],[\"执行普通\",{\"1\":{\"292\":1}}],[\"执行计划中的\",{\"1\":{\"243\":1}}],[\"执行计划是指一条\",{\"1\":{\"243\":1}}],[\"执行计划\",{\"0\":{\"243\":1},\"1\":{\"243\":1}}],[\"执行事物的前后\",{\"1\":{\"231\":1}}],[\"执行语句\",{\"1\":{\"226\":1}}],[\"执行器\",{\"1\":{\"226\":1}}],[\"执行查询语句的时候\",{\"1\":{\"226\":1,\"229\":1}}],[\"执行流程\",{\"1\":{\"152\":1,\"714\":1}}],[\"执行docker\",{\"1\":{\"109\":1}}],[\"执行了\",{\"1\":{\"100\":1}}],[\"执行余下的块内指令\",{\"1\":{\"66\":1}}],[\"执行前会使用\",{\"1\":{\"29\":1}}],[\"执行响应的系统调用\",{\"1\":{\"3\":1}}],[\"号占位符设置参数值\",{\"1\":{\"29\":1}}],[\"号\",{\"1\":{\"29\":1}}],[\"号的文件\",{\"1\":{\"15\":1}}],[\"替换为\",{\"1\":{\"29\":1}}],[\"dump\",{\"1\":{\"248\":1}}],[\"db\",{\"1\":{\"286\":2,\"287\":3,\"302\":6,\"303\":5,\"304\":6,\"328\":5}}],[\"dba\",{\"1\":{\"222\":1}}],[\"dbtype\",{\"1\":{\"34\":1}}],[\"ddl\",{\"0\":{\"222\":1},\"1\":{\"222\":2}}],[\"dml\",{\"0\":{\"222\":1},\"1\":{\"222\":3}}],[\"drop\",{\"0\":{\"221\":1},\"1\":{\"221\":2}}],[\"driver\",{\"1\":{\"29\":2}}],[\"dynamic\",{\"1\":{\"210\":1,\"311\":1,\"383\":1,\"458\":1}}],[\"dhcp\",{\"1\":{\"191\":1,\"210\":1}}],[\"dhe\",{\"1\":{\"62\":1}}],[\"dns是应用层协议\",{\"1\":{\"184\":1}}],[\"dns\",{\"0\":{\"183\":1,\"184\":1,\"185\":1},\"1\":{\"172\":1,\"178\":1,\"184\":2,\"185\":12,\"191\":2}}],[\"d\",{\"1\":{\"107\":1,\"108\":1,\"499\":2}}],[\"double\",{\"1\":{\"469\":1}}],[\"down\",{\"1\":{\"426\":1}}],[\"download\",{\"1\":{\"66\":4}}],[\"dog\",{\"1\":{\"376\":6}}],[\"domain\",{\"1\":{\"172\":1,\"184\":1,\"191\":1}}],[\"docker容器化部署\",{\"1\":{\"137\":1}}],[\"docker挂载目录\",{\"0\":{\"108\":1}}],[\"docker部署的优势\",{\"0\":{\"106\":1}}],[\"docker是一个应用打包\",{\"1\":{\"104\":1}}],[\"docker\",{\"0\":{\"104\":1,\"109\":1},\"1\":{\"107\":1,\"108\":1,\"109\":1,\"136\":1,\"137\":1}}],[\"deque\",{\"1\":{\"537\":1}}],[\"deque是双端队列\",{\"1\":{\"537\":1}}],[\"dependency>\",{\"1\":{\"515\":1}}],[\"debuginvocationhandler\",{\"1\":{\"507\":2}}],[\"desc\",{\"1\":{\"405\":1}}],[\"destkey\",{\"1\":{\"399\":1,\"402\":3}}],[\"destination\",{\"1\":{\"393\":6,\"396\":4}}],[\"desk2\",{\"1\":{\"316\":2}}],[\"desk1\",{\"1\":{\"316\":2}}],[\"decr\",{\"1\":{\"384\":1,\"385\":1}}],[\"derived\",{\"1\":{\"243\":2}}],[\"default\",{\"1\":{\"706\":1}}],[\"defaultredisscript<long>\",{\"1\":{\"155\":1}}],[\"defrag\",{\"1\":{\"350\":4}}],[\"definition\",{\"1\":{\"222\":1}}],[\"delegation\",{\"1\":{\"713\":1}}],[\"deleted\",{\"1\":{\"287\":1}}],[\"delete操作\",{\"1\":{\"241\":1}}],[\"delete\",{\"0\":{\"221\":1},\"1\":{\"221\":2,\"241\":1,\"284\":1,\"285\":2,\"287\":1,\"292\":1}}],[\"delayedworkqueue\",{\"1\":{\"607\":3}}],[\"delayedworkqueue延迟阻塞队列\",{\"1\":{\"604\":1}}],[\"del\",{\"1\":{\"155\":1,\"374\":3,\"384\":1}}],[\"delivery\",{\"1\":{\"83\":1}}],[\"dead\",{\"1\":{\"93\":2}}],[\"dlx\",{\"1\":{\"93\":1}}],[\"dirs\",{\"1\":{\"711\":1}}],[\"direct类型的exchange路由规则也很简单\",{\"1\":{\"89\":1}}],[\"direct\",{\"0\":{\"89\":1},\"1\":{\"84\":1}}],[\"discardoldestpolicy\",{\"1\":{\"606\":1}}],[\"discardpolicy\",{\"1\":{\"606\":1}}],[\"dispaterservlet\",{\"1\":{\"456\":1}}],[\"dispatcherservlet\",{\"1\":{\"456\":2,\"457\":1,\"458\":2}}],[\"dispatcherservlet拦截请求\",{\"1\":{\"456\":1}}],[\"dispatcherservlet结构如图\",{\"1\":{\"456\":1}}],[\"diskless\",{\"1\":{\"422\":1}}],[\"distance\",{\"1\":{\"405\":3}}],[\"dist\",{\"1\":{\"62\":1}}],[\"dict\",{\"1\":{\"328\":1}}],[\"dao接口的全路径名对应xml文件中的namespace\",{\"1\":{\"30\":1}}],[\"dao接口返回值类型对应\",{\"1\":{\"30\":1}}],[\"dao接口参数对应\",{\"1\":{\"30\":1}}],[\"dao接口方法名对应\",{\"1\":{\"30\":1}}],[\"dao\",{\"0\":{\"30\":2},\"1\":{\"30\":6,\"451\":1}}],[\"dangling\",{\"1\":{\"15\":1}}],[\"database\",{\"1\":{\"408\":1}}],[\"datagram\",{\"1\":{\"173\":1}}],[\"data\",{\"1\":{\"15\":1,\"58\":1,\"109\":1,\"222\":2,\"262\":1}}],[\"$表示结束\",{\"1\":{\"66\":1}}],[\"$2是截取前面括号中匹配的内容\",{\"1\":{\"66\":1}}],[\"$2\",{\"1\":{\"66\":2}}],[\"$1\",{\"1\":{\"66\":3}}],[\"$request\",{\"1\":{\"60\":1}}],[\"$remote\",{\"1\":{\"52\":2}}],[\"$host\",{\"1\":{\"52\":1}}],[\"$http\",{\"1\":{\"52\":2}}],[\"$proxy\",{\"1\":{\"52\":3}}],[\"$\",{\"0\":{\"29\":1},\"1\":{\"29\":1,\"66\":2}}],[\"和卸载\",{\"1\":{\"700\":1}}],[\"和第\",{\"1\":{\"692\":2}}],[\"和用户线程\",{\"1\":{\"683\":1}}],[\"和另外一边的边界划定一个对象内存大小的区域\",{\"1\":{\"650\":1}}],[\"和虚拟机栈所发挥的作用非常相似\",{\"1\":{\"642\":1}}],[\"和数据结构上的栈类似\",{\"1\":{\"641\":1}}],[\"和share\",{\"1\":{\"623\":1}}],[\"和start\",{\"0\":{\"568\":1}}],[\"和notify\",{\"1\":{\"594\":1}}],[\"和nio中的selector组件很像\",{\"1\":{\"321\":1}}],[\"和非公平锁\",{\"1\":{\"592\":1}}],[\"和hashmap\",{\"1\":{\"544\":1}}],[\"和面向切面\",{\"1\":{\"434\":1}}],[\"和专业的消息队列相比\",{\"1\":{\"388\":1}}],[\"和操作系统的内部碎片外部碎片相同意思\",{\"1\":{\"347\":1}}],[\"和间隙锁\",{\"1\":{\"282\":1}}],[\"和共享锁兼容\",{\"1\":{\"240\":1}}],[\"和usernamepasswordauthenticationfilter\",{\"1\":{\"146\":1}}],[\"和4层反向代理\",{\"1\":{\"139\":1}}],[\"和提交阶段\",{\"1\":{\"122\":1}}],[\"和eventually\",{\"1\":{\"120\":1}}],[\"和consumer\",{\"0\":{\"83\":1}}],[\"和\",{\"0\":{\"29\":1,\"181\":1,\"182\":1,\"196\":1,\"210\":1,\"228\":1,\"290\":1,\"299\":1,\"416\":1,\"468\":1,\"536\":1,\"543\":1,\"544\":1,\"550\":1,\"551\":1,\"590\":1,\"594\":1,\"612\":1,\"719\":1},\"1\":{\"90\":1,\"152\":1,\"175\":6,\"234\":1,\"243\":1,\"261\":1,\"284\":1,\"286\":1,\"290\":1,\"291\":1,\"303\":2,\"304\":3,\"306\":1,\"316\":1,\"345\":2,\"362\":2,\"377\":1,\"379\":1,\"387\":1,\"395\":1,\"396\":2,\"398\":1,\"399\":1,\"416\":2,\"498\":3,\"536\":1,\"550\":2,\"589\":2,\"592\":1,\"598\":1,\"607\":2,\"612\":1,\"624\":1,\"647\":1,\"650\":1,\"674\":1,\"679\":1,\"684\":1,\"726\":1}}],[\"和异步\",{\"1\":{\"19\":1}}],[\"框架的工具类\",{\"1\":{\"604\":1}}],[\"框架中也使用了动态代理\",{\"1\":{\"507\":1}}],[\"框架\",{\"0\":{\"27\":1,\"41\":1}}],[\"异步任务编排组合\",{\"1\":{\"613\":1}}],[\"异步缓存写入\",{\"0\":{\"304\":1}}],[\"异步io是基于事件和回调机制实现的\",{\"1\":{\"23\":1}}],[\"异常类型错误\",{\"1\":{\"448\":1}}],[\"异常不能被spring感知就不会执行rollback\",{\"1\":{\"448\":1}}],[\"异常代码\",{\"1\":{\"448\":1}}],[\"异常数进行服务熔断\",{\"1\":{\"165\":1}}],[\"异常比例\",{\"1\":{\"165\":1}}],[\"异常\",{\"1\":{\"3\":1,\"634\":1,\"721\":1}}],[\"7采用永久代\",{\"1\":{\"736\":1}}],[\"7采用拉链法\",{\"1\":{\"551\":1}}],[\"7开启了逃逸分析\",{\"1\":{\"644\":1}}],[\"7中最大的并发度是segment的个数\",{\"1\":{\"551\":1}}],[\"7的时候\",{\"1\":{\"550\":1}}],[\"7取消循环\",{\"1\":{\"534\":1}}],[\"7取消\",{\"1\":{\"530\":1}}],[\"7位无符号数的表示范围\",{\"1\":{\"471\":1}}],[\"7字节\",{\"1\":{\"287\":1}}],[\"7层代理可以\",{\"1\":{\"139\":1}}],[\"7层代理是写在http模块中的\",{\"1\":{\"139\":1}}],[\"7\",{\"0\":{\"551\":1},\"1\":{\"23\":1,\"448\":1,\"549\":1,\"550\":1,\"551\":1,\"647\":2,\"671\":2,\"692\":1,\"700\":1,\"704\":1,\"721\":1,\"726\":1,\"736\":1}}],[\"attribute\",{\"1\":{\"698\":1}}],[\"attributes\",{\"0\":{\"698\":1},\"1\":{\"698\":3}}],[\"atomicinteger类主要利用cas\",{\"1\":{\"581\":1}}],[\"atomic包下面的原子变量类\",{\"1\":{\"581\":1}}],[\"aton\",{\"1\":{\"242\":2}}],[\"awit\",{\"1\":{\"625\":1}}],[\"await\",{\"1\":{\"625\":7}}],[\"aqs资源共享方式\",{\"0\":{\"623\":1}}],[\"aqs的核心原理图如下\",{\"1\":{\"622\":1}}],[\"aqs的核心思想是如果被请求的共享资源空闲\",{\"1\":{\"622\":1}}],[\"aqs核心思想\",{\"0\":{\"622\":1}}],[\"aqs原理\",{\"0\":{\"621\":1}}],[\"aqs抽象队列同步器\",{\"0\":{\"620\":1}}],[\"aqs\",{\"1\":{\"592\":1,\"620\":3,\"622\":2,\"623\":1,\"624\":1,\"625\":1}}],[\"abstract\",{\"1\":{\"694\":1,\"713\":1}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"592\":1,\"620\":1}}],[\"abortpolicy\",{\"1\":{\"606\":1}}],[\"aba问题\",{\"0\":{\"584\":1}}],[\"ab\",{\"1\":{\"499\":1}}],[\"abc就会被追加到root目录之后\",{\"1\":{\"48\":1}}],[\"abc\",{\"0\":{\"497\":1},\"1\":{\"48\":3,\"278\":1,\"497\":7,\"501\":1,\"671\":3}}],[\"age\",{\"1\":{\"476\":1,\"662\":1}}],[\"aop表示面向切面编程\",{\"1\":{\"449\":1}}],[\"aop\",{\"1\":{\"434\":1,\"437\":2,\"442\":1,\"459\":1}}],[\"aof重写了解吗\",{\"0\":{\"414\":1}}],[\"aof记录日志不会对命令进行语法检查\",{\"1\":{\"413\":1}}],[\"aof为什么是在执行完命令之后记录日志\",{\"0\":{\"413\":1}}],[\"aof缓冲区根据对应的持久化方式向磁盘做同步操作\",{\"1\":{\"411\":1}}],[\"aof工作基本流程\",{\"0\":{\"411\":1}}],[\"aof持久化机制是在执行完命令之后再记录日志\",{\"1\":{\"413\":1}}],[\"aof持久化方式有哪些\",{\"0\":{\"412\":1}}],[\"aof持久化功能的实现可以简单分为5步\",{\"1\":{\"411\":1}}],[\"aof持久化的实时性更好\",{\"1\":{\"410\":1}}],[\"aof持久化\",{\"0\":{\"410\":1}}],[\"aof\",{\"0\":{\"364\":1,\"415\":1,\"416\":1},\"1\":{\"306\":1,\"324\":3,\"364\":3,\"414\":13,\"415\":6,\"416\":21}}],[\"afterpropertiesset\",{\"1\":{\"439\":1}}],[\"after\",{\"1\":{\"426\":1,\"449\":1,\"507\":1}}],[\"a>1\",{\"1\":{\"271\":1}}],[\"annotationconfigwebapplicationcontext\",{\"1\":{\"458\":2}}],[\"annotationconfigapplicationcontext\",{\"1\":{\"436\":2}}],[\"antirez\",{\"1\":{\"378\":1}}],[\"and\",{\"1\":{\"271\":6,\"316\":1,\"399\":1,\"581\":1,\"583\":1,\"674\":1}}],[\"anull\",{\"1\":{\"62\":1}}],[\"a=1\",{\"1\":{\"271\":3,\"448\":1}}],[\"avl\",{\"1\":{\"261\":2}}],[\"avl树需要频繁的进行旋转来保持平衡\",{\"1\":{\"260\":1}}],[\"avl树是自平衡的二叉查找树\",{\"1\":{\"260\":1}}],[\"avl树\",{\"0\":{\"260\":1}}],[\"available\",{\"1\":{\"120\":1}}],[\"availability可用性\",{\"0\":{\"114\":1}}],[\"availability\",{\"1\":{\"112\":1}}],[\"acquire\",{\"1\":{\"624\":4}}],[\"acc\",{\"1\":{\"589\":2}}],[\"access\",{\"0\":{\"694\":1},\"1\":{\"213\":1,\"694\":1}}],[\"active\",{\"1\":{\"350\":4}}],[\"activedefrag\",{\"1\":{\"350\":1}}],[\"acid\",{\"1\":{\"231\":1,\"282\":1}}],[\"acid特性\",{\"0\":{\"231\":1}}],[\"ack=y+1\",{\"1\":{\"193\":1,\"195\":2}}],[\"ack=x+1\",{\"1\":{\"193\":1,\"195\":1}}],[\"acknowledge=\",{\"1\":{\"101\":3}}],[\"ack指acknowledge\",{\"1\":{\"101\":1}}],[\"ack\",{\"0\":{\"101\":1,\"196\":1},\"1\":{\"99\":1,\"193\":1,\"195\":4,\"196\":1,\"197\":4,\"199\":1,\"306\":1}}],[\"a调用b\",{\"1\":{\"165\":1}}],[\"aservice普通对象注入一级缓存中的bservice完整对象\",{\"1\":{\"450\":1}}],[\"aservice和bservice相互依赖\",{\"1\":{\"450\":1}}],[\"aspectj就是其中的一种实现方式\",{\"1\":{\"449\":1}}],[\"ascii\",{\"1\":{\"726\":1}}],[\"asc\",{\"1\":{\"405\":1}}],[\"aside\",{\"0\":{\"302\":1},\"1\":{\"302\":1,\"303\":3,\"360\":2}}],[\"aslist\",{\"1\":{\"155\":1}}],[\"asynchronous\",{\"0\":{\"23\":1}}],[\"artifactid>\",{\"1\":{\"515\":1}}],[\"arrylist和vector区别\",{\"0\":{\"533\":1}}],[\"arrayblockingqueue\",{\"0\":{\"632\":1},\"1\":{\"632\":2,\"633\":1}}],[\"arraydeque\",{\"0\":{\"538\":1},\"1\":{\"538\":4}}],[\"arrayqueue\",{\"1\":{\"530\":1}}],[\"arraylist实现了randomaccess接口\",{\"1\":{\"534\":1}}],[\"arraylist底层使用object\",{\"1\":{\"534\":1}}],[\"arraylist是list的主要实现类\",{\"1\":{\"533\":1}}],[\"arraylist能插入null\",{\"1\":{\"532\":1}}],[\"arraylist支持插入\",{\"1\":{\"532\":1}}],[\"arraylist只能存储对象\",{\"1\":{\"532\":1}}],[\"arraylist会根据实际存储的元素动态扩容或者缩容\",{\"1\":{\"532\":1}}],[\"arraylist存储元素的特点是顺序\",{\"1\":{\"532\":1}}],[\"arraylist\",{\"0\":{\"534\":1},\"1\":{\"530\":1}}],[\"array为引用类型\",{\"1\":{\"503\":1}}],[\"array\",{\"1\":{\"503\":2}}],[\"arrays\",{\"1\":{\"155\":1}}],[\"arr\",{\"1\":{\"503\":4}}],[\"around等注解\",{\"1\":{\"449\":1}}],[\"args\",{\"1\":{\"436\":1,\"503\":1,\"507\":2,\"514\":2,\"515\":2,\"725\":3}}],[\"argv\",{\"1\":{\"155\":2,\"374\":1,\"376\":2}}],[\"arq\",{\"1\":{\"202\":1,\"203\":1,\"204\":1}}],[\"arq称为自动重传请求\",{\"1\":{\"202\":1}}],[\"arq协议\",{\"0\":{\"202\":1}}],[\"arp\",{\"0\":{\"212\":1,\"214\":1},\"1\":{\"174\":3,\"214\":4}}],[\"always\",{\"1\":{\"412\":1}}],[\"alg\",{\"1\":{\"150\":1}}],[\"allof\",{\"1\":{\"613\":1}}],[\"allkeys\",{\"1\":{\"328\":3,\"342\":1}}],[\"all\",{\"1\":{\"32\":1,\"243\":3}}],[\"appclassloader\",{\"1\":{\"707\":1,\"711\":1}}],[\"appconfig\",{\"1\":{\"436\":2,\"458\":1}}],[\"app\",{\"1\":{\"458\":2}}],[\"application\",{\"1\":{\"463\":1}}],[\"applicationeventpublisher等接口\",{\"1\":{\"452\":1}}],[\"applicationcontext和beanfactory有什么区别\",{\"0\":{\"452\":1}}],[\"applicationcontext\",{\"1\":{\"436\":3,\"437\":1}}],[\"appendfsync\",{\"1\":{\"412\":3}}],[\"appendonly开启\",{\"1\":{\"412\":1}}],[\"append\",{\"1\":{\"410\":1,\"411\":1}}],[\"app0000000002\",{\"1\":{\"380\":1}}],[\"app0000000001\",{\"1\":{\"380\":1}}],[\"appserver\",{\"1\":{\"139\":2}}],[\"apps\",{\"1\":{\"59\":2,\"60\":4,\"61\":1}}],[\"api\",{\"1\":{\"311\":1,\"383\":1,\"401\":1,\"594\":1}}],[\"ap\",{\"0\":{\"117\":1}}],[\"authenticate\",{\"1\":{\"146\":3}}],[\"authenticationmanager<<interface>>\",{\"1\":{\"146\":1}}],[\"authenticationmanager\",{\"1\":{\"146\":1}}],[\"authentication\",{\"1\":{\"146\":2}}],[\"authenticationtoken\",{\"1\":{\"146\":3}}],[\"autocommit=false\",{\"1\":{\"446\":1}}],[\"autoconfigurationimportselector\",{\"1\":{\"461\":1}}],[\"autoconfiguration\",{\"1\":{\"210\":1}}],[\"automatic\",{\"1\":{\"202\":1}}],[\"autowired只能根据类型注入的\",{\"1\":{\"444\":1}}],[\"autowired注解默认使用的构造方法\",{\"1\":{\"443\":1}}],[\"autowired\",{\"1\":{\"146\":1,\"444\":1}}],[\"auto\",{\"1\":{\"101\":1,\"414\":2,\"463\":1}}],[\"audio\",{\"1\":{\"66\":1}}],[\"admin\",{\"1\":{\"439\":1,\"442\":1}}],[\"advice\",{\"1\":{\"437\":1}}],[\"advanced\",{\"1\":{\"78\":1,\"80\":1}}],[\"addelapsedtimefrom\",{\"1\":{\"714\":1}}],[\"addtime\",{\"1\":{\"714\":1}}],[\"addlast\",{\"1\":{\"537\":1}}],[\"addfirst\",{\"1\":{\"537\":1}}],[\"addmapping\",{\"1\":{\"458\":1}}],[\"addservlet\",{\"1\":{\"458\":1}}],[\"add\",{\"1\":{\"52\":1,\"537\":1,\"629\":1}}],[\"address\",{\"1\":{\"174\":2,\"210\":2,\"211\":1,\"213\":1,\"214\":1}}],[\"addr\",{\"1\":{\"52\":2}}],[\"addinnerinterceptor\",{\"1\":{\"34\":1}}],[\"amqp天然具有跨平台\",{\"1\":{\"74\":1}}],[\"amqp\",{\"1\":{\"74\":1,\"80\":1,\"97\":1}}],[\"amqp是什么\",{\"0\":{\"74\":1}}],[\"aes128\",{\"1\":{\"62\":1}}],[\"a\",{\"0\":{\"114\":1},\"1\":{\"54\":2,\"271\":4,\"302\":6,\"442\":1,\"480\":2,\"484\":3,\"499\":3}}],[\"aio\",{\"0\":{\"23\":1},\"1\":{\"23\":1}}],[\"概念\",{\"1\":{\"22\":1}}],[\"还要看类的加载器是否相同\",{\"1\":{\"714\":1}}],[\"还要实现invocationhandler接口\",{\"1\":{\"514\":1}}],[\"还具备高吞吐量性能特征\",{\"1\":{\"684\":1}}],[\"还具有很好的可移植性\",{\"1\":{\"467\":1}}],[\"还提供了函数式编程\",{\"1\":{\"613\":1}}],[\"还规定了java源代码到cpu可执行指令这个转化过程要遵循哪些和并发相关的原则和规范\",{\"1\":{\"572\":1}}],[\"还能建立可预测的停顿时间模型\",{\"1\":{\"684\":1}}],[\"还能调用这些方法和属性\",{\"1\":{\"506\":1}}],[\"还能做什么\",{\"0\":{\"306\":1}}],[\"还会维护一个\",{\"1\":{\"414\":1}}],[\"还会对性能造成很大的影响\",{\"1\":{\"337\":1}}],[\"还有一个是筛选回收\",{\"1\":{\"687\":1}}],[\"还有一些时间复杂度可能在\",{\"1\":{\"362\":1}}],[\"还有用于存放各种字面量和符号引用的常量池表\",{\"1\":{\"646\":1}}],[\"还有部分在o\",{\"1\":{\"345\":1}}],[\"还需要根据主键去聚簇索引中去查找对应行的数据\",{\"1\":{\"267\":1}}],[\"还可以通过\",{\"1\":{\"395\":1,\"720\":1}}],[\"还可以再次获取锁\",{\"1\":{\"372\":1}}],[\"还可以隐藏内部网络的实际拓扑结构\",{\"1\":{\"211\":1}}],[\"还可以方便的实现多线程优先级的比较操作\",{\"1\":{\"7\":1}}],[\"还支持如果队列已满\",{\"1\":{\"540\":1,\"631\":1}}],[\"还支持事务\",{\"1\":{\"297\":1}}],[\"还支持行级锁\",{\"1\":{\"237\":1}}],[\"还支持stomp\",{\"1\":{\"81\":1}}],[\"还支持\",{\"1\":{\"78\":1,\"376\":1}}],[\"还是跨代引用的问题\",{\"1\":{\"684\":1}}],[\"还是有很多欠缺的地方比如消息丢失和堆积问题不好解决\",{\"1\":{\"388\":1}}],[\"还是\",{\"0\":{\"190\":1,\"310\":1,\"312\":1,\"496\":1},\"1\":{\"175\":1}}],[\"还是会导致同一个ip请求转发到其他的服务器\",{\"1\":{\"60\":1}}],[\"还是阻塞的\",{\"1\":{\"22\":1}}],[\"应该在\",{\"1\":{\"725\":1}}],[\"应该设置库存释放的死信队列\",{\"1\":{\"155\":1}}],[\"应该尽量保持服务的粒度足够小\",{\"1\":{\"144\":1}}],[\"应用上下文\",{\"1\":{\"463\":1}}],[\"应用场景\",{\"0\":{\"385\":1,\"388\":1,\"391\":1,\"394\":1,\"397\":1,\"400\":1,\"403\":1,\"406\":1}}],[\"应用\",{\"0\":{\"305\":1},\"1\":{\"463\":1}}],[\"应用的并发量太大\",{\"1\":{\"252\":1}}],[\"应用数据被分割成\",{\"1\":{\"199\":1}}],[\"应用于内部网到外部网的地址转换过程中\",{\"1\":{\"174\":1}}],[\"应用层\",{\"0\":{\"172\":1},\"1\":{\"139\":1}}],[\"应用程序类加载器\",{\"1\":{\"711\":1}}],[\"应用程序不断进行i\",{\"1\":{\"22\":1}}],[\"应用程序会一直发起read调用\",{\"1\":{\"22\":1}}],[\"应用程序发起read调用后\",{\"1\":{\"21\":1}}],[\"应使用nio\",{\"1\":{\"22\":1}}],[\"基数计数概率算法为了节省内存并不会直接存储元数据\",{\"1\":{\"401\":1}}],[\"基数统计\",{\"1\":{\"308\":1}}],[\"基础\",{\"0\":{\"296\":1}}],[\"基础上实现的\",{\"1\":{\"80\":1}}],[\"基本上\",{\"1\":{\"683\":1}}],[\"基本上解决了数据冗余过大\",{\"1\":{\"220\":1}}],[\"基本类型和包装类型\",{\"0\":{\"470\":1}}],[\"基本数据类型使用==进行比较\",{\"1\":{\"470\":1}}],[\"基本数据类型的成员变量没有被static修饰的话放在堆中\",{\"1\":{\"470\":1}}],[\"基本数据类型的局部变量存放在java虚拟机栈中的局部变量表中\",{\"1\":{\"470\":1}}],[\"基本数据类型\",{\"0\":{\"469\":1}}],[\"基本数据结构的底层数据结构实现如下\",{\"1\":{\"382\":1}}],[\"基本可用\",{\"1\":{\"120\":2}}],[\"基本思想和电梯非常类似\",{\"1\":{\"16\":1}}],[\"基于hashmap实现\",{\"1\":{\"530\":1}}],[\"基于内存\",{\"1\":{\"298\":1}}],[\"基于mvcc和next\",{\"1\":{\"228\":1}}],[\"基于数据块传输\",{\"1\":{\"199\":1}}],[\"基于udp协议之上\",{\"1\":{\"184\":1}}],[\"基于url和ip以及cookie和请求头进行分流\",{\"1\":{\"139\":1}}],[\"基于距离向量算法\",{\"1\":{\"174\":1}}],[\"基于链路状态算法\",{\"1\":{\"174\":1}}],[\"基于\",{\"0\":{\"190\":1,\"373\":1,\"379\":1},\"1\":{\"172\":7,\"190\":1,\"298\":1,\"392\":1,\"401\":1,\"404\":1}}],[\"基于ip和端口进行转发\",{\"1\":{\"139\":1}}],[\"基于tcp\",{\"1\":{\"139\":1}}],[\"基于此协议的客户端与消息中间件可传递消息\",{\"1\":{\"74\":1}}],[\"基于通道的i\",{\"1\":{\"22\":1}}],[\"提交给了\",{\"1\":{\"611\":1}}],[\"提交事务\",{\"1\":{\"230\":1}}],[\"提供一个静态的共有方法\",{\"1\":{\"522\":1}}],[\"提供额外的功能\",{\"1\":{\"511\":1}}],[\"提供的线程安全的\",{\"1\":{\"630\":1}}],[\"提供的这些容器大部分在\",{\"1\":{\"627\":1}}],[\"提供的\",{\"1\":{\"401\":1}}],[\"提供的数据结构\",{\"1\":{\"306\":1}}],[\"提供了一些参数\",{\"1\":{\"725\":1}}],[\"提供了一系列的启动器\",{\"1\":{\"463\":1}}],[\"提供了\",{\"1\":{\"612\":1}}],[\"提供了atomicreference类来保证引用对象之间的原子性\",{\"1\":{\"585\":1}}],[\"提供了例如\",{\"1\":{\"449\":1}}],[\"提供了面向切面编程的丰富支持\",{\"1\":{\"434\":1}}],[\"提供了很多开箱即用的功能\",{\"1\":{\"376\":1}}],[\"提供了两个命令来生成\",{\"1\":{\"363\":1}}],[\"提供了channel\",{\"1\":{\"22\":1}}],[\"提供可靠的传输服务\",{\"1\":{\"188\":1}}],[\"提供面向连接的服务\",{\"1\":{\"188\":1}}],[\"提供\",{\"1\":{\"173\":2,\"328\":1}}],[\"提高线程的可管理性\",{\"1\":{\"603\":1}}],[\"提高响应速度\",{\"1\":{\"603\":1}}],[\"提高资源利用率\",{\"1\":{\"603\":1}}],[\"提高网络io读写性能\",{\"1\":{\"319\":1}}],[\"提高了网络性能\",{\"1\":{\"210\":1}}],[\"提高吞吐量\",{\"1\":{\"124\":1}}],[\"提高扩展性和可靠性\",{\"1\":{\"59\":1}}],[\"提出了有名管道\",{\"1\":{\"9\":1}}],[\"对类进行link操作\",{\"1\":{\"714\":1}}],[\"对类对象加锁\",{\"1\":{\"579\":1}}],[\"对字节码描述的信息进行语义分析\",{\"1\":{\"703\":1}}],[\"对各个region的回收价值和成本进行排序\",{\"1\":{\"684\":1}}],[\"对垃圾内存的回收速度\",{\"1\":{\"670\":1}}],[\"对整个新生代和部分老年代进行垃圾收集\",{\"1\":{\"663\":1}}],[\"对齐填充部分不是必然存在的\",{\"1\":{\"654\":1}}],[\"对元素顺序无要求则用hashset\",{\"1\":{\"536\":1}}],[\"对外暴露一个静态的公共方法\",{\"1\":{\"520\":1}}],[\"对某一个类只会存在一个对象实例\",{\"1\":{\"518\":1}}],[\"对方法的增强是手动完成的\",{\"1\":{\"512\":1}}],[\"对方发送正常\",{\"1\":{\"194\":1}}],[\"对方发送\",{\"1\":{\"194\":3}}],[\"对形参本身修改会导致实参变化\",{\"1\":{\"503\":1}}],[\"对形参的修改将会影响到实参\",{\"1\":{\"502\":1}}],[\"对内部方法加了同步锁\",{\"1\":{\"494\":1}}],[\"对其进行强制磁盘同步\",{\"1\":{\"411\":1}}],[\"对一些代码上要求同步\",{\"1\":{\"616\":1}}],[\"对一个或多个\",{\"1\":{\"399\":1}}],[\"对一行或者多行记录加锁\",{\"1\":{\"237\":1}}],[\"对相同元素对应的\",{\"1\":{\"396\":1}}],[\"对指定哈希中的指定字段做运算操作\",{\"1\":{\"390\":1}}],[\"对性能更友好\",{\"1\":{\"380\":1}}],[\"对不同的key设置不同的随机失效时间避免同时失效\",{\"1\":{\"355\":1}}],[\"对给定的元素进行相同的哈希计算\",{\"1\":{\"353\":1}}],[\"对redis的性能有一点影响\",{\"1\":{\"338\":1}}],[\"对设置到指定哈希表中\",{\"1\":{\"332\":1,\"390\":1}}],[\"对记录加\",{\"1\":{\"285\":2}}],[\"对同一字段的多次读取结果都是一致的\",{\"1\":{\"282\":1}}],[\"对索引中包含的字段做判断\",{\"1\":{\"272\":1}}],[\"对索引列进行范围查询\",{\"1\":{\"243\":1}}],[\"对排序查找和范围查找优化\",{\"1\":{\"266\":1}}],[\"对语句进行分析\",{\"1\":{\"243\":1}}],[\"对修改的记录加一个x锁\",{\"1\":{\"241\":1}}],[\"对读的记录加一个s锁\",{\"1\":{\"241\":1}}],[\"对读的记录加一个x锁\",{\"1\":{\"241\":1}}],[\"对当前操作的整张表加锁\",{\"1\":{\"237\":1}}],[\"对应到新生代就是survivor中的from区和to区\",{\"1\":{\"675\":1}}],[\"对应于创建bean过程中的初始化前\",{\"1\":{\"442\":1}}],[\"对应于表中的字段\",{\"1\":{\"218\":1}}],[\"对应的引用\",{\"1\":{\"498\":2}}],[\"对应的子节点由于是临时顺序节点\",{\"1\":{\"379\":1}}],[\"对应的是\",{\"1\":{\"375\":1}}],[\"对应的\",{\"1\":{\"374\":1,\"375\":1}}],[\"对应的扫描区间是\",{\"1\":{\"271\":1}}],[\"对应\",{\"1\":{\"374\":1}}],[\"对应java\",{\"1\":{\"22\":1}}],[\"对标头结构进行了改进\",{\"1\":{\"210\":1}}],[\"对按序到达的最后一个分组发送确认\",{\"1\":{\"204\":1}}],[\"对失序数据包重新排序以及去重\",{\"1\":{\"199\":1}}],[\"对\",{\"0\":{\"286\":1},\"1\":{\"175\":1,\"401\":1,\"683\":1,\"726\":1}}],[\"对数据完整性安全性要求较高的场景\",{\"1\":{\"416\":1}}],[\"对数据库造成很大的压力\",{\"1\":{\"352\":1}}],[\"对数据库进行数据修改之后\",{\"1\":{\"152\":2}}],[\"对数据包进行路由和寻址\",{\"1\":{\"174\":1,\"208\":1}}],[\"对请求的qps进行限制\",{\"1\":{\"165\":1}}],[\"对此仍然可以对外提供服务\",{\"1\":{\"115\":1}}],[\"对队列设置ttl\",{\"1\":{\"95\":1}}],[\"对路由\",{\"1\":{\"80\":1}}],[\"对象使用\",{\"1\":{\"726\":1}}],[\"对象一起存放在\",{\"1\":{\"704\":1}}],[\"对象没有在任何地方被引用\",{\"1\":{\"672\":1}}],[\"对象没有覆盖finalize方法\",{\"1\":{\"669\":1}}],[\"对象可以被回收\",{\"0\":{\"669\":1}}],[\"对象晋升到老年代的年龄阈值\",{\"1\":{\"662\":1}}],[\"对象都会首先在\",{\"1\":{\"662\":1}}],[\"对象在\",{\"1\":{\"662\":1}}],[\"对象在新生代中\",{\"1\":{\"660\":1}}],[\"对象在内存中的布局可以分为\",{\"1\":{\"654\":1}}],[\"对象优先在eden中分配\",{\"0\":{\"660\":1}}],[\"对象头包含两部分信息\",{\"1\":{\"654\":1}}],[\"对象头\",{\"1\":{\"654\":1}}],[\"对象头会有不同的设置方式\",{\"1\":{\"652\":1}}],[\"对象引用该字符串常量的话\",{\"1\":{\"671\":1}}],[\"对象引用\",{\"1\":{\"641\":1}}],[\"对象时\",{\"1\":{\"633\":1}}],[\"对象也会在方法内部转换为callable\",{\"1\":{\"612\":1}}],[\"对象锁的的拥有者线程才可以执行\",{\"1\":{\"589\":1}}],[\"对象类型和引用类型之间具有继承\",{\"1\":{\"486\":1}}],[\"对象给dispatcherservlet\",{\"1\":{\"456\":1}}],[\"对象数据存储场景\",{\"1\":{\"391\":1}}],[\"对象\",{\"1\":{\"30\":2,\"32\":6,\"437\":1,\"612\":2}}],[\"对象的类型转换是否合理\",{\"1\":{\"703\":1}}],[\"对象的访问定位就是如何找到创建的对象信息\",{\"1\":{\"655\":1}}],[\"对象的访问定位\",{\"0\":{\"655\":1}}],[\"对象的内存布局\",{\"0\":{\"654\":1}}],[\"对象的哈希码\",{\"1\":{\"652\":1}}],[\"对象的相等是是比较内存中存放的对象是否相等\",{\"1\":{\"484\":1}}],[\"对象的相等和引用的相等\",{\"0\":{\"484\":1}}],[\"对象的\",{\"1\":{\"29\":1,\"652\":1}}],[\"对于大型应用程序来说\",{\"1\":{\"725\":1}}],[\"对于大key严重的时候会触发集群内的故障转移\",{\"1\":{\"367\":1}}],[\"对于已经加载的类会被放在\",{\"1\":{\"710\":1}}],[\"对于初始化\",{\"1\":{\"706\":1}}],[\"对于collection接口有三个子接口\",{\"1\":{\"528\":1}}],[\"对于在编译期间就能确定的字符串\",{\"1\":{\"499\":1}}],[\"对于string\",{\"1\":{\"499\":1}}],[\"对于引用类型来说==是比较地址\",{\"1\":{\"490\":1}}],[\"对于基本类型来说==是比较值\",{\"1\":{\"490\":1}}],[\"对于多例bean不需要在启动过程中取创建\",{\"1\":{\"453\":1}}],[\"对于节点数在1000个以内的redis\",{\"1\":{\"430\":1}}],[\"对于小key时间基本可以忽略不计\",{\"1\":{\"367\":1}}],[\"对于遇到大量key过期\",{\"1\":{\"335\":1}}],[\"对于过期key\",{\"1\":{\"335\":1}}],[\"对于不支持批量操作的命令\",{\"1\":{\"333\":1}}],[\"对于读写来说\",{\"1\":{\"319\":1}}],[\"对于热点数据可以提前放入缓存中\",{\"1\":{\"303\":1}}],[\"对于当前事务也是不可见的\",{\"1\":{\"288\":1}}],[\"对于这种读取历史数据的方式\",{\"1\":{\"284\":1}}],[\"对于一个类加载器来说\",{\"1\":{\"710\":1}}],[\"对于一个volatile变量的写操作happens\",{\"1\":{\"576\":1}}],[\"对于一致性非锁定读的实现\",{\"1\":{\"284\":1}}],[\"对于一般的\",{\"1\":{\"239\":1}}],[\"对于快照数据\",{\"1\":{\"241\":2}}],[\"对于经常变化的数据就应该直接查询数据库\",{\"1\":{\"152\":1}}],[\"对于接收到重复的消息应该只能有一个执行结果\",{\"1\":{\"128\":1}}],[\"对于rabbitmq来说\",{\"1\":{\"86\":1}}],[\"对于典型的路由功能\",{\"1\":{\"78\":1}}],[\"对于需要尽快开始接收响应的快速交互式客户端是可取的\",{\"1\":{\"57\":1}}],[\"对于高负载\",{\"1\":{\"22\":1}}],[\"对于java来说\",{\"1\":{\"5\":1}}],[\"在名称中找到一个\",{\"1\":{\"725\":1}}],[\"在遇到\",{\"1\":{\"725\":1}}],[\"在父类加载器没有找到所请求的类情况下\",{\"1\":{\"714\":1}}],[\"在加载时调用\",{\"1\":{\"712\":1}}],[\"在内存中生成一个类的\",{\"1\":{\"702\":1}}],[\"在内部\",{\"1\":{\"287\":1}}],[\"在内部实现中\",{\"1\":{\"286\":1}}],[\"在常量池结束之后\",{\"1\":{\"694\":1}}],[\"在并发标记的最后以及最终标记中进行处理\",{\"1\":{\"687\":1}}],[\"在并发标记阶段用户新产生的垃圾\",{\"1\":{\"683\":1}}],[\"在重新标记阶段进行处理\",{\"1\":{\"687\":1}}],[\"在重新标记阶段不会标记浮动的新垃圾\",{\"1\":{\"683\":1}}],[\"在判断对象是否可达的时候\",{\"1\":{\"684\":1}}],[\"在注重吞吐量以及\",{\"1\":{\"682\":1}}],[\"在进行垃圾收集工作的时候必须暂停其他所有的工作线程\",{\"1\":{\"678\":1}}],[\"在进行微服务划分时\",{\"1\":{\"144\":1}}],[\"在新生代中\",{\"1\":{\"676\":1}}],[\"在标记完成后统一回收掉所有没有被标记的对象\",{\"1\":{\"674\":1}}],[\"在程序运行的时候就会产生两个object类\",{\"1\":{\"715\":1}}],[\"在程序运行的时候才能确定\",{\"1\":{\"486\":1}}],[\"在程序设计中一般很少使用弱引用与虚引用\",{\"1\":{\"670\":1}}],[\"在发生\",{\"1\":{\"664\":1}}],[\"在有的语境中也用于指代整堆收集\",{\"1\":{\"663\":1}}],[\"在分配的时候找到一块能满足分配大小的空闲内存进行分配\",{\"1\":{\"650\":1}}],[\"在jdk1\",{\"1\":{\"644\":1}}],[\"在虚拟机启动时创建\",{\"1\":{\"644\":1}}],[\"在读多写少的场合性能非常好\",{\"1\":{\"627\":1}}],[\"在编写代码的时候\",{\"1\":{\"617\":1}}],[\"在编译期间就会优化放入字符串常量池中\",{\"1\":{\"499\":1}}],[\"在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列\",{\"1\":{\"630\":1}}],[\"在实际使用过程中存在一些局限性比如不支持异步任务的编排组合\",{\"1\":{\"613\":1}}],[\"在实现repeatable\",{\"1\":{\"285\":1}}],[\"在这期间还可以取消任务以及获取任务的执行状态\",{\"1\":{\"611\":1}}],[\"在调用\",{\"1\":{\"600\":1}}],[\"在垃圾回收的时候\",{\"1\":{\"600\":1}}],[\"在执行任务前先countdownlatch\",{\"1\":{\"625\":1}}],[\"在执行\",{\"1\":{\"589\":1}}],[\"在执行monitorenter时\",{\"1\":{\"589\":1}}],[\"在执行运行在用户态下的程序时\",{\"1\":{\"3\":1}}],[\"在cpu的物理世界里\",{\"1\":{\"579\":1}}],[\"在线程中对象分配内存的时候先会在tlab中分配\",{\"1\":{\"650\":1}}],[\"在线程并发执行的时候\",{\"1\":{\"575\":1}}],[\"在线活跃用户数\",{\"1\":{\"316\":1}}],[\"在多线程下\",{\"1\":{\"558\":1,\"571\":1}}],[\"在多线程环境下扩容操作可能存在死循环问题\",{\"1\":{\"549\":1}}],[\"在队列两端都能插入和删除元素\",{\"1\":{\"537\":1}}],[\"在上面结构的基础上\",{\"1\":{\"530\":1}}],[\"在静态代码块中创建单例对象\",{\"1\":{\"521\":1}}],[\"在堆中创建字符串对象\",{\"1\":{\"498\":1}}],[\"在堆上创建一个新对象n\",{\"1\":{\"488\":1}}],[\"在类加载的时候\",{\"1\":{\"710\":1,\"714\":1}}],[\"在类加载的时候就会分配内存\",{\"1\":{\"479\":1}}],[\"在类的非静态成员不存在的时候静态方法就已经存在\",{\"1\":{\"479\":1}}],[\"在hotspot虚拟机中引入jit优化之后\",{\"1\":{\"470\":1}}],[\"在启动过程中\",{\"1\":{\"463\":4}}],[\"在启动时会比较计算出的校验和与文件末尾保存的校验和\",{\"1\":{\"415\":1}}],[\"在启动时对\",{\"1\":{\"415\":1}}],[\"在单例池map中会存在多个类型相同的bean\",{\"1\":{\"444\":1}}],[\"在单个\",{\"1\":{\"190\":1}}],[\"在master中配置repl\",{\"1\":{\"422\":1}}],[\"在mq发送方将消息成功发送给mq\",{\"1\":{\"129\":1}}],[\"在mq的配置中配置\",{\"1\":{\"103\":1}}],[\"在命令执行完之后再记录\",{\"1\":{\"413\":1}}],[\"在指定列表的头部\",{\"1\":{\"387\":1}}],[\"在指定列表的尾部\",{\"1\":{\"387\":1}}],[\"在没有同步到其他节点时\",{\"1\":{\"378\":1}}],[\"在位数组中把对应下标的值置为1\",{\"1\":{\"353\":1}}],[\"在键空间中\",{\"1\":{\"328\":2,\"342\":1}}],[\"在写数据的过程中\",{\"1\":{\"302\":2}}],[\"在当前读下\",{\"1\":{\"292\":1}}],[\"在快照读的情况下\",{\"1\":{\"292\":1}}],[\"在事务隔离级别\",{\"1\":{\"290\":1}}],[\"在同一个事务中\",{\"1\":{\"286\":1}}],[\"在同步非阻塞io模型中\",{\"1\":{\"22\":1}}],[\"在第一次查询时生成\",{\"1\":{\"285\":1}}],[\"在第二步认证成功之后通过userid生成jwt返回给前端\",{\"1\":{\"147\":1}}],[\"在一定程度上解决了传统解释型语言执行效率低的问题\",{\"1\":{\"689\":1}}],[\"在一段代码中\",{\"1\":{\"616\":1}}],[\"在一致性非锁定读下\",{\"1\":{\"285\":1}}],[\"在一个事务内开启多次读\",{\"1\":{\"232\":1}}],[\"在一个关系中\",{\"1\":{\"219\":1}}],[\"在一个局域网内\",{\"1\":{\"214\":1}}],[\"在一个小的子网\",{\"1\":{\"174\":1}}],[\"在锁定读下\",{\"1\":{\"285\":1}}],[\"在更新数据的同时版本号\",{\"1\":{\"284\":1}}],[\"在索引列上进行计算\",{\"1\":{\"278\":1}}],[\"在使用联合索引进行查询的时候\",{\"1\":{\"271\":1}}],[\"在innodb引擎中\",{\"1\":{\"269\":1}}],[\"在根据辅助索引查找时\",{\"1\":{\"262\":1}}],[\"在b树中进行范围查询时\",{\"1\":{\"262\":1}}],[\"在排序时使用了外部的索引排序\",{\"1\":{\"243\":1}}],[\"在满足需求的前提下越短越好\",{\"1\":{\"243\":1}}],[\"在redis\",{\"1\":{\"322\":1}}],[\"在rr隔离级别下\",{\"1\":{\"291\":1}}],[\"在rr级别下\",{\"1\":{\"241\":1}}],[\"在rc级别下\",{\"1\":{\"241\":1}}],[\"在为数据行加共享\",{\"1\":{\"240\":1}}],[\"在清空表中数据的时候使用\",{\"1\":{\"221\":1}}],[\"在删除表的时候使用\",{\"1\":{\"221\":1}}],[\"在关系模式\",{\"1\":{\"219\":1}}],[\"在属性x\",{\"1\":{\"219\":1}}],[\"在互联网中使用的\",{\"1\":{\"211\":1}}],[\"在网络发生拥塞之后\",{\"1\":{\"201\":1}}],[\"在网络上是明文传输的\",{\"1\":{\"175\":1}}],[\"在传输过程中\",{\"1\":{\"430\":1}}],[\"在传递数据之前\",{\"1\":{\"188\":1}}],[\"在传送数据之前必须先建立连接\",{\"1\":{\"188\":1}}],[\"在传送数据之前不需要先建立连接\",{\"1\":{\"188\":1}}],[\"在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的\",{\"1\":{\"185\":1}}],[\"在请求大资源前的预热请求\",{\"1\":{\"181\":1}}],[\"在约定中\",{\"1\":{\"175\":1}}],[\"在整个\",{\"1\":{\"174\":1}}],[\"在广域网\",{\"1\":{\"174\":1}}],[\"在秒杀项目中采用提前预热\",{\"1\":{\"356\":1}}],[\"在秒杀项目中为了防止数据库同时创建多个订单导致压力剧增\",{\"1\":{\"164\":1}}],[\"在秒杀开始时返回到前端的随机码\",{\"1\":{\"158\":1}}],[\"在通过key\",{\"1\":{\"149\":1}}],[\"在onceperrequestfilter过滤器添加redis数据的时候加上过期时间\",{\"1\":{\"149\":1}}],[\"在配置类中添加了jwtauthenticationtokenfilter\",{\"1\":{\"146\":1}}],[\"在本项目中\",{\"1\":{\"139\":1}}],[\"在stream中\",{\"1\":{\"139\":1}}],[\"在server服务器后面添加参数weight参数指定权重\",{\"1\":{\"60\":1}}],[\"在所有分布式事务场景中不会同时具备cap三个特性\",{\"1\":{\"115\":1}}],[\"在docker\",{\"1\":{\"109\":1}}],[\"在解锁前还需要检查订单是否支付\",{\"1\":{\"96\":1}}],[\"在绑定的时候一般会指定一个bindingkey\",{\"1\":{\"84\":1}}],[\"在大数据领域中以及日志采集中\",{\"1\":{\"79\":1}}],[\"在消息量大的时候建立tcp\",{\"1\":{\"97\":1}}],[\"在消息进入队列之前\",{\"1\":{\"78\":1,\"81\":1}}],[\"在消息发布的时候进行处理\",{\"1\":{\"77\":1}}],[\"在n个服务器中选择一台发送请求\",{\"1\":{\"60\":1}}],[\"在高并发的情况下\",{\"1\":{\"57\":1}}],[\"在服务器内存使用完之后\",{\"1\":{\"299\":2}}],[\"在服务器返回给客户端的时候进行分页\",{\"1\":{\"34\":1}}],[\"在服务端代理转发请求称为反向代理\",{\"1\":{\"50\":1}}],[\"在客户端代理转发请求称为正向代理\",{\"1\":{\"50\":1}}],[\"在客户端连接数量不高的情况下是没有问题的\",{\"1\":{\"21\":1}}],[\"在\",{\"1\":{\"29\":1,\"30\":1,\"32\":1,\"84\":1,\"181\":1,\"219\":2,\"238\":1,\"243\":2,\"263\":1,\"284\":2,\"285\":1,\"290\":2,\"291\":1,\"303\":1,\"346\":1,\"374\":1,\"578\":1,\"581\":1,\"622\":1,\"654\":1,\"689\":1,\"698\":1}}],[\"多核环境下的硬件优势\",{\"1\":{\"684\":1}}],[\"多余的空闲线程存活的最长时间\",{\"1\":{\"605\":1}}],[\"多余的不要\",{\"1\":{\"104\":1}}],[\"多态不能调用只在子类中存在\",{\"1\":{\"486\":1}}],[\"多态\",{\"1\":{\"486\":1}}],[\"多重锁\",{\"1\":{\"377\":1}}],[\"多线程操作导致死链问题\",{\"0\":{\"549\":1}}],[\"多线程下使用stringbuffer\",{\"1\":{\"494\":1}}],[\"多线程下验证令牌和删除令牌的过程应该是原子性的\",{\"1\":{\"155\":1}}],[\"多线程就会存在死锁\",{\"1\":{\"322\":1}}],[\"多种开箱即用的集群方案\",{\"1\":{\"297\":1}}],[\"多种协议\",{\"1\":{\"81\":1}}],[\"多版本并发控制就是对非锁定读的实现\",{\"1\":{\"284\":1}}],[\"多版本并发控制是勒段控制的模式\",{\"1\":{\"233\":1}}],[\"多条收集线程并发执行\",{\"1\":{\"684\":1}}],[\"多条\",{\"1\":{\"230\":1}}],[\"多对多\",{\"1\":{\"188\":1,\"224\":1}}],[\"多对一\",{\"1\":{\"188\":1}}],[\"多语言客户端\",{\"1\":{\"78\":1}}],[\"多个任务等待异步完成\",{\"1\":{\"613\":1}}],[\"多个事务方法相互调用的时候\",{\"1\":{\"447\":1}}],[\"多个redis节点实现主从集群\",{\"1\":{\"418\":1}}],[\"多个rabbitmq节点可以组成一个集群\",{\"1\":{\"78\":1,\"81\":1}}],[\"多个socket\",{\"1\":{\"321\":1}}],[\"多个消费者可以订阅同一队列\",{\"1\":{\"92\":1}}],[\"多个消费者可以订阅同一个队列\",{\"1\":{\"85\":1}}],[\"多个同名方法\",{\"1\":{\"30\":1}}],[\"多个线程可同时执行\",{\"1\":{\"623\":1}}],[\"多个线程共享本进程的堆和方法区\",{\"1\":{\"557\":1}}],[\"多个线程共享进程的堆和方法区\",{\"1\":{\"5\":1}}],[\"多个线程同时对链表进行操作\",{\"1\":{\"549\":1}}],[\"多个线程能并发处理不同的任务\",{\"1\":{\"6\":1}}],[\"多路复用\",{\"1\":{\"19\":1,\"298\":1}}],[\"种表有一个共同的特点\",{\"1\":{\"693\":1}}],[\"种包装类默认创建了数值\",{\"1\":{\"471\":1}}],[\"种数据结构\",{\"1\":{\"382\":1}}],[\"种数据结构是直接提供给用户使用的\",{\"1\":{\"382\":1}}],[\"种数据淘汰策略\",{\"1\":{\"328\":1}}],[\"种基本数据结构\",{\"1\":{\"382\":1}}],[\"种基础数据结构\",{\"1\":{\"308\":1}}],[\"种特殊数据结构\",{\"1\":{\"308\":1}}],[\"种常见\",{\"0\":{\"20\":1}}],[\"种\",{\"1\":{\"19\":1,\"181\":1,\"588\":1}}],[\"具备\",{\"1\":{\"376\":1}}],[\"具有四种类型的\",{\"1\":{\"723\":1}}],[\"具有弱引用的对象具有更短的声明周期\",{\"1\":{\"670\":1}}],[\"具有取消任务\",{\"1\":{\"612\":1}}],[\"具有以下特点\",{\"1\":{\"259\":1,\"261\":1}}],[\"具有提交和回滚事务的能力\",{\"1\":{\"228\":1}}],[\"具有高度的灵活性和可扩展性\",{\"1\":{\"174\":1}}],[\"具有三个关键功能\",{\"1\":{\"77\":1}}],[\"具有特定的格式\",{\"1\":{\"9\":1}}],[\"具体来说就是jvm将符号引用转化为直接引用的时候\",{\"1\":{\"703\":1}}],[\"具体什么时候清理需要通过下面两个参数控制\",{\"1\":{\"350\":1}}],[\"具体的执行方式\",{\"1\":{\"243\":1}}],[\"具体地说\",{\"1\":{\"174\":1}}],[\"具体包括\",{\"1\":{\"131\":1}}],[\"具体\",{\"1\":{\"18\":1}}],[\"操作字节流了\",{\"1\":{\"703\":1}}],[\"操作实现\",{\"1\":{\"630\":1}}],[\"操作去修改\",{\"1\":{\"624\":2}}],[\"操作的结果还没有存入变量中\",{\"1\":{\"575\":1}}],[\"操作的调用而已\",{\"1\":{\"18\":1}}],[\"操作数栈\",{\"1\":{\"559\":1,\"641\":2}}],[\"操作步骤\",{\"1\":{\"431\":1}}],[\"操作轻量\",{\"1\":{\"416\":1}}],[\"操作缓存就是直接操作内存\",{\"1\":{\"300\":1}}],[\"操作在内部被视为更新\",{\"1\":{\"287\":1}}],[\"操作才能查询到\",{\"1\":{\"261\":1}}],[\"操作都互斥\",{\"1\":{\"239\":1}}],[\"操作\",{\"1\":{\"18\":1,\"284\":1,\"285\":1,\"585\":1}}],[\"操作系统基本特征\",{\"1\":{\"679\":1}}],[\"操作系统负责的内核执行具体的\",{\"1\":{\"18\":1}}],[\"操作系统负责管理计算机网络的使用\",{\"1\":{\"2\":1}}],[\"操作系统会通知相应的线程进行后续的操作\",{\"1\":{\"23\":1}}],[\"操作系统会将孤儿进程的父进程设置为\",{\"1\":{\"10\":1}}],[\"操作系统会根据这些信息来管理和调度进程\",{\"1\":{\"8\":1}}],[\"操作系统重启\",{\"1\":{\"9\":1}}],[\"操作系统需要管理计算机网络的配置\",{\"1\":{\"2\":1}}],[\"操作系统的功能\",{\"0\":{\"2\":1}}],[\"操作系统\",{\"0\":{\"1\":1}}],[\"输入了两个参数\",{\"1\":{\"480\":1}}],[\"输入了一个参数\",{\"1\":{\"480\":1}}],[\"输入的数据一样\",{\"1\":{\"480\":1}}],[\"输入输出设备和外部存储设备等\",{\"1\":{\"2\":1}}],[\"输出为\",{\"1\":{\"503\":1}}],[\"输出\",{\"1\":{\"18\":1}}],[\"何为io\",{\"0\":{\"18\":1}}],[\"依次包括了访问标志\",{\"1\":{\"697\":1}}],[\"依次是\",{\"1\":{\"614\":1}}],[\"依赖于\",{\"1\":{\"594\":2}}],[\"依赖于有序的数据\",{\"1\":{\"266\":1,\"267\":1}}],[\"依赖注入的时候是把二级缓存中的aservice的普通对象进行赋值\",{\"1\":{\"450\":1}}],[\"依赖注入时\",{\"1\":{\"444\":1}}],[\"依赖注入\",{\"1\":{\"438\":1}}],[\"依据\",{\"1\":{\"426\":1}}],[\"依此往复\",{\"1\":{\"16\":2}}],[\"依然存在于系统中\",{\"1\":{\"10\":1}}],[\"磁头沿着一个方向扫描磁盘\",{\"1\":{\"16\":1}}],[\"磁盘等\",{\"1\":{\"2\":1}}],[\"扫描算法\",{\"1\":{\"16\":1}}],[\"避免程序一直原地等待耗时任务执行完成\",{\"1\":{\"611\":1}}],[\"避免堆上分配对象\",{\"1\":{\"470\":1}}],[\"避免全量更新时的磁盘io\",{\"1\":{\"422\":1}}],[\"避免额外的检查开销\",{\"1\":{\"413\":1}}],[\"避免竞争锁\",{\"1\":{\"380\":1}}],[\"避免了线程同步问题\",{\"1\":{\"521\":1}}],[\"避免了锁无法被释放\",{\"1\":{\"379\":1}}],[\"避免了分布式事务中的同步阻塞操作的影响\",{\"1\":{\"130\":1}}],[\"避免无效自旋\",{\"1\":{\"379\":1}}],[\"避免锁的误释放\",{\"1\":{\"374\":1}}],[\"避免同时处理大量的请求\",{\"1\":{\"355\":1}}],[\"避免单击出现问题导致的整个服务都没办法使用\",{\"1\":{\"355\":1}}],[\"避免阻塞主线程\",{\"1\":{\"335\":1,\"339\":1}}],[\"避免索引失效\",{\"0\":{\"278\":1}}],[\"避免出现饥饿问题\",{\"1\":{\"16\":1}}],[\"避免僵尸进程的产生\",{\"1\":{\"10\":1}}],[\"t1\",{\"1\":{\"714\":3}}],[\"t0\",{\"1\":{\"714\":2}}],[\"take\",{\"1\":{\"634\":1}}],[\"takeover\",{\"1\":{\"431\":1}}],[\"targetsurvivorratio=percent\",{\"1\":{\"662\":1}}],[\"targetobject\",{\"1\":{\"510\":1}}],[\"targetclass\",{\"1\":{\"510\":1}}],[\"target\",{\"1\":{\"446\":2,\"507\":5,\"509\":5}}],[\"table\",{\"1\":{\"221\":3,\"237\":2,\"243\":1,\"271\":2,\"382\":2}}],[\"tag\",{\"1\":{\"181\":1,\"693\":1}}],[\"tlab\",{\"1\":{\"730\":1}}],[\"tld\",{\"1\":{\"185\":3}}],[\"tls\",{\"1\":{\"180\":2}}],[\"tlsv1\",{\"1\":{\"62\":3}}],[\"the\",{\"1\":{\"678\":1,\"684\":1}}],[\"thenacceptasync\",{\"1\":{\"613\":1}}],[\"then\",{\"1\":{\"155\":1,\"374\":1,\"376\":1}}],[\"this\",{\"0\":{\"695\":1},\"1\":{\"376\":2,\"444\":1,\"507\":1,\"599\":1,\"613\":1,\"695\":1,\"713\":1}}],[\"threadfactory\",{\"1\":{\"605\":3}}],[\"threadpoolexecutor其他常见参数\",{\"1\":{\"605\":1}}],[\"threadpoolexecutor\",{\"1\":{\"604\":1,\"605\":1,\"606\":4}}],[\"thread\",{\"1\":{\"599\":5,\"622\":1}}],[\"thread类源码\",{\"1\":{\"599\":1}}],[\"threadlocal中就存在内存泄漏\",{\"1\":{\"729\":1}}],[\"threadlocal内存泄露\",{\"0\":{\"600\":1}}],[\"threadlocal类的set\",{\"1\":{\"599\":1}}],[\"threadlocal类主要解决的就是让每个线程绑定自己的值\",{\"1\":{\"598\":1}}],[\"threadlocal可以理解为threadlocalmap的封装\",{\"1\":{\"599\":1}}],[\"threadlocals\",{\"1\":{\"599\":3}}],[\"threadlocalmap是threadlocal的静态内部类\",{\"1\":{\"599\":1}}],[\"threadlocalmap\",{\"1\":{\"599\":4,\"600\":3}}],[\"threadlocal原理\",{\"0\":{\"599\":1}}],[\"threadlocal\",{\"0\":{\"597\":1,\"598\":1},\"1\":{\"599\":2,\"600\":2}}],[\"threadlocal<map\",{\"1\":{\"446\":1}}],[\"thread对象的start\",{\"1\":{\"576\":1}}],[\"threadid\",{\"1\":{\"376\":2}}],[\"threshold\",{\"1\":{\"350\":1}}],[\"through\",{\"0\":{\"303\":1},\"1\":{\"303\":6,\"304\":2}}],[\"throwable\",{\"1\":{\"514\":1,\"515\":1}}],[\"throw\",{\"1\":{\"146\":1}}],[\"throws\",{\"1\":{\"146\":1,\"439\":1,\"458\":1,\"507\":1,\"514\":2,\"515\":1,\"714\":1}}],[\"than阈值的命令时\",{\"1\":{\"346\":1}}],[\"than\",{\"1\":{\"346\":1}}],[\"typ\",{\"1\":{\"150\":1}}],[\"type\",{\"1\":{\"243\":2}}],[\"types\",{\"0\":{\"87\":1}}],[\"type=\",{\"1\":{\"33\":1}}],[\"tm独立出来是为了成为公用组件\",{\"1\":{\"123\":1}}],[\"tm事务管理器可以实现为独立的服务\",{\"1\":{\"123\":1}}],[\"tm事务管理器\",{\"1\":{\"123\":1}}],[\"treemap还实现了navigablemap接口和sortedmap\",{\"1\":{\"544\":1}}],[\"treemap\",{\"0\":{\"544\":1},\"1\":{\"544\":3}}],[\"treeset底层是红黑树\",{\"1\":{\"536\":1}}],[\"treeset\",{\"0\":{\"536\":1},\"1\":{\"395\":1,\"530\":1,\"536\":1}}],[\"trx\",{\"1\":{\"286\":1,\"287\":1,\"288\":1}}],[\"truncate\",{\"0\":{\"221\":1},\"1\":{\"221\":2}}],[\"true\",{\"1\":{\"100\":1,\"153\":1,\"484\":3,\"498\":2,\"499\":1,\"510\":1,\"712\":1}}],[\"true成功\",{\"1\":{\"99\":1}}],[\"transactional修饰的方法不是public方法\",{\"1\":{\"448\":1}}],[\"transactional\",{\"1\":{\"446\":1,\"448\":2}}],[\"transaction\",{\"1\":{\"230\":1}}],[\"translation\",{\"1\":{\"174\":1,\"210\":1,\"211\":1}}],[\"transmission\",{\"1\":{\"173\":1}}],[\"transport\",{\"1\":{\"172\":1}}],[\"transfer\",{\"1\":{\"172\":3,\"191\":4}}],[\"try\",{\"1\":{\"448\":1,\"714\":1}}],[\"tryacquire\",{\"1\":{\"158\":1,\"624\":1}}],[\"trysetpermits\",{\"1\":{\"158\":1}}],[\"try阶段所有分支事务执行成功后开始执行confirm\",{\"1\":{\"123\":1}}],[\"try阶段是做业务检查\",{\"1\":{\"123\":1}}],[\"tcc和2pc的区别\",{\"0\":{\"124\":1}}],[\"tcc则认为confirm阶段是不会出错的\",{\"1\":{\"123\":1}}],[\"tcc分为三个阶段\",{\"1\":{\"123\":1}}],[\"tcc要求每个分支事务实现三个操作\",{\"1\":{\"123\":1}}],[\"tcc是try\",{\"1\":{\"123\":1}}],[\"tcc\",{\"0\":{\"123\":1}}],[\"tcp三次握手\",{\"0\":{\"193\":1}}],[\"tcp反向代理使用stream模块\",{\"1\":{\"63\":1}}],[\"tcp反向代理\",{\"0\":{\"63\":1}}],[\"tcp\",{\"0\":{\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":1,\"195\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1},\"1\":{\"9\":1,\"97\":1,\"172\":7,\"173\":1,\"174\":1,\"175\":4,\"178\":1,\"180\":2,\"188\":12,\"189\":1,\"190\":7,\"191\":2,\"193\":1,\"199\":8,\"200\":1}}],[\"tz=asia\",{\"1\":{\"109\":1}}],[\"ttl\",{\"1\":{\"214\":1,\"326\":1,\"328\":1}}],[\"ttl>\",{\"1\":{\"214\":1}}],[\"ttl属性\",{\"1\":{\"156\":1}}],[\"ttl属性来设置过期时间\",{\"1\":{\"95\":1}}],[\"ttl就是消息的存活时间\",{\"1\":{\"95\":1}}],[\"to\",{\"1\":{\"724\":1}}],[\"totalnum\",{\"1\":{\"575\":1}}],[\"token是生成的sku随机码\",{\"1\":{\"158\":1}}],[\"token\",{\"0\":{\"150\":1},\"1\":{\"155\":1,\"158\":1,\"309\":1,\"385\":1}}],[\"todo\",{\"1\":{\"146\":1}}],[\"tolerance分区容错性\",{\"0\":{\"115\":1}}],[\"tolerance三个词语的缩写\",{\"1\":{\"112\":1}}],[\"topic类型的交换器在匹配规则上进行了扩展\",{\"1\":{\"90\":1}}],[\"topic类似于文件系统中的文件夹\",{\"1\":{\"85\":1}}],[\"topic\",{\"0\":{\"90\":1}}],[\"topic中的事件可以根据需要随时读取\",{\"1\":{\"85\":1}}],[\"topic和headers\",{\"1\":{\"84\":1}}],[\"top\",{\"1\":{\"62\":5}}],[\"tomcat主要用来处理servlet请求\",{\"1\":{\"55\":1}}],[\"two\",{\"1\":{\"60\":1}}],[\"teachernum\",{\"1\":{\"575\":2}}],[\"terminated\",{\"1\":{\"561\":1}}],[\"test\",{\"1\":{\"436\":1,\"446\":2,\"448\":1}}],[\"test=\",{\"1\":{\"30\":1}}],[\"telnet\",{\"1\":{\"172\":3,\"191\":3}}],[\"temporary\",{\"1\":{\"243\":1}}],[\"template\",{\"1\":{\"155\":1,\"437\":1}}],[\"temp\",{\"1\":{\"57\":2,\"539\":6}}],[\"t\",{\"1\":{\"34\":2,\"271\":2,\"509\":2,\"599\":6,\"724\":1}}],[\"timeunit\",{\"1\":{\"158\":1,\"376\":1,\"605\":1}}],[\"timeout有可能是服务器断网了\",{\"1\":{\"179\":1}}],[\"timeout\",{\"1\":{\"62\":1,\"566\":1}}],[\"timeout=30s\",{\"1\":{\"61\":1}}],[\"timeout来设置检查周期\",{\"1\":{\"61\":1}}],[\"time\",{\"1\":{\"16\":2,\"172\":1,\"561\":1}}],[\"最快的gc是不发生gc\",{\"0\":{\"729\":1}}],[\"最多分割几个文件\",{\"1\":{\"724\":1}}],[\"最多丢失\",{\"1\":{\"416\":1}}],[\"最顶层的加载类\",{\"1\":{\"711\":1}}],[\"最低层的链表维护了跳表内所有的元素\",{\"1\":{\"635\":1}}],[\"最低的隔离级别\",{\"1\":{\"282\":1}}],[\"最近通过自旋获得过这个锁\",{\"1\":{\"615\":1}}],[\"最近最少使用\",{\"1\":{\"342\":1}}],[\"最新动态\",{\"1\":{\"388\":1}}],[\"最新文章\",{\"1\":{\"388\":1}}],[\"最右边\",{\"1\":{\"387\":1}}],[\"最左边\",{\"1\":{\"387\":1}}],[\"最左匹配原则\",{\"0\":{\"271\":1}}],[\"最主要的是对会话失效的情况处理不一样\",{\"1\":{\"380\":1}}],[\"最要命的是没有广播机制\",{\"1\":{\"306\":1}}],[\"最高的隔离级别\",{\"1\":{\"282\":1}}],[\"最坏情况下退化为线性链表\",{\"1\":{\"259\":1}}],[\"最后把需要回收的region里的存活对象复制到新region中\",{\"1\":{\"684\":1}}],[\"最后sentinel将故障节点标记为slave\",{\"1\":{\"427\":1}}],[\"最后判断slave节点运行id的大小\",{\"1\":{\"426\":1}}],[\"最后\",{\"1\":{\"414\":1}}],[\"最后再发送给从节点\",{\"1\":{\"420\":1}}],[\"最后再根据持久化方式的配置来决定何时将系统内核缓存区的数据同步到磁盘中\",{\"1\":{\"410\":1}}],[\"最后再从内核态切换为用户态\",{\"1\":{\"3\":1}}],[\"最后hs256加盐算法中的秘钥secret也可以通过base64加密获得\",{\"1\":{\"150\":1}}],[\"最小2gb内存\",{\"1\":{\"719\":1}}],[\"最小可行服务\",{\"1\":{\"144\":1}}],[\"最小连接\",{\"1\":{\"60\":2,\"140\":1}}],[\"最终的请求都会到顶层的启动类加载器bootstrapclassloader中\",{\"1\":{\"714\":1}}],[\"最终标记\",{\"1\":{\"684\":1}}],[\"最终都会被转发到正确的节点上\",{\"1\":{\"429\":1}}],[\"最终需要会表查询\",{\"1\":{\"269\":1}}],[\"最终一直\",{\"1\":{\"120\":1}}],[\"最终一致性\",{\"1\":{\"120\":1}}],[\"最终拖垮server端\",{\"1\":{\"57\":1}}],[\"最大大小\",{\"1\":{\"721\":1}}],[\"最大扩容可达\",{\"1\":{\"607\":1}}],[\"最大可以同时运行的线程数量\",{\"1\":{\"605\":1}}],[\"最大线程数是线程池参数\",{\"1\":{\"604\":1}}],[\"最大线程数为integer\",{\"1\":{\"604\":2}}],[\"最大线程数为1\",{\"1\":{\"604\":1}}],[\"最大线程数为n\",{\"1\":{\"604\":1}}],[\"最大努力通知解决方案\",{\"0\":{\"133\":1}}],[\"最大努力通知无法保证消息从发出到接收的一致性\",{\"1\":{\"132\":1}}],[\"最大努力通知关注的是交易后的通知事务\",{\"1\":{\"132\":1}}],[\"最大努力通知和可靠消息一致性的区别\",{\"0\":{\"132\":1}}],[\"最大努力通知\",{\"0\":{\"131\":1},\"1\":{\"132\":1}}],[\"最大消费者数量\",{\"1\":{\"103\":1}}],[\"最大限度减少缓存失效\",{\"1\":{\"60\":1}}],[\"最大化吞吐量\",{\"1\":{\"59\":1}}],[\"最短寻道时间优先算法\",{\"1\":{\"16\":1}}],[\"同样满足\",{\"1\":{\"633\":1}}],[\"同样根据返回值不同分为两类方法\",{\"1\":{\"537\":1}}],[\"同样也使用了这些注解但是实现方式是完全不同的\",{\"1\":{\"449\":1}}],[\"同样存在脏数据问题\",{\"1\":{\"152\":1}}],[\"同类的商品就能对应到同一个节点上\",{\"1\":{\"430\":1}}],[\"同一个时间段内大量的key同时失效或者redis服务器宕机\",{\"1\":{\"354\":1}}],[\"同一个数据库中的表分布在不同的数据库中\",{\"1\":{\"254\":2}}],[\"同一个进程的线程共享内存和文件\",{\"1\":{\"6\":1}}],[\"同上\",{\"1\":{\"144\":1}}],[\"同步锁就没有必要加上了\",{\"1\":{\"616\":1}}],[\"同步队列\",{\"1\":{\"607\":1}}],[\"同步语句块的实现使用的是\",{\"1\":{\"589\":2}}],[\"同步代码块\",{\"1\":{\"519\":1}}],[\"同步方法\",{\"0\":{\"522\":1},\"1\":{\"519\":1}}],[\"同步保存操作\",{\"1\":{\"363\":1}}],[\"同步更新\",{\"1\":{\"303\":1}}],[\"同步数据本地\",{\"1\":{\"248\":1}}],[\"同步的事物变成了基于消息执行的异步事务\",{\"1\":{\"130\":1}}],[\"同步非阻塞io模型确实有很大的改进\",{\"1\":{\"22\":1}}],[\"同步非阻塞\",{\"1\":{\"19\":1}}],[\"同步阻塞io模型中\",{\"1\":{\"21\":1}}],[\"同步阻塞\",{\"1\":{\"19\":1}}],[\"同时又保留了解释型语言可移植的特点\",{\"1\":{\"689\":1}}],[\"同时开启\",{\"1\":{\"683\":1}}],[\"同时工作\",{\"1\":{\"683\":1}}],[\"同时对队列的读写存在多个线程同时进行的场景\",{\"1\":{\"630\":1}}],[\"同时会唤醒同步队列中的一个线程\",{\"1\":{\"624\":1}}],[\"同时通过对链表进行相应的操作\",{\"1\":{\"530\":1}}],[\"同时通过uuid生成随机码保存到sku详情数据\",{\"1\":{\"158\":1}}],[\"同时存在普通对象和代理对象违背了单例池规则\",{\"1\":{\"450\":1}}],[\"同时也带来了风险\",{\"1\":{\"413\":1}}],[\"同时将一个或多个\",{\"1\":{\"332\":1,\"390\":1}}],[\"同时使用了惰性删除与定期删除\",{\"1\":{\"299\":1}}],[\"同时还能减少传统的重量级锁使用操作系统互斥量产生的性能消耗\",{\"1\":{\"618\":1}}],[\"同时还提供\",{\"1\":{\"299\":1}}],[\"同时还需要添加过期时间\",{\"1\":{\"158\":1}}],[\"同时在创建秒杀单时可以通过分布式锁对秒杀单的创建流程上锁\",{\"1\":{\"164\":1}}],[\"同时秒杀商品信号量的semaphore的key也是skuid生成的uuid组合起来的\",{\"1\":{\"162\":1}}],[\"同时kafka最好是支撑较少的topic\",{\"1\":{\"79\":1}}],[\"同时根据客户端网络质量以合适的网速将响应传递给客户端\",{\"1\":{\"57\":1}}],[\"同时\",{\"1\":{\"16\":1,\"634\":1,\"683\":1}}],[\"先判断这个类是否已经加载过了\",{\"1\":{\"714\":1}}],[\"先会检查指令的参数能否在常量池中找到这个参数对应类的符号引用\",{\"1\":{\"649\":1}}],[\"先申请的线程先得到锁\",{\"1\":{\"593\":1}}],[\"先bytype再byname\",{\"0\":{\"444\":1}}],[\"先比较锁对应的\",{\"1\":{\"374\":1}}],[\"先获取互斥锁\",{\"1\":{\"357\":1}}],[\"先从\",{\"1\":{\"303\":1}}],[\"先查\",{\"1\":{\"303\":1}}],[\"先更新\",{\"1\":{\"302\":1}}],[\"先更新db\",{\"1\":{\"302\":1,\"360\":1}}],[\"先把\",{\"1\":{\"302\":1}}],[\"先是按照a字段的值排序\",{\"1\":{\"271\":1}}],[\"先用\",{\"1\":{\"242\":1}}],[\"先发送\",{\"1\":{\"175\":1}}],[\"先到达的请求的先被服务\",{\"1\":{\"16\":1}}],[\"先来先服务算法\",{\"1\":{\"16\":1}}],[\"先进先出\",{\"1\":{\"9\":1}}],[\"又有新的任务提交\",{\"1\":{\"604\":1}}],[\"又可以很好地与redis服务器中其他同样以单线程方式运行的模块进行对阶\",{\"1\":{\"320\":1}}],[\"又称写锁\",{\"1\":{\"239\":1}}],[\"又称读锁\",{\"1\":{\"239\":1}}],[\"又称为管态\",{\"1\":{\"3\":1}}],[\"又称为目态\",{\"1\":{\"3\":1}}],[\"又从\",{\"1\":{\"221\":1}}],[\"又被叫为符号链接\",{\"1\":{\"15\":1}}],[\"56\",{\"1\":{\"326\":1}}],[\"5之前\",{\"1\":{\"227\":1}}],[\"5开头的表示服务端错误\",{\"1\":{\"179\":1}}],[\"5分钟session会话保持\",{\"1\":{\"62\":1}}],[\"5m\",{\"1\":{\"62\":1}}],[\"50\",{\"1\":{\"350\":3,\"662\":2}}],[\"50x\",{\"1\":{\"48\":1,\"53\":2,\"62\":2}}],[\"504\",{\"1\":{\"48\":1,\"53\":1,\"62\":1,\"179\":1}}],[\"503\",{\"1\":{\"48\":1,\"53\":1,\"62\":1}}],[\"502\",{\"1\":{\"48\":1,\"53\":1,\"62\":1,\"179\":1}}],[\"500mb\",{\"1\":{\"350\":2}}],[\"500服务端内部出现错误\",{\"1\":{\"179\":1}}],[\"500\",{\"1\":{\"48\":1,\"53\":1,\"62\":1}}],[\"5\",{\"0\":{\"653\":1},\"1\":{\"15\":1,\"19\":1,\"227\":2,\"272\":1,\"276\":1,\"306\":2,\"308\":1,\"350\":1,\"382\":2,\"388\":1,\"448\":1,\"503\":1,\"539\":1,\"585\":1,\"624\":2,\"681\":1,\"692\":1}}],[\"4~1\",{\"1\":{\"732\":1}}],[\"4种整数类型\",{\"1\":{\"469\":1}}],[\"410\",{\"1\":{\"181\":1}}],[\"409\",{\"1\":{\"181\":1}}],[\"404not\",{\"1\":{\"179\":1}}],[\"403服务器拒绝执行该请求\",{\"1\":{\"179\":1}}],[\"401未授权\",{\"1\":{\"179\":1}}],[\"400\",{\"1\":{\"179\":1}}],[\"4开头的表示客户端错误\",{\"1\":{\"179\":1}}],[\"4平潭\",{\"0\":{\"168\":1}}],[\"4层代理设备将client发送报文中的目标地址\",{\"1\":{\"139\":1}}],[\"4层代理是基于ip和端口转发的\",{\"1\":{\"139\":1}}],[\"443\",{\"1\":{\"62\":1,\"180\":1}}],[\"4k\",{\"1\":{\"57\":1}}],[\"4中引入\",{\"1\":{\"22\":1}}],[\"4\",{\"0\":{\"91\":1,\"652\":1},\"1\":{\"15\":1,\"300\":1,\"319\":1,\"322\":1,\"328\":1,\"335\":1,\"339\":3,\"342\":1,\"350\":1,\"376\":1,\"380\":1,\"448\":1,\"471\":1,\"503\":1,\"691\":1}}],[\"不应该查询所有返回再筛选\",{\"1\":{\"729\":1}}],[\"不引用任何一个常量池项\",{\"1\":{\"693\":1}}],[\"不适合老年代\",{\"1\":{\"675\":1}}],[\"不适合作为mysql底层索引的数据结构\",{\"1\":{\"259\":1}}],[\"不管内存空间是否紧张都会回收这个对象\",{\"1\":{\"670\":1}}],[\"不管是插入操作还是读取操作\",{\"1\":{\"632\":1}}],[\"不管是在win\",{\"1\":{\"105\":1}}],[\"不为\",{\"1\":{\"625\":1}}],[\"不为null的字段\",{\"1\":{\"274\":1}}],[\"不够灵活\",{\"1\":{\"615\":1}}],[\"不存储元素\",{\"1\":{\"607\":1}}],[\"不存在线程安全问题\",{\"1\":{\"451\":1}}],[\"不存在时设置\",{\"1\":{\"384\":1}}],[\"不存在的话\",{\"1\":{\"374\":1}}],[\"不存在这个问题\",{\"1\":{\"311\":1}}],[\"不存在算法开销\",{\"1\":{\"16\":1}}],[\"不处理新任务\",{\"1\":{\"606\":1}}],[\"不涉及对象\",{\"1\":{\"567\":1}}],[\"不剥夺\",{\"1\":{\"563\":1}}],[\"不仅能避免多线程同步问题\",{\"1\":{\"525\":1}}],[\"不仅仅拷贝对象\",{\"1\":{\"488\":1}}],[\"不仅仅包括多种分布式锁的实现\",{\"1\":{\"376\":1}}],[\"不仅仅支持简单的\",{\"1\":{\"299\":1}}],[\"不断监控slave和master是否正常工作\",{\"1\":{\"424\":1}}],[\"不完整\",{\"1\":{\"416\":1}}],[\"不具备\",{\"1\":{\"376\":1}}],[\"不设置过期时间\",{\"1\":{\"326\":1}}],[\"不直接更新\",{\"1\":{\"304\":1}}],[\"不行\",{\"1\":{\"302\":1}}],[\"不支持存储null和non\",{\"1\":{\"539\":1}}],[\"不支持存储\",{\"1\":{\"538\":1}}],[\"不支持\",{\"1\":{\"299\":1}}],[\"不太适合经常使用范围查询的场景\",{\"1\":{\"253\":1}}],[\"不用回表\",{\"1\":{\"243\":1}}],[\"不光可以保存文本数据还可以保存二进制数据\",{\"1\":{\"383\":1}}],[\"不光可以缓解\",{\"1\":{\"211\":1}}],[\"不光支持表级锁\",{\"1\":{\"237\":1}}],[\"不允许外部直接访问这些属性\",{\"1\":{\"486\":1}}],[\"不允许多个事务同时获取\",{\"1\":{\"239\":1}}],[\"不允许分割\",{\"1\":{\"231\":1}}],[\"不允许重复\",{\"1\":{\"30\":1}}],[\"不符合\",{\"1\":{\"220\":1}}],[\"不确定\",{\"1\":{\"219\":1}}],[\"不包括实例变量\",{\"1\":{\"704\":1}}],[\"不包括对象头\",{\"1\":{\"651\":1}}],[\"不包括当前事务自己和已提交的事务\",{\"1\":{\"288\":1}}],[\"不包括\",{\"1\":{\"284\":1}}],[\"不包括记录本身\",{\"1\":{\"238\":1}}],[\"不包括uri\",{\"1\":{\"52\":1}}],[\"不包含\",{\"1\":{\"219\":1,\"243\":1}}],[\"不成立\",{\"1\":{\"219\":2}}],[\"不论他到哪里都不会改变\",{\"1\":{\"213\":1}}],[\"不重复\",{\"1\":{\"188\":1}}],[\"不丢失\",{\"1\":{\"188\":1}}],[\"不属于\",{\"1\":{\"175\":1,\"185\":1}}],[\"不带参数时\",{\"1\":{\"175\":1}}],[\"不保证是否顺序到达\",{\"1\":{\"188\":1}}],[\"不保证数据传输的可靠性\",{\"1\":{\"173\":1}}],[\"不保证实时传输质量\",{\"1\":{\"172\":1}}],[\"不再要求各个属性表具有严格的顺序\",{\"1\":{\"698\":1}}],[\"不再写入磁盘\",{\"1\":{\"422\":1}}],[\"不再调用b的服务\",{\"1\":{\"165\":1}}],[\"不再匹配其他location\",{\"1\":{\"54\":1}}],[\"不要过度设计\",{\"1\":{\"152\":1}}],[\"不要求立即到账\",{\"1\":{\"117\":1}}],[\"不建议使用java中的数据结构作为缓存实现\",{\"1\":{\"729\":1}}],[\"不建议单独使用\",{\"1\":{\"416\":1}}],[\"不建议这样做\",{\"1\":{\"388\":1}}],[\"不建议和其他多核\",{\"1\":{\"369\":1}}],[\"不建议\",{\"1\":{\"152\":1}}],[\"不可以插入\",{\"1\":{\"634\":1}}],[\"不可中断锁\",{\"1\":{\"595\":1}}],[\"不可重复的\",{\"1\":{\"529\":1}}],[\"不可重复\",{\"1\":{\"529\":1}}],[\"不可重复读以及幻读\",{\"1\":{\"282\":1}}],[\"不可重复读\",{\"1\":{\"232\":1,\"282\":1}}],[\"不可重入的分布式锁基本可以满足绝大部分业务场景了\",{\"1\":{\"377\":1}}],[\"不可缓存\",{\"1\":{\"175\":1}}],[\"不可行\",{\"1\":{\"146\":1}}],[\"不可避免出现由于网络问题而导致的节点之间通信失败\",{\"1\":{\"115\":1}}],[\"不安全\",{\"1\":{\"146\":1}}],[\"不足在于tcc对应用的侵入很大\",{\"1\":{\"124\":1}}],[\"不考虑网络挂掉的情况\",{\"1\":{\"119\":1}}],[\"不会加载自己写的object\",{\"1\":{\"715\":1}}],[\"不会加任何锁\",{\"1\":{\"239\":1}}],[\"不会再直接读取\",{\"1\":{\"703\":1}}],[\"不会被清理掉\",{\"1\":{\"600\":1}}],[\"不会创建副本\",{\"1\":{\"502\":1}}],[\"不会产生优化\",{\"1\":{\"499\":1}}],[\"不会生成新的对象\",{\"1\":{\"494\":1}}],[\"不会造成精度丢失问题\",{\"1\":{\"474\":1}}],[\"不会造成缓冲区溢出\",{\"1\":{\"383\":1}}],[\"不会发生死锁的问题\",{\"1\":{\"380\":1}}],[\"不会影响其他线程对共享资源的访问\",{\"1\":{\"372\":1}}],[\"不会回表\",{\"1\":{\"269\":1}}],[\"不会出现死锁\",{\"1\":{\"237\":1}}],[\"不会出现从开发到部署环境不兼容的问题\",{\"1\":{\"106\":1}}],[\"不会将拥塞窗口设置为1\",{\"1\":{\"201\":1}}],[\"不会分开发送\",{\"1\":{\"175\":1}}],[\"不会阻塞当前的命令执行\",{\"1\":{\"413\":1}}],[\"不会阻塞redis主进程\",{\"1\":{\"409\":1}}],[\"不会阻塞\",{\"1\":{\"23\":1,\"363\":1}}],[\"不推荐\",{\"0\":{\"91\":1},\"1\":{\"339\":1,\"355\":1,\"360\":1,\"519\":2}}],[\"不需要一直等到获取锁之后\",{\"1\":{\"595\":1}}],[\"不需要一条一条地执行命令\",{\"1\":{\"416\":1}}],[\"不需要扩容\",{\"1\":{\"538\":1}}],[\"不需要实现接口可以直接代理实现类\",{\"1\":{\"517\":1}}],[\"不需要对每一个目标对象创建一个代理类\",{\"1\":{\"513\":1}}],[\"不需要手动释放内存\",{\"1\":{\"468\":1}}],[\"不需要使用哨兵\",{\"1\":{\"431\":1}}],[\"不需要给出任何确认\",{\"1\":{\"188\":1}}],[\"不需要做任何判断操作\",{\"1\":{\"88\":1}}],[\"不需要了解底层网络的通信机制\",{\"1\":{\"75\":1}}],[\"不写默认为1\",{\"1\":{\"60\":1}}],[\"不写修饰符\",{\"1\":{\"54\":1}}],[\"不区分大小写\",{\"1\":{\"54\":1}}],[\"不单纯是new\",{\"1\":{\"22\":1}}],[\"不过均摊后的插入操作依然为\",{\"1\":{\"538\":1}}],[\"不过可能会经过初始化前和初始化后的增强\",{\"1\":{\"441\":1}}],[\"不过带来了部分额外的内存开销\",{\"1\":{\"386\":1}}],[\"不过多线程主要是针对一些大键值对的删除操作的命令\",{\"1\":{\"322\":1}}],[\"不过在redis\",{\"1\":{\"319\":1}}],[\"不过在8\",{\"1\":{\"229\":1}}],[\"不过需要添加一个锁来保证更新cache的时候不存在线程安全问题\",{\"1\":{\"302\":1}}],[\"不过概率非常小\",{\"1\":{\"302\":1}}],[\"不过条件变成了a>=1\",{\"1\":{\"271\":1}}],[\"不过\",{\"1\":{\"16\":1,\"334\":1,\"362\":1,\"374\":1,\"389\":1,\"592\":1}}],[\"不能存储基本类型\",{\"1\":{\"532\":1}}],[\"不能被修改而且必须有初始值\",{\"1\":{\"487\":1}}],[\"不能创建子节点\",{\"1\":{\"380\":1}}],[\"不能重复\",{\"1\":{\"263\":1}}],[\"不能再分为多个其他的字段了\",{\"1\":{\"218\":1}}],[\"不能再被分割\",{\"1\":{\"218\":1}}],[\"不能保存数据\",{\"1\":{\"451\":1}}],[\"不能保持登录状态\",{\"1\":{\"147\":1}}],[\"不能保证同一个客户端将始终定位到同一个服务器\",{\"1\":{\"60\":1}}],[\"不能加http\",{\"1\":{\"139\":1}}],[\"不能将数据库进行锁定\",{\"1\":{\"114\":1}}],[\"不能对目录进行创建\",{\"1\":{\"15\":1}}],[\"不能交叉文件系统进行硬链接的创建\",{\"1\":{\"15\":1}}],[\"不同类型的threadpoolexecutor\",{\"1\":{\"604\":1}}],[\"不同类型的对象可能会具有相似特点\",{\"1\":{\"486\":1}}],[\"不同点\",{\"1\":{\"487\":1}}],[\"不同于proxy\",{\"1\":{\"54\":1}}],[\"不同的beanname对应不同的bean对象\",{\"1\":{\"435\":1}}],[\"不同的字符串可能哈希出的位置相同\",{\"1\":{\"353\":1}}],[\"不同的key最后会得到相同的index\",{\"1\":{\"258\":1}}],[\"不同的业务使用不同的数据库\",{\"1\":{\"250\":1}}],[\"不同的类型对应着不同的路由策略\",{\"1\":{\"84\":1}}],[\"不同的开发语言等条件的限制\",{\"1\":{\"74\":1}}],[\"不同的xml映射文件\",{\"0\":{\"31\":1},\"1\":{\"31\":1}}],[\"不同的是消息队列存放在内核中\",{\"1\":{\"9\":1}}],[\"不同进程可以及时看到对方进程中对共享内存中数据的更新\",{\"1\":{\"9\":1}}],[\"3操作已经开始执行\",{\"1\":{\"575\":1}}],[\"3新增了hotkeys参数\",{\"1\":{\"342\":1}}],[\"3nf在2nf的基础上\",{\"1\":{\"220\":1}}],[\"3nf\",{\"0\":{\"220\":1},\"1\":{\"220\":1}}],[\"3开头的表示重定向\",{\"1\":{\"179\":1}}],[\"3更新缓存\",{\"1\":{\"152\":1}}],[\"3读数据库\",{\"1\":{\"152\":1}}],[\"3查询缓存没有\",{\"1\":{\"152\":1}}],[\"30s\",{\"1\":{\"376\":1}}],[\"30秒\",{\"1\":{\"376\":1}}],[\"30\",{\"1\":{\"376\":3}}],[\"30w+\",{\"1\":{\"300\":1}}],[\"303响应状态码返回时\",{\"1\":{\"179\":1}}],[\"302\",{\"1\":{\"179\":1}}],[\"302表示临时性的重定向\",{\"1\":{\"179\":1}}],[\"304表示客户端发送附带条件的请求时\",{\"1\":{\"179\":1}}],[\"30028\",{\"1\":{\"139\":1}}],[\"301表示永久性的重定向\",{\"1\":{\"179\":1}}],[\"301表示永久重定向\",{\"1\":{\"65\":1}}],[\"301\",{\"1\":{\"65\":1}}],[\"3306\",{\"1\":{\"63\":1}}],[\"3\",{\"0\":{\"20\":1,\"90\":1,\"128\":1,\"651\":1},\"1\":{\"15\":1,\"103\":1,\"136\":1,\"190\":4,\"308\":1,\"338\":2,\"375\":3,\"376\":1,\"431\":1,\"448\":1,\"503\":1,\"515\":1,\"575\":1,\"588\":1,\"605\":1,\"654\":1,\"672\":2,\"732\":1}}],[\"及之后\",{\"1\":{\"704\":1}}],[\"及之前版本的\",{\"1\":{\"549\":1}}],[\"及以后方法区的实现变成了元空间\",{\"1\":{\"645\":1}}],[\"及资源预留\",{\"1\":{\"123\":1}}],[\"及\",{\"1\":{\"15\":1}}],[\"lwp\",{\"1\":{\"726\":1}}],[\"lfence\",{\"1\":{\"579\":1}}],[\"lfu\",{\"1\":{\"328\":2,\"342\":1}}],[\"llc\",{\"1\":{\"401\":1}}],[\"llen\",{\"1\":{\"387\":1}}],[\"lpop\",{\"1\":{\"387\":1}}],[\"lpush\",{\"1\":{\"387\":1,\"388\":1}}],[\"lset\",{\"1\":{\"387\":1}}],[\"lrange\",{\"1\":{\"345\":1,\"362\":1,\"387\":1,\"388\":1}}],[\"lru\",{\"1\":{\"328\":2}}],[\"lua\",{\"1\":{\"297\":1,\"299\":1,\"306\":1,\"334\":9,\"374\":2}}],[\"lua脚本\",{\"0\":{\"334\":1},\"1\":{\"155\":1}}],[\"largepagesizeinbytes\",{\"1\":{\"726\":1}}],[\"latitude\",{\"1\":{\"405\":1}}],[\"latitude1\",{\"1\":{\"405\":1}}],[\"latest拉去最新的nginx镜像\",{\"1\":{\"108\":1}}],[\"latest\",{\"1\":{\"107\":2,\"108\":1,\"109\":1}}],[\"lazy实现懒惰式加载\",{\"1\":{\"450\":1}}],[\"lazy\",{\"1\":{\"324\":1,\"335\":1,\"339\":1}}],[\"layer\",{\"1\":{\"174\":1}}],[\"lang\",{\"1\":{\"515\":1,\"672\":1,\"695\":2,\"706\":1,\"712\":1,\"715\":1,\"721\":1}}],[\"language\",{\"1\":{\"222\":2}}],[\"lan\",{\"1\":{\"174\":4,\"213\":1}}],[\"lambdaquerywrapper<>\",{\"1\":{\"146\":1}}],[\"lambdaquerywrapper<user>\",{\"1\":{\"146\":1}}],[\"last与break\",{\"1\":{\"66\":1}}],[\"last\",{\"1\":{\"66\":3,\"195\":1}}],[\"len\",{\"1\":{\"243\":3,\"311\":3,\"346\":1}}],[\"letter\",{\"1\":{\"93\":1}}],[\"least\",{\"1\":{\"60\":3,\"328\":4}}],[\"level\",{\"1\":{\"33\":1,\"237\":3}}],[\"levelid\",{\"1\":{\"33\":1}}],[\"lib\",{\"1\":{\"711\":1}}],[\"lib目录下的\",{\"1\":{\"711\":1}}],[\"list\",{\"0\":{\"386\":1,\"529\":1,\"531\":1},\"1\":{\"299\":1,\"306\":4,\"308\":1,\"345\":1,\"362\":1,\"382\":2,\"386\":2,\"388\":1,\"529\":1,\"530\":1,\"627\":1,\"629\":1}}],[\"listen\",{\"1\":{\"48\":5,\"51\":1,\"53\":1,\"59\":1,\"62\":1,\"63\":1,\"139\":2,\"142\":1}}],[\"like\",{\"1\":{\"278\":2}}],[\"linux环境中\",{\"1\":{\"105\":1}}],[\"linking\",{\"1\":{\"700\":1}}],[\"linkedblockingqueue\",{\"0\":{\"633\":1},\"1\":{\"607\":1,\"633\":3}}],[\"linkedblockingqueue无界队列\",{\"1\":{\"604\":2}}],[\"linkedhashset底层是链表和哈希表\",{\"1\":{\"536\":1}}],[\"linkedhashset\",{\"0\":{\"536\":1},\"1\":{\"536\":1}}],[\"linkedhashset是hashset子类\",{\"1\":{\"530\":1}}],[\"linkedhashmap\",{\"1\":{\"530\":4}}],[\"linkedlist不支持随机访问\",{\"1\":{\"534\":1}}],[\"linkedlist底层使用双向链表存储数据\",{\"1\":{\"534\":1}}],[\"linkedlist\",{\"0\":{\"534\":1,\"538\":1},\"1\":{\"382\":2,\"530\":1,\"538\":3,\"627\":1}}],[\"link\",{\"1\":{\"15\":4}}],[\"limit\",{\"1\":{\"34\":1,\"288\":4,\"729\":1}}],[\"lower\",{\"1\":{\"350\":1}}],[\"low\",{\"1\":{\"288\":2,\"539\":2}}],[\"loop\",{\"1\":{\"243\":1}}],[\"look\",{\"1\":{\"16\":5}}],[\"longadder\",{\"1\":{\"581\":1}}],[\"longitude\",{\"1\":{\"405\":1}}],[\"longitude1\",{\"1\":{\"405\":1}}],[\"longcodec\",{\"1\":{\"376\":1}}],[\"long\",{\"1\":{\"155\":2,\"326\":1,\"376\":4,\"469\":1,\"471\":1,\"505\":1,\"566\":1,\"605\":1,\"714\":2}}],[\"loglog\",{\"1\":{\"401\":1}}],[\"logn\",{\"1\":{\"260\":1,\"261\":1,\"539\":1}}],[\"log2\",{\"1\":{\"259\":1}}],[\"login\",{\"1\":{\"146\":1,\"147\":2,\"149\":1}}],[\"loginuser\",{\"1\":{\"146\":1}}],[\"log\",{\"0\":{\"289\":1},\"1\":{\"108\":1,\"228\":1,\"248\":2,\"286\":2,\"287\":1,\"289\":2,\"345\":2,\"346\":3,\"362\":2,\"724\":1}}],[\"logs\",{\"1\":{\"108\":1}}],[\"loading\",{\"1\":{\"700\":1}}],[\"loader\",{\"1\":{\"514\":2,\"713\":1}}],[\"loadclass\",{\"1\":{\"509\":1,\"712\":2,\"714\":2,\"716\":1}}],[\"loadclasss\",{\"1\":{\"509\":1}}],[\"loaduserbyusername\",{\"1\":{\"146\":1}}],[\"load\",{\"1\":{\"80\":1,\"411\":1,\"579\":1}}],[\"locate\",{\"1\":{\"182\":1}}],[\"locator\",{\"1\":{\"182\":1}}],[\"location可以使用正则表达式\",{\"1\":{\"54\":1}}],[\"location将被追加到转发地址中\",{\"1\":{\"52\":1}}],[\"location\",{\"1\":{\"48\":4,\"51\":1,\"52\":3,\"53\":2,\"54\":1,\"57\":1,\"58\":1,\"59\":1,\"62\":2,\"139\":1,\"142\":1}}],[\"localhost\",{\"1\":{\"48\":1,\"51\":2,\"52\":8,\"53\":1,\"57\":1,\"58\":1,\"59\":3,\"60\":10,\"61\":2,\"63\":1,\"65\":1}}],[\"lockinterruptibly\",{\"1\":{\"594\":1}}],[\"locking\",{\"1\":{\"237\":3}}],[\"lock0上注册一个事件监听器\",{\"1\":{\"379\":1}}],[\"lock1是最小的子节点\",{\"1\":{\"379\":1}}],[\"lock1是否是\",{\"1\":{\"379\":1}}],[\"lock1节点\",{\"1\":{\"379\":1}}],[\"locks\",{\"1\":{\"379\":4,\"620\":1}}],[\"lockwatchdogtimeout\",{\"1\":{\"376\":5}}],[\"lockkey\",{\"1\":{\"374\":3,\"375\":3}}],[\"lock来防止这种情况\",{\"1\":{\"292\":1}}],[\"lock来解决幻读问题\",{\"1\":{\"292\":1}}],[\"lock防止幻读\",{\"0\":{\"292\":1}}],[\"lock+gap\",{\"1\":{\"238\":1,\"292\":1}}],[\"lock可解决幻读\",{\"1\":{\"232\":1}}],[\"lock\",{\"1\":{\"7\":2,\"228\":1,\"238\":7,\"240\":2,\"241\":2,\"282\":4,\"284\":1,\"285\":3,\"292\":3,\"376\":7,\"377\":3,\"592\":1,\"594\":1}}],[\"硬链接\",{\"1\":{\"15\":2}}],[\"硬链接和软链接有什么区别\",{\"0\":{\"15\":1}}],[\"eden\",{\"1\":{\"660\":2,\"662\":3,\"726\":2}}],[\"earlysingletonobjects\",{\"1\":{\"450\":1}}],[\"e\",{\"1\":{\"448\":1,\"537\":12,\"583\":1,\"714\":1}}],[\"ephemeral\",{\"1\":{\"380\":3}}],[\"everysec\",{\"1\":{\"412\":1,\"416\":1}}],[\"event\",{\"1\":{\"7\":1,\"158\":1}}],[\"eval\",{\"1\":{\"376\":1}}],[\"evalwriteasync\",{\"1\":{\"376\":1}}],[\"eviction\",{\"1\":{\"328\":1}}],[\"element\",{\"1\":{\"537\":1}}],[\"element2\",{\"1\":{\"317\":1,\"402\":1}}],[\"element1\",{\"1\":{\"317\":1,\"402\":1}}],[\"elevator\",{\"1\":{\"16\":1}}],[\"else\",{\"1\":{\"155\":1,\"374\":1,\"539\":1,\"599\":1,\"714\":1}}],[\"equals存在两种情况\",{\"1\":{\"490\":1}}],[\"equals\",{\"0\":{\"492\":1},\"1\":{\"484\":2}}],[\"eq\",{\"1\":{\"146\":1,\"243\":2}}],[\"entry\",{\"1\":{\"600\":1}}],[\"entity\",{\"1\":{\"33\":1,\"181\":1}}],[\"enum\",{\"1\":{\"525\":1}}],[\"enableautoconfiguration\",{\"1\":{\"461\":3}}],[\"end\",{\"1\":{\"155\":1,\"374\":1,\"376\":1,\"387\":2,\"396\":4,\"399\":2}}],[\"encodedstring\",{\"1\":{\"150\":2}}],[\"environment\",{\"1\":{\"109\":1}}],[\"etc\",{\"1\":{\"108\":1}}],[\"executorservice\",{\"1\":{\"612\":1}}],[\"executors\",{\"1\":{\"604\":1}}],[\"executor\",{\"1\":{\"604\":1,\"605\":1,\"613\":4}}],[\"executequery\",{\"1\":{\"729\":1}}],[\"execute方法传入三个参数\",{\"1\":{\"155\":1}}],[\"execute\",{\"1\":{\"155\":2}}],[\"example\",{\"1\":{\"476\":1,\"480\":1}}],[\"exists\",{\"1\":{\"374\":1,\"384\":1}}],[\"ex\",{\"1\":{\"326\":1,\"375\":4,\"459\":2}}],[\"ext\",{\"1\":{\"711\":2}}],[\"extclassloader\",{\"1\":{\"707\":1}}],[\"extra\",{\"1\":{\"243\":1}}],[\"extends\",{\"1\":{\"446\":1,\"515\":1}}],[\"extensionclassloader\",{\"1\":{\"711\":1}}],[\"extension\",{\"1\":{\"210\":1}}],[\"external\",{\"1\":{\"12\":1}}],[\"expected\",{\"1\":{\"583\":1}}],[\"expire\",{\"1\":{\"326\":1,\"384\":1}}],[\"expires\",{\"1\":{\"181\":1,\"328\":4}}],[\"explain\",{\"1\":{\"243\":2}}],[\"exceptionhandler\",{\"1\":{\"459\":4}}],[\"exception\",{\"1\":{\"439\":1,\"448\":1}}],[\"exclusive\",{\"1\":{\"240\":1,\"623\":1}}],[\"exchange交换机\",{\"1\":{\"158\":1}}],[\"exchange交换机是否成功收到信息\",{\"1\":{\"99\":1}}],[\"exchange交换器\",{\"0\":{\"92\":1}}],[\"exchange和queue的绑定可以是多对多的关系\",{\"1\":{\"84\":1}}],[\"exchange用来接收生产者发送的消息并将这些消息路由给服务器中的队列\",{\"1\":{\"84\":1}}],[\"exchange\",{\"0\":{\"84\":1,\"87\":1},\"1\":{\"92\":1,\"93\":1,\"100\":1}}],[\"ecdhe\",{\"1\":{\"62\":1}}],[\"error\",{\"1\":{\"48\":1,\"53\":1,\"62\":1}}],[\"外部实现的\",{\"1\":{\"711\":1}}],[\"外部内存碎片指的是那些并为分配给进程但又不能使用的内存\",{\"1\":{\"12\":1}}],[\"外部内存碎片\",{\"1\":{\"12\":1}}],[\"外\",{\"1\":{\"695\":1}}],[\"外层的\",{\"1\":{\"243\":1}}],[\"外键对于维护数据的一致性非常有帮助\",{\"1\":{\"228\":1}}],[\"外衣的\",{\"1\":{\"191\":1}}],[\"外存\",{\"1\":{\"2\":1}}],[\"6中引入的一项锁优化\",{\"1\":{\"619\":1}}],[\"6之中加入的新型锁机制\",{\"1\":{\"618\":1}}],[\"6之后引入自适应锁\",{\"1\":{\"615\":1}}],[\"6之前为循环链表\",{\"1\":{\"530\":1,\"534\":1}}],[\"64\",{\"1\":{\"726\":1}}],[\"64位补码的范围数字应该如何表示\",{\"0\":{\"475\":1}}],[\"64mb\",{\"1\":{\"414\":1}}],[\"6种数字类型\",{\"1\":{\"469\":1}}],[\"6\",{\"0\":{\"322\":1,\"323\":1},\"1\":{\"299\":1,\"319\":1,\"323\":1,\"328\":1,\"448\":1,\"538\":1,\"587\":1,\"692\":1,\"726\":1}}],[\"6字节\",{\"1\":{\"287\":2}}],[\"6版本中提供的索引优化功能\",{\"1\":{\"272\":1}}],[\"6byte\",{\"1\":{\"263\":1}}],[\"60s\",{\"1\":{\"326\":2}}],[\"60\",{\"1\":{\"188\":1,\"326\":2}}],[\"68海里景区\",{\"1\":{\"168\":1}}],[\"6379>\",{\"1\":{\"326\":3,\"375\":1}}],[\"6379\",{\"1\":{\"107\":2,\"338\":1}}],[\"63\",{\"1\":{\"12\":1}}],[\"65\",{\"1\":{\"12\":1}}],[\"那该接口要在其之前被初始化\",{\"1\":{\"706\":1}}],[\"那这时就要改为进行一次\",{\"1\":{\"664\":1}}],[\"那这一次\",{\"1\":{\"664\":1}}],[\"那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小\",{\"1\":{\"664\":1}}],[\"那偏向锁就是在无竞争的情况下把整个同步都消除掉\",{\"1\":{\"619\":1}}],[\"那里直接取出任务执行结果\",{\"1\":{\"611\":1}}],[\"那就会直接放到humongous里\",{\"1\":{\"686\":1}}],[\"那就证明任务还没有执行完毕\",{\"1\":{\"625\":1}}],[\"那就在常量池中创建一个指向该字符串对象的引用并返回\",{\"1\":{\"498\":1}}],[\"那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了\",{\"1\":{\"300\":1}}],[\"那三级缓存的作用\",{\"1\":{\"450\":1}}],[\"那其他事务不能再对这条事务加任何类型的锁\",{\"1\":{\"239\":1}}],[\"那么该类是通过\",{\"1\":{\"711\":1}}],[\"那么该消息就会丢失\",{\"1\":{\"101\":1}}],[\"那么value变量在准备阶段的的初始值是0而不是111\",{\"1\":{\"704\":1}}],[\"那么当前任务会被拒绝\",{\"1\":{\"608\":1}}],[\"那么当这个表的数据达到一个体量后\",{\"1\":{\"277\":1}}],[\"那么访问这个变量的每一个线程都有这个变量的副本\",{\"1\":{\"598\":1}}],[\"那么它就会从内存重新读取\",{\"1\":{\"579\":1}}],[\"那么另外的线程都是能立即看到的\",{\"1\":{\"577\":1}}],[\"那么\",{\"1\":{\"448\":1,\"657\":1}}],[\"那么校验和也会随之改变\",{\"1\":{\"415\":1}}],[\"那么我们就可以很放心地将该用户访问的数据存在缓存中\",{\"1\":{\"300\":1}}],[\"那么会导致索引失效\",{\"1\":{\"278\":1}}],[\"那么就可以在所引用的对象的内存被回收之前采取必要的行动\",{\"1\":{\"670\":1}}],[\"那么就将计数器减\",{\"1\":{\"626\":1}}],[\"那么就把该任务放入到任务队列里等待执行\",{\"1\":{\"608\":1}}],[\"那么就会新建一个线程来执行任务\",{\"1\":{\"608\":1}}],[\"那么就更不应该在这种字段上建立索引了\",{\"1\":{\"275\":1}}],[\"那么就需要在插入时排序\",{\"1\":{\"266\":1}}],[\"那么索引也需要改动\",{\"1\":{\"256\":1}}],[\"那么数据库自带的事物就无法满足要求\",{\"1\":{\"254\":1}}],[\"那么和这张表的所有缓存数据都失效\",{\"1\":{\"229\":1}}],[\"那么可以说y函数依赖于x\",{\"1\":{\"219\":1}}],[\"那么可能会引起网络阻塞\",{\"1\":{\"201\":1}}],[\"那么一切网络设备都由\",{\"1\":{\"213\":1}}],[\"那么对效率影响不大\",{\"1\":{\"278\":1}}],[\"那么对应的索引也将会被修改\",{\"1\":{\"266\":1}}],[\"那么对应的数据包就被假设为已丢失open\",{\"1\":{\"199\":1}}],[\"那么对数据准确性会造成极其轻微的影响\",{\"1\":{\"79\":1}}],[\"那么系统就不是一个分布式系统\",{\"1\":{\"119\":1}}],[\"那么location将不会被追加到转发地址中\",{\"1\":{\"52\":1}}],[\"那么id不能重复\",{\"1\":{\"31\":1}}],[\"那么id可以重复\",{\"1\":{\"31\":1}}],[\"那\",{\"1\":{\"12\":1}}],[\"2个字节\",{\"1\":{\"692\":2}}],[\"2个是slave\",{\"1\":{\"429\":1}}],[\"2n\",{\"1\":{\"609\":1}}],[\"2nf在1nf的基础上\",{\"1\":{\"219\":1}}],[\"2nf\",{\"0\":{\"219\":1}}],[\"2种浮点数类型\",{\"1\":{\"469\":1}}],[\"2^16^=65536\",{\"1\":{\"430\":1}}],[\"2^14^=16384\",{\"1\":{\"430\":1}}],[\"2^7\",{\"1\":{\"12\":1}}],[\"2msl\",{\"1\":{\"195\":1,\"197\":1}}],[\"24\",{\"1\":{\"181\":1}}],[\"20\",{\"1\":{\"188\":1,\"214\":1,\"350\":2}}],[\"206\",{\"1\":{\"181\":2}}],[\"200表示请求成功\",{\"1\":{\"179\":1}}],[\"20210309\",{\"1\":{\"316\":3}}],[\"20210308~20210309\",{\"1\":{\"316\":2}}],[\"20210308\",{\"1\":{\"316\":4}}],[\"2023\",{\"0\":{\"168\":1}}],[\"2022\",{\"1\":{\"136\":2}}],[\"2开头的表示客户端的请求成功被接收\",{\"1\":{\"179\":1}}],[\"2删除缓存\",{\"1\":{\"152\":1}}],[\"2更新缓存\",{\"1\":{\"152\":1}}],[\"2修改数据库\",{\"1\":{\"152\":2}}],[\"2pc通常都是在跨库的db层面\",{\"1\":{\"124\":1}}],[\"2pc\",{\"0\":{\"122\":1}}],[\"2k\",{\"1\":{\"57\":1,\"430\":1}}],[\"2\",{\"0\":{\"89\":1,\"127\":1,\"197\":1,\"548\":1,\"650\":1},\"1\":{\"12\":1,\"15\":2,\"23\":2,\"62\":1,\"83\":1,\"190\":3,\"195\":1,\"197\":1,\"271\":2,\"292\":1,\"300\":1,\"302\":2,\"306\":2,\"316\":2,\"317\":1,\"376\":2,\"448\":1,\"503\":1,\"538\":1,\"539\":3,\"575\":2,\"607\":1,\"675\":1,\"720\":2}}],[\"导致concurrent\",{\"1\":{\"685\":1}}],[\"导致他们的计数值都不为0\",{\"1\":{\"666\":1}}],[\"导致repl\",{\"1\":{\"422\":1}}],[\"导致大量的请求到达数据库\",{\"1\":{\"354\":1}}],[\"导致无法使用join操作\",{\"1\":{\"254\":1}}],[\"导致队列堆积很长\",{\"1\":{\"103\":1}}],[\"导致的死信的几种原因\",{\"1\":{\"93\":1}}],[\"导致nginx只能以较慢的速度将响应传给客户端\",{\"1\":{\"57\":1}}],[\"导致内部内存碎片的主要原因是\",{\"1\":{\"12\":1}}],[\"导致子进程的\",{\"1\":{\"10\":1}}],[\"简化了网络配置和管理\",{\"1\":{\"210\":1}}],[\"简化多服务器的管理\",{\"1\":{\"137\":1}}],[\"简称replid\",{\"1\":{\"420\":1}}],[\"简称\",{\"1\":{\"210\":1,\"404\":1}}],[\"简称为外部碎片\",{\"1\":{\"12\":1}}],[\"简称为内存碎片\",{\"1\":{\"12\":1}}],[\"简单地说\",{\"1\":{\"634\":1}}],[\"简单理解\",{\"1\":{\"611\":1}}],[\"简单动态字符串\",{\"1\":{\"311\":1,\"382\":1,\"383\":1}}],[\"简单限流可以用到\",{\"1\":{\"309\":1,\"385\":1}}],[\"简单查询\",{\"1\":{\"243\":1}}],[\"简单来说\",{\"1\":{\"222\":1}}],[\"简单来说就是不管发出去之后的事情了\",{\"1\":{\"188\":1}}],[\"简单邮件传输协议\",{\"1\":{\"191\":1}}],[\"简单邮件发送协议\",{\"1\":{\"172\":1}}],[\"简单高效\",{\"1\":{\"173\":1,\"666\":1,\"678\":1}}],[\"简单的执行器\",{\"1\":{\"35\":1}}],[\"简单的说就是通信的两方的一种约定\",{\"1\":{\"9\":1}}],[\"简历项目详解\",{\"0\":{\"135\":1}}],[\"fullgc和minorgc频繁\",{\"1\":{\"734\":1}}],[\"full\",{\"1\":{\"663\":1,\"664\":1,\"721\":2}}],[\"fulltext\",{\"1\":{\"243\":1}}],[\"future4\",{\"1\":{\"613\":2}}],[\"future3\",{\"1\":{\"613\":2}}],[\"future2\",{\"1\":{\"613\":2}}],[\"future1\",{\"1\":{\"613\":3}}],[\"futuretask相当于对callable\",{\"1\":{\"612\":1}}],[\"futuretask\",{\"1\":{\"612\":3}}],[\"future类有什么用\",{\"0\":{\"611\":1}}],[\"future\",{\"0\":{\"610\":1,\"612\":1},\"1\":{\"611\":3,\"612\":2,\"613\":2}}],[\"fence\",{\"1\":{\"579\":3}}],[\"feignclient\",{\"1\":{\"165\":1}}],[\"ft\",{\"1\":{\"405\":1}}],[\"ftp\",{\"1\":{\"172\":2,\"191\":3}}],[\"float\",{\"1\":{\"469\":1}}],[\"flushall\",{\"1\":{\"366\":1}}],[\"flushdb\",{\"1\":{\"366\":1}}],[\"flu\",{\"1\":{\"342\":1}}],[\"flags\",{\"0\":{\"694\":1},\"1\":{\"694\":1}}],[\"flag\",{\"1\":{\"287\":1}}],[\"fsync将阻塞直到写入磁盘完成之后返回\",{\"1\":{\"411\":1}}],[\"fsync针对单个文件操作\",{\"1\":{\"411\":1}}],[\"fsync\",{\"1\":{\"324\":2,\"411\":1,\"416\":1}}],[\"ff\",{\"1\":{\"213\":6}}],[\"found请求路径不存在\",{\"1\":{\"179\":1}}],[\"forname\",{\"1\":{\"509\":2}}],[\"force\",{\"1\":{\"431\":1}}],[\"fork采用copy\",{\"1\":{\"409\":1}}],[\"fork出一个子进程\",{\"1\":{\"409\":1}}],[\"fork子进程\",{\"1\":{\"408\":1}}],[\"fork\",{\"1\":{\"363\":1}}],[\"for\",{\"1\":{\"52\":2,\"210\":1,\"241\":2,\"284\":1,\"285\":2,\"292\":1,\"442\":1,\"539\":2}}],[\"forwarded\",{\"1\":{\"52\":2}}],[\"factories中指定的组件\",{\"1\":{\"462\":1}}],[\"factories文件\",{\"1\":{\"462\":1}}],[\"factories文件有什么作用\",{\"0\":{\"462\":1}}],[\"factories就是对springboot进行扩展的\",{\"1\":{\"462\":1}}],[\"factories是springboot\",{\"1\":{\"462\":1}}],[\"fairsync\",{\"1\":{\"592\":1}}],[\"fair\",{\"1\":{\"377\":1}}],[\"failure进而full\",{\"1\":{\"685\":1}}],[\"failure\",{\"1\":{\"664\":1}}],[\"failover命令\",{\"1\":{\"431\":1}}],[\"failover命令让集群中的某个master宕机\",{\"1\":{\"431\":1}}],[\"failover的slave节点\",{\"1\":{\"431\":1}}],[\"fail\",{\"1\":{\"61\":1}}],[\"fails=3\",{\"1\":{\"61\":1}}],[\"fails来设置失败次数\",{\"1\":{\"61\":1}}],[\"fallback\",{\"1\":{\"165\":1}}],[\"false详见后半部分string\",{\"1\":{\"484\":1}}],[\"false失败\",{\"1\":{\"99\":1}}],[\"false\",{\"1\":{\"93\":1,\"484\":1,\"498\":1,\"624\":1,\"714\":1}}],[\"fanout类型常用来广播消息\",{\"1\":{\"88\":1}}],[\"fanout类型的exchange路由规则非常简单\",{\"1\":{\"88\":1}}],[\"fanout\",{\"0\":{\"88\":1},\"1\":{\"84\":1}}],[\"free特性是redis\",{\"1\":{\"335\":1,\"339\":1}}],[\"free\",{\"1\":{\"335\":1,\"339\":1}}],[\"free后台线程释放大对象\",{\"1\":{\"324\":1}}],[\"frequently\",{\"1\":{\"328\":2}}],[\"fr和ca\",{\"1\":{\"185\":1}}],[\"from\",{\"1\":{\"30\":1,\"34\":3,\"221\":1,\"243\":1,\"271\":2,\"729\":1}}],[\"fragmentation\",{\"1\":{\"12\":2}}],[\"fcfs\",{\"1\":{\"16\":2}}],[\"fixedthreadpool最多只能创建核心线程数的线程\",{\"1\":{\"607\":1}}],[\"fixedthreadpool\",{\"1\":{\"604\":2,\"607\":1}}],[\"fields\",{\"0\":{\"696\":1},\"1\":{\"696\":3}}],[\"field2\",{\"1\":{\"390\":3}}],[\"field1\",{\"1\":{\"390\":3}}],[\"field\",{\"1\":{\"312\":1,\"332\":1,\"389\":1,\"390\":6,\"696\":2}}],[\"findbootstrapclassornull\",{\"1\":{\"714\":1}}],[\"findloadedclass\",{\"1\":{\"714\":1}}],[\"findclass\",{\"1\":{\"712\":2,\"714\":1,\"716\":1}}],[\"finalize\",{\"1\":{\"724\":1}}],[\"final类型\",{\"1\":{\"487\":1}}],[\"final\",{\"1\":{\"480\":1,\"495\":2,\"499\":2,\"505\":1,\"507\":1,\"520\":1,\"524\":1,\"546\":1,\"624\":1,\"693\":1,\"694\":1,\"713\":1}}],[\"fin\",{\"0\":{\"196\":1},\"1\":{\"195\":5,\"196\":1,\"197\":3}}],[\"filesort\",{\"1\":{\"243\":1}}],[\"file1\",{\"1\":{\"66\":1}}],[\"file1就会变成\",{\"1\":{\"66\":1}}],[\"file\",{\"1\":{\"57\":2,\"172\":1,\"191\":1,\"324\":1,\"408\":1,\"410\":1}}],[\"fifo\",{\"1\":{\"9\":1,\"624\":1,\"633\":1}}],[\"first\",{\"1\":{\"9\":2,\"16\":4,\"174\":1,\"684\":2}}],[\"由jvm自带的类加载器\",{\"1\":{\"707\":1}}],[\"由inheritablethreadlocal类维护\",{\"1\":{\"599\":1}}],[\"由threadlocal类维护\",{\"1\":{\"599\":1}}],[\"由数组+链表组成的\",{\"1\":{\"530\":1}}],[\"由被\",{\"1\":{\"459\":1}}],[\"由操作系统决定什么时候写回磁盘\",{\"1\":{\"412\":1}}],[\"由主进程执行save\",{\"1\":{\"409\":1}}],[\"由远到近\",{\"1\":{\"405\":1}}],[\"由近到远\",{\"1\":{\"405\":1}}],[\"由此可见\",{\"1\":{\"300\":1}}],[\"由交换器将消息路由到一个或者多个队列中\",{\"1\":{\"92\":1}}],[\"由库存模块中的监听器完成库存解锁和释放\",{\"1\":{\"69\":1}}],[\"由于是线程私有的\",{\"1\":{\"730\":1}}],[\"由于这个\",{\"1\":{\"711\":1}}],[\"由于这些命令时间复杂度是\",{\"1\":{\"362\":1}}],[\"由于字节码并不针对一种特定的机器\",{\"1\":{\"689\":1}}],[\"由于队列永远不会被放满\",{\"1\":{\"607\":1}}],[\"由于队列queue是一种先进先出的数据结构\",{\"1\":{\"67\":1}}],[\"由于指令重排序问题\",{\"1\":{\"577\":1}}],[\"由于linkedlist内部包含前驱和后继\",{\"1\":{\"534\":1}}],[\"由于静态内部类在singleton被装载的时候\",{\"1\":{\"524\":1}}],[\"由于第一次同步需要生成rdb文件\",{\"1\":{\"420\":1}}],[\"由于文件事件处理器是单线程方式运行的\",{\"1\":{\"320\":1}}],[\"由于购物车中的商品频繁修改和变动\",{\"1\":{\"312\":1}}],[\"由于联合索引是先按照a字段的值排序的\",{\"1\":{\"271\":1}}],[\"由于非聚簇索引的叶子节点存放的是主键\",{\"1\":{\"267\":1}}],[\"由于\",{\"1\":{\"190\":2,\"239\":1,\"378\":1,\"414\":1,\"695\":1}}],[\"由于使用不断扩容到\",{\"1\":{\"721\":1}}],[\"由于使用\",{\"1\":{\"188\":1}}],[\"由于使用反向代理之后\",{\"1\":{\"52\":1}}],[\"由于库存工作单存在状态标识\",{\"1\":{\"155\":1}}],[\"由于cookie存储在客户端\",{\"1\":{\"146\":1}}],[\"由于不要求强一致性\",{\"1\":{\"120\":1}}],[\"由于要保证数据库的可用性\",{\"1\":{\"114\":1}}],[\"由于数据同步的过程\",{\"1\":{\"113\":1}}],[\"由于tcp链接的创建和销毁开销较大\",{\"1\":{\"97\":1}}],[\"由于rabbitmq是以byte\",{\"1\":{\"86\":1}}],[\"由于没有考虑磁头移动的路径和方向\",{\"1\":{\"16\":1}}],[\"由于未分配的连续内存区域太小\",{\"1\":{\"12\":1}}],[\"由\",{\"1\":{\"10\":1,\"282\":1,\"711\":2}}],[\"由处理机的各种寄存器中的内容组成的\",{\"1\":{\"8\":1}}],[\"14\",{\"1\":{\"693\":1}}],[\"15\",{\"1\":{\"662\":1}}],[\"111\",{\"1\":{\"704\":1}}],[\"1111\",{\"1\":{\"548\":1}}],[\"1110\",{\"1\":{\"548\":2}}],[\"1101\",{\"1\":{\"548\":3}}],[\"1905122041950251207l\",{\"1\":{\"505\":1}}],[\"192\",{\"1\":{\"139\":2,\"142\":2}}],[\"1种布尔类型\",{\"1\":{\"469\":1}}],[\"1种字符类型\",{\"1\":{\"469\":1}}],[\"1表示集群中每个master的副本个数为1\",{\"1\":{\"429\":1}}],[\"1和4耗费时间称为rtt\",{\"1\":{\"331\":1}}],[\"1w\",{\"1\":{\"300\":1}}],[\"1nf是所有关系型数据库的最基本要求\",{\"1\":{\"218\":1}}],[\"1nf\",{\"0\":{\"218\":1}}],[\"1开头的表示临时响应\",{\"1\":{\"179\":1}}],[\"1删除缓存\",{\"1\":{\"152\":1}}],[\"1更新缓存\",{\"1\":{\"152\":1}}],[\"1修改数据库\",{\"1\":{\"152\":2}}],[\"13\",{\"1\":{\"139\":1,\"185\":1}}],[\"13306\",{\"1\":{\"63\":1}}],[\"1支持\",{\"1\":{\"103\":1}}],[\"16384个槽位完全够用\",{\"1\":{\"430\":1}}],[\"16384\",{\"1\":{\"430\":1}}],[\"168\",{\"1\":{\"139\":2,\"142\":2}}],[\"16\",{\"1\":{\"57\":1,\"546\":1}}],[\"12k\",{\"1\":{\"401\":2}}],[\"123456\",{\"1\":{\"150\":1}}],[\"12\",{\"1\":{\"139\":1}}],[\"127\",{\"1\":{\"48\":1,\"326\":3,\"375\":1,\"471\":2}}],[\"128\",{\"1\":{\"12\":1,\"471\":1}}],[\"1024\",{\"1\":{\"430\":2}}],[\"10w+\",{\"1\":{\"300\":1}}],[\"101\",{\"1\":{\"139\":1,\"142\":1}}],[\"1001\",{\"1\":{\"548\":4}}],[\"1000\",{\"1\":{\"376\":1}}],[\"100\",{\"1\":{\"139\":1,\"142\":1,\"158\":1,\"175\":1,\"181\":1,\"414\":1}}],[\"10m\",{\"1\":{\"58\":1}}],[\"10\",{\"1\":{\"34\":1,\"139\":2,\"376\":2,\"426\":1,\"472\":1,\"476\":1,\"532\":1}}],[\"1\",{\"0\":{\"88\":1,\"126\":1,\"181\":3,\"551\":2,\"649\":1},\"1\":{\"10\":1,\"15\":2,\"22\":1,\"48\":1,\"62\":1,\"65\":1,\"139\":2,\"142\":2,\"155\":3,\"159\":1,\"181\":14,\"195\":1,\"201\":2,\"213\":1,\"221\":1,\"261\":1,\"271\":1,\"284\":1,\"292\":1,\"300\":1,\"302\":4,\"311\":1,\"316\":10,\"317\":3,\"326\":4,\"338\":1,\"345\":1,\"350\":1,\"362\":1,\"374\":5,\"375\":1,\"376\":6,\"379\":4,\"383\":1,\"398\":1,\"399\":1,\"400\":1,\"416\":1,\"429\":1,\"448\":1,\"503\":1,\"516\":1,\"532\":1,\"534\":1,\"538\":1,\"539\":5,\"546\":1,\"548\":2,\"551\":1,\"557\":1,\"575\":1,\"585\":1,\"589\":2,\"604\":3,\"607\":1,\"618\":1,\"619\":1,\"624\":2,\"625\":2,\"626\":1,\"645\":2,\"662\":3,\"666\":1,\"675\":1,\"693\":3,\"720\":2,\"721\":2,\"726\":1,\"736\":2}}],[\"该类型可以用纯\",{\"1\":{\"726\":1}}],[\"该类才会尝试去加载\",{\"1\":{\"714\":1}}],[\"该类的类加载器的实例已经被gc\",{\"1\":{\"707\":1}}],[\"该类的所有实例对象都被gc\",{\"1\":{\"707\":1}}],[\"该类没有在其他任何地方被引用\",{\"1\":{\"707\":1}}],[\"该类对应的\",{\"1\":{\"672\":1}}],[\"该类所有的实例都已经被回收\",{\"1\":{\"672\":1}}],[\"该锁没有被其他的线程获取\",{\"1\":{\"619\":1}}],[\"该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池\",{\"1\":{\"604\":1}}],[\"该线程池中的线程数量始终不变\",{\"1\":{\"604\":1}}],[\"该方法如果获取不到许可就立即返回\",{\"1\":{\"624\":1}}],[\"该方法返回一个可根据实际情况调整线程数量的线程池\",{\"1\":{\"604\":1}}],[\"该方法返回一个只有一个线程的线程池\",{\"1\":{\"604\":1}}],[\"该方法返回一个固定线程数量的线程池\",{\"1\":{\"604\":1}}],[\"该方法中又调用了另一个需要相同锁的方法\",{\"1\":{\"377\":1}}],[\"该标识指明了该方法是一个同步方法\",{\"1\":{\"589\":1}}],[\"该缓冲区会在子进程创建新\",{\"1\":{\"414\":1}}],[\"该数据存在于数据库中\",{\"1\":{\"358\":1}}],[\"该级别可以防止脏读\",{\"1\":{\"282\":1}}],[\"该条目将被丢弃\",{\"1\":{\"214\":1}}],[\"该映射关系以\",{\"1\":{\"214\":1}}],[\"该地址表示广播地址\",{\"1\":{\"213\":1}}],[\"该请求被发往本地\",{\"1\":{\"185\":1}}],[\"该去往何处\",{\"1\":{\"174\":1,\"214\":1}}],[\"该算法容易出现饥饿问题\",{\"1\":{\"16\":1}}],[\"该进程就是孤儿进程\",{\"1\":{\"10\":1}}],[\"该消息队列才会被真正的删除\",{\"1\":{\"9\":1}}],[\"孤儿进程通常是由于父进程意外终止或未及时调用\",{\"1\":{\"10\":1}}],[\"孤儿进程\",{\"1\":{\"10\":1}}],[\"等问题的产生\",{\"1\":{\"670\":1}}],[\"等能力\",{\"1\":{\"613\":1}}],[\"等价于string\",{\"1\":{\"499\":1}}],[\"等价于int\",{\"1\":{\"472\":1}}],[\"等以\",{\"1\":{\"437\":1}}],[\"等参数\",{\"1\":{\"405\":1}}],[\"等场景\",{\"1\":{\"394\":1}}],[\"等多种部署架构\",{\"1\":{\"376\":1}}],[\"等缓存服务可用之后\",{\"1\":{\"360\":1}}],[\"等过程中产生的临时文件资源\",{\"1\":{\"324\":1}}],[\"等数据结构的存储\",{\"1\":{\"299\":1}}],[\"等当前读\",{\"1\":{\"292\":1}}],[\"等号右边的条件一定要用引号引起来标明这是一个字符串\",{\"1\":{\"278\":1}}],[\"等号右边的条件就写成对应的类型\",{\"1\":{\"278\":1}}],[\"等到state值为0的时候才不会被阻塞\",{\"1\":{\"625\":1}}],[\"等到有线程释放了共享资源\",{\"1\":{\"624\":1}}],[\"等到数据发完之后再发\",{\"1\":{\"196\":1}}],[\"等到整个响应完成再返回给客户端\",{\"1\":{\"57\":1}}],[\"等更多可供选择的缓存头来控制缓存策略\",{\"1\":{\"181\":1}}],[\"等待state值变为0\",{\"1\":{\"625\":1}}],[\"等待n个线程准备\",{\"1\":{\"625\":1}}],[\"等待n个线程完成任务之后\",{\"1\":{\"625\":1}}],[\"等待两个线程执行完成\",{\"1\":{\"625\":1}}],[\"等待可中断\",{\"1\":{\"594\":1}}],[\"等待状态\",{\"1\":{\"561\":1}}],[\"等待运行\",{\"1\":{\"561\":1}}],[\"等待后续使用\",{\"1\":{\"311\":1}}],[\"等待目的端确认收到这个报文段\",{\"1\":{\"199\":1}}],[\"等待服务器的确认\",{\"1\":{\"193\":1}}],[\"等待一段时间之后如果没有出现差错则订单已经创建在数据库中了\",{\"1\":{\"158\":1}}],[\"等待数据从内核空间拷贝到用户空间的这段时间\",{\"1\":{\"22\":1}}],[\"等\",{\"1\":{\"78\":1,\"81\":1,\"83\":1}}],[\"等于\",{\"1\":{\"54\":1}}],[\"等内核把数据准备好了\",{\"1\":{\"22\":1}}],[\"等系统调用来回收子进程导致的\",{\"1\":{\"10\":1}}],[\"等系统调用来获取子进程的状态信息\",{\"1\":{\"10\":1}}],[\"等等\",{\"1\":{\"8\":1,\"314\":1,\"629\":1,\"694\":1}}],[\"或属性组\",{\"1\":{\"219\":1}}],[\"或减少发布频率\",{\"1\":{\"103\":1}}],[\"或返回给生产者或直接丢弃\",{\"1\":{\"92\":1}}],[\"或者其他要测试\",{\"1\":{\"724\":1}}],[\"或者finalize方法已经被虚拟机调用过\",{\"1\":{\"669\":1}}],[\"或者初始化时通过构造器参数\",{\"1\":{\"634\":1}}],[\"或者\",{\"1\":{\"612\":1,\"662\":1,\"664\":1,\"684\":1,\"694\":1}}],[\"或者是其他原因导致任务暂停带来的影响\",{\"1\":{\"609\":1}}],[\"或者也可以使用\",{\"1\":{\"566\":1}}],[\"或者notifyall\",{\"1\":{\"566\":1}}],[\"或者产生缓存击穿\",{\"1\":{\"341\":1}}],[\"或者说是监听多个socket\",{\"1\":{\"321\":1}}],[\"或者更新时间戳\",{\"1\":{\"284\":1}}],[\"或者子查询\",{\"1\":{\"243\":1}}],[\"或者反向映射\",{\"1\":{\"211\":1}}],[\"或者rabbitmq服务实例\",{\"1\":{\"86\":1}}],[\"或者直接丢失\",{\"1\":{\"84\":1}}],[\"或者数据持久化都有很好的支持\",{\"1\":{\"80\":1}}],[\"或者显式地删除一个消息队列时\",{\"1\":{\"9\":1}}],[\"或\",{\"1\":{\"10\":3,\"15\":1,\"172\":1,\"191\":1,\"284\":1,\"676\":1}}],[\"僵尸进程\",{\"1\":{\"10\":2}}],[\"套接字是支持\",{\"1\":{\"9\":1}}],[\"套接字\",{\"1\":{\"9\":1}}],[\"如文本字符串\",{\"1\":{\"693\":1}}],[\"如是否启用偏向锁等\",{\"1\":{\"652\":1}}],[\"如semaphore\",{\"1\":{\"623\":1}}],[\"如reentrantlock\",{\"1\":{\"623\":1}}],[\"如tomcat\",{\"1\":{\"463\":1}}],[\"如数据库连接\",{\"1\":{\"463\":1}}],[\"如参与秒杀的商品\",{\"1\":{\"340\":1}}],[\"如不可见\",{\"1\":{\"286\":1}}],[\"如在局域网中使用的\",{\"1\":{\"211\":1}}],[\"如邻居发现\",{\"1\":{\"210\":1}}],[\"如uk\",{\"1\":{\"185\":1}}],[\"如com\",{\"1\":{\"185\":1}}],[\"如何才能找到类的元数据信息\",{\"1\":{\"652\":1}}],[\"如何设定线程池的大小\",{\"0\":{\"609\":1}}],[\"如何创建线程池\",{\"0\":{\"604\":1}}],[\"如何预防死锁\",{\"0\":{\"564\":1}}],[\"如何避免死锁\",{\"0\":{\"565\":1}}],[\"如何避免\",{\"0\":{\"562\":1}}],[\"如何判断一个类是无用的类\",{\"0\":{\"672\":1}}],[\"如何判断一个常量是废弃常量\",{\"0\":{\"671\":1}}],[\"如何判断是不是第一次主从同步\",{\"1\":{\"420\":1}}],[\"如何判断表中的记录没有行锁呢\",{\"1\":{\"240\":1}}],[\"如何选择\",{\"0\":{\"416\":1}}],[\"如何防止释放锁逻辑失效导致的锁无法释放\",{\"0\":{\"375\":1}}],[\"如何基于\",{\"0\":{\"374\":1}}],[\"如何清理redis内存碎片\",{\"0\":{\"350\":1}}],[\"如何查看redis内存碎片的信息\",{\"0\":{\"349\":1}}],[\"如何找到慢查询命令\",{\"0\":{\"346\":1}}],[\"如何解决浮点数运算的时候精度丢失问题\",{\"0\":{\"474\":1}}],[\"如何解决集群情况下分布式锁的可靠性\",{\"0\":{\"378\":1}}],[\"如何解决\",{\"0\":{\"343\":1}}],[\"如何处理\",{\"0\":{\"339\":1}}],[\"如何发现\",{\"0\":{\"338\":1,\"342\":1}}],[\"如何生成的\",{\"0\":{\"150\":1}}],[\"如何实现故障转移\",{\"0\":{\"427\":1}}],[\"如何实现可重入锁\",{\"0\":{\"377\":1}}],[\"如何实现可用性\",{\"1\":{\"114\":1}}],[\"如何实现锁的优雅续期\",{\"0\":{\"376\":1}}],[\"如何实现读写分离\",{\"0\":{\"247\":1}}],[\"如何实现流量控制\",{\"0\":{\"200\":1}}],[\"如何实现分区容错性\",{\"1\":{\"115\":1}}],[\"如何实现一致性\",{\"1\":{\"113\":1}}],[\"如何保证缓存和数据库数据的一致性\",{\"0\":{\"360\":1}}],[\"如何保证传输的可靠性\",{\"0\":{\"199\":1}}],[\"如何保证\",{\"0\":{\"102\":1}}],[\"如何保证消息的可靠性\",{\"0\":{\"98\":1}}],[\"如何产生的\",{\"0\":{\"93\":1}}],[\"如\",{\"1\":{\"90\":1,\"172\":1,\"191\":1,\"213\":1,\"243\":1,\"345\":1}}],[\"如下图所示\",{\"1\":{\"84\":1,\"219\":1}}],[\"如持久化\",{\"1\":{\"78\":1}}],[\"如果系统支持\",{\"1\":{\"726\":1}}],[\"如果系统对性能和资源消耗非常敏感的话\",{\"1\":{\"310\":1}}],[\"如果想打破双亲委派模型则需要重写\",{\"1\":{\"712\":1,\"716\":1}}],[\"如果想要使用\",{\"1\":{\"306\":1,\"315\":1,\"316\":1}}],[\"如果想要用户仅仅在一段时间内免登录怎么办\",{\"0\":{\"149\":1}}],[\"如果我们想在内存不足时重启服务器\",{\"1\":{\"725\":1}}],[\"如果我们没有指定\",{\"1\":{\"721\":1}}],[\"如果我们要自定义自己的类加载器\",{\"1\":{\"712\":1}}],[\"如果我们将变量声明为\",{\"1\":{\"578\":1}}],[\"如果回收速度赶不上分配速度\",{\"1\":{\"684\":1}}],[\"如果存活对象数量比较大\",{\"1\":{\"675\":1}}],[\"如果存在事务则将当前事务嵌套进去\",{\"1\":{\"447\":1}}],[\"如果存在事务则加入\",{\"1\":{\"447\":3}}],[\"如果内存不太够则可能会回收\",{\"1\":{\"670\":1}}],[\"如果内部方法的事务传播类型为不支持事务的传播类型\",{\"1\":{\"448\":1}}],[\"如果小于\",{\"1\":{\"664\":1}}],[\"如果大于\",{\"1\":{\"664\":1}}],[\"如果允许\",{\"1\":{\"664\":1}}],[\"如果未指定\",{\"1\":{\"633\":1}}],[\"如果未在规定时间内响应\",{\"1\":{\"425\":1}}],[\"如果资源被占用\",{\"1\":{\"622\":1}}],[\"如果资源不存在则会创建一个新的资源\",{\"1\":{\"176\":1}}],[\"如果向任务队列投放任务失败\",{\"1\":{\"608\":1}}],[\"如果核心线程已经满了\",{\"1\":{\"607\":1}}],[\"如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话\",{\"1\":{\"606\":1}}],[\"如果这个类本身是接口的话则是extends\",{\"1\":{\"695\":1}}],[\"如果这个条件成立\",{\"1\":{\"664\":1}}],[\"如果这时发生内存回收的话而且有必要的话\",{\"1\":{\"671\":1}}],[\"如果这时没有新的任务提交\",{\"1\":{\"605\":1}}],[\"如果这些表发生变化\",{\"1\":{\"229\":1}}],[\"如果达到的话\",{\"1\":{\"605\":1}}],[\"如果创建了一个threadlocal变量\",{\"1\":{\"598\":1}}],[\"如果锁的计数器为\",{\"1\":{\"589\":1}}],[\"如果长时间不成功\",{\"1\":{\"585\":1}}],[\"如果将变量通过volatile修饰\",{\"1\":{\"579\":1}}],[\"如果a\",{\"1\":{\"576\":1}}],[\"如果直接调用run\",{\"1\":{\"568\":1}}],[\"如果一直没有使用这个实例\",{\"1\":{\"521\":1}}],[\"如果一个对象仅持有虚引用\",{\"1\":{\"670\":1}}],[\"如果一个对象引用不会逃出本方法的作用范围\",{\"1\":{\"644\":1}}],[\"如果一个key的访问次数明显多余其他key\",{\"1\":{\"340\":1}}],[\"如果一个key对应的value所占用的内存比较大\",{\"1\":{\"336\":1}}],[\"如果一个表的字段过多\",{\"1\":{\"277\":1}}],[\"如果一个字段不被经常查询\",{\"1\":{\"275\":1}}],[\"如果一个索引包含所有需要查询字段的值\",{\"1\":{\"269\":1}}],[\"如果一个记录已经被加了排他锁\",{\"1\":{\"239\":1}}],[\"如果字符串常量池中没有保存了对应的字符串对象的引用\",{\"1\":{\"498\":1}}],[\"如果字符串常量池中保存了对应的字符串对象的引用\",{\"1\":{\"498\":1}}],[\"如果字符串常量池中存在\",{\"1\":{\"497\":1}}],[\"如果字符串常量池中不存在\",{\"1\":{\"497\":1}}],[\"如果两个操作不满足上述条件的任意一个\",{\"1\":{\"576\":1}}],[\"如果两个对象的hashcode不同则对象一定不同\",{\"1\":{\"492\":1}}],[\"如果两个都设置了会选择较小值\",{\"1\":{\"95\":1}}],[\"如果hashcode相同\",{\"1\":{\"492\":1}}],[\"如果子类重写了父类方法\",{\"1\":{\"486\":1}}],[\"如果自己添加了构造方法无论是否有参数都不会再自动生成无参构造方法\",{\"1\":{\"485\":1}}],[\"如果类没有声明构造方法则会默认生成一个不带参数的构造方法\",{\"1\":{\"485\":1}}],[\"如果父类方法访问修饰符是private\",{\"1\":{\"480\":1}}],[\"如果应用是一个\",{\"1\":{\"463\":1}}],[\"如果应用程序支持多线程\",{\"1\":{\"97\":1}}],[\"如果要保证线程安全可以将作用域改为prototype\",{\"1\":{\"451\":1}}],[\"如果采用以下方法\",{\"1\":{\"450\":1}}],[\"如果bean实现了接口\",{\"1\":{\"449\":1}}],[\"如果已经存在事务\",{\"1\":{\"447\":1}}],[\"如果当前没有任何\",{\"1\":{\"671\":1}}],[\"如果当前没有事务则开启一个新的事务\",{\"1\":{\"447\":1}}],[\"如果当前运行的线程数已经等同于最大线程数了\",{\"1\":{\"608\":1}}],[\"如果当前运行的线程数等于或大于核心线程数\",{\"1\":{\"608\":1}}],[\"如果当前运行的线程数小于核心线程数\",{\"1\":{\"608\":1}}],[\"如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时\",{\"1\":{\"606\":1}}],[\"如果当日活跃过就设置为\",{\"1\":{\"316\":1}}],[\"如果节点过多\",{\"1\":{\"430\":1}}],[\"如果节点是红色的\",{\"1\":{\"261\":1}}],[\"如果消息头是8k\",{\"1\":{\"430\":1}}],[\"如果消息没有被正确的消费\",{\"1\":{\"73\":1}}],[\"如果槽位是16384个\",{\"1\":{\"430\":1}}],[\"如果槽位是65536个\",{\"1\":{\"430\":1}}],[\"如果slave\",{\"1\":{\"426\":1}}],[\"如果slave的offset小于master的offset\",{\"1\":{\"420\":1}}],[\"如果超过指定值\",{\"1\":{\"426\":1}}],[\"如果master故障\",{\"1\":{\"424\":1}}],[\"如果实在太多\",{\"1\":{\"422\":1}}],[\"如果保存的数据要求安全性比较高的话\",{\"1\":{\"416\":1}}],[\"如果执行程序已关闭\",{\"1\":{\"606\":1}}],[\"如果执行有参构造方法\",{\"1\":{\"444\":1}}],[\"如果执行flushall命令意外地刷新了所有内容后\",{\"1\":{\"416\":1}}],[\"如果执行的是当前读\",{\"1\":{\"285\":1}}],[\"如果执行的是下列语句\",{\"1\":{\"285\":1}}],[\"如果文件内容发生了变化\",{\"1\":{\"415\":1}}],[\"如果文件有扩展名也会被删除\",{\"1\":{\"66\":1}}],[\"如果刚执行完命令redis宕机了就会导致对应的修改记录丢失\",{\"1\":{\"413\":1}}],[\"如果获取到\",{\"1\":{\"711\":1}}],[\"如果获取成功的话\",{\"1\":{\"624\":1}}],[\"如果获取锁失败\",{\"1\":{\"379\":1}}],[\"如果获取信号量成功则表示秒杀成功\",{\"1\":{\"158\":1}}],[\"如果操作共享资源的线程还未执行完成的话\",{\"1\":{\"376\":1}}],[\"如果操作共享资源的时间大于过期时间\",{\"1\":{\"375\":1}}],[\"如果操作的索引是唯一索引或主键\",{\"1\":{\"238\":1}}],[\"如果手动使用\",{\"1\":{\"363\":1}}],[\"如果重试还是失败则可以把当前更新失败的key存储队列中\",{\"1\":{\"360\":1}}],[\"如果cache服务当前不可用导致缓存删除失败\",{\"1\":{\"360\":1}}],[\"如果数据更新成功\",{\"1\":{\"360\":1}}],[\"如果数据有索引\",{\"1\":{\"256\":1}}],[\"如果热点key失效\",{\"1\":{\"356\":1}}],[\"如果都为1则表示这个值在布隆过滤器中\",{\"1\":{\"353\":1}}],[\"如果遇到构建不同请求的key就会导致redis缓存大量的无效key\",{\"1\":{\"353\":1}}],[\"如果缓存和数据库都差不到某个key的数据就写一个到redis中并设置过期时间\",{\"1\":{\"353\":1}}],[\"如果暴增的请求超出了redis的处理能力\",{\"1\":{\"341\":1}}],[\"如果对象在\",{\"1\":{\"662\":1}}],[\"如果对象的作用范围没有超过当前方法\",{\"1\":{\"470\":1}}],[\"如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息\",{\"1\":{\"310\":1}}],[\"如果对索引列的数据被修改时\",{\"1\":{\"266\":1}}],[\"如果其它事务有插入新的记录\",{\"1\":{\"292\":1}}],[\"如果该行未被更新\",{\"1\":{\"287\":1}}],[\"如果加\",{\"1\":{\"285\":1}}],[\"如果是类的话是否声明为\",{\"1\":{\"694\":1}}],[\"如果是出现了多个线程进行抢占共享变量\",{\"1\":{\"618\":1}}],[\"如果是\",{\"1\":{\"416\":1}}],[\"如果是就执行续期操作\",{\"1\":{\"376\":1}}],[\"如果是当前读\",{\"1\":{\"285\":1}}],[\"如果是执行普通的\",{\"1\":{\"284\":1}}],[\"如果是skuid则很容易被人猜到\",{\"1\":{\"162\":1}}],[\"如果读取的行正在执行\",{\"1\":{\"284\":1}}],[\"如果读取的记录正在执行update\",{\"1\":{\"241\":1}}],[\"如果记录的版本小于可见版本\",{\"1\":{\"284\":1}}],[\"如果索引的数据不是有序的\",{\"1\":{\"266\":1}}],[\"如果单个操作涉及到多个数据库\",{\"1\":{\"254\":1}}],[\"如果为\",{\"1\":{\"243\":1,\"712\":1}}],[\"如果表使用的引擎对于表行数统计是精确的\",{\"1\":{\"243\":1}}],[\"如果需要用到表锁的话\",{\"1\":{\"240\":1}}],[\"如果查询中包含任何用户自定义函数\",{\"1\":{\"229\":1}}],[\"如果\",{\"1\":{\"219\":1,\"243\":1,\"288\":1,\"303\":1,\"334\":1,\"374\":2,\"379\":1,\"600\":1,\"624\":3,\"625\":2,\"626\":1,\"714\":1,\"725\":1}}],[\"如果x\",{\"1\":{\"219\":1}}],[\"如果说轻量级锁是在无竞争的情况下使用cas操作去消除同步使用的互斥量\",{\"1\":{\"619\":1}}],[\"如果说\",{\"1\":{\"213\":1,\"300\":1}}],[\"如果立即把大量数据字节注入到网络\",{\"1\":{\"201\":1}}],[\"如果发现它还有虚引用\",{\"1\":{\"670\":1}}],[\"如果发现操作的变量是共享变量\",{\"1\":{\"579\":1}}],[\"如果发现文件有问题\",{\"1\":{\"415\":1}}],[\"如果发现发送方有事务已经提交\",{\"1\":{\"129\":1}}],[\"如果发生超时\",{\"1\":{\"205\":1}}],[\"如果发送方超时没有收到确认帧\",{\"1\":{\"204\":1}}],[\"如果发送机接收到三个重复确认\",{\"1\":{\"201\":1}}],[\"如果发送端实体在合理的往返时延\",{\"1\":{\"199\":1}}],[\"如果收到了序号n的确认\",{\"1\":{\"204\":1}}],[\"如果收到段的检验和有差错\",{\"1\":{\"199\":1}}],[\"如果收到mq\",{\"1\":{\"129\":1}}],[\"如果客户端发生异常导致没来得及释放锁也没关系\",{\"1\":{\"380\":1}}],[\"如果客户端能够和半数以上的实例成功地完成加锁操作\",{\"1\":{\"378\":1}}],[\"如果客户端在\",{\"1\":{\"197\":1}}],[\"如果客户端等待\",{\"1\":{\"195\":1}}],[\"如果服务端因为某些原因而没有收到\",{\"1\":{\"197\":1}}],[\"如果服务器上不存在该资源\",{\"1\":{\"176\":1}}],[\"如果服务器有这个资源\",{\"1\":{\"176\":1}}],[\"如果访问的网址在hosts文件中有对应的映射表目\",{\"1\":{\"184\":1}}],[\"如果请求成功\",{\"1\":{\"176\":1}}],[\"如果请求中没有携带token则表示是不需要登录的请求\",{\"1\":{\"147\":1}}],[\"如果因为某些原因b宕机\",{\"1\":{\"165\":1}}],[\"如果订单支付成功\",{\"1\":{\"155\":1}}],[\"如果库存锁定成功则发送订单消息给队列创建订单\",{\"1\":{\"155\":1}}],[\"如果比对成功则创建订单并将令牌删除\",{\"1\":{\"155\":1}}],[\"如果硬要解决缓存一致性问题\",{\"1\":{\"152\":1}}],[\"如果解密为有效的userid\",{\"1\":{\"147\":1}}],[\"如果使用包装类\",{\"1\":{\"729\":1}}],[\"如果使用这个\",{\"1\":{\"726\":1}}],[\"如果使用了直接引用\",{\"1\":{\"705\":1}}],[\"如果使用句柄的话\",{\"1\":{\"657\":1}}],[\"如果使用直接指针访问\",{\"1\":{\"656\":1}}],[\"如果使用cookie存储用户数据\",{\"1\":{\"146\":1}}],[\"如果使用session保存用户数据则会导致其他的服务器无法获取用户数据\",{\"1\":{\"146\":1}}],[\"如果本地事务出现问题\",{\"1\":{\"129\":1}}],[\"如果接收失败可以重复接收消息\",{\"1\":{\"127\":1}}],[\"如果每个虚拟机中需要创建很多的容器\",{\"1\":{\"109\":1}}],[\"如果每一次访问rabbitmq都建立一个connection\",{\"1\":{\"97\":1}}],[\"如果申请机器行不通\",{\"1\":{\"103\":1}}],[\"如果出现异常\",{\"1\":{\"101\":1}}],[\"如果设置了手动确认模式\",{\"1\":{\"101\":1}}],[\"如果不想打破双亲委派模型\",{\"1\":{\"712\":1,\"716\":1}}],[\"如果不成立\",{\"1\":{\"664\":1}}],[\"如果不存在数据依赖性\",{\"1\":{\"571\":1}}],[\"如果不存在事务则抛出异常\",{\"1\":{\"447\":1}}],[\"如果不指定serialversionuid\",{\"1\":{\"505\":1}}],[\"如果不同则会抛出invalidclassexception异常\",{\"1\":{\"505\":1}}],[\"如果不重写hashcode\",{\"1\":{\"492\":1}}],[\"如果不满足\",{\"1\":{\"311\":1}}],[\"如果不遵循最左匹配原则\",{\"1\":{\"271\":1}}],[\"如果不是主键索引\",{\"1\":{\"269\":1}}],[\"如果不加\",{\"1\":{\"221\":1}}],[\"如果不对接口返回确认\",{\"1\":{\"131\":1}}],[\"如果不设置\",{\"1\":{\"100\":1}}],[\"如果不适合放入内存\",{\"1\":{\"57\":1}}],[\"如果路由不到则会返回给producer\",{\"1\":{\"84\":1}}],[\"如果有这个接口的实现类发生了初始化\",{\"1\":{\"706\":1}}],[\"如果有空闲线程\",{\"1\":{\"607\":1}}],[\"如果有则直接返回这个对象的引用\",{\"1\":{\"490\":1}}],[\"如果有一个线程将变量值a改为b\",{\"1\":{\"584\":1}}],[\"如果有一个事务已经存在则会抛出异常\",{\"1\":{\"448\":1}}],[\"如果有一个值不为1\",{\"1\":{\"353\":1}}],[\"如果有无参构造方法则调用无参构造\",{\"1\":{\"443\":1}}],[\"如果有\",{\"1\":{\"263\":1}}],[\"如果有新的消费者上线\",{\"1\":{\"71\":1}}],[\"如果有多个sql则不知道执行哪个了\",{\"1\":{\"30\":1}}],[\"如果后端服务器在某个周期内响应失败的次数超过规定值\",{\"1\":{\"61\":1}}],[\"如果在接下来的执行过程中\",{\"1\":{\"619\":1}}],[\"如果在某段时间内没有多个线程访问这块同步代码那就可以不需要去指向操作系统互斥量\",{\"1\":{\"618\":1}}],[\"如果在同一个锁对象上\",{\"1\":{\"615\":1}}],[\"如果在循环内使用+进行拼接多个字符串\",{\"1\":{\"496\":1}}],[\"如果在一个类里面调用本类的方法就相当于this调用\",{\"1\":{\"448\":1}}],[\"如果在\",{\"1\":{\"378\":1}}],[\"如果在上游服务器组中添加或者删除服务器\",{\"1\":{\"60\":1}}],[\"如果在执行过程中遇到阻塞就会挂起直到结果返回\",{\"1\":{\"6\":1}}],[\"如果某个时刻对应的服务器宕机\",{\"1\":{\"60\":1}}],[\"如果整个响应不适合放入内存中\",{\"1\":{\"57\":1}}],[\"如果禁用了缓冲\",{\"1\":{\"57\":1}}],[\"如果匹配成功\",{\"1\":{\"54\":1}}],[\"如果proxy\",{\"1\":{\"52\":2}}],[\"如果没有需要先执行响应的类加载过程\",{\"1\":{\"649\":1}}],[\"如果没有就创建一个string对象\",{\"1\":{\"490\":1}}],[\"如果没有重写则执行的是父类中的方法\",{\"1\":{\"486\":1}}],[\"如果没有声明构造方法\",{\"0\":{\"485\":1}}],[\"如果没有实现接口\",{\"1\":{\"449\":1}}],[\"如果没有无参构造\",{\"1\":{\"443\":1}}],[\"如果没有空间记录命令\",{\"1\":{\"421\":1}}],[\"如果没有命中则去查找数据库并将数据写入缓存\",{\"1\":{\"360\":1}}],[\"如果没有设置主键且该表没有唯一非空索引时\",{\"1\":{\"287\":1}}],[\"如果没有查到则抛出异常\",{\"1\":{\"146\":1}}],[\"如果没有namespace\",{\"1\":{\"31\":1}}],[\"如果没有配置namespace\",{\"1\":{\"31\":1}}],[\"如果配置了namespace\",{\"1\":{\"31\":1}}],[\"如果磁头移动的方向上已经没有磁道访问请求了\",{\"1\":{\"16\":1}}],[\"如果磁头移动方向上已经没有别的请求\",{\"1\":{\"16\":1}}],[\"如果磁头从一个方向刚扫描完\",{\"1\":{\"16\":1}}],[\"如果经过的磁道有请求就处理\",{\"1\":{\"16\":1}}],[\"如互斥锁和信号量等\",{\"1\":{\"9\":1}}],[\"这反过来又会迫使\",{\"1\":{\"726\":1}}],[\"这反过来会导致应用程序崩溃\",{\"1\":{\"725\":1}}],[\"这可能会导致\",{\"1\":{\"726\":1}}],[\"这可能会导致一些数据需要进行多次磁盘\",{\"1\":{\"261\":1}}],[\"这通过将重复\",{\"1\":{\"726\":1}}],[\"这二者在针对并发标记过程中用户线程对可达性分析的影响的处理方式不同\",{\"1\":{\"685\":1}}],[\"这么多region\",{\"1\":{\"684\":1}}],[\"这也就是它的名字\",{\"1\":{\"684\":1}}],[\"这也就是说在查找过程中\",{\"1\":{\"635\":1}}],[\"这也是\",{\"1\":{\"261\":1}}],[\"这也是创建索引的主要原因\",{\"1\":{\"256\":1}}],[\"这就是为什么\",{\"1\":{\"725\":1}}],[\"这就是为什么如今很少使用\",{\"1\":{\"172\":1,\"191\":1}}],[\"这就指示\",{\"1\":{\"578\":1}}],[\"这句话创建了几个字符串对象\",{\"0\":{\"497\":1}}],[\"这两个收集器的处理策略是不同的\",{\"1\":{\"687\":1}}],[\"这两个注解实现统一异常处理\",{\"1\":{\"459\":1}}],[\"这两个都是过期时间设置\",{\"1\":{\"375\":1}}],[\"这里说的仅仅是\",{\"1\":{\"672\":1}}],[\"这里没有提到运行时常量池\",{\"1\":{\"671\":1}}],[\"这里并没有抛出异常\",{\"1\":{\"448\":1}}],[\"这里指的就是rabbitmq\",{\"1\":{\"97\":1}}],[\"这次的文件大小比上次增长超过100\",{\"1\":{\"414\":1}}],[\"这一步\",{\"1\":{\"706\":1}}],[\"这一步的作用是确保class文件的字节流中包含的信息符合\",{\"1\":{\"703\":1}}],[\"这一步操作保证了对象的实例字段在\",{\"1\":{\"651\":1}}],[\"这一步需要调用fsync函数\",{\"1\":{\"411\":1}}],[\"这一步需要调用write函数\",{\"1\":{\"411\":1}}],[\"这一点和kafka相反\",{\"1\":{\"85\":1}}],[\"这\",{\"1\":{\"382\":1,\"471\":1,\"693\":1}}],[\"这点和\",{\"1\":{\"346\":1}}],[\"这点轻微影响可以忽略\",{\"1\":{\"79\":1}}],[\"这同样是\",{\"1\":{\"334\":1}}],[\"这保持列redis内部单线程设计的简单性\",{\"1\":{\"320\":1}}],[\"这套时间处理模型对应的是redis中的文件事件处理器\",{\"1\":{\"320\":1}}],[\"这存在一些问题\",{\"1\":{\"311\":1}}],[\"这部分内存不会立即被回收\",{\"1\":{\"311\":1}}],[\"这对客户端是透明的\",{\"1\":{\"303\":1}}],[\"这类的数据库的\",{\"1\":{\"300\":1}}],[\"这边的\",{\"1\":{\"285\":1}}],[\"这被称为聚簇索引\",{\"1\":{\"262\":1}}],[\"这被称为非聚簇索引\",{\"1\":{\"262\":1}}],[\"这列包含了\",{\"1\":{\"243\":1}}],[\"这在并发写的情况下性非常差\",{\"1\":{\"237\":1}}],[\"这是因为bootstrapclassloader\",{\"1\":{\"711\":1}}],[\"这是因为软引用可以加速\",{\"1\":{\"670\":1}}],[\"这是设置的初始值\",{\"1\":{\"704\":1}}],[\"这是一个非常关键的场景\",{\"1\":{\"725\":1}}],[\"这是一个非阻塞队列\",{\"1\":{\"627\":1}}],[\"这是一个\",{\"1\":{\"627\":1}}],[\"这是一个接口\",{\"1\":{\"627\":1}}],[\"这是一个端到端的检验和\",{\"1\":{\"199\":1}}],[\"这是由于当一个桶位中有多个元素需要进行扩容时\",{\"1\":{\"549\":1}}],[\"这是\",{\"1\":{\"334\":1,\"684\":1}}],[\"这是redis中的一个性能瓶颈\",{\"1\":{\"323\":1}}],[\"这是多数分布式系统设计时的选择\",{\"1\":{\"117\":1}}],[\"这俩请求的报文只有在http请求行的\",{\"1\":{\"175\":1}}],[\"这有潜在的安全风险\",{\"1\":{\"172\":1,\"191\":1}}],[\"这时候进行内存分配的仅包括类变量\",{\"1\":{\"704\":1}}],[\"这时候字符串常量池还在堆\",{\"1\":{\"671\":1}}],[\"这时可将cpu资源交给其他任务\",{\"1\":{\"609\":1}}],[\"这时得到的结果就不是正确结果\",{\"1\":{\"575\":1}}],[\"这时如果两次查询中间有其它事务插入数据\",{\"1\":{\"285\":1}}],[\"这时记录也是可以被读取的\",{\"1\":{\"285\":1}}],[\"这时读取操作不会去等待行上锁的释放\",{\"1\":{\"284\":1}}],[\"这时先回复\",{\"1\":{\"196\":1}}],[\"这时rabbitmq的处理能力很低下\",{\"1\":{\"103\":1}}],[\"这时队列中的消息会被平摊\",{\"1\":{\"92\":1}}],[\"这时队列中的消息会被平均分摊给多个消费者进行处理\",{\"1\":{\"85\":1}}],[\"这时会触发由当前运行进程切换到处理此异常的内核相关程序中\",{\"1\":{\"3\":1}}],[\"这些参数将堆内存转储到一个物理文件中\",{\"1\":{\"725\":1}}],[\"这些内存都在方法区内分配\",{\"1\":{\"704\":1}}],[\"这些被实现的接口将按\",{\"1\":{\"695\":1}}],[\"这些humongous被当作老年代处理\",{\"1\":{\"684\":1}}],[\"这些信息存放在对象头中\",{\"1\":{\"652\":1}}],[\"这些命令并不是一定不能使用\",{\"1\":{\"362\":1}}],[\"这些redis命令会被一次性提交到服务器\",{\"1\":{\"333\":1}}],[\"这些场景对传输数据的准确性要求不是特别高\",{\"1\":{\"189\":1}}],[\"这些记录将这些主机的名字映射为\",{\"1\":{\"185\":1}}],[\"这些功能由\",{\"1\":{\"172\":1}}],[\"这些属性包括\",{\"1\":{\"83\":1}}],[\"这些小片段且不连续的内存空间被称为外部碎片\",{\"1\":{\"12\":1}}],[\"这意味着消息在发送给客户端时先在中心队列排队\",{\"1\":{\"80\":1}}],[\"这个时候类变量则会随着\",{\"1\":{\"704\":1}}],[\"这个时候就可能会产生内存泄露\",{\"1\":{\"600\":1}}],[\"这个类是否继承了不允许继承的类\",{\"1\":{\"703\":1}}],[\"这个类在\",{\"1\":{\"620\":1}}],[\"这个\",{\"1\":{\"694\":1}}],[\"这个标志用于识别一些类或者接口层次的访问信息\",{\"1\":{\"694\":1}}],[\"这个哈希表表示我指向谁\",{\"1\":{\"687\":1}}],[\"这个humongous也被认为是老年代\",{\"1\":{\"686\":1}}],[\"这个阶段的停顿时间一般会比初始标记阶段的时间稍长\",{\"1\":{\"683\":1}}],[\"这个闭包结构并不能保证包含当前所有的可达对象\",{\"1\":{\"683\":1}}],[\"这个算法的基本思想就是通过一系列的称为\",{\"1\":{\"667\":1}}],[\"这个机制aqs是基于clh锁实现的\",{\"1\":{\"622\":1}}],[\"这个对象的内存相比较2bit的锁标志位是要大很多的\",{\"1\":{\"618\":1}}],[\"这个变量是共享且不稳定的\",{\"1\":{\"578\":1}}],[\"这个变量都是共享的\",{\"1\":{\"477\":1}}],[\"这个注解会负责进行自动配置类的导入\",{\"1\":{\"461\":1}}],[\"这个部分会计算hash值转化为插槽\",{\"1\":{\"430\":1}}],[\"这个校验和是通过对整个\",{\"1\":{\"415\":1}}],[\"这个整数作为\",{\"1\":{\"405\":1}}],[\"这个整数保存了key所指向的数据库键的过期时间\",{\"1\":{\"326\":1}}],[\"这个监听器的作用是当前一个节点释放锁之后通知客户端\",{\"1\":{\"379\":1}}],[\"这个方法返回的是看门狗给锁续期的过期时间\",{\"1\":{\"376\":1}}],[\"这个命令会扫描redis中的所有key\",{\"1\":{\"338\":1}}],[\"这个key就能看做是bigkey\",{\"1\":{\"336\":1}}],[\"这个应该没人使用吧\",{\"1\":{\"328\":1}}],[\"这个是最常用的\",{\"1\":{\"328\":1}}],[\"这个索引的key是数据表的主键\",{\"1\":{\"262\":1}}],[\"这个过程也被称为\",{\"1\":{\"641\":1}}],[\"这个过程是比较慢\",{\"1\":{\"300\":1}}],[\"这个过程称为主从复制\",{\"1\":{\"247\":1}}],[\"这个过程就像调用本地方法一样简单\",{\"1\":{\"75\":1}}],[\"这个恢复过程依赖于redo\",{\"1\":{\"228\":1}}],[\"这个列称为主键\",{\"1\":{\"219\":1}}],[\"这个有状态说的是\",{\"1\":{\"188\":1}}],[\"这个和上面的\",{\"1\":{\"188\":1}}],[\"这个资源\",{\"1\":{\"182\":1}}],[\"这个状态不影响系统可用性\",{\"1\":{\"120\":1}}],[\"这个tcp被多个线程共享\",{\"1\":{\"97\":1}}],[\"这个交换器就是dlx\",{\"1\":{\"93\":1}}],[\"这个逻辑层面\",{\"1\":{\"85\":1}}],[\"这个特性天然适合大数据实时计算以及日志收集\",{\"1\":{\"79\":1}}],[\"这个请求就需要等到磁头从相反方向过来之后才能得到处理\",{\"1\":{\"16\":1}}],[\"这样做的好处是用户可以自定义类加载器\",{\"1\":{\"711\":1}}],[\"这样一个真正可用的对象才算完全产生出来\",{\"1\":{\"653\":1}}],[\"这样一来\",{\"1\":{\"600\":1}}],[\"这样才能实现多线程\",{\"1\":{\"568\":1}}],[\"这样才可以避免\",{\"1\":{\"378\":1}}],[\"这样能在不改变目标对象的前提下\",{\"1\":{\"511\":1}}],[\"这样能小幅度提升写性能\",{\"1\":{\"245\":1}}],[\"这样对内存更加友好\",{\"1\":{\"710\":1}}],[\"这样对性能不友好\",{\"1\":{\"380\":1}}],[\"这样对cpu友好\",{\"1\":{\"327\":1}}],[\"这样的话\",{\"1\":{\"380\":1,\"392\":1}}],[\"这样客户端\",{\"1\":{\"379\":1}}],[\"这样用户的一部分请求会直接到缓存这里而不用经过数据库\",{\"1\":{\"300\":1}}],[\"这样有什么好处呢\",{\"1\":{\"300\":1}}],[\"这样事务之间就完全不可能产生干扰\",{\"1\":{\"282\":1}}],[\"这样b的问题就不会影响到a的运作\",{\"1\":{\"165\":1}}],[\"这样会导致现在的缓存数据是1修改的数据\",{\"1\":{\"152\":1}}],[\"这样只要客户端保存正确的token就能保持登录状态\",{\"1\":{\"147\":1}}],[\"这样client就可以和server建立tcp连接并发送数据\",{\"1\":{\"139\":1}}],[\"这样就可以根据各个年代的特点选择合适的垃圾收集算法\",{\"1\":{\"676\":1}}],[\"这样就可以保证写操作不会影响读操作\",{\"1\":{\"629\":1}}],[\"这样就使每次的内存回收都是对内存区间的一半进行回收\",{\"1\":{\"675\":1}}],[\"这样就能保证即使数据不一致影响也比较小\",{\"1\":{\"302\":1}}],[\"这样就能保证本地事务和消息发送的原子性\",{\"1\":{\"129\":1}}],[\"这样就方便了开发者自由的选择以便于充分利用带宽和连接\",{\"1\":{\"181\":1}}],[\"这样就保证了在确认页面只有第一次点击订单能创建成功\",{\"1\":{\"155\":1}}],[\"这样就不存在分布式系统\",{\"1\":{\"119\":1}}],[\"这样在目录\",{\"1\":{\"108\":1}}],[\"这样可以减少连续执行字符串增长操作所需的内存重分配次数\",{\"1\":{\"311\":1}}],[\"这样可以避免重复消费\",{\"1\":{\"85\":1}}],[\"这样可能会做很多无用功\",{\"1\":{\"16\":2}}],[\"这样\",{\"1\":{\"84\":1}}],[\"这样相同的请求不用每次都发送给后端服务器\",{\"1\":{\"58\":1}}],[\"这样既解决了server端连接过多的问题\",{\"1\":{\"57\":1}}],[\"这种使用\",{\"1\":{\"684\":1}}],[\"这种算法没有什么新的思想\",{\"1\":{\"676\":1}}],[\"这种策略是为了提高获得锁和释放锁的效率\",{\"1\":{\"614\":1}}],[\"这种策略在我们平时开发过程中也非常非常少见\",{\"1\":{\"304\":1}}],[\"这种方法一般是c或者c++实现的\",{\"1\":{\"559\":1}}],[\"这种方式实现分布式锁存在一些问题\",{\"1\":{\"374\":1}}],[\"这种方式需要修改业务层代码\",{\"1\":{\"339\":1}}],[\"这种方式需要依靠某种同步操作\",{\"1\":{\"9\":1}}],[\"这种方式只能找到每种数据结构top\",{\"1\":{\"338\":1}}],[\"这种方式对数据一致性带来了更大的挑战\",{\"1\":{\"304\":1}}],[\"这种异常处理方式下\",{\"1\":{\"459\":1}}],[\"这种解决办法对于先操作缓存后操作数据库的场景不适用\",{\"1\":{\"360\":1}}],[\"这种读也被称为\",{\"1\":{\"285\":1}}],[\"这种逻辑定位是\",{\"1\":{\"213\":1}}],[\"这种确认叫做累计确认机制\",{\"1\":{\"204\":1}}],[\"这种自动重传方式常称为\",{\"1\":{\"203\":1}}],[\"这种分布式事务的实现方式可以让应用自己定义数据操作的粒度\",{\"1\":{\"124\":1}}],[\"这种情况下\",{\"1\":{\"10\":2}}],[\"这种通信方式主要用于解决与同步相关的问题并避免竞争条件\",{\"1\":{\"9\":1}}],[\"比n多1是为了处理线程偶然发生的缺页中断\",{\"1\":{\"609\":1}}],[\"比synchronized\",{\"1\":{\"594\":1}}],[\"比较简单\",{\"1\":{\"672\":1}}],[\"比较与交换\",{\"1\":{\"583\":1}}],[\"比较适合读请求比较多的场景\",{\"1\":{\"302\":1}}],[\"比较\",{\"0\":{\"24\":1,\"536\":1}}],[\"比\",{\"1\":{\"9\":1,\"175\":1,\"180\":1,\"188\":1,\"416\":2}}],[\"比如atomicinteger\",{\"1\":{\"581\":1}}],[\"比如要添加listener\",{\"1\":{\"462\":1}}],[\"比如是否点赞过某个视频\",{\"1\":{\"400\":1}}],[\"比如优先级任务队列\",{\"1\":{\"397\":1}}],[\"比如可以将一个用户所有的关注人存在一个集合中\",{\"1\":{\"392\":1}}],[\"比如一个线程在执行一个带锁的方法\",{\"1\":{\"377\":1}}],[\"比如使用hyperloglog统计页面的uv\",{\"1\":{\"339\":1}}],[\"比如直播间送礼物的排行榜\",{\"1\":{\"313\":1}}],[\"比如图片\",{\"1\":{\"311\":1}}],[\"比如拼接\",{\"1\":{\"311\":1}}],[\"比如浏览量\",{\"1\":{\"304\":1}}],[\"比如消息队列中消息的异步写入磁盘\",{\"1\":{\"304\":1}}],[\"比如在关系\",{\"1\":{\"219\":1,\"220\":1}}],[\"比如学生基本信息表\",{\"1\":{\"219\":2}}],[\"比如文件传输\",{\"1\":{\"189\":1}}],[\"比如你看视频即使少个一两帧\",{\"1\":{\"189\":1}}],[\"比如说住在某省某市某街道的张三\",{\"1\":{\"213\":1}}],[\"比如说\",{\"1\":{\"181\":1}}],[\"比如100表示客户端可以继续发送剩余请求\",{\"1\":{\"179\":1}}],[\"比如java\",{\"1\":{\"78\":1,\"81\":1}}],[\"比如$\",{\"1\":{\"29\":1}}],[\"比如\",{\"1\":{\"7\":2,\"29\":1,\"189\":1,\"297\":1,\"304\":1,\"306\":1,\"309\":1,\"326\":1,\"380\":1,\"416\":1,\"450\":1,\"620\":1,\"661\":1}}],[\"比如缺页异常\",{\"1\":{\"3\":1}}],[\"比如硬盘读写操作完成\",{\"1\":{\"3\":1}}],[\"也保证了java的核心api不会被修改\",{\"1\":{\"715\":1}}],[\"也并不会立即被回收\",{\"1\":{\"669\":1}}],[\"也没有什么特别的含义\",{\"1\":{\"654\":1}}],[\"也不需要强制实现接口\",{\"1\":{\"513\":1}}],[\"也不能实现类似数据库回滚的原子性\",{\"1\":{\"334\":1}}],[\"也会导致冻结用户线程\",{\"1\":{\"684\":1}}],[\"也会造成网络拥堵\",{\"1\":{\"430\":1}}],[\"也会被自动删除\",{\"1\":{\"379\":1}}],[\"也会很快失效\",{\"1\":{\"360\":1}}],[\"也涉及到删除和释放所有的键值对\",{\"1\":{\"366\":1}}],[\"也有首次请求数据一定不再\",{\"1\":{\"303\":1}}],[\"也叫作组合索引或者复合索引\",{\"1\":{\"270\":1}}],[\"也叫作组合索引或复合索引\",{\"1\":{\"270\":1}}],[\"也存放数据\",{\"1\":{\"262\":1}}],[\"也正因如此\",{\"1\":{\"261\":1}}],[\"也正是如此\",{\"1\":{\"80\":1}}],[\"也是一个bean工厂\",{\"1\":{\"452\":1}}],[\"也是一种动态路由协议\",{\"1\":{\"174\":1}}],[\"也是\",{\"1\":{\"366\":1}}],[\"也是广泛使用的一种动态路由协议\",{\"1\":{\"174\":1}}],[\"也是将消息路由到bindingkey和routingkey相匹配的队列中\",{\"1\":{\"90\":1}}],[\"也能保证持续稳定的向客户端传递响应\",{\"1\":{\"57\":1}}],[\"也可以理解成如果同步代码块没有多个出现并发问题的话\",{\"1\":{\"618\":1}}],[\"也可以理解为\",{\"1\":{\"213\":1}}],[\"也可以直接操作\",{\"1\":{\"416\":1}}],[\"也可以通过自定义类实现\",{\"1\":{\"634\":1}}],[\"也可以通过以下配置\",{\"1\":{\"414\":1}}],[\"也可以通过插件机制来实现自己的交换器\",{\"1\":{\"78\":1}}],[\"也可以修改或者添加部分字段\",{\"1\":{\"310\":1}}],[\"也可以是通过工具动态生成或者是从网络上下载而来\",{\"1\":{\"709\":1}}],[\"也可以是水平拆分\",{\"1\":{\"251\":1}}],[\"也可以是uri\",{\"1\":{\"60\":1}}],[\"也可以水平分库\",{\"1\":{\"250\":1}}],[\"也可以让全局事务发起方充当tm的角色\",{\"1\":{\"123\":1}}],[\"也可以为每一个消息单独设置ttl\",{\"1\":{\"95\":1}}],[\"也可以有零个\",{\"1\":{\"85\":1}}],[\"也可以根据实际业务情况动态地扩展\",{\"1\":{\"81\":1}}],[\"也可以根据实际业务情况动态地扩展集群中节点\",{\"1\":{\"78\":1}}],[\"也可以使用分页插件来完成物理分页\",{\"1\":{\"34\":1}}],[\"也可以按消息的类型读取\",{\"1\":{\"9\":1}}],[\"也被称为记录锁\",{\"1\":{\"238\":1}}],[\"也被称为电梯\",{\"1\":{\"16\":1}}],[\"也被称为最佳服务优先\",{\"1\":{\"16\":1}}],[\"也就是得到类或者字段\",{\"1\":{\"705\":1}}],[\"也就是保存个快照\",{\"1\":{\"687\":1}}],[\"也就是分析每个region的回收收益\",{\"1\":{\"685\":1}}],[\"也就是字节码\",{\"1\":{\"642\":1}}],[\"也就是直接在调用execute方法的线程中运行\",{\"1\":{\"606\":1}}],[\"也就是线程可以再次获取自己的内部锁\",{\"1\":{\"594\":1}}],[\"也就是加\",{\"1\":{\"589\":1}}],[\"也就是不成功就一直循环执行直到成功\",{\"1\":{\"585\":1}}],[\"也就是对这个变量的修改对其后的所有操作都可见\",{\"1\":{\"576\":1}}],[\"也就是并发度固定为16\",{\"1\":{\"550\":1}}],[\"也就是new在堆中创建的对象\",{\"1\":{\"497\":1}}],[\"也就是通过c或者是c++实现的\",{\"1\":{\"491\":1}}],[\"也就是通过辅助索引能定位主键的位置\",{\"1\":{\"264\":1}}],[\"也就是新对象n内部对象和原来的对象o的内部对象是同一个\",{\"1\":{\"488\":1}}],[\"也就是hero能调用的方法是看父类hero的\",{\"1\":{\"486\":1}}],[\"也就是我们平常说的\",{\"1\":{\"456\":1}}],[\"也就是前一个节点被删除\",{\"1\":{\"381\":1}}],[\"也就是数据在网络上传输的时间\",{\"1\":{\"331\":1}}],[\"也就是范围查询的字段可以用到联合索引\",{\"1\":{\"271\":1}}],[\"也就是按照最左优先的方式进行索引的匹配\",{\"1\":{\"271\":1}}],[\"也就是再执行一遍\",{\"1\":{\"248\":1}}],[\"也就是aid是手段\",{\"1\":{\"231\":1}}],[\"也就是这个字段只能是一个值\",{\"1\":{\"218\":1}}],[\"也就是它在互联网中的定位发生了变化\",{\"1\":{\"213\":1}}],[\"也就是由小到大逐渐增大拥塞窗口数值\",{\"1\":{\"201\":1}}],[\"也就是接口的幂等性\",{\"1\":{\"155\":1}}],[\"也就是客户端ip\",{\"1\":{\"52\":1}}],[\"也就是应用操作之后会直接返回\",{\"1\":{\"23\":1}}],[\"也就是\",{\"1\":{\"23\":1,\"175\":1,\"671\":1,\"672\":1}}],[\"也就是边扫描边观察指定方向上还有无请求\",{\"1\":{\"16\":1}}],[\"也就是说堆中不存在该类的实例对象\",{\"1\":{\"707\":1}}],[\"也就是说字符串常量池被单独拿到堆\",{\"1\":{\"671\":1}}],[\"也就是说正在等待的线程可以选择放弃等待\",{\"1\":{\"594\":1}}],[\"也就是说bean是线程不安全的\",{\"1\":{\"451\":1}}],[\"也就是说同一个类可以创建多个实例\",{\"1\":{\"435\":1}}],[\"也就是说slots越小\",{\"1\":{\"430\":1}}],[\"也就是说当内存不足以容纳新写入数据时\",{\"1\":{\"328\":1}}],[\"也就是说关系型数据库中创建的表一定满足第一范式\",{\"1\":{\"218\":1}}],[\"也就是说访问\",{\"1\":{\"48\":1}}],[\"也就是说\",{\"1\":{\"12\":1,\"18\":1,\"175\":1,\"282\":1,\"334\":1,\"416\":1,\"607\":1,\"625\":1,\"710\":2}}],[\"也就转到了内核态\",{\"1\":{\"3\":1}}],[\"即该类的class对象被gc\",{\"1\":{\"707\":1}}],[\"即是静态变量\",{\"1\":{\"704\":1}}],[\"即扩展名为\",{\"1\":{\"689\":1}}],[\"即对象指向他的类数据的指针\",{\"1\":{\"654\":1}}],[\"即通过字面我们就能知道其值的含义\",{\"1\":{\"646\":1}}],[\"即如果对队列加锁的成本较高则适合使用无锁的\",{\"1\":{\"630\":1}}],[\"即永远不会阻塞\",{\"1\":{\"607\":1}}],[\"即认为将要修改的数据并没有被其他线程修改\",{\"1\":{\"581\":1}}],[\"即在其他cpu中也存在该变量的副本\",{\"1\":{\"579\":1}}],[\"即读写屏障\",{\"1\":{\"579\":1}}],[\"即读取的快照数据\",{\"1\":{\"285\":1}}],[\"即立刻进行flush\",{\"1\":{\"579\":1}}],[\"即立刻让cpu\",{\"1\":{\"579\":1}}],[\"即时编译器编译之后的代码\",{\"1\":{\"560\":1}}],[\"即总是优先级最高的元素先出队\",{\"1\":{\"539\":1}}],[\"即向数组中添加第一个元素时\",{\"1\":{\"532\":1}}],[\"即方法名相同\",{\"1\":{\"480\":1}}],[\"即应用上下文\",{\"1\":{\"463\":1}}],[\"即可表示\",{\"1\":{\"400\":1}}],[\"即可以支持反向查找和遍历\",{\"1\":{\"386\":1}}],[\"即可\",{\"1\":{\"374\":1}}],[\"即可保持基本平衡状态\",{\"1\":{\"261\":1}}],[\"即以空字符\",{\"1\":{\"311\":1}}],[\"即下一个将被分配的事务\",{\"1\":{\"288\":1}}],[\"即相同的黑色高度\",{\"1\":{\"261\":1}}],[\"即仅锁住索引本身\",{\"1\":{\"238\":1}}],[\"即每经过一个往返时间\",{\"1\":{\"201\":1}}],[\"即由小到大逐渐增大发送窗口\",{\"1\":{\"201\":1}}],[\"即返回码是\",{\"1\":{\"181\":1}}],[\"即执行多次\",{\"1\":{\"176\":1}}],[\"即消息发出并且被接收到\",{\"1\":{\"132\":1}}],[\"即将交易结果可靠的通知出去\",{\"1\":{\"132\":1}}],[\"即实现本地事务和消息发送的原子性\",{\"1\":{\"126\":1}}],[\"即使两个类来源于同一个class文件\",{\"1\":{\"714\":1}}],[\"即使被标记为不可达的对象\",{\"1\":{\"669\":1}}],[\"即使部分\",{\"1\":{\"378\":1}}],[\"即使客户端的释放锁的代码逻辑出现问题\",{\"1\":{\"372\":1}}],[\"即使读取的记录已被其它事务加上\",{\"1\":{\"285\":1}}],[\"即使数据库发生故障也不应该对其有任何影响\",{\"1\":{\"231\":1}}],[\"即使数据库没有同步完成\",{\"1\":{\"114\":1}}],[\"即使因为高流量导致秒杀微服务宕机也不会影响到正常的订单微服务\",{\"1\":{\"144\":1}}],[\"即使没有收到mq发送方发送的commit\",{\"1\":{\"129\":1}}],[\"即使结果是旧数据\",{\"1\":{\"114\":1}}],[\"即advanced\",{\"1\":{\"74\":1}}],[\"即输入\",{\"1\":{\"18\":1}}],[\"即磁头附近的请求不断被服务\",{\"1\":{\"16\":1}}],[\"即一些后到的磁盘请求可能需要等待很长时间才能得到服务\",{\"1\":{\"16\":1}}],[\"即\",{\"1\":{\"9\":1,\"15\":1,\"123\":1,\"182\":1,\"374\":1}}],[\"即进程控制块\",{\"1\":{\"8\":1}}],[\"存活对象少了\",{\"1\":{\"735\":1}}],[\"存活时间越长\",{\"1\":{\"426\":1}}],[\"存活时间大于订单的释放时间\",{\"1\":{\"155\":1}}],[\"存放的数据不能重复的场景\",{\"1\":{\"314\":1}}],[\"存放的是整个对象\",{\"1\":{\"310\":1}}],[\"存放在消息队列中的消息并不一定会立即被处理\",{\"1\":{\"75\":1}}],[\"存放在内存中并由消息队列标识符标识\",{\"1\":{\"9\":1}}],[\"存在一定的误差\",{\"1\":{\"401\":1}}],[\"存在一些缺陷\",{\"1\":{\"385\":1}}],[\"存在一些浪费带宽的现象\",{\"1\":{\"181\":1}}],[\"存在暂时脏数据问题\",{\"1\":{\"152\":1}}],[\"存在于实际的磁盘介质或者文件系统\",{\"1\":{\"9\":1}}],[\"存储了\",{\"1\":{\"612\":1}}],[\"存储了主内存中的变量副本\",{\"1\":{\"573\":1}}],[\"存储元素\",{\"1\":{\"534\":1}}],[\"存储的元素无序\",{\"1\":{\"529\":1}}],[\"存储的元素是有序的\",{\"1\":{\"529\":1}}],[\"存储的是连续的二进制数字\",{\"1\":{\"316\":1,\"398\":1}}],[\"存储的是序列化后的对象数据\",{\"1\":{\"310\":1}}],[\"存储的是\",{\"1\":{\"297\":1}}],[\"存储任意大小的整型数据\",{\"1\":{\"475\":1}}],[\"存储有上限\",{\"1\":{\"421\":1}}],[\"存储更节省内存\",{\"1\":{\"385\":1}}],[\"存储更好呢\",{\"0\":{\"312\":1}}],[\"存储\",{\"1\":{\"312\":1,\"533\":2}}],[\"存储具有多层嵌套的对象时也方便很多\",{\"1\":{\"310\":1}}],[\"存储相对来说更加节省内存\",{\"1\":{\"310\":1}}],[\"存储对象数据更好呢\",{\"0\":{\"310\":1}}],[\"存储引擎使用\",{\"1\":{\"290\":1}}],[\"存储引擎的默认事务隔离级别\",{\"1\":{\"290\":1}}],[\"存储引擎的默认支持的隔离级别是\",{\"1\":{\"235\":1,\"282\":1}}],[\"存储引擎为每行数据添加了三个隐藏字段\",{\"1\":{\"287\":1}}],[\"存储引擎会去读取行的一个快照数据\",{\"1\":{\"284\":1}}],[\"存储引擎中\",{\"1\":{\"284\":1}}],[\"存储函数\",{\"1\":{\"229\":1}}],[\"存储和转发消息\",{\"1\":{\"82\":1}}],[\"存储管理\",{\"1\":{\"2\":1}}],[\"mb\",{\"1\":{\"726\":1}}],[\"mfence\",{\"1\":{\"579\":1}}],[\"mvc\",{\"1\":{\"437\":1,\"463\":1}}],[\"mvcc+next\",{\"0\":{\"292\":1}}],[\"mvcc下解决不可重复读问题\",{\"0\":{\"291\":1}}],[\"mvcc\",{\"0\":{\"286\":1,\"290\":1,\"293\":1},\"1\":{\"234\":1,\"239\":1,\"282\":1,\"284\":2,\"285\":1,\"286\":1,\"289\":1,\"290\":1,\"291\":1,\"292\":1}}],[\"multilock\",{\"1\":{\"377\":1}}],[\"mutex\",{\"1\":{\"7\":1}}],[\"misc\",{\"1\":{\"714\":3}}],[\"mixed\",{\"1\":{\"663\":1}}],[\"mi\",{\"1\":{\"405\":1}}],[\"minorgc次数就会减少\",{\"1\":{\"734\":1}}],[\"minorgc\",{\"1\":{\"662\":1}}],[\"minor\",{\"0\":{\"692\":1},\"1\":{\"660\":1,\"662\":1,\"663\":1,\"664\":4,\"692\":1,\"730\":1}}],[\"min\",{\"1\":{\"350\":1,\"414\":1}}],[\"milliseconds\",{\"1\":{\"158\":1,\"426\":1}}],[\"monitorexit\",{\"1\":{\"589\":7}}],[\"monitorenter\",{\"1\":{\"589\":5}}],[\"monitor命令是redis提供的一种实时查看redis的所有操作的方式\",{\"1\":{\"342\":1}}],[\"modified\",{\"1\":{\"181\":1}}],[\"model\",{\"1\":{\"456\":2,\"713\":1}}],[\"modelandview包含了数据模型以及相应的视图的信息\",{\"1\":{\"456\":1}}],[\"modelandview\",{\"1\":{\"456\":1}}],[\"mode\",{\"1\":{\"83\":1,\"241\":2,\"284\":1,\"285\":2,\"292\":1,\"685\":1}}],[\"mget\",{\"1\":{\"332\":1,\"384\":1}}],[\"m\",{\"1\":{\"288\":9,\"290\":2,\"345\":4,\"362\":4,\"405\":1,\"684\":1}}],[\"mtu\",{\"1\":{\"210\":1}}],[\"mset\",{\"1\":{\"332\":1,\"384\":1}}],[\"msl\",{\"0\":{\"197\":1},\"1\":{\"197\":1}}],[\"ms级的延迟\",{\"1\":{\"79\":1}}],[\"mq\",{\"1\":{\"133\":1}}],[\"mqtt等多种消息\",{\"1\":{\"81\":1}}],[\"mqtt等多种消息中间件协议\",{\"1\":{\"78\":1}}],[\"mp3\",{\"1\":{\"66\":5}}],[\"md5\",{\"1\":{\"62\":1}}],[\"magic\",{\"0\":{\"691\":1},\"1\":{\"691\":2}}],[\"mark\",{\"1\":{\"674\":2,\"683\":2}}],[\"major\",{\"0\":{\"692\":1},\"1\":{\"663\":2,\"692\":1}}],[\"main\",{\"1\":{\"436\":1,\"503\":1}}],[\"mail\",{\"1\":{\"172\":1,\"191\":1}}],[\"master之间通过ping检测彼此健康状况\",{\"1\":{\"429\":1}}],[\"master获取repl\",{\"1\":{\"422\":1}}],[\"master将完整的内存数据生成rdb\",{\"1\":{\"422\":1}}],[\"master才能判断需要更新哪些数据\",{\"1\":{\"420\":1}}],[\"mandatory\",{\"1\":{\"447\":1}}],[\"manipulation\",{\"1\":{\"222\":1}}],[\"manual\",{\"1\":{\"101\":1}}],[\"match\",{\"1\":{\"179\":1,\"181\":2}}],[\"mac\",{\"0\":{\"213\":1},\"1\":{\"105\":1,\"174\":2,\"213\":8,\"214\":3}}],[\"maxheapfreeratio\",{\"1\":{\"726\":1}}],[\"maxmetaspacesize=n\",{\"1\":{\"721\":1}}],[\"maxpermsize=n\",{\"1\":{\"721\":1}}],[\"maxnewsize=1024m\",{\"1\":{\"720\":1}}],[\"maxnewsize指定\",{\"1\":{\"720\":1}}],[\"maxtenuringthreshold=threshold\",{\"1\":{\"731\":1}}],[\"maxtenuringthreshold\",{\"1\":{\"662\":2}}],[\"maximumpoolsize\",{\"1\":{\"604\":1,\"605\":2}}],[\"max\",{\"1\":{\"57\":1,\"61\":1,\"346\":1,\"350\":1,\"604\":5,\"607\":3,\"633\":1}}],[\"map不断的放入对象\",{\"1\":{\"729\":1}}],[\"map\",{\"0\":{\"529\":1,\"542\":1},\"1\":{\"529\":1,\"530\":1,\"599\":3,\"627\":1,\"729\":1}}],[\"map<string\",{\"1\":{\"31\":1}}],[\"mappedstatement>的key使用的\",{\"1\":{\"31\":1}}],[\"mappedstatement\",{\"1\":{\"30\":5,\"32\":1}}],[\"mapper\",{\"1\":{\"30\":1}}],[\"mywebapplicationinitializer\",{\"1\":{\"458\":1}}],[\"myisam引擎中\",{\"1\":{\"262\":1}}],[\"myisam引擎和innodb引擎都是使用b+树作为索引结构\",{\"1\":{\"262\":1}}],[\"myisam引擎innodb引擎都是使用b+tree作为索引结构\",{\"1\":{\"228\":1}}],[\"myisam和innodb都支持表级锁\",{\"1\":{\"237\":1}}],[\"myisam不支持并发\",{\"1\":{\"228\":1}}],[\"myisam不支持\",{\"1\":{\"228\":3}}],[\"myisam不提供事务\",{\"1\":{\"228\":1}}],[\"myisam一锁就是整张表\",{\"1\":{\"228\":1}}],[\"myisam只有表级锁\",{\"1\":{\"228\":1}}],[\"myisam是mysql的默认存储引擎\",{\"1\":{\"227\":1}}],[\"myisam\",{\"0\":{\"228\":1},\"1\":{\"226\":1,\"237\":1,\"243\":1}}],[\"mydata\",{\"1\":{\"108\":5}}],[\"mycache\",{\"1\":{\"58\":1}}],[\"mysql事务隔离级别\",{\"0\":{\"280\":1}}],[\"mysql日志\",{\"0\":{\"279\":1}}],[\"mysql索引\",{\"0\":{\"255\":1}}],[\"mysql提供了两个方法来处理ip地址\",{\"1\":{\"242\":1}}],[\"mysql如何存储ip地址\",{\"0\":{\"242\":1}}],[\"mysql的myisam引擎不管是主键还是非主键\",{\"1\":{\"267\":1}}],[\"mysql的默认隔离级别是什么\",{\"0\":{\"235\":1}}],[\"mysql的隔离级别基于锁和mvcc机制共同实现的\",{\"1\":{\"234\":1}}],[\"mysql的隔离级别是基于锁实现的吗\",{\"0\":{\"234\":1}}],[\"mysql的查询缓存系统会跟踪查询中涉及的没一张表\",{\"1\":{\"229\":1}}],[\"mysql中锁定粒度最小的一种锁\",{\"1\":{\"237\":1}}],[\"mysql中锁定粒度最大的锁\",{\"1\":{\"237\":1}}],[\"mysql中并发事务的控制方式有两种\",{\"1\":{\"233\":1}}],[\"mysql中开启事务\",{\"1\":{\"230\":1}}],[\"mysql库中的系统表\",{\"1\":{\"229\":1}}],[\"mysql查询缓存\",{\"0\":{\"229\":1}}],[\"mysql存储引擎\",{\"0\":{\"227\":1}}],[\"mysql主要由下面几个部分构成\",{\"1\":{\"226\":1}}],[\"mysql有什么优点\",{\"0\":{\"225\":1}}],[\"mysql基础架构\",{\"0\":{\"226\":1}}],[\"mysql基础\",{\"0\":{\"223\":1}}],[\"mysql\",{\"0\":{\"230\":1,\"236\":1,\"294\":1},\"1\":{\"29\":1,\"34\":1,\"63\":2,\"226\":1,\"227\":1,\"235\":1,\"243\":7,\"261\":1,\"263\":1,\"282\":1,\"300\":1,\"304\":1,\"346\":1,\"416\":1,\"439\":1,\"442\":1}}],[\"mybatis等框架中都大量使用了反射机制\",{\"1\":{\"507\":1}}],[\"mybatis作为数据库框架\",{\"1\":{\"137\":1}}],[\"mybatis中的执行器有哪些\",{\"0\":{\"35\":1}}],[\"mybatis中的分页\",{\"0\":{\"34\":1}}],[\"mybatisplusinterceptor\",{\"1\":{\"34\":4}}],[\"mybatis的xml映射文件和mybatis内部数据结构的映射关系\",{\"0\":{\"32\":1}}],[\"mybatis的xml映射文件中\",{\"0\":{\"31\":1}}],[\"mybatis\",{\"0\":{\"28\":1},\"1\":{\"29\":1,\"30\":4,\"32\":1,\"34\":1,\"136\":1,\"137\":1}}],[\"metaspacesize参数指定的量\",{\"1\":{\"721\":1}}],[\"metaspacesize=n\",{\"1\":{\"721\":1}}],[\"metaspace\",{\"1\":{\"671\":2,\"721\":5}}],[\"methodhandle和varhandle可以看做轻量级的反射调用机制\",{\"1\":{\"706\":1}}],[\"methods\",{\"0\":{\"697\":1},\"1\":{\"697\":4}}],[\"methodproxy\",{\"1\":{\"515\":1}}],[\"methodinterceptor\",{\"1\":{\"515\":1}}],[\"method2\",{\"1\":{\"476\":1}}],[\"method字段不一样\",{\"1\":{\"175\":1}}],[\"method\",{\"1\":{\"153\":1,\"442\":4,\"476\":1,\"480\":2,\"501\":2,\"507\":7,\"510\":1,\"514\":3,\"515\":3,\"697\":2}}],[\"method包含了channel\",{\"1\":{\"97\":1}}],[\"merge\",{\"1\":{\"243\":3}}],[\"media\",{\"1\":{\"66\":2,\"213\":1}}],[\"memcached\",{\"0\":{\"299\":1},\"1\":{\"299\":7}}],[\"member2\",{\"1\":{\"315\":1,\"393\":1,\"396\":1,\"405\":2}}],[\"member1\",{\"1\":{\"315\":1,\"393\":1,\"396\":1,\"405\":3}}],[\"memberresponsevo\",{\"1\":{\"155\":1}}],[\"membermap\",{\"1\":{\"33\":1}}],[\"memberentity\",{\"1\":{\"33\":1}}],[\"member\",{\"1\":{\"33\":1,\"393\":1,\"396\":2,\"405\":1}}],[\"memory命令可查看redis内存相关的信息\",{\"1\":{\"349\":1}}],[\"memory等多种存储引擎\",{\"1\":{\"226\":1}}],[\"memory\",{\"1\":{\"9\":1,\"12\":2,\"579\":1}}],[\"messagesourse\",{\"1\":{\"452\":1}}],[\"message\",{\"1\":{\"9\":1,\"74\":2,\"78\":1,\"80\":1,\"93\":1,\"95\":1,\"100\":2,\"156\":1,\"174\":1,\"210\":1}}],[\"只与类有关\",{\"1\":{\"704\":1}}],[\"只面向虚拟机\",{\"1\":{\"689\":1}}],[\"只标识着某个内存区域是否为脏\",{\"1\":{\"687\":1}}],[\"只对老年代进行垃圾收集\",{\"1\":{\"663\":1}}],[\"只对新生代进行垃圾收集\",{\"1\":{\"663\":1}}],[\"只对单个共享变量有效\",{\"1\":{\"585\":1}}],[\"只锁定当前链表或红黑二叉树的首节点\",{\"1\":{\"551\":1}}],[\"只会使用一条垃圾收集线程去完成垃圾收集工作\",{\"1\":{\"678\":1}}],[\"只会分配一次内存\",{\"1\":{\"477\":1}}],[\"只会在取出key的时候才对数据进行过期检查\",{\"1\":{\"327\":1}}],[\"只会重新映射部分键\",{\"1\":{\"60\":1}}],[\"只支持出栈和入栈两种操作\",{\"1\":{\"641\":1}}],[\"只支持最简单的\",{\"1\":{\"299\":1}}],[\"只支持点对点通信\",{\"1\":{\"188\":1}}],[\"只不过方法区的实现从永久代变成了元空间\",{\"1\":{\"671\":1}}],[\"只不过范围比较小\",{\"1\":{\"435\":1}}],[\"只不过会在记录头\",{\"1\":{\"287\":1}}],[\"只不过扫描的是索引\",{\"1\":{\"243\":1}}],[\"只需要付出少量对象的复制成本就能完成垃圾收集\",{\"1\":{\"676\":1}}],[\"只需要在这个文件中添加类路径名\",{\"1\":{\"462\":1}}],[\"只需要\",{\"1\":{\"401\":1}}],[\"只需要一个\",{\"1\":{\"398\":1}}],[\"只需要一次网络传输\",{\"1\":{\"333\":1}}],[\"只需要监听前一个节点就好了\",{\"1\":{\"380\":1}}],[\"只需要拍对链表进行遍历即可\",{\"1\":{\"262\":1}}],[\"只需要将消费者关联到这个消息队列中\",{\"1\":{\"71\":1}}],[\"只针对当前操作的行记录进行加锁\",{\"1\":{\"237\":1}}],[\"只删除表中的数据\",{\"1\":{\"221\":1}}],[\"只是根据对象存活周期的不同将内存分为几块\",{\"1\":{\"676\":1}}],[\"只是参照的中心点是\",{\"1\":{\"405\":1}}],[\"只是实现了这个算法并提供了一些开箱即用的\",{\"1\":{\"401\":1}}],[\"只是功能依然非常简陋\",{\"1\":{\"388\":1}}],[\"只是功能过于简单且存在很多缺陷\",{\"1\":{\"388\":1}}],[\"只是对表内部数据的操作\",{\"1\":{\"222\":1}}],[\"只是\",{\"1\":{\"175\":1,\"713\":1}}],[\"只提供消息接收的可靠性机制\",{\"1\":{\"132\":1}}],[\"只要加载它们的类加载器不同\",{\"1\":{\"714\":1}}],[\"只要知道这个方法在方法表中的偏移量就能调用这个方法了\",{\"1\":{\"705\":1}}],[\"只要能无歧义的定位到目标即可\",{\"1\":{\"705\":1}}],[\"只要对象大小超过region的一半\",{\"1\":{\"686\":1}}],[\"只要\",{\"1\":{\"416\":1}}],[\"只要保证\",{\"1\":{\"378\":1}}],[\"只要我不让你插入\",{\"1\":{\"292\":1}}],[\"只要四次挥手没有结束\",{\"1\":{\"195\":1}}],[\"只要在网络节点上捉包\",{\"1\":{\"175\":1}}],[\"只要在服务端做好支持就好了\",{\"1\":{\"175\":1}}],[\"只要服务端能够解释出来就行\",{\"1\":{\"175\":1}}],[\"只要mq订阅方没有返回ack则会一直给他消费\",{\"1\":{\"129\":1}}],[\"只要try成功\",{\"1\":{\"123\":1}}],[\"只要最终会退款即可\",{\"1\":{\"117\":1}}],[\"只在磁盘的一侧进行扫描\",{\"1\":{\"16\":1}}],[\"只可对文件创建\",{\"1\":{\"15\":1}}],[\"只能再次全量同步\",{\"1\":{\"421\":1}}],[\"只能通过\",{\"1\":{\"306\":1}}],[\"只能通过添加过期时间缓解\",{\"1\":{\"152\":1}}],[\"只能读取到第一次查询之前所插入的数据\",{\"1\":{\"285\":1}}],[\"只能对已存在的文件进行创建\",{\"1\":{\"15\":1}}],[\"只能用于亲缘关系的进程间通信\",{\"1\":{\"9\":1}}],[\"只有两者都是一样的才认为是相同的java类\",{\"1\":{\"714\":1}}],[\"只有父类加载器反馈不能完成这个加载请求的时候\",{\"1\":{\"714\":1}}],[\"只有它能与\",{\"1\":{\"679\":1}}],[\"只有写入和写入之间需要进行同步等待\",{\"1\":{\"628\":1}}],[\"只有拿到许可证的线程才能执行\",{\"1\":{\"624\":1}}],[\"只有获取到共享资源的线程才能执行\",{\"1\":{\"624\":1}}],[\"只有一个线程能执行\",{\"1\":{\"623\":1}}],[\"只有同步到磁盘中才算持久化保存\",{\"1\":{\"410\":1}}],[\"只有指定字段不存在时设置指定字段的值\",{\"1\":{\"390\":1}}],[\"只有未指定锁超时时间\",{\"1\":{\"376\":1}}],[\"只有当\",{\"1\":{\"375\":1}}],[\"只有叶子节点存储data\",{\"1\":{\"262\":1}}],[\"只有在被用到的时候才会实例化\",{\"1\":{\"524\":1}}],[\"只有在调用方法用到属性的时候才会进行初始化\",{\"1\":{\"450\":1}}],[\"只有在\",{\"1\":{\"384\":1}}],[\"只有在事务隔离级别rc和rr下\",{\"1\":{\"241\":1}}],[\"只有在内核重启\",{\"1\":{\"9\":1}}],[\"只有保证了事务的持久性\",{\"1\":{\"231\":1}}],[\"只有到达磁盘边界时才能改变磁头移动方向\",{\"1\":{\"16\":1}}],[\"只有拥有互斥对象的线程才有访问公共资源的权限\",{\"1\":{\"7\":1}}],[\"只存在于内存中的文件\",{\"1\":{\"9\":1}}],[\"n个线程同时被唤醒\",{\"1\":{\"625\":1}}],[\"n>5\",{\"1\":{\"624\":1}}],[\"n表示cpu核心数\",{\"1\":{\"609\":1}}],[\"n表示节点数\",{\"1\":{\"430\":1}}],[\"n+1\",{\"1\":{\"609\":1}}],[\"n对象中的内部对象是引用类型的话\",{\"1\":{\"488\":1}}],[\"nx\",{\"1\":{\"375\":2}}],[\"n\",{\"0\":{\"362\":1},\"1\":{\"259\":2,\"311\":1,\"345\":11,\"362\":14,\"383\":1,\"430\":1,\"472\":2,\"539\":4,\"546\":1,\"548\":2,\"583\":1,\"604\":5,\"624\":2,\"684\":1,\"729\":1}}],[\"ntoa\",{\"1\":{\"242\":2}}],[\"nlri\",{\"1\":{\"174\":1}}],[\"never\",{\"1\":{\"447\":1,\"448\":1}}],[\"nested\",{\"1\":{\"243\":1,\"447\":1}}],[\"next\",{\"1\":{\"238\":3,\"282\":2,\"285\":1,\"292\":2,\"622\":1}}],[\"netty的线程模型也是基于reactor模式\",{\"1\":{\"320\":1}}],[\"net和edu等\",{\"1\":{\"185\":1}}],[\"network\",{\"1\":{\"174\":2,\"210\":1,\"211\":1}}],[\"new对象手下会在tlab中分配\",{\"1\":{\"730\":1}}],[\"newratio=1\",{\"1\":{\"720\":1}}],[\"newratio=<int>\",{\"1\":{\"720\":1}}],[\"newsize=256m\",{\"1\":{\"720\":1}}],[\"newsize和\",{\"1\":{\"720\":1}}],[\"new一个thread\",{\"1\":{\"568\":1}}],[\"newcapacity\",{\"1\":{\"532\":1}}],[\"newproxyinstance\",{\"1\":{\"514\":2}}],[\"new\",{\"0\":{\"22\":1,\"497\":1},\"1\":{\"34\":2,\"100\":1,\"146\":5,\"155\":1,\"199\":1,\"436\":1,\"444\":2,\"447\":1,\"458\":2,\"484\":1,\"486\":1,\"497\":2,\"498\":1,\"509\":1,\"520\":1,\"521\":1,\"522\":1,\"523\":1,\"524\":1,\"561\":1,\"583\":1,\"624\":1,\"653\":1}}],[\"numberofgclogfiles=14\",{\"1\":{\"724\":1}}],[\"number\",{\"0\":{\"691\":1},\"1\":{\"691\":1}}],[\"num2\",{\"1\":{\"476\":2}}],[\"num1\",{\"1\":{\"476\":2}}],[\"numkeys\",{\"1\":{\"396\":4}}],[\"num\",{\"1\":{\"158\":2}}],[\"null\",{\"1\":{\"30\":1,\"243\":4,\"263\":1,\"442\":1,\"522\":1,\"523\":2,\"538\":1,\"546\":1,\"599\":3,\"600\":2,\"634\":1,\"711\":2,\"714\":4}}],[\"nanotime\",{\"1\":{\"714\":2}}],[\"navigablemap\",{\"1\":{\"544\":1}}],[\"native\",{\"1\":{\"642\":1}}],[\"nat作用是什么\",{\"0\":{\"211\":1}}],[\"nat\",{\"1\":{\"174\":2,\"210\":1,\"211\":2}}],[\"nacos作为注册中心和配置中心\",{\"1\":{\"137\":1}}],[\"nack\",{\"1\":{\"93\":1}}],[\"namespace+id是作为\",{\"1\":{\"31\":1}}],[\"namespace\",{\"1\":{\"30\":1}}],[\"name\",{\"1\":{\"29\":2,\"48\":2,\"51\":1,\"53\":1,\"59\":1,\"62\":1,\"107\":1,\"108\":1,\"150\":1,\"153\":1,\"172\":1,\"184\":1,\"191\":1,\"476\":1,\"712\":3,\"714\":6}}],[\"named\",{\"1\":{\"9\":1}}],[\"nginx可以配置正向代理\",{\"1\":{\"142\":1}}],[\"nginx可以配置正向代理吗\",{\"0\":{\"142\":1}}],[\"nginx动静分离\",{\"0\":{\"141\":1}}],[\"nginx的负载均衡算法有哪些\",{\"0\":{\"140\":1}}],[\"nginx代理服务器其实建立了两次tcp连接\",{\"1\":{\"139\":1,\"142\":1}}],[\"nginx反向代理怎么配置的\",{\"0\":{\"142\":1}}],[\"nginx反向代理包含7层反向代理\",{\"1\":{\"139\":1}}],[\"nginx反向代理在计算机网络的第几层\",{\"0\":{\"139\":1}}],[\"nginx用来动静分离\",{\"1\":{\"137\":1}}],[\"nginx容器就能直接读取\",{\"1\":{\"108\":1}}],[\"nginx将会标记服务器为失败\",{\"1\":{\"61\":1}}],[\"nginx将流量分配到多个服务器\",{\"1\":{\"59\":1}}],[\"nginx将响应保存在磁盘中\",{\"1\":{\"58\":1}}],[\"nginx以尽可能快的速度将响应读入缓冲区中\",{\"1\":{\"57\":1}}],[\"nginx先将后端的请求响应\",{\"1\":{\"57\":1}}],[\"nginx主机ip和端口\",{\"1\":{\"52\":1}}],[\"nginx主机ip\",{\"1\":{\"52\":1}}],[\"nginx\",{\"0\":{\"47\":1},\"1\":{\"53\":1,\"58\":1,\"62\":4,\"108\":12,\"136\":1,\"137\":1}}],[\"node\",{\"1\":{\"550\":1,\"551\":1,\"622\":1,\"624\":1}}],[\"node数组+链表\",{\"1\":{\"550\":1}}],[\"node+链表\",{\"1\":{\"550\":1}}],[\"node1\",{\"1\":{\"380\":2}}],[\"not\",{\"1\":{\"374\":1,\"399\":1}}],[\"notifyall\",{\"1\":{\"594\":1}}],[\"notify\",{\"1\":{\"7\":1,\"381\":1}}],[\"no\",{\"1\":{\"328\":1,\"412\":1,\"427\":1}}],[\"nonfairsync\",{\"1\":{\"592\":1}}],[\"none\",{\"1\":{\"101\":1,\"181\":1}}],[\"non\",{\"0\":{\"22\":1}}],[\"nio中的n可以理解为non\",{\"1\":{\"22\":1}}],[\"nio包\",{\"1\":{\"22\":1}}],[\"nio\",{\"0\":{\"22\":1},\"1\":{\"23\":3}}],[\"匿名管道由于没有名字\",{\"1\":{\"9\":1}}],[\"匿名管道\",{\"1\":{\"9\":1}}],[\"old收集器\",{\"0\":{\"681\":1}}],[\"old\",{\"0\":{\"682\":1},\"1\":{\"663\":1,\"682\":1}}],[\"oldcapacity\",{\"1\":{\"532\":2}}],[\"oom\",{\"0\":{\"725\":1},\"1\":{\"607\":1}}],[\"offerlast\",{\"1\":{\"537\":1}}],[\"offerfirst\",{\"1\":{\"537\":1}}],[\"offer\",{\"1\":{\"537\":1}}],[\"offset落后于master则表示需要更新\",{\"1\":{\"420\":1}}],[\"offset\",{\"1\":{\"316\":1,\"399\":4,\"420\":1}}],[\"obj\",{\"1\":{\"515\":2}}],[\"object类\",{\"1\":{\"715\":1}}],[\"object对象为value的键值对\",{\"1\":{\"599\":1}}],[\"object\",{\"0\":{\"489\":1},\"1\":{\"436\":2,\"507\":6,\"514\":4,\"515\":3,\"530\":4,\"546\":1,\"695\":2}}],[\"objects\",{\"1\":{\"146\":1}}],[\"operation\",{\"1\":{\"399\":1}}],[\"openjdk\",{\"1\":{\"726\":1}}],[\"open\",{\"1\":{\"174\":1}}],[\"ok\",{\"1\":{\"326\":1,\"375\":1}}],[\"or\",{\"1\":{\"243\":1,\"278\":2,\"316\":1,\"399\":1}}],[\"org\",{\"1\":{\"185\":1}}],[\"orderservice\",{\"1\":{\"444\":1}}],[\"order\",{\"1\":{\"155\":1,\"158\":1,\"243\":1}}],[\"orderconstant\",{\"1\":{\"155\":1}}],[\"ordertoken\",{\"1\":{\"155\":2}}],[\"ospf\",{\"1\":{\"174\":1}}],[\"override\",{\"1\":{\"100\":1,\"146\":1,\"439\":1,\"458\":1,\"485\":1}}],[\"onoutofmemoryerror\",{\"1\":{\"725\":1}}],[\"onoutofmemoryerror=\",{\"1\":{\"725\":2}}],[\"onstartup\",{\"1\":{\"458\":1}}],[\"only\",{\"1\":{\"410\":1}}],[\"onceperrequestfilter用来做请求拦截并根据情况做业务处理之后放行\",{\"1\":{\"148\":1}}],[\"onceperrequestfilter的实现类\",{\"1\":{\"146\":1}}],[\"on\",{\"1\":{\"57\":1,\"62\":1,\"409\":1}}],[\"one命令\",{\"1\":{\"427\":1}}],[\"one\",{\"1\":{\"32\":1}}],[\"o系统调用论文数据是否已经准备好的过程是很消耗cpu资源的\",{\"1\":{\"22\":1}}],[\"o多路复用模型\",{\"1\":{\"22\":1}}],[\"o操作方法\",{\"1\":{\"22\":1}}],[\"outofmemory\",{\"1\":{\"670\":1,\"725\":1}}],[\"outofmemoryerror\",{\"1\":{\"646\":1,\"721\":2,\"725\":1}}],[\"outpu\",{\"1\":{\"18\":1}}],[\"out\",{\"1\":{\"9\":1,\"100\":1,\"436\":2,\"448\":2,\"476\":2,\"480\":2,\"484\":5,\"498\":3,\"499\":1,\"501\":1,\"503\":2,\"507\":2}}],[\"o\",{\"0\":{\"17\":1,\"21\":1,\"22\":1,\"23\":1,\"362\":1},\"1\":{\"8\":1,\"18\":3,\"19\":5,\"248\":3,\"260\":1,\"261\":2,\"311\":2,\"345\":5,\"362\":9,\"383\":2,\"538\":1,\"609\":1}}],[\"i+1\",{\"1\":{\"539\":1}}],[\"illegalargumentexception\",{\"1\":{\"514\":1}}],[\"illegalaccessexception\",{\"1\":{\"507\":1}}],[\"i=10等价于integer\",{\"1\":{\"472\":1}}],[\"ignore\",{\"1\":{\"350\":1}}],[\"igp\",{\"1\":{\"174\":2}}],[\"i参数控制扫描的频率\",{\"1\":{\"338\":1}}],[\"ix\",{\"1\":{\"240\":2}}],[\"isannotationpresent\",{\"1\":{\"442\":1}}],[\"isinitializingbean\",{\"1\":{\"439\":1}}],[\"is\",{\"1\":{\"240\":3}}],[\"isp\",{\"1\":{\"185\":1}}],[\"isnull\",{\"1\":{\"146\":1}}],[\"icmpv6\",{\"1\":{\"210\":2}}],[\"icmp\",{\"1\":{\"174\":2,\"210\":1}}],[\"if\",{\"1\":{\"146\":1,\"155\":1,\"179\":2,\"181\":4,\"374\":2,\"376\":1,\"442\":1,\"522\":1,\"523\":2,\"539\":2,\"579\":2,\"599\":1,\"714\":4}}],[\"if>\",{\"1\":{\"30\":1}}],[\"import\",{\"1\":{\"461\":1}}],[\"implements\",{\"1\":{\"146\":1,\"439\":1,\"458\":1,\"495\":1,\"507\":1,\"599\":1,\"695\":1}}],[\"imap\",{\"1\":{\"172\":5,\"191\":5}}],[\"image\",{\"1\":{\"109\":1}}],[\"img\",{\"1\":{\"54\":3}}],[\"item\",{\"1\":{\"29\":2}}],[\"ioc\",{\"1\":{\"434\":1}}],[\"io多路复用程序\",{\"1\":{\"321\":1}}],[\"io多路复用技术的使用让redis不需要额外创建多余的线程来监听客户端的大量连接\",{\"1\":{\"321\":1}}],[\"io多路复用\",{\"1\":{\"320\":1}}],[\"io多路复用模型\",{\"1\":{\"22\":1}}],[\"io多路复用模型中\",{\"1\":{\"22\":1}}],[\"io\",{\"0\":{\"19\":1,\"20\":1},\"1\":{\"18\":4,\"19\":1,\"21\":1,\"23\":1,\"261\":1,\"298\":1,\"299\":2,\"495\":1}}],[\"ip中的应用层\",{\"1\":{\"504\":1}}],[\"ip><masterport>\",{\"1\":{\"418\":1,\"427\":1}}],[\"ip寻址如何工作\",{\"0\":{\"209\":1}}],[\"ip协议中最重要的协议之一\",{\"1\":{\"208\":1}}],[\"ip协议的作用是什么\",{\"0\":{\"208\":1}}],[\"ipv6采用128位的地址\",{\"1\":{\"210\":1}}],[\"ipv6\",{\"0\":{\"210\":1},\"1\":{\"174\":1,\"210\":7}}],[\"ipv4\",{\"0\":{\"210\":1},\"1\":{\"174\":1,\"210\":2,\"211\":1}}],[\"ip\",{\"0\":{\"207\":1},\"1\":{\"9\":1,\"52\":1,\"60\":3,\"140\":1,\"172\":1,\"174\":8,\"175\":1,\"181\":1,\"184\":1,\"185\":3,\"191\":1,\"208\":1,\"209\":1,\"210\":1,\"211\":6,\"213\":7,\"214\":3,\"242\":3,\"403\":1}}],[\"info\",{\"1\":{\"613\":4,\"693\":1,\"696\":2,\"697\":2,\"698\":1,\"713\":1}}],[\"information\",{\"1\":{\"174\":2}}],[\"inheritablethreadlocals\",{\"1\":{\"599\":1}}],[\"invocationtargetexception\",{\"1\":{\"507\":1}}],[\"invocationhandler\",{\"1\":{\"507\":1,\"514\":2}}],[\"invokestatic这4条字节码指令\",{\"1\":{\"706\":1}}],[\"invoke\",{\"1\":{\"442\":1,\"507\":2,\"510\":1,\"514\":2}}],[\"ing\",{\"1\":{\"499\":2}}],[\"increment\",{\"1\":{\"390\":1,\"714\":1}}],[\"incr\",{\"1\":{\"384\":1,\"385\":1}}],[\"instanceof\",{\"1\":{\"439\":1}}],[\"instance\",{\"1\":{\"376\":1}}],[\"insert\",{\"1\":{\"241\":1,\"285\":2,\"292\":1}}],[\"inet\",{\"1\":{\"242\":4}}],[\"innodb存储引擎在rr隔离级别下通过mvcc和next\",{\"1\":{\"292\":1}}],[\"innodb中的主键索引就属于聚簇索引\",{\"1\":{\"266\":1}}],[\"innodb中\",{\"1\":{\"262\":1}}],[\"innodb才会使用快照读\",{\"1\":{\"241\":1}}],[\"innodb会先获取该行数据所在数据表对应的意向锁\",{\"1\":{\"240\":1}}],[\"innodb读写支持并发\",{\"1\":{\"228\":1}}],[\"innodb的性能比myisam性能更好\",{\"1\":{\"228\":1}}],[\"innodb引擎中\",{\"1\":{\"228\":1}}],[\"innodb支持三种行锁定方式\",{\"1\":{\"238\":1}}],[\"innodb支持myisam不支持\",{\"1\":{\"237\":1}}],[\"innodb支持\",{\"1\":{\"228\":1}}],[\"innodb提供事务支持\",{\"1\":{\"228\":1}}],[\"innodb\",{\"0\":{\"228\":1,\"238\":1,\"286\":1},\"1\":{\"235\":1,\"237\":2,\"238\":2,\"239\":1,\"263\":3,\"282\":1,\"284\":2,\"285\":1,\"286\":1,\"287\":2,\"290\":2,\"292\":1,\"304\":1}}],[\"innodb是mysql的默认存储引擎\",{\"1\":{\"227\":1}}],[\"intvalue\",{\"1\":{\"472\":1}}],[\"intset\",{\"1\":{\"382\":2}}],[\"integer\",{\"1\":{\"316\":7,\"326\":2,\"374\":3,\"471\":1,\"472\":2,\"604\":3,\"607\":3,\"633\":1}}],[\"intention\",{\"1\":{\"240\":2}}],[\"intercept\",{\"1\":{\"515\":1}}],[\"interceptor\",{\"1\":{\"34\":3}}],[\"interfaces\",{\"0\":{\"695\":1},\"1\":{\"514\":2,\"695\":3}}],[\"interface\",{\"1\":{\"461\":1,\"514\":1,\"515\":1}}],[\"interior\",{\"1\":{\"174\":2}}],[\"intern\",{\"0\":{\"498\":1},\"1\":{\"498\":3}}],[\"internet\",{\"1\":{\"174\":3,\"210\":1}}],[\"internallockleasetime\",{\"1\":{\"376\":1}}],[\"internal\",{\"1\":{\"12\":1}}],[\"int\",{\"1\":{\"100\":1,\"448\":1,\"469\":1,\"472\":1,\"476\":4,\"503\":2,\"539\":11,\"546\":2,\"575\":3,\"605\":2,\"622\":1,\"704\":1}}],[\"index\",{\"0\":{\"404\":1},\"1\":{\"48\":6,\"53\":3,\"62\":3,\"139\":3,\"142\":3,\"243\":8,\"387\":2,\"404\":1}}],[\"input\",{\"1\":{\"18\":1}}],[\"inode\",{\"1\":{\"15\":1}}],[\"initialization\",{\"1\":{\"700\":1}}],[\"initializingbean\",{\"1\":{\"439\":2,\"442\":1}}],[\"init\",{\"0\":{\"653\":1},\"1\":{\"10\":2}}],[\"in\",{\"1\":{\"9\":1,\"32\":1,\"199\":1,\"241\":2,\"284\":1,\"285\":2,\"292\":1}}],[\"i\",{\"0\":{\"17\":1,\"21\":1,\"22\":1,\"23\":1},\"1\":{\"8\":1,\"18\":3,\"19\":5,\"248\":3,\"328\":5,\"338\":1,\"472\":3,\"539\":15,\"609\":1}}],[\"id越小说明越先被创建\",{\"1\":{\"426\":1}}],[\"id不同则表示是第一次主从同步\",{\"1\":{\"420\":1}}],[\"id和offset\",{\"1\":{\"420\":1}}],[\"id一致表示是同一个数据集\",{\"1\":{\"420\":1}}],[\"ids\",{\"1\":{\"288\":4,\"290\":2}}],[\"id+1\",{\"1\":{\"288\":1}}],[\"id如果相同\",{\"1\":{\"243\":1}}],[\"identifier\",{\"1\":{\"182\":1}}],[\"id帮助客户端和message\",{\"1\":{\"97\":1}}],[\"id字段映射为属性名levelid\",{\"1\":{\"33\":1}}],[\"id重复就会导致数据覆盖\",{\"1\":{\"31\":1}}],[\"id是否可以重复\",{\"0\":{\"31\":1}}],[\"id=\",{\"1\":{\"30\":1,\"33\":1}}],[\"id\",{\"1\":{\"8\":1,\"30\":7,\"33\":3,\"97\":1,\"221\":1,\"243\":1,\"286\":1,\"287\":4,\"288\":12,\"312\":2,\"316\":1,\"317\":1,\"420\":1,\"725\":1}}],[\"运行步骤\",{\"1\":{\"683\":1}}],[\"运行状态\",{\"1\":{\"561\":1}}],[\"运行时常量池还在方法区\",{\"1\":{\"671\":1}}],[\"运行时常量池剩下的东西还在方法区\",{\"1\":{\"671\":1}}],[\"运行时常量池\",{\"0\":{\"646\":1}}],[\"运行时数据区\",{\"1\":{\"645\":1}}],[\"运行时数据区域的一块逻辑区域\",{\"1\":{\"645\":1}}],[\"运行时数据区域\",{\"0\":{\"638\":1}}],[\"运行时编译器\",{\"1\":{\"467\":1}}],[\"运行时会使用\",{\"1\":{\"30\":1}}],[\"运行应用\",{\"1\":{\"463\":1}}],[\"运行于\",{\"1\":{\"191\":2}}],[\"运行在\",{\"1\":{\"180\":1}}],[\"运行上述命令会先去下载镜像redis\",{\"1\":{\"107\":1}}],[\"运行\",{\"1\":{\"8\":1}}],[\"就已经开始了\",{\"1\":{\"721\":1}}],[\"就重写\",{\"1\":{\"712\":1,\"716\":1}}],[\"就重传超时的帧\",{\"1\":{\"205\":1}}],[\"就重传前面发送过的分组\",{\"1\":{\"203\":1}}],[\"就需要每个region都维护一个remember\",{\"1\":{\"684\":1}}],[\"就需要选举新的slave作为master\",{\"1\":{\"426\":1}}],[\"就将还存活的对象复制到另一块去\",{\"1\":{\"675\":1}}],[\"就说明常量\",{\"1\":{\"671\":1}}],[\"就代表一定会被回收吗\",{\"0\":{\"669\":1}}],[\"就应该尽可能的减少实现同步互斥所带来的一系列损耗\",{\"1\":{\"618\":1}}],[\"就新建一个线程来执行任务\",{\"1\":{\"608\":1}}],[\"就只能等到拿到锁以后才能进行其他的逻辑处理\",{\"1\":{\"595\":1}}],[\"就只有加密\",{\"1\":{\"175\":1}}],[\"就属于是不可中断锁\",{\"1\":{\"595\":1}}],[\"就属于是可中断锁\",{\"1\":{\"595\":1}}],[\"就属于非聚簇索引\",{\"1\":{\"267\":1}}],[\"就对应着栈帧的入栈和出栈\",{\"1\":{\"559\":1}}],[\"就加锁成功了\",{\"1\":{\"379\":1}}],[\"就认为客户端成功地获得分布式锁\",{\"1\":{\"378\":1}}],[\"就锁的过期时间设置为\",{\"1\":{\"376\":1}}],[\"就能破坏双亲委派\",{\"1\":{\"714\":1}}],[\"就能过滤掉部分恶意请求\",{\"1\":{\"353\":1}}],[\"就能完整地获取数据报文\",{\"1\":{\"175\":1}}],[\"就可以把它们当做栈上数据\",{\"1\":{\"616\":1}}],[\"就可以立即让磁头返回\",{\"1\":{\"16\":1}}],[\"就可以立即改变磁头移动方向\",{\"1\":{\"16\":1}}],[\"就可能包括空字符\",{\"1\":{\"311\":1}}],[\"就非常适合\",{\"1\":{\"310\":2}}],[\"就没有问题了么\",{\"1\":{\"302\":1}}],[\"就从db中读取数据返回\",{\"1\":{\"302\":1}}],[\"就单机\",{\"1\":{\"300\":1}}],[\"就不会发生幻读\",{\"1\":{\"292\":1}}],[\"就不符合最左匹配原则\",{\"1\":{\"271\":1}}],[\"就丢弃该分组\",{\"1\":{\"203\":1}}],[\"就把发送方的\",{\"1\":{\"201\":1}}],[\"就给每个包一个序列号\",{\"1\":{\"199\":1}}],[\"就证明服务端已正常关闭\",{\"1\":{\"195\":1}}],[\"就知道如何正确将消息路由到队列了\",{\"1\":{\"84\":1}}],[\"就会发生\",{\"1\":{\"721\":1}}],[\"就会被系统清理出常量池了\",{\"1\":{\"671\":1}}],[\"就会被晋升到老年代中\",{\"1\":{\"662\":1}}],[\"就会在回收对象的内存之前\",{\"1\":{\"670\":1}}],[\"就会转入下一层链表继续找\",{\"1\":{\"635\":1}}],[\"就会释放所有等待的线程\",{\"1\":{\"625\":1}}],[\"就会使用操作系统互斥量达到互斥同步\",{\"1\":{\"618\":1}}],[\"就会放入到阻塞队列中\",{\"1\":{\"607\":1}}],[\"就会将对应的机器码保存下来\",{\"1\":{\"467\":1}}],[\"就会将该命令记录在慢查询日志\",{\"1\":{\"346\":1}}],[\"就会采用jdk动态代理来生成该接口的代理对象\",{\"1\":{\"449\":1}}],[\"就会拒绝启动并提供相应的错误信息\",{\"1\":{\"415\":1}}],[\"就会阻塞主线程\",{\"1\":{\"363\":1}}],[\"就会导致内存泄漏\",{\"1\":{\"729\":1}}],[\"就会导致大量的请求落入数据库\",{\"1\":{\"356\":1}}],[\"就会导致每次的请求都会请求数据库\",{\"1\":{\"352\":1}}],[\"就会造成缓冲区溢出\",{\"1\":{\"311\":1}}],[\"就会直接报异常\",{\"1\":{\"299\":1}}],[\"就会产生幻读\",{\"1\":{\"285\":1,\"292\":1}}],[\"就会重新发送\",{\"1\":{\"197\":1}}],[\"就会带来一致性问题\",{\"1\":{\"73\":1}}],[\"就会从用户态切换为内核态\",{\"1\":{\"3\":1}}],[\"就剩下id\",{\"1\":{\"31\":1}}],[\"就是废弃常量\",{\"1\":{\"671\":1}}],[\"就是一个抽象类\",{\"1\":{\"620\":1}}],[\"就是偏心的\",{\"1\":{\"619\":1}}],[\"就是用一个预期值和要更新的变量值进行比较\",{\"1\":{\"583\":1}}],[\"就是使用了乐观锁的一种实现方式\",{\"1\":{\"581\":1}}],[\"就是将gc\",{\"1\":{\"687\":1}}],[\"就是将项目中的自动配置类导入到spring容器中\",{\"1\":{\"461\":1}}],[\"就是将服务器停止服务\",{\"1\":{\"165\":1}}],[\"就是三个map集合\",{\"1\":{\"450\":1}}],[\"就是标识有效部分\",{\"1\":{\"430\":1}}],[\"就是锁定读\",{\"1\":{\"285\":1}}],[\"就是联合索引\",{\"1\":{\"270\":2}}],[\"就是对应元素本身\",{\"1\":{\"316\":1,\"398\":1}}],[\"就是对单表的数据进行拆分\",{\"1\":{\"251\":1}}],[\"就是对数据库内部的对象进行创建\",{\"1\":{\"222\":1}}],[\"就是给行记录加x锁或者s锁\",{\"1\":{\"241\":1}}],[\"就是单纯的\",{\"1\":{\"241\":1}}],[\"就是说用户代理需要采取进一步措施才能满足要求\",{\"1\":{\"179\":1}}],[\"就是说rabbitmq在一条tcp链接上建立成百上千个信道来达到多个线程处理\",{\"1\":{\"97\":1}}],[\"就是仅仅提供较少的核心功能\",{\"1\":{\"79\":1}}],[\"就是匹配\",{\"1\":{\"66\":1}}],[\"就是传递给\",{\"1\":{\"30\":1}}],[\"就是映射文件中\",{\"1\":{\"30\":1}}],[\"就是映射文件中的\",{\"1\":{\"30\":1}}],[\"就绪\",{\"1\":{\"8\":1}}],[\"包和类以及被\",{\"1\":{\"711\":1}}],[\"包和类\",{\"1\":{\"711\":2}}],[\"包中\",{\"1\":{\"627\":1}}],[\"包下面\",{\"1\":{\"620\":1}}],[\"包装类的缓存机制\",{\"0\":{\"471\":1}}],[\"包装类型占用的空间比基本类型要大\",{\"1\":{\"470\":1}}],[\"包装类型能用于泛型\",{\"1\":{\"470\":1}}],[\"包装器设计模式\",{\"1\":{\"437\":1}}],[\"包含jre和一些其他的工具\",{\"1\":{\"466\":1}}],[\"包含和管理应用对象的配置和声明周期\",{\"1\":{\"434\":1}}],[\"包含记录本身\",{\"1\":{\"238\":1,\"292\":1}}],[\"包含时间段校验\",{\"1\":{\"162\":1}}],[\"包含当前所处时间是否处于秒杀时间\",{\"1\":{\"158\":1}}],[\"包含类型和加密算法\",{\"1\":{\"150\":1}}],[\"包含谷粒商城\",{\"1\":{\"135\":1}}],[\"包含哪些信息\",{\"0\":{\"8\":1}}],[\"包括下面三类常量\",{\"1\":{\"693\":1}}],[\"包括实例和类数据\",{\"1\":{\"655\":1}}],[\"包括私有属性和私有方法\",{\"1\":{\"486\":1}}],[\"包括了合并beandefinition\",{\"1\":{\"453\":1}}],[\"包括读写\",{\"1\":{\"342\":1}}],[\"包括用户名和密码\",{\"1\":{\"172\":1,\"191\":1}}],[\"包括通用寄存器\",{\"1\":{\"8\":1}}],[\"包括文件描述符\",{\"1\":{\"8\":1}}],[\"包括\",{\"1\":{\"8\":1,\"54\":1,\"694\":1}}],[\"包括进程阻塞原因\",{\"1\":{\"8\":1}}],[\"包括进程的名称\",{\"1\":{\"8\":1}}],[\"并记录下直接与\",{\"1\":{\"683\":1}}],[\"并行垃圾收集器\",{\"1\":{\"723\":1}}],[\"并行与并发\",{\"1\":{\"684\":1}}],[\"并行\",{\"1\":{\"679\":1}}],[\"并检查这个符号引用代表的类是否已经加载\",{\"1\":{\"649\":1}}],[\"并装载入cache中\",{\"1\":{\"579\":1}}],[\"并调用start\",{\"1\":{\"568\":1}}],[\"并加载到jvm中\",{\"1\":{\"513\":1,\"517\":1}}],[\"并添加servlet匹配路径\",{\"1\":{\"458\":1}}],[\"并添加到securitycontextholder中\",{\"1\":{\"147\":1}}],[\"并传递给dispatcherservlet响应给客户端\",{\"1\":{\"457\":1}}],[\"并给予客户端响应\",{\"1\":{\"457\":1}}],[\"并会将请求涉及到的拦截器和handler一起封装\",{\"1\":{\"457\":1}}],[\"并会将请求涉及到的拦截器和\",{\"1\":{\"456\":1}}],[\"并放在一个map中\",{\"1\":{\"453\":1}}],[\"并在前后做增强\",{\"1\":{\"446\":1}}],[\"并使用\",{\"1\":{\"346\":1,\"624\":1,\"725\":1}}],[\"并使用至事务提交\",{\"1\":{\"292\":1}}],[\"并集\",{\"1\":{\"345\":1,\"362\":1,\"392\":1,\"394\":2}}],[\"并集和差集的场景\",{\"1\":{\"314\":1,\"394\":1}}],[\"并根据套接字目前执行的任务来为套接字关联不同的事件处理器\",{\"1\":{\"320\":1}}],[\"并允许数据重复和null\",{\"1\":{\"264\":1}}],[\"并显示对应的信息\",{\"1\":{\"243\":1}}],[\"并发收集\",{\"1\":{\"683\":1}}],[\"并发清除\",{\"1\":{\"683\":1}}],[\"并发标记\",{\"1\":{\"683\":1,\"684\":1,\"685\":2}}],[\"并发\",{\"1\":{\"679\":1}}],[\"并发现自己缓存行是无效的\",{\"1\":{\"579\":1}}],[\"并发编程\",{\"0\":{\"636\":1}}],[\"并发编程三\",{\"0\":{\"596\":1}}],[\"并发编程的三个特性\",{\"0\":{\"577\":1}}],[\"并发编程二\",{\"0\":{\"569\":1}}],[\"并发编程一\",{\"0\":{\"553\":1}}],[\"并发度更大\",{\"1\":{\"551\":1}}],[\"并发度\",{\"1\":{\"551\":1}}],[\"并发度高\",{\"1\":{\"237\":1}}],[\"并发度低\",{\"1\":{\"237\":1}}],[\"并发度不及innodb\",{\"1\":{\"228\":1}}],[\"并发事务的控制方式有哪些\",{\"0\":{\"233\":1}}],[\"并发事务带来了哪些问题\",{\"0\":{\"232\":1}}],[\"并发访问数据库时\",{\"1\":{\"231\":1}}],[\"并立即重传这些丢失的数据段\",{\"1\":{\"201\":1}}],[\"并再次等待\",{\"1\":{\"197\":1}}],[\"并删除请求报文内的主体\",{\"1\":{\"179\":1}}],[\"并返回该资源的\",{\"1\":{\"176\":1}}],[\"并返回响应\",{\"1\":{\"176\":1}}],[\"并进行认证\",{\"1\":{\"146\":1}}],[\"并重写方法\",{\"1\":{\"146\":1}}],[\"并通过单独的通知程序定期通知给调用方\",{\"1\":{\"133\":1}}],[\"并实现了服务的解耦\",{\"1\":{\"130\":1}}],[\"并将对象年龄设为\",{\"1\":{\"662\":1}}],[\"并将自身阻塞\",{\"1\":{\"626\":1}}],[\"并将共享资源的状态设置为锁定状态\",{\"1\":{\"622\":1}}],[\"并将应用部署到该容器中\",{\"1\":{\"463\":1}}],[\"并将主要配置类加载到这个应用上下文中\",{\"1\":{\"463\":1}}],[\"并将容器放入\",{\"1\":{\"458\":1}}],[\"并将代理对象放入单例池中\",{\"1\":{\"440\":1}}],[\"并将数据包转发到正确的目的地网络或子网络\",{\"1\":{\"209\":1}}],[\"并将接收窗口向前移动\",{\"1\":{\"204\":1}}],[\"并将该请求转发到\",{\"1\":{\"185\":1}}],[\"并将令牌放入redis中\",{\"1\":{\"155\":1}}],[\"并将项目拆分为多个微服务\",{\"1\":{\"137\":1}}],[\"并将相应的message从rabbitmq缓存中移除\",{\"1\":{\"101\":1}}],[\"并将结果返回给进程\",{\"1\":{\"3\":1}}],[\"并不存在于redis和数据库中\",{\"1\":{\"352\":1}}],[\"并不是存在threadlocal中\",{\"1\":{\"599\":1}}],[\"并不是\",{\"1\":{\"401\":1}}],[\"并不是通过\",{\"1\":{\"378\":1}}],[\"并不是一种单独的索引类型\",{\"1\":{\"266\":1,\"267\":1}}],[\"并不是后执行的2修改的数据\",{\"1\":{\"152\":1}}],[\"并不会一次性加载所有的类\",{\"1\":{\"710\":1}}],[\"并不会实例化静态内部类singletoninstance\",{\"1\":{\"524\":1}}],[\"并不会被序列化\",{\"1\":{\"505\":1}}],[\"并不会不停地循环去尝试加锁\",{\"1\":{\"379\":1}}],[\"并不会真的去执行相关的语句\",{\"1\":{\"243\":1}}],[\"并不会立刻让消费者得到消息\",{\"1\":{\"94\":1}}],[\"并不受客户端\",{\"1\":{\"74\":1}}],[\"并且全都继承自\",{\"1\":{\"711\":1}}],[\"并且没有父级\",{\"1\":{\"711\":1}}],[\"并且没有额外的空间对它进行分配担保\",{\"1\":{\"676\":1}}],[\"并且只要不与已有的属性名重复\",{\"1\":{\"698\":1}}],[\"并且只按照一个方向扫描\",{\"1\":{\"16\":1}}],[\"并且收集这些region所需的停顿时间要大概率不超过期望的停顿时间\",{\"1\":{\"685\":1}}],[\"并且能被\",{\"1\":{\"662\":1}}],[\"并且链表是分层的\",{\"1\":{\"635\":1}}],[\"并且更厉害的是\",{\"1\":{\"628\":1}}],[\"并且锁住缓存行\",{\"1\":{\"579\":1}}],[\"并且每一个线程只能访问自己的本地内存\",{\"1\":{\"573\":1}}],[\"并且都不是线程安全的\",{\"1\":{\"536\":1}}],[\"并且类只提供一个取得对象实例的方法\",{\"1\":{\"518\":1}}],[\"并且内部没有暴露能修改这个数组的方法\",{\"1\":{\"495\":1}}],[\"并且有参构造不止一个则会报错\",{\"1\":{\"443\":1}}],[\"并且获取字符串长度复杂度为\",{\"1\":{\"383\":1}}],[\"并且redis底层会通过限制删除操作执行的时长和频率来减少删除操作对cpu时间的影响\",{\"1\":{\"327\":1}}],[\"并且根据特定的算法分配多余的内存\",{\"1\":{\"311\":1}}],[\"并且是以db的结果为准\",{\"1\":{\"302\":1}}],[\"并且\",{\"1\":{\"297\":2,\"299\":1,\"310\":1,\"334\":1,\"372\":1,\"376\":1,\"380\":1,\"401\":1,\"582\":1,\"611\":1}}],[\"并且刚好在当前事务查询范围内\",{\"1\":{\"292\":1}}],[\"并且在repl\",{\"1\":{\"422\":1}}],[\"并且在秒杀结束之前key不会过期来防止缓存击穿\",{\"1\":{\"356\":1}}],[\"并且在\",{\"1\":{\"284\":1,\"416\":1}}],[\"并且使用avl树\",{\"1\":{\"260\":1}}],[\"并且innodb默认使用repeaetable\",{\"1\":{\"228\":1}}],[\"并且存在x的一个真子集x0\",{\"1\":{\"219\":1}}],[\"并且去掉重复序列号的数据就可以实现数据包去重\",{\"1\":{\"199\":1}}],[\"并且按序到达\",{\"1\":{\"188\":1}}],[\"并且将消息发到接收通知方\",{\"1\":{\"132\":1}}],[\"并且不用为每一个目标类都创建一个代理类\",{\"1\":{\"517\":1}}],[\"并且不能为null\",{\"1\":{\"263\":1}}],[\"并且不保证数据不丢失\",{\"1\":{\"188\":1}}],[\"并且不支持断点续传功能\",{\"1\":{\"181\":1}}],[\"并且不会出现响应错误或者响应超时\",{\"1\":{\"114\":1}}],[\"并且不需要直接连接到对方\",{\"1\":{\"67\":1}}],[\"并且不同\",{\"1\":{\"31\":1}}],[\"并且磁头只需要返回到有磁道访问请求的位置即可\",{\"1\":{\"16\":1}}],[\"并且磁头返回时也需要返回到磁盘起点\",{\"1\":{\"16\":1}}],[\"并且为该进程创建一个对应的进程控制块\",{\"1\":{\"8\":1}}],[\"会指定其大小\",{\"1\":{\"633\":1}}],[\"会自旋\",{\"1\":{\"625\":1}}],[\"会自旋更多次\",{\"1\":{\"615\":1}}],[\"会自动启动一个嵌入式的\",{\"1\":{\"463\":1}}],[\"会自动先检查表中是否有唯一索引且不允许存在\",{\"1\":{\"263\":1}}],[\"会清理掉\",{\"1\":{\"600\":1}}],[\"会尝试获取对象的锁\",{\"1\":{\"589\":1}}],[\"会发出信号通知其他cpu将该变量的缓存行置为无效状态\",{\"1\":{\"579\":1}}],[\"会发生隐式转换\",{\"1\":{\"278\":1}}],[\"会把run\",{\"1\":{\"568\":1}}],[\"会把最早的执行命令依次舍弃\",{\"1\":{\"346\":1}}],[\"会释放对象锁\",{\"1\":{\"567\":1}}],[\"会实际调用实现invocationhandler接口类的invoke\",{\"1\":{\"514\":1}}],[\"会直接复制原本类o的内部对象引用地址\",{\"1\":{\"488\":1}}],[\"会开始运行应用\",{\"1\":{\"463\":1}}],[\"会创建副本\",{\"1\":{\"502\":1}}],[\"会创建1个或者2个字符串对象\",{\"1\":{\"497\":1}}],[\"会创建一个根应用上下文\",{\"1\":{\"463\":1}}],[\"会创建aserviceproxy代理对象\",{\"1\":{\"450\":1}}],[\"会找出项目中所有的spring\",{\"1\":{\"462\":1}}],[\"会在堆中在单独创建一个字符串对象\",{\"1\":{\"498\":1}}],[\"会在编译器对类进行增强\",{\"1\":{\"449\":1}}],[\"会在本机中进行地址映射也就是ip地址127\",{\"1\":{\"65\":1}}],[\"会有压缩\",{\"1\":{\"416\":1}}],[\"会有三次握手来建立连接\",{\"1\":{\"188\":1}}],[\"会结合多个源\",{\"1\":{\"402\":1}}],[\"会话断开后失效\",{\"1\":{\"451\":1}}],[\"会话失效节点自动被删除\",{\"1\":{\"380\":1}}],[\"会话消失则节点消失\",{\"1\":{\"380\":1}}],[\"会判断\",{\"1\":{\"379\":1}}],[\"会不断地延长锁的过期时间\",{\"1\":{\"376\":1}}],[\"会阻塞\",{\"1\":{\"363\":1}}],[\"会造成短时间的不一致性\",{\"1\":{\"360\":1}}],[\"会造成性能瓶颈\",{\"1\":{\"97\":1}}],[\"会返回\",{\"1\":{\"345\":1,\"362\":1}}],[\"会返回一个\",{\"1\":{\"345\":1,\"362\":1,\"456\":1}}],[\"会返回所有符合规则的\",{\"1\":{\"345\":1,\"362\":1}}],[\"会导致阻塞\",{\"1\":{\"367\":1}}],[\"会导致oom\",{\"1\":{\"326\":1}}],[\"会导致多线程阻塞\",{\"1\":{\"21\":1}}],[\"会为\",{\"1\":{\"311\":1}}],[\"会为该进程分配一个唯一的进程\",{\"1\":{\"8\":1}}],[\"会锁定读取到的记录的同时\",{\"1\":{\"292\":1}}],[\"会使用该\",{\"1\":{\"287\":1}}],[\"会先将请求转发给父类加载器\",{\"1\":{\"714\":1}}],[\"会先将驱动表读出来放到\",{\"1\":{\"243\":1}}],[\"会先根据\",{\"1\":{\"311\":1}}],[\"会先查询缓存\",{\"1\":{\"226\":1,\"229\":1}}],[\"会对对象进行逃逸分析\",{\"1\":{\"470\":1}}],[\"会对bitmap进行压缩\",{\"1\":{\"430\":1}}],[\"会对\",{\"1\":{\"238\":1}}],[\"会出现死锁\",{\"1\":{\"237\":1}}],[\"会去记录自己发送消息的状态比如消息是否发送了\",{\"1\":{\"188\":1}}],[\"会根据应用的类型和配置\",{\"1\":{\"463\":1}}],[\"会根据配置和类路径上的依赖\",{\"1\":{\"463\":1}}],[\"会根据逻辑\",{\"1\":{\"456\":1}}],[\"会根据初始化的长度决定使用哪种类型\",{\"1\":{\"311\":1}}],[\"会根据请求中使用的方法返回响应的实体\",{\"1\":{\"179\":1}}],[\"会根据消息头把消息发送给感兴趣的\",{\"1\":{\"83\":1}}],[\"会产生两个userservice类型的bean\",{\"1\":{\"444\":1}}],[\"会产生两个\",{\"1\":{\"175\":1}}],[\"会给所有或者指定的\",{\"1\":{\"459\":1}}],[\"会给\",{\"1\":{\"175\":1,\"585\":1}}],[\"会让旧的缓存数据失效\",{\"1\":{\"152\":1}}],[\"会接着把新数据写入redis\",{\"1\":{\"152\":1}}],[\"会回调confirmcallback\",{\"1\":{\"99\":1}}],[\"会被清理掉\",{\"1\":{\"600\":1}}],[\"会被记录下来\",{\"1\":{\"311\":1}}],[\"会被解析为\",{\"1\":{\"32\":1}}],[\"会被静态替换为com\",{\"1\":{\"29\":1}}],[\"会拦截接口方法\",{\"1\":{\"30\":1}}],[\"会将最新的消息发送给redis客户端\",{\"1\":{\"424\":1}}],[\"会将对应的子节点删除\",{\"1\":{\"379\":1}}],[\"会将\",{\"1\":{\"29\":1,\"175\":1}}],[\"会一直阻塞\",{\"1\":{\"21\":1}}],[\"会经历两个步骤\",{\"1\":{\"18\":1}}],[\"会向cpu发出响应的中断信号\",{\"1\":{\"3\":1}}],[\"bgsave\",{\"1\":{\"363\":2,\"409\":1,\"416\":1}}],[\"bgp\",{\"1\":{\"174\":1}}],[\"before这个线程的每一个操作\",{\"1\":{\"576\":1}}],[\"before后面对这个变量的读操作\",{\"1\":{\"576\":1}}],[\"before加锁\",{\"1\":{\"576\":1}}],[\"before于书写在后面的操作\",{\"1\":{\"576\":1}}],[\"before\",{\"0\":{\"575\":1,\"576\":1},\"1\":{\"449\":1,\"507\":1,\"576\":3}}],[\"behind\",{\"0\":{\"304\":1},\"1\":{\"304\":3}}],[\"bean有多种作用域\",{\"1\":{\"451\":1}}],[\"bean的创建生命周期\",{\"1\":{\"450\":1}}],[\"bean的实例化就是步骤userservice类\",{\"1\":{\"439\":1}}],[\"beanconfig\",{\"1\":{\"444\":1}}],[\"bean对象本身就是普通对象\",{\"1\":{\"441\":1}}],[\"bean对象和普通对象之间的区别是什么\",{\"0\":{\"441\":1}}],[\"bean实现了initializingbean则调用afterpropertiesset\",{\"1\":{\"439\":1}}],[\"bean初始化和实例化的区别是什么\",{\"0\":{\"439\":1}}],[\"beanfactory是spring中非常核心的组件\",{\"1\":{\"452\":1}}],[\"beanfactory\",{\"1\":{\"437\":1}}],[\"bean\",{\"1\":{\"34\":1,\"146\":1,\"437\":2,\"439\":1,\"444\":2}}],[\"bservice完成创建周期放入一级缓存\",{\"1\":{\"450\":1}}],[\"bservice对象需要依赖注入aservice对象\",{\"1\":{\"450\":1}}],[\"bsd\",{\"1\":{\"297\":1}}],[\"bst\",{\"0\":{\"259\":1}}],[\"b字段是有序的\",{\"1\":{\"271\":1}}],[\"b字段的值是无序的\",{\"1\":{\"271\":2}}],[\"b=2\",{\"1\":{\"271\":5}}],[\"b树的检索过程相当于对范围内的每个结点的关键字做二分查找\",{\"1\":{\"262\":1}}],[\"b树的叶子节点都是独立的\",{\"1\":{\"262\":1}}],[\"b树的所有节点既存放键\",{\"1\":{\"262\":1}}],[\"b树和b+树中的b是balanced的意思\",{\"1\":{\"262\":1}}],[\"b树也称为b\",{\"1\":{\"262\":1}}],[\"b+树的叶子节点不是数据本身\",{\"1\":{\"267\":1}}],[\"b+树的叶子节点有一条引用链指向与他相邻的叶子节点\",{\"1\":{\"262\":1}}],[\"b+树叶节点的data域存放的是数据记录的地址\",{\"1\":{\"262\":1}}],[\"b+树是b树的编题\",{\"1\":{\"262\":1}}],[\"b+树\",{\"0\":{\"262\":1},\"1\":{\"277\":1}}],[\"byname\",{\"1\":{\"444\":1}}],[\"bytype\",{\"1\":{\"444\":1}}],[\"byte\",{\"1\":{\"398\":1,\"469\":1,\"471\":1,\"726\":1}}],[\"bytes\",{\"1\":{\"350\":1}}],[\"by\",{\"1\":{\"243\":2}}],[\"b\",{\"0\":{\"262\":1},\"1\":{\"158\":1,\"271\":4,\"480\":1,\"499\":3,\"576\":2}}],[\"bootstrap\",{\"1\":{\"713\":1}}],[\"bootstrapclassloader\",{\"1\":{\"707\":1,\"711\":4,\"712\":1}}],[\"boot\",{\"1\":{\"463\":10}}],[\"boolean直接返回true或者是false\",{\"1\":{\"471\":1}}],[\"boolean\",{\"1\":{\"158\":1,\"376\":1,\"439\":1,\"469\":1,\"712\":1,\"714\":1}}],[\"body\",{\"1\":{\"175\":7}}],[\"border\",{\"1\":{\"174\":1}}],[\"boundsql\",{\"1\":{\"32\":1}}],[\"bcryptpasswordencoder\",{\"1\":{\"146\":1}}],[\"bcd不能访问外网但是能访问a\",{\"1\":{\"142\":1}}],[\"broker识别channel\",{\"1\":{\"97\":1}}],[\"broker不会断开连接\",{\"1\":{\"97\":1}}],[\"broker看作一台rabbitmq服务器\",{\"1\":{\"86\":1}}],[\"broker可以简单地看作一个rabbitmq服务节点\",{\"1\":{\"86\":1}}],[\"broker\",{\"0\":{\"86\":1},\"1\":{\"86\":1,\"92\":1,\"97\":1}}],[\"break\",{\"1\":{\"66\":1,\"539\":1}}],[\"biginteger内部使用int\",{\"1\":{\"475\":1}}],[\"bigkeys\",{\"1\":{\"338\":1}}],[\"bigkeys查找\",{\"1\":{\"338\":1}}],[\"bigkey\",{\"0\":{\"336\":1},\"1\":{\"338\":1,\"366\":1}}],[\"bitcount\",{\"1\":{\"316\":2,\"399\":1,\"400\":1}}],[\"bitop\",{\"1\":{\"316\":2,\"399\":1,\"400\":1}}],[\"bit\",{\"1\":{\"316\":1,\"398\":2}}],[\"bitmap的填充率越低\",{\"1\":{\"430\":1}}],[\"bitmap只需要一个\",{\"1\":{\"316\":1}}],[\"bitmap\",{\"0\":{\"316\":1,\"398\":1},\"1\":{\"297\":1,\"306\":1,\"308\":1,\"316\":2,\"398\":3,\"399\":1,\"430\":1}}],[\"binlog\",{\"1\":{\"248\":5,\"416\":1}}],[\"bindingkey中可以存在两种特殊字符串\",{\"1\":{\"90\":1}}],[\"bindingkey和routingkey一样也是点号\",{\"1\":{\"90\":1}}],[\"bindkey就像路由表中的一个表项\",{\"1\":{\"84\":1}}],[\"bio\",{\"0\":{\"21\":1},\"1\":{\"21\":1,\"324\":3}}],[\"bundle\",{\"1\":{\"62\":1}}],[\"buffers\",{\"1\":{\"57\":1}}],[\"buffers设置每个连接读取响应的缓冲区的数量和大小\",{\"1\":{\"57\":1}}],[\"buffering\",{\"1\":{\"57\":1}}],[\"buffering启用和禁用缓冲区\",{\"1\":{\"57\":1}}],[\"buffer\",{\"0\":{\"57\":1},\"1\":{\"57\":2,\"141\":1,\"243\":2,\"304\":1}}],[\"buffer等抽象\",{\"1\":{\"22\":1}}],[\"baklog大小\",{\"1\":{\"422\":1}}],[\"baklog做增量同步\",{\"1\":{\"421\":1}}],[\"baklog\",{\"1\":{\"421\":1,\"422\":1}}],[\"baklog中能找到offset时\",{\"1\":{\"422\":1}}],[\"baklog中的offset已经被覆盖\",{\"1\":{\"422\":1}}],[\"baklog中的数据增多而逐渐增大\",{\"1\":{\"420\":1}}],[\"baklog中从offset之后的命令给slave\",{\"1\":{\"422\":1}}],[\"baklog中\",{\"1\":{\"420\":1}}],[\"backup\",{\"1\":{\"408\":1}}],[\"backend\",{\"1\":{\"63\":2}}],[\"bad\",{\"1\":{\"179\":2}}],[\"baseexception\",{\"1\":{\"459\":2}}],[\"base64\",{\"1\":{\"309\":1,\"383\":1}}],[\"base64urlencode\",{\"1\":{\"150\":2}}],[\"base是basically\",{\"1\":{\"120\":1}}],[\"base理论允许系统出现中间状态\",{\"1\":{\"120\":1}}],[\"base理论\",{\"0\":{\"120\":1}}],[\"base理论就是根据ap扩展来\",{\"1\":{\"117\":1}}],[\"basicnack\",{\"1\":{\"101\":1}}],[\"basicack\",{\"1\":{\"101\":1}}],[\"basicack机制\",{\"1\":{\"98\":1}}],[\"basic\",{\"1\":{\"93\":2}}],[\"balance\",{\"1\":{\"80\":1}}],[\"batchexecutor\",{\"1\":{\"35\":1}}],[\"barrier\",{\"1\":{\"7\":1}}],[\"blocked\",{\"1\":{\"561\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"605\":1}}],[\"blockingqueue阻塞的原因是其支持当队列没有元素时一直阻塞\",{\"1\":{\"540\":1,\"631\":1}}],[\"blockingqueue\",{\"0\":{\"540\":1,\"631\":1},\"1\":{\"540\":2,\"627\":1,\"630\":1,\"631\":2,\"632\":1}}],[\"blocking\",{\"0\":{\"21\":1,\"22\":1},\"1\":{\"22\":1}}],[\"block\",{\"1\":{\"8\":1,\"15\":1,\"243\":1,\"634\":1}}],[\"p操作\",{\"1\":{\"624\":1}}],[\"pms\",{\"1\":{\"613\":1}}],[\"peeklast\",{\"1\":{\"537\":1}}],[\"peekfirst\",{\"1\":{\"537\":1}}],[\"peek\",{\"1\":{\"537\":1}}],[\"pexpire\",{\"1\":{\"376\":1}}],[\"permgen\",{\"1\":{\"721\":1,\"726\":1}}],[\"permsize=n\",{\"1\":{\"721\":1}}],[\"permits\",{\"1\":{\"624\":2}}],[\"perfcounter\",{\"1\":{\"714\":3}}],[\"percentage\",{\"1\":{\"414\":1}}],[\"persistent\",{\"1\":{\"380\":3}}],[\"persist命令可以溢出一个键的过期时间\",{\"1\":{\"326\":1}}],[\"per\",{\"1\":{\"300\":1}}],[\"px\",{\"1\":{\"375\":1}}],[\"pfmerge\",{\"1\":{\"402\":1}}],[\"pfcount\",{\"1\":{\"317\":2,\"402\":1,\"403\":1}}],[\"pfadd\",{\"1\":{\"317\":2,\"402\":1,\"403\":1}}],[\"ptr\",{\"1\":{\"286\":1,\"287\":1}}],[\"pub\",{\"1\":{\"306\":1}}],[\"publisher\",{\"1\":{\"97\":1}}],[\"public\",{\"1\":{\"34\":1,\"100\":1,\"146\":3,\"376\":2,\"436\":4,\"439\":2,\"442\":2,\"444\":2,\"446\":1,\"448\":1,\"458\":2,\"459\":3,\"461\":1,\"476\":3,\"480\":3,\"495\":1,\"503\":2,\"507\":3,\"514\":3,\"515\":2,\"520\":2,\"521\":2,\"522\":2,\"523\":1,\"524\":2,\"579\":2,\"599\":2,\"694\":1,\"713\":1}}],[\"putstatic\",{\"1\":{\"706\":1}}],[\"put\",{\"1\":{\"176\":2,\"634\":1}}],[\"put请求是http协议中的一种请求方法\",{\"1\":{\"176\":1}}],[\"put请求\",{\"1\":{\"176\":1}}],[\"put和post的区别\",{\"0\":{\"176\":1}}],[\"pid<pid>\",{\"1\":{\"725\":1}}],[\"pipeline可以打包不同的命令\",{\"1\":{\"333\":1}}],[\"pipeline是非原子操作\",{\"1\":{\"333\":1}}],[\"pipeline\",{\"0\":{\"333\":1},\"1\":{\"334\":2}}],[\"pipes\",{\"1\":{\"9\":2}}],[\"pire\",{\"1\":{\"326\":1}}],[\"ping\",{\"1\":{\"174\":1}}],[\"polllast\",{\"1\":{\"537\":1}}],[\"pollfirst\",{\"1\":{\"537\":1}}],[\"poll\",{\"1\":{\"537\":1}}],[\"policy参数设置为lfu算法\",{\"1\":{\"342\":1}}],[\"pool\",{\"0\":{\"693\":1},\"1\":{\"304\":1,\"693\":4}}],[\"postconstruct修饰的方法\",{\"1\":{\"442\":1}}],[\"postconstruct\",{\"1\":{\"442\":4}}],[\"postconstruct是如何工作的\",{\"0\":{\"442\":1}}],[\"postconstruct注解\",{\"1\":{\"438\":1}}],[\"post请求\",{\"1\":{\"176\":1}}],[\"post\",{\"1\":{\"175\":10,\"176\":4}}],[\"pop3\",{\"1\":{\"172\":3,\"191\":3}}],[\"pojo\",{\"1\":{\"30\":1}}],[\"phase\",{\"1\":{\"122\":2}}],[\"php\",{\"1\":{\"78\":1,\"81\":1}}],[\"p映射本机端口80到容器中\",{\"1\":{\"108\":1}}],[\"p\",{\"0\":{\"115\":1},\"1\":{\"107\":1,\"108\":1,\"338\":1}}],[\"python\",{\"1\":{\"78\":1,\"81\":1}}],[\"pattern遇到数据更新时\",{\"1\":{\"360\":1}}],[\"pattern\",{\"0\":{\"302\":1,\"303\":1,\"304\":1},\"1\":{\"302\":1,\"303\":7,\"304\":3,\"360\":1}}],[\"path\",{\"1\":{\"58\":1,\"174\":1,\"724\":1}}],[\"path指定缓存路径名称和大小\",{\"1\":{\"58\":1}}],[\"parent\",{\"1\":{\"713\":3,\"714\":2}}],[\"parents\",{\"1\":{\"713\":1}}],[\"parallelgc\",{\"1\":{\"728\":1}}],[\"parallel\",{\"0\":{\"680\":1,\"682\":1},\"1\":{\"681\":1,\"682\":3}}],[\"parametermapping\",{\"1\":{\"32\":1}}],[\"parametermap\",{\"1\":{\"32\":1}}],[\"parametervalue\",{\"1\":{\"29\":1}}],[\"param\",{\"1\":{\"29\":1}}],[\"parnew\",{\"0\":{\"679\":1},\"1\":{\"650\":1,\"679\":1}}],[\"parties\",{\"1\":{\"626\":1}}],[\"partial\",{\"1\":{\"181\":2,\"663\":1}}],[\"partition\",{\"0\":{\"115\":1},\"1\":{\"112\":1}}],[\"payload\",{\"1\":{\"83\":1,\"150\":2}}],[\"passwordencoder\",{\"1\":{\"146\":2}}],[\"pass进行请求代理\",{\"1\":{\"142\":1}}],[\"pass配置行直接加集群名\",{\"1\":{\"139\":1}}],[\"pass的地址包括uri\",{\"1\":{\"52\":1}}],[\"pass的地址只配置到\",{\"1\":{\"52\":1}}],[\"pass说明\",{\"1\":{\"52\":1}}],[\"pass里面配置的主机名和端口\",{\"1\":{\"52\":1}}],[\"pass\",{\"1\":{\"51\":1,\"52\":3,\"54\":1,\"57\":1,\"58\":1,\"59\":1,\"63\":1,\"139\":2,\"142\":1}}],[\"page\",{\"1\":{\"48\":1,\"52\":4,\"53\":1,\"62\":1,\"317\":2}}],[\"paginationinnerinterceptor\",{\"1\":{\"34\":1}}],[\"ps\",{\"1\":{\"29\":1}}],[\"psw\",{\"1\":{\"8\":1}}],[\"printtenuringdistribution\",{\"1\":{\"731\":1}}],[\"printsafepointstatisticscount=1\",{\"1\":{\"724\":1}}],[\"println\",{\"1\":{\"100\":1,\"436\":2,\"448\":2,\"476\":2,\"480\":2,\"484\":5,\"498\":3,\"499\":1,\"501\":1,\"503\":2,\"507\":2}}],[\"primary\",{\"0\":{\"263\":1},\"1\":{\"243\":2}}],[\"privatemethod\",{\"1\":{\"510\":4}}],[\"private\",{\"1\":{\"146\":1,\"376\":1,\"439\":1,\"442\":1,\"476\":2,\"495\":1,\"505\":1,\"507\":1,\"520\":2,\"521\":2,\"522\":2,\"523\":2,\"524\":3,\"579\":2,\"713\":1}}],[\"priorityblockingqueue\",{\"0\":{\"634\":1},\"1\":{\"634\":1}}],[\"priorityqueue默认是小顶堆\",{\"1\":{\"539\":1}}],[\"priorityqueue是线程不安全的\",{\"1\":{\"539\":1}}],[\"priorityqueue使用堆实现了在o\",{\"1\":{\"539\":1}}],[\"priorityqueue使用变长数组存储元素\",{\"1\":{\"539\":1}}],[\"priorityqueue\",{\"0\":{\"539\":1},\"1\":{\"530\":1,\"539\":1,\"634\":1}}],[\"priority相同\",{\"1\":{\"426\":1}}],[\"priority值\",{\"1\":{\"426\":1}}],[\"priority\",{\"1\":{\"83\":1}}],[\"preparation\",{\"1\":{\"700\":1}}],[\"prepare\",{\"1\":{\"122\":1}}],[\"preparedstatement\",{\"1\":{\"29\":1}}],[\"pretunuresizethreshold指定对象大小的阈值\",{\"1\":{\"686\":1}}],[\"prev\",{\"1\":{\"622\":1}}],[\"prefix\",{\"1\":{\"155\":1}}],[\"prefer\",{\"1\":{\"62\":1}}],[\"promotion\",{\"1\":{\"664\":1}}],[\"promotionsessionid封装发送到rabbitmq的order\",{\"1\":{\"158\":1}}],[\"propagation\",{\"1\":{\"448\":2}}],[\"propagation事务传播机制设置错误\",{\"1\":{\"448\":1}}],[\"property=\",{\"1\":{\"33\":2}}],[\"properties\",{\"1\":{\"29\":1}}],[\"prototype\",{\"1\":{\"451\":1}}],[\"protocol\",{\"1\":{\"74\":1,\"78\":1,\"80\":1,\"172\":5,\"173\":2,\"174\":7,\"191\":4,\"210\":2,\"214\":1}}],[\"protocols\",{\"1\":{\"62\":1}}],[\"protected\",{\"1\":{\"376\":1,\"712\":2,\"713\":1,\"714\":1}}],[\"producer端发送消息需要添加异常处理\",{\"1\":{\"99\":1}}],[\"producer\",{\"0\":{\"83\":1},\"1\":{\"83\":1}}],[\"proxy类中使用较多的方法是newproxyinstance\",{\"1\":{\"514\":1}}],[\"proxy\",{\"1\":{\"30\":2,\"51\":1,\"52\":10,\"57\":7,\"58\":3,\"59\":1,\"63\":1,\"139\":3,\"142\":1,\"507\":1,\"514\":2,\"515\":2}}],[\"process\",{\"1\":{\"8\":1}}],[\"pcb\",{\"0\":{\"8\":1},\"1\":{\"8\":5,\"10\":1}}],[\"通用\",{\"1\":{\"384\":2}}],[\"通用hash\",{\"1\":{\"60\":1}}],[\"通知机制\",{\"1\":{\"594\":1}}],[\"通知或中断\",{\"1\":{\"561\":1}}],[\"通知\",{\"1\":{\"424\":1}}],[\"通知获取锁失败的客户端\",{\"1\":{\"381\":1}}],[\"通知程序\",{\"1\":{\"133\":1}}],[\"通知的可靠性关键在接收通知方\",{\"1\":{\"132\":1}}],[\"通常表示为\",{\"1\":{\"711\":1}}],[\"通常情况\",{\"1\":{\"704\":1}}],[\"通常情况下被final修饰的static变量会成为常量\",{\"1\":{\"477\":1}}],[\"通常情况下是usernamepasswordauthenticationtoken这个实现类\",{\"1\":{\"146\":1}}],[\"通常情况下\",{\"1\":{\"123\":2,\"176\":1,\"306\":1}}],[\"通常在创建\",{\"1\":{\"633\":1}}],[\"通常会比\",{\"1\":{\"416\":1}}],[\"通常不建议这样实现分布式锁\",{\"1\":{\"385\":1}}],[\"通常是带有\",{\"1\":{\"463\":1}}],[\"通常是将\",{\"1\":{\"380\":1}}],[\"通常是因为缓存的数据已经过期\",{\"1\":{\"358\":1}}],[\"通常做法是加一个版本号或者时间戳字段\",{\"1\":{\"284\":1}}],[\"通常用于线程之间的通信\",{\"1\":{\"566\":1}}],[\"通常用于创建新的资源或提交数据到服务器进行处理\",{\"1\":{\"176\":1}}],[\"通常用于更新或者是替换服务器上的资源\",{\"1\":{\"176\":1}}],[\"通常基于\",{\"1\":{\"172\":1}}],[\"通常实现ap都会保证最终一致性\",{\"1\":{\"117\":1}}],[\"通常每个thread创建单独的channel进行通讯\",{\"1\":{\"97\":1}}],[\"通常设置成小于默认值\",{\"1\":{\"57\":1}}],[\"通常一个\",{\"1\":{\"30\":1}}],[\"通过创建太多相同\",{\"1\":{\"726\":1}}],[\"通过创建唯一性索引\",{\"1\":{\"256\":1}}],[\"通过解析操作符号引用就能直接变成为目标方法在类中方法表的位置\",{\"1\":{\"705\":1}}],[\"通过数据流分析和控制流分析\",{\"1\":{\"703\":1}}],[\"通过数据行的\",{\"1\":{\"286\":1}}],[\"通过全类名获取定义此类的二进制字节流\",{\"1\":{\"702\":1}}],[\"通过移动中间的指针\",{\"1\":{\"650\":1}}],[\"通过内置的\",{\"1\":{\"622\":1}}],[\"通过threadpoolexecutor构造函数来创建\",{\"1\":{\"604\":1}}],[\"通过该\",{\"1\":{\"589\":1}}],[\"通过位运算实现取模\",{\"1\":{\"548\":1}}],[\"通过key的hashcode经过扰动函数之后获得hash值\",{\"1\":{\"546\":1}}],[\"通过enhancer类来动态获取被代理类\",{\"1\":{\"515\":1}}],[\"通过expiration或者x\",{\"1\":{\"95\":1}}],[\"通过类加载器获取class对象不会进行初始化\",{\"1\":{\"509\":1}}],[\"通过类加载器xxxclassloader\",{\"1\":{\"509\":1}}],[\"通过类名直接访问\",{\"1\":{\"479\":1}}],[\"通过实例对象的getclass\",{\"1\":{\"509\":1}}],[\"通过实现类或者是父类生成代理对象\",{\"1\":{\"448\":1}}],[\"通过cas\",{\"1\":{\"618\":1}}],[\"通过class\",{\"1\":{\"509\":1}}],[\"通过config\",{\"1\":{\"350\":1}}],[\"通过一个个方法的执行解决问题\",{\"1\":{\"483\":1}}],[\"通过biginteger存储\",{\"1\":{\"475\":1}}],[\"通过base64加密之后得到token的第二个部分\",{\"1\":{\"150\":1}}],[\"通过对注入属性添加\",{\"1\":{\"450\":1}}],[\"通过对header和payload进行再次加密得到的数据再通过hs256加盐得到最终的signature\",{\"1\":{\"150\":1}}],[\"通过判断\",{\"1\":{\"439\":1}}],[\"通过容器实现\",{\"1\":{\"434\":1}}],[\"通过控制反转的技术达到松耦合\",{\"1\":{\"434\":1}}],[\"通过在redis\",{\"1\":{\"418\":1}}],[\"通过在插入和删除节点时金星颜色变换和旋转操作\",{\"1\":{\"261\":1}}],[\"通过使用一种叫做\",{\"1\":{\"415\":1}}],[\"通过appendonly参数开启\",{\"1\":{\"410\":1}}],[\"通过顺序节点解决顺序唤醒后续节点\",{\"1\":{\"380\":1}}],[\"通过过期时间来避免锁无法被释放导致死锁问题的\",{\"1\":{\"380\":1}}],[\"通过调用\",{\"1\":{\"376\":1}}],[\"通过键可以快速取出对应的值\",{\"1\":{\"258\":1}}],[\"通过这些信息\",{\"1\":{\"243\":1}}],[\"通过mvcc和next\",{\"1\":{\"232\":1}}],[\"通过max\",{\"1\":{\"61\":1}}],[\"通过拥塞控制算法实现\",{\"1\":{\"201\":1}}],[\"通过加密和认证机制实现安全的访问和文件传输等业务\",{\"1\":{\"172\":1}}],[\"通过semaphore\",{\"1\":{\"158\":1}}],[\"通过\",{\"1\":{\"146\":2,\"188\":1,\"306\":3,\"316\":1,\"324\":3,\"350\":1,\"398\":1,\"404\":1,\"442\":1,\"546\":1,\"594\":1,\"604\":1,\"720\":2}}],[\"通过userdetailsservice实现类获取包含用户账号密码的userdetails实现类\",{\"1\":{\"146\":1}}],[\"通过userdetails实现类查询用户账号和密码\",{\"1\":{\"146\":1}}],[\"通过nginx配置进行获取这些静态文件\",{\"1\":{\"141\":1}}],[\"通过消息队列中间件完成\",{\"1\":{\"125\":1}}],[\"通过消息队列减少同时创建订单的任务数\",{\"1\":{\"70\":1}}],[\"通过交换器来路由消息\",{\"1\":{\"78\":1,\"81\":1}}],[\"通过redssion的semaphore\",{\"1\":{\"158\":1}}],[\"通过resultmap来设置字段和属性的映射关系\",{\"1\":{\"33\":1}}],[\"通过rpc发出的调用一般会立即被处理\",{\"1\":{\"75\":1}}],[\"通过rpc可以帮助我们调用远程计算机上某个服务的方法\",{\"1\":{\"75\":1}}],[\"通过异步处理提高系统性能\",{\"0\":{\"69\":1}}],[\"通过fail\",{\"1\":{\"61\":1}}],[\"通过配置upstream实现多个服务器的负载均衡\",{\"1\":{\"59\":1}}],[\"通过proxy类的newinstance\",{\"1\":{\"514\":1}}],[\"通过proxy\",{\"1\":{\"57\":1,\"58\":1}}],[\"通过添加插件的方式进行分页\",{\"1\":{\"34\":1}}],[\"通过它只需要一个线程便可以管理多个客户端连接\",{\"1\":{\"22\":1}}],[\"通过减少无效的系统调用\",{\"1\":{\"22\":1}}],[\"通过轮训操作避免了一直阻塞\",{\"1\":{\"22\":1}}],[\"通过通知操作的方式来保持多线程同步\",{\"1\":{\"7\":1}}],[\"通信和安全等\",{\"1\":{\"2\":1}}],[\"world\",{\"1\":{\"678\":1,\"684\":1}}],[\"workqueue\",{\"1\":{\"605\":2}}],[\"worker\",{\"1\":{\"102\":1}}],[\"while\",{\"1\":{\"539\":1}}],[\"where\",{\"1\":{\"221\":2,\"243\":2,\"271\":8,\"278\":2}}],[\"where>\",{\"1\":{\"30\":1}}],[\"window并进行重传\",{\"1\":{\"199\":1}}],[\"warning\",{\"1\":{\"713\":1}}],[\"watcher\",{\"1\":{\"379\":1}}],[\"watch\",{\"1\":{\"376\":6}}],[\"wan\",{\"1\":{\"174\":1}}],[\"waitstatus\",{\"1\":{\"622\":1}}],[\"waiting\",{\"1\":{\"561\":2}}],[\"wait状态\",{\"1\":{\"195\":1}}],[\"waitpid\",{\"1\":{\"10\":3}}],[\"wait\",{\"0\":{\"566\":1},\"1\":{\"7\":1,\"10\":3,\"195\":3,\"566\":4,\"567\":1}}],[\"wrapper\",{\"1\":{\"146\":3}}],[\"write将数据写入到了系统内核缓冲区之后直接返回\",{\"1\":{\"411\":1}}],[\"write技术\",{\"1\":{\"409\":1}}],[\"write\",{\"0\":{\"303\":1,\"304\":1},\"1\":{\"7\":1,\"57\":1,\"303\":2,\"304\":5,\"411\":1,\"412\":3,\"579\":1}}],[\"webapplicationinitializer\",{\"1\":{\"458\":1}}],[\"webrtc\",{\"1\":{\"172\":1}}],[\"web\",{\"1\":{\"139\":2,\"142\":2,\"172\":2,\"191\":2,\"463\":4}}],[\"west\",{\"1\":{\"66\":2}}],[\"weight=3\",{\"1\":{\"60\":1}}],[\"w+匹配出现1次或者多次任意字母或者数字\",{\"1\":{\"66\":1}}],[\"w+\",{\"1\":{\"66\":2}}],[\"是由jvm自动产生的\",{\"1\":{\"709\":1}}],[\"是由客户端自己负责把数据写入\",{\"1\":{\"303\":1}}],[\"是类加载的最后一步\",{\"1\":{\"706\":1}}],[\"是类还是接口\",{\"1\":{\"694\":1}}],[\"是有风险的\",{\"1\":{\"664\":1}}],[\"是各个线程共享的内存区域\",{\"1\":{\"645\":1}}],[\"是共享锁的一种实现\",{\"1\":{\"624\":1,\"625\":1}}],[\"是相对于使用操作系统互斥量来实现的传统锁而言的\",{\"1\":{\"618\":1}}],[\"是强引用\",{\"1\":{\"600\":1}}],[\"是随机或者按照其他优先级排序的\",{\"1\":{\"593\":1}}],[\"是让获得对象锁的线程等待\",{\"1\":{\"567\":1}}],[\"是继承自\",{\"1\":{\"551\":1}}],[\"是在\",{\"1\":{\"538\":1,\"539\":1}}],[\"是线程安全的\",{\"1\":{\"494\":1}}],[\"是本地方法\",{\"1\":{\"491\":1}}],[\"是子类对父类方法的实现过程重新编写\",{\"1\":{\"480\":1}}],[\"是个逻辑上的\",{\"1\":{\"456\":1}}],[\"是返回的数据对象\",{\"1\":{\"456\":1}}],[\"是不变的类\",{\"1\":{\"451\":1}}],[\"是不可以防止幻读的\",{\"1\":{\"282\":1}}],[\"是安全的\",{\"1\":{\"383\":1}}],[\"是直接操作\",{\"1\":{\"378\":1}}],[\"是典型的\",{\"1\":{\"369\":1}}],[\"是最常用的一致性方案\",{\"1\":{\"360\":1}}],[\"是单线程模型\",{\"1\":{\"324\":1}}],[\"是基于可变长的数组和双指针来实现\",{\"1\":{\"538\":1}}],[\"是基于\",{\"1\":{\"311\":1}}],[\"是同步更新\",{\"1\":{\"304\":1}}],[\"是我们平时使用比较多的一个缓存读写模式\",{\"1\":{\"302\":1}}],[\"是多线程\",{\"1\":{\"299\":1}}],[\"是一款面向服务器的垃圾收集器\",{\"1\":{\"684\":1}}],[\"是一次性的\",{\"1\":{\"625\":1}}],[\"是一个支持优先级的无界阻塞队列\",{\"1\":{\"634\":1}}],[\"是一个虚拟的双向队列\",{\"1\":{\"622\":1}}],[\"是一个可重入且独占式的锁\",{\"1\":{\"592\":1}}],[\"是一个原子操作\",{\"1\":{\"583\":1}}],[\"是一个接口\",{\"1\":{\"540\":1,\"631\":1}}],[\"是一个本地方法\",{\"1\":{\"498\":1}}],[\"是一个思想\",{\"1\":{\"449\":1}}],[\"是一个\",{\"1\":{\"389\":1}}],[\"是一个开源的\",{\"1\":{\"376\":1}}],[\"是一个基于\",{\"1\":{\"297\":1}}],[\"是一种策略\",{\"1\":{\"725\":1}}],[\"是一种双向卡表\",{\"1\":{\"687\":1}}],[\"是一种有名的基数计数概率算法\",{\"1\":{\"401\":1}}],[\"是一种无序集合\",{\"1\":{\"314\":1}}],[\"是一种二进制安全的数据结构\",{\"1\":{\"309\":1,\"383\":1}}],[\"是一种不安全的协议\",{\"1\":{\"172\":1,\"191\":1}}],[\"是一种用于在计算机之间传输文件的协议\",{\"1\":{\"172\":1,\"191\":1}}],[\"是一种用于发送电子邮件的协议\",{\"1\":{\"172\":1,\"191\":1}}],[\"是一种用于传输超文本和多媒体内容的协议\",{\"1\":{\"172\":1,\"191\":1}}],[\"是指在一致性非锁定读\",{\"1\":{\"285\":1}}],[\"是指对数据库中表记录的操作\",{\"1\":{\"222\":1}}],[\"是行锁\",{\"1\":{\"282\":1}}],[\"是目前搜索引擎数据库使用的一种技术\",{\"1\":{\"264\":1}}],[\"是目前较可靠\",{\"1\":{\"191\":1}}],[\"是因为二级索引的叶子节点存储的数据是主键\",{\"1\":{\"264\":1}}],[\"是除了\",{\"1\":{\"243\":1}}],[\"是查询中select的序号\",{\"1\":{\"243\":1}}],[\"是针对索引字段加锁\",{\"1\":{\"237\":1}}],[\"是数据集的标记\",{\"1\":{\"420\":1}}],[\"是数据的保存形式\",{\"1\":{\"382\":1}}],[\"是数据定义语言的缩写\",{\"1\":{\"222\":1}}],[\"是数据库操作语言\",{\"1\":{\"222\":1}}],[\"是开发人员日常使用最频繁的操作\",{\"1\":{\"222\":1}}],[\"是的x0\",{\"1\":{\"219\":1}}],[\"是tcp\",{\"1\":{\"208\":1}}],[\"是面向报文的\",{\"1\":{\"188\":1}}],[\"是面向字节流的\",{\"1\":{\"188\":1}}],[\"是无状态服务\",{\"1\":{\"188\":1}}],[\"是无副作用的\",{\"1\":{\"175\":1}}],[\"是否为\",{\"1\":{\"694\":1}}],[\"是否能存储null\",{\"1\":{\"543\":1}}],[\"是否有正确的访问权限\",{\"1\":{\"703\":1}}],[\"是否有损坏或者丢失的数据\",{\"1\":{\"415\":1}}],[\"是否有状态\",{\"1\":{\"188\":1}}],[\"是否存在内存泄露\",{\"1\":{\"729\":1}}],[\"是否存在\",{\"1\":{\"384\":1}}],[\"是否支持mvcc\",{\"1\":{\"228\":1}}],[\"是否支持数据库异常崩溃后的安全恢复\",{\"1\":{\"228\":1}}],[\"是否支持外键\",{\"1\":{\"228\":1}}],[\"是否支持事务\",{\"1\":{\"228\":1}}],[\"是否支持行级锁\",{\"1\":{\"228\":1}}],[\"是否提供广播或多播服务\",{\"1\":{\"188\":1}}],[\"是否被接收了等等\",{\"1\":{\"188\":1}}],[\"是否可靠传输\",{\"1\":{\"188\":1}}],[\"是否是可靠传输\",{\"1\":{\"188\":1}}],[\"是否面向连接\",{\"1\":{\"188\":1}}],[\"是当用户使用浏览器访问网址之后\",{\"1\":{\"184\":1}}],[\"是统一资源定位符\",{\"1\":{\"182\":1}}],[\"是统一资源标志符\",{\"1\":{\"182\":1}}],[\"是运行在\",{\"1\":{\"180\":1}}],[\"是幂等的\",{\"1\":{\"175\":1}}],[\"是为了考虑系统结构和软件复用\",{\"1\":{\"123\":1}}],[\"是ap组合模式的拓展\",{\"1\":{\"120\":1}}],[\"是对对象的每个字段单独存储\",{\"1\":{\"310\":1}}],[\"是对数据表行的拆分\",{\"1\":{\"251\":1}}],[\"是对数据表列的拆分\",{\"1\":{\"251\":1}}],[\"是对应一个\",{\"1\":{\"102\":1}}],[\"是对原文件起了一个别名\",{\"1\":{\"15\":1}}],[\"是生产者\",{\"1\":{\"97\":1}}],[\"是消息的容器也是终点\",{\"1\":{\"85\":1}}],[\"是应用层协议的一个开放标准\",{\"1\":{\"74\":1}}],[\"是\",{\"1\":{\"29\":2,\"66\":1,\"219\":1,\"243\":1,\"309\":1,\"383\":1,\"587\":1,\"632\":1,\"647\":1,\"711\":1}}],[\"是操作系统中用来管理和跟踪进程的数据结构\",{\"1\":{\"8\":1}}],[\"是操作系统中拥有资源的基本单位\",{\"1\":{\"5\":1}}],[\"是什么\",{\"0\":{\"8\":1,\"587\":1,\"592\":1}}],[\"是这种机制\",{\"1\":{\"7\":1}}],[\"cmd\",{\"1\":{\"725\":3}}],[\"cmsinitiatingoccupancyfraction=percent\",{\"1\":{\"732\":1}}],[\"cms的老年代内存越大越好\",{\"1\":{\"732\":1}}],[\"cms采用的是增量更新\",{\"1\":{\"687\":1}}],[\"cms采用标记清除算法\",{\"1\":{\"685\":1}}],[\"cms和g1在根节点枚举上的区别就在于处理跨代引用上\",{\"1\":{\"687\":1}}],[\"cms和g1的stw的区别\",{\"0\":{\"687\":1}}],[\"cms和g1的异同\",{\"0\":{\"685\":1}}],[\"cms和g1都是响应时间优先的收集器\",{\"1\":{\"685\":1}}],[\"cms大致可以分为初始标记\",{\"1\":{\"685\":1}}],[\"cms收集器\",{\"0\":{\"683\":1}}],[\"cms垃圾收集器关注的是停顿时间\",{\"1\":{\"680\":1}}],[\"cms\",{\"1\":{\"650\":1,\"679\":1,\"681\":1,\"683\":3,\"684\":3,\"685\":1,\"723\":1,\"728\":1,\"735\":1}}],[\"cglib是通过生成一个被代理类的子类来拦截代理类的方法调用\",{\"1\":{\"516\":1}}],[\"cglib则不需要\",{\"1\":{\"516\":1}}],[\"cglib动态代理中methodintercepter接口和enhancer类是核心\",{\"1\":{\"515\":1}}],[\"cglib动态代理\",{\"0\":{\"515\":1},\"1\":{\"513\":1}}],[\"c++实现\",{\"1\":{\"711\":1}}],[\"c++支持多继承\",{\"1\":{\"468\":1}}],[\"c++\",{\"0\":{\"468\":1},\"1\":{\"711\":2}}],[\"cycle\",{\"1\":{\"350\":2}}],[\"cyclicbarrier\",{\"0\":{\"626\":1},\"1\":{\"7\":1,\"626\":1}}],[\"currentthread\",{\"1\":{\"599\":1}}],[\"current\",{\"1\":{\"285\":1}}],[\"c=2\",{\"1\":{\"271\":1}}],[\"c=3\",{\"1\":{\"271\":2}}],[\"c是目的\",{\"1\":{\"231\":1}}],[\"cwnd\",{\"1\":{\"201\":4}}],[\"checkcreateclassloader\",{\"1\":{\"713\":1}}],[\"checksum\",{\"1\":{\"415\":1}}],[\"change\",{\"1\":{\"503\":2}}],[\"channel作为轻量级的connection极大减少了操作系统建立tcp\",{\"1\":{\"97\":1}}],[\"channel是在connection内部建立的逻辑连接\",{\"1\":{\"97\":1}}],[\"channel\",{\"1\":{\"97\":2}}],[\"charsets\",{\"1\":{\"711\":1}}],[\"charsequence\",{\"1\":{\"495\":1}}],[\"character创建了\",{\"1\":{\"471\":1}}],[\"char\",{\"1\":{\"469\":1,\"495\":1,\"726\":1}}],[\"chrome\",{\"1\":{\"175\":1}}],[\"createmap\",{\"1\":{\"599\":1}}],[\"create\",{\"1\":{\"429\":1}}],[\"creator\",{\"1\":{\"288\":1}}],[\"crc64\",{\"1\":{\"415\":1}}],[\"cron\",{\"1\":{\"159\":1}}],[\"crt\",{\"1\":{\"62\":1}}],[\"cpp\",{\"1\":{\"647\":1}}],[\"cp\",{\"0\":{\"118\":1},\"1\":{\"693\":1}}],[\"cpu竞争\",{\"0\":{\"369\":1}}],[\"cpu调度的最小单位变成线程\",{\"1\":{\"5\":1}}],[\"cpu\",{\"1\":{\"3\":1,\"8\":1,\"350\":2,\"369\":3,\"416\":1,\"583\":1,\"585\":1,\"609\":1,\"682\":1,\"683\":1,\"684\":4}}],[\"cpu响应的时候切换到核心态\",{\"1\":{\"3\":1}}],[\"cas+重试\",{\"1\":{\"650\":1}}],[\"cas问题\",{\"0\":{\"585\":1}}],[\"cas\",{\"0\":{\"583\":1},\"1\":{\"550\":1,\"551\":1,\"581\":1,\"583\":4,\"585\":4,\"624\":2,\"625\":2,\"630\":2}}],[\"catch\",{\"1\":{\"448\":1,\"714\":1}}],[\"category\",{\"1\":{\"153\":1}}],[\"caffeine\",{\"1\":{\"343\":1}}],[\"callable\",{\"0\":{\"612\":1},\"1\":{\"612\":3}}],[\"callerrunspolicy\",{\"1\":{\"606\":1}}],[\"callback\",{\"1\":{\"515\":1}}],[\"call\",{\"1\":{\"155\":2,\"374\":2,\"376\":2,\"612\":1}}],[\"cancel阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消\",{\"1\":{\"123\":1}}],[\"cancel三个词语的缩写\",{\"1\":{\"123\":1}}],[\"ca\",{\"0\":{\"119\":1}}],[\"cap组合方式\",{\"0\":{\"116\":1}}],[\"cap是consistency\",{\"1\":{\"112\":1}}],[\"cap\",{\"0\":{\"112\":1}}],[\"cause\",{\"1\":{\"99\":1}}],[\"cachedthreadpool\",{\"1\":{\"604\":2,\"607\":2}}],[\"cache失效\",{\"1\":{\"579\":1}}],[\"cache中没有取到数据\",{\"1\":{\"302\":1}}],[\"cacheable\",{\"1\":{\"153\":1}}],[\"cacheable快速添加返回结果到缓存\",{\"1\":{\"151\":1}}],[\"cacheevict执行缓存失效\",{\"1\":{\"152\":1}}],[\"cache指定缓存区\",{\"1\":{\"58\":1}}],[\"cache\",{\"0\":{\"58\":1,\"302\":1},\"1\":{\"58\":4,\"302\":5,\"303\":17,\"304\":5,\"360\":2}}],[\"clh锁的结构如下\",{\"1\":{\"622\":1}}],[\"clh\",{\"1\":{\"622\":3}}],[\"clazz\",{\"1\":{\"509\":3}}],[\"classnotfoundexception\",{\"1\":{\"714\":2}}],[\"classpath\",{\"1\":{\"711\":1}}],[\"classcastexception\",{\"1\":{\"634\":1}}],[\"class<\",{\"1\":{\"514\":1,\"712\":1,\"714\":1}}],[\"classloader抽象类\",{\"1\":{\"711\":1,\"712\":1}}],[\"classloader\",{\"1\":{\"509\":1,\"514\":1,\"672\":1,\"710\":1,\"711\":4,\"712\":3,\"713\":10,\"716\":2}}],[\"class通过解释器和jit\",{\"1\":{\"467\":1}}],[\"class文件格式检查\",{\"1\":{\"703\":1}}],[\"class文件结构总结\",{\"0\":{\"690\":1}}],[\"class文件中除了有类的版本号\",{\"1\":{\"646\":1}}],[\"class文件\",{\"1\":{\"467\":1,\"692\":2,\"702\":1,\"709\":1}}],[\"class\",{\"0\":{\"692\":1,\"695\":2},\"1\":{\"146\":2,\"155\":1,\"165\":1,\"436\":4,\"439\":1,\"442\":2,\"444\":1,\"446\":1,\"458\":2,\"459\":3,\"461\":1,\"476\":1,\"480\":1,\"495\":1,\"507\":1,\"509\":5,\"512\":1,\"520\":1,\"521\":1,\"522\":1,\"523\":2,\"524\":2,\"579\":2,\"588\":2,\"599\":1,\"641\":1,\"672\":1,\"689\":1,\"691\":3,\"692\":3,\"694\":2,\"695\":2,\"696\":1,\"697\":2,\"698\":2,\"704\":1,\"712\":2,\"713\":2,\"714\":1}}],[\"cli连接需要变成master的节点\",{\"1\":{\"431\":1}}],[\"cli\",{\"1\":{\"338\":1,\"429\":1}}],[\"client确认了\",{\"1\":{\"194\":2}}],[\"client什么都不能确认\",{\"1\":{\"194\":1}}],[\"client\",{\"1\":{\"90\":2}}],[\"cluster\",{\"1\":{\"297\":1,\"299\":1,\"334\":1,\"343\":1,\"376\":1,\"429\":3,\"430\":1}}],[\"closed\",{\"0\":{\"197\":1}}],[\"close\",{\"1\":{\"52\":1,\"195\":2,\"324\":1}}],[\"cdn\",{\"1\":{\"66\":1}}],[\"ciphers\",{\"1\":{\"62\":2}}],[\"circular\",{\"1\":{\"16\":1}}],[\"certificate\",{\"1\":{\"62\":2}}],[\"css|js|png|jpg|gif|ico\",{\"1\":{\"53\":2}}],[\"cnd\",{\"1\":{\"66\":1}}],[\"cn\",{\"1\":{\"52\":2}}],[\"c\",{\"0\":{\"113\":1},\"1\":{\"16\":5,\"78\":1,\"81\":1,\"271\":1,\"297\":1,\"311\":8,\"383\":2,\"499\":2,\"576\":2,\"712\":1,\"714\":9}}],[\"copying\",{\"1\":{\"675\":1}}],[\"copyonwritearraylist\",{\"0\":{\"628\":1,\"629\":1},\"1\":{\"627\":1,\"628\":1,\"629\":1}}],[\"corepoolsize\",{\"1\":{\"604\":1,\"605\":3}}],[\"correlationdata\",{\"1\":{\"99\":1}}],[\"collections\",{\"1\":{\"376\":1}}],[\"column=\",{\"1\":{\"33\":2}}],[\"countdown\",{\"1\":{\"625\":4}}],[\"countdownlatch\",{\"0\":{\"625\":1},\"1\":{\"623\":1,\"625\":11}}],[\"counting\",{\"1\":{\"401\":1}}],[\"count\",{\"1\":{\"315\":2,\"393\":2,\"405\":1,\"625\":2,\"626\":3,\"693\":3,\"695\":2,\"696\":2,\"697\":3,\"698\":2}}],[\"condition\",{\"1\":{\"243\":1}}],[\"context\",{\"1\":{\"458\":3,\"463\":1}}],[\"content\",{\"1\":{\"181\":2}}],[\"continue\",{\"1\":{\"181\":1}}],[\"controlleradvice\",{\"1\":{\"459\":2}}],[\"controller\",{\"1\":{\"451\":1,\"456\":1,\"459\":2}}],[\"control\",{\"1\":{\"8\":1,\"173\":1,\"174\":1,\"210\":1,\"213\":1}}],[\"conf中添加\",{\"1\":{\"418\":1}}],[\"conflict\",{\"1\":{\"181\":1}}],[\"conf\",{\"1\":{\"108\":1,\"346\":1}}],[\"config\",{\"1\":{\"350\":5,\"376\":1}}],[\"configuration表示这是一个配置类\",{\"1\":{\"461\":1}}],[\"configuration\",{\"1\":{\"32\":1,\"210\":1,\"444\":1,\"463\":1}}],[\"confirm一定成功\",{\"1\":{\"123\":1}}],[\"confirm阶段是做确认提交\",{\"1\":{\"123\":1}}],[\"confirm\",{\"1\":{\"123\":1}}],[\"confirmcallback\",{\"0\":{\"99\":1}}],[\"concurrentskiplistmap\",{\"0\":{\"635\":1},\"1\":{\"627\":1}}],[\"concurrentlinkedqueue\",{\"0\":{\"630\":1},\"1\":{\"627\":1,\"630\":4}}],[\"concurrenthashmap\",{\"0\":{\"550\":1,\"551\":1},\"1\":{\"550\":4,\"627\":1}}],[\"concurrent\",{\"1\":{\"90\":1,\"581\":1,\"620\":1,\"627\":1,\"683\":2}}],[\"constant\",{\"0\":{\"693\":1},\"1\":{\"693\":4}}],[\"const\",{\"1\":{\"243\":4}}],[\"consistency\",{\"0\":{\"113\":1}}],[\"consistent参数启用ketama一致哈希算法\",{\"1\":{\"60\":1}}],[\"consistent\",{\"1\":{\"60\":1,\"120\":1}}],[\"consumer和broker之间的tcp连接\",{\"1\":{\"97\":1}}],[\"consumer\",{\"1\":{\"83\":2,\"102\":2}}],[\"conn>\",{\"1\":{\"446\":1}}],[\"conn\",{\"1\":{\"60\":2,\"446\":1}}],[\"connected\",{\"1\":{\"60\":1}}],[\"connection的开销\",{\"1\":{\"97\":1}}],[\"connection的开销会比较大且效率也较低\",{\"1\":{\"97\":1}}],[\"connection\",{\"1\":{\"52\":1,\"97\":1}}],[\"completablefuture<skuinfoentity>\",{\"1\":{\"613\":4}}],[\"completablefuture\",{\"0\":{\"613\":1},\"1\":{\"613\":5}}],[\"completionstage<boolean>\",{\"1\":{\"376\":1}}],[\"comparator\",{\"1\":{\"634\":1}}],[\"comparable\",{\"1\":{\"634\":1}}],[\"comparable对象\",{\"1\":{\"539\":1}}],[\"comparable<string>\",{\"1\":{\"495\":1}}],[\"compareto\",{\"1\":{\"634\":1}}],[\"compare\",{\"1\":{\"581\":1,\"583\":1}}],[\"component就能声明一个bean\",{\"1\":{\"507\":1}}],[\"component\",{\"1\":{\"436\":1,\"439\":1,\"442\":1}}],[\"componentscan三个注解\",{\"1\":{\"461\":1}}],[\"componentscan\",{\"1\":{\"436\":1,\"461\":2}}],[\"compose命令和docker命令结构是相同的\",{\"1\":{\"109\":1}}],[\"compose把项目的多个服务集合到一起\",{\"1\":{\"109\":1}}],[\"compose\",{\"0\":{\"109\":1},\"1\":{\"109\":4}}],[\"committed\",{\"1\":{\"232\":2,\"234\":1,\"282\":2,\"284\":1}}],[\"commit\",{\"1\":{\"122\":1,\"230\":1,\"446\":1}}],[\"com\",{\"1\":{\"30\":1,\"33\":1,\"90\":5,\"436\":1,\"509\":2}}],[\"come\",{\"1\":{\"16\":1}}],[\"它尽可能优化字符串串联操作\",{\"1\":{\"726\":1}}],[\"它采用\",{\"1\":{\"726\":1}}],[\"它限制在抛出\",{\"1\":{\"725\":1}}],[\"它首先不会自己去尝试加载这个类\",{\"1\":{\"716\":1}}],[\"它首先不会尝试去加载这个类\",{\"1\":{\"714\":1}}],[\"它不面向任何特定的处理器\",{\"1\":{\"689\":1}}],[\"它不再坚持以固定大小以及固定数量的分代区域划分\",{\"1\":{\"684\":1}}],[\"它不能再次被使用\",{\"1\":{\"625\":1}}],[\"它使用的回收算法\",{\"1\":{\"683\":1}}],[\"它第一次实现了让垃圾收集线程与用户线程\",{\"1\":{\"683\":1}}],[\"它非常符合在注重用户体验的应用上使用\",{\"1\":{\"683\":1}}],[\"它主要有两大用途\",{\"1\":{\"681\":1}}],[\"它主要的作用就是bean出现循环依赖后\",{\"1\":{\"450\":1}}],[\"它同样是一个单线程收集器\",{\"1\":{\"681\":1}}],[\"它同时实现了一个broker构架\",{\"1\":{\"80\":1}}],[\"它可以将内存分为大小相同的两块\",{\"1\":{\"675\":1}}],[\"它可以用于大型软件系统各个模块之间的高效通信\",{\"1\":{\"80\":1}}],[\"它可以用于标签属性值和\",{\"1\":{\"29\":1}}],[\"它里面的\",{\"1\":{\"663\":1}}],[\"它就是\",{\"1\":{\"634\":1}}],[\"它默认构造\",{\"1\":{\"624\":1,\"625\":1}}],[\"它保存着线程的引用\",{\"1\":{\"622\":1}}],[\"它保存的就是一个lambda表达式\",{\"1\":{\"450\":1}}],[\"它名字中的\",{\"1\":{\"618\":1}}],[\"它通过条件化配置来根据应用的依赖和配置来自动装配和配置各种功能和组件\",{\"1\":{\"463\":1}}],[\"它用来保存哪些没有经过完整bean生命周期的单例bean对象\",{\"1\":{\"450\":1}}],[\"它用来存放经过完整bean生命周期过程的单例bean对象\",{\"1\":{\"450\":1}}],[\"它们是一组预配置的依赖关系\",{\"1\":{\"463\":1}}],[\"它们就使用到了模板模式\",{\"1\":{\"437\":1}}],[\"它们才会一起继续执行\",{\"1\":{\"7\":1}}],[\"它将感兴趣的事件及类型注册到内核中并监听每个事件是否发生\",{\"1\":{\"321\":1}}],[\"它比较类似于\",{\"1\":{\"306\":1}}],[\"它对数据库中的数据改变是持久的\",{\"1\":{\"231\":1}}],[\"它和\",{\"1\":{\"222\":1}}],[\"它和后续的confirm一起才能真正构成一个完整的业务逻辑\",{\"1\":{\"123\":1}}],[\"它解决的是网络层地址和链路层地址之间的转换问题\",{\"1\":{\"214\":1}}],[\"它的整个生命周期可以简单概括为\",{\"1\":{\"700\":1}}],[\"它的唯一作用是确定这个文件是否为一个能被虚拟机接收的\",{\"1\":{\"691\":1}}],[\"它的插入操作\",{\"1\":{\"634\":1}}],[\"它的意思是这个锁会偏向于第一个获得它的线程\",{\"1\":{\"619\":1}}],[\"它的目的是消除数据在无竞争情况下的同步原语\",{\"1\":{\"619\":1}}],[\"它的本意是在没有多线程竞争的前提下\",{\"1\":{\"618\":1}}],[\"它的查找\",{\"1\":{\"260\":1}}],[\"它的\",{\"1\":{\"213\":1}}],[\"它启动一个定时器\",{\"1\":{\"199\":1}}],[\"它发送一个\",{\"1\":{\"195\":1}}],[\"它起着代理的作用\",{\"1\":{\"185\":1}}],[\"它允许将私有\",{\"1\":{\"211\":1}}],[\"它允许只请求资源的某个部分\",{\"1\":{\"181\":1}}],[\"它允许同一时刻多个线程访问同一资源\",{\"1\":{\"7\":1}}],[\"它提供了端到端的实时传输数据的功能\",{\"1\":{\"172\":1}}],[\"它在功能和性能上都更加强大\",{\"1\":{\"172\":1,\"191\":1}}],[\"它只虚拟软件需要运行的环境\",{\"1\":{\"104\":1}}],[\"它能被重新被发送到另一个交换器中\",{\"1\":{\"93\":1}}],[\"它约定\",{\"1\":{\"90\":1}}],[\"它与direct类型的交换器相似\",{\"1\":{\"90\":1}}],[\"它会触发各种生命周期事件\",{\"1\":{\"463\":1}}],[\"它会假定确认件指出的数据段丢失了\",{\"1\":{\"201\":1}}],[\"它会把消息路由到那些bindingkey与routingkey完全匹配的queue中\",{\"1\":{\"89\":1}}],[\"它会把所有发送到该exchange的消息路由到所有与它绑定的queue中\",{\"1\":{\"88\":1}}],[\"它会停止执行并等待其他线程到达屏障\",{\"1\":{\"7\":1}}],[\"它最初起源于金融系统\",{\"1\":{\"78\":1}}],[\"它是\",{\"1\":{\"380\":1}}],[\"它是一种具体的\",{\"1\":{\"182\":1}}],[\"它是针对resultset结果集执行的内存分页\",{\"1\":{\"34\":1}}],[\"它是异步\",{\"1\":{\"23\":1}}],[\"它包含了到原文件的路径信息\",{\"1\":{\"15\":1}}],[\"用一个闭包结构去记录可达对象\",{\"1\":{\"683\":1}}],[\"用key搜索\",{\"1\":{\"529\":1}}],[\"用正则等工具从数据中获取\",{\"1\":{\"175\":1}}],[\"用的都是同一个传输层协议\",{\"1\":{\"175\":1}}],[\"用\",{\"1\":{\"150\":1,\"175\":1,\"686\":1}}],[\"用来表示哪部分的内存是空闲的\",{\"1\":{\"650\":1}}],[\"用来加载代理对象\",{\"1\":{\"514\":1}}],[\"用来生成一个代理对象\",{\"1\":{\"514\":1}}],[\"用来扫描项目中的自动配置类并将其返回为自动配置类的名字string\",{\"1\":{\"461\":1}}],[\"用来保证不完整的bean也是单例\",{\"1\":{\"450\":1}}],[\"用来保存消息直到发送给消费者\",{\"1\":{\"85\":1}}],[\"用来标识整个查询中select语句的顺序\",{\"1\":{\"243\":1}}],[\"用来关闭客户端到服务器的数据传送\",{\"1\":{\"195\":1}}],[\"用来指定这个消息的路由规则\",{\"1\":{\"84\":1}}],[\"用完就会立即关闭\",{\"1\":{\"35\":1}}],[\"用套接字中的相关函数来完成通信过程\",{\"1\":{\"9\":1}}],[\"用于发出紧急命令\",{\"1\":{\"725\":1}}],[\"用于统计类加载器相关的信息\",{\"1\":{\"714\":1}}],[\"用于描述接口或类中声明的变量\",{\"1\":{\"696\":1}}],[\"用于展示当前临界资源的获锁情况\",{\"1\":{\"622\":1}}],[\"用于实现类加载过程中的第一步\",{\"1\":{\"709\":1}}],[\"用于实现乐观锁\",{\"1\":{\"583\":1}}],[\"用于实现不同类型的功能和选项\",{\"1\":{\"210\":1}}],[\"用于线程的暂停执行\",{\"1\":{\"566\":1}}],[\"用于调用原始方法\",{\"1\":{\"515\":1}}],[\"用于拦截增强被代理类的方法\",{\"1\":{\"515\":1}}],[\"用于对传输准确性要求特别高的场景\",{\"1\":{\"189\":1}}],[\"用于修改服务器上的数据\",{\"1\":{\"175\":1}}],[\"用于获取信息\",{\"1\":{\"175\":1}}],[\"用于解决域名和\",{\"1\":{\"172\":1}}],[\"用于通过一个终端登陆到其他服务器\",{\"1\":{\"172\":1,\"191\":1}}],[\"用于通知接收进程某个事件已经发生\",{\"1\":{\"9\":1}}],[\"用于防止恶意请求\",{\"1\":{\"158\":1}}],[\"用于存放方法执行过程中产生的中间计算结果\",{\"1\":{\"641\":1}}],[\"用于存放新创建的对象\",{\"1\":{\"560\":1}}],[\"用于存放局部变量表\",{\"1\":{\"559\":1}}],[\"用于存放主要信息\",{\"1\":{\"150\":1}}],[\"用于存储消息\",{\"1\":{\"92\":1}}],[\"用于匹配零个或者多个单词\",{\"1\":{\"90\":1}}],[\"用于匹配一个单词\",{\"1\":{\"90\":1}}],[\"用于做模糊匹配\",{\"1\":{\"90\":1}}],[\"用于在分布式系统中存储转发消息\",{\"1\":{\"78\":1}}],[\"用于优化资源利用率\",{\"1\":{\"59\":1}}],[\"用于多进程对共享数据的访问\",{\"1\":{\"9\":1}}],[\"用于具有亲缘关系的父子进程间或者兄弟进程之间的通信\",{\"1\":{\"9\":1}}],[\"用于等待多个线程到达某个点再一起继续执行\",{\"1\":{\"7\":1}}],[\"用户可通过覆写该方法\",{\"1\":{\"714\":1}}],[\"用户可以重新定义或追加header信息传递给后端服务器\",{\"1\":{\"52\":1}}],[\"用户需要定义一个需要执行的主类\",{\"1\":{\"706\":1}}],[\"用户行为统计\",{\"1\":{\"400\":1}}],[\"用户签到情况\",{\"1\":{\"400\":1}}],[\"用户信息\",{\"1\":{\"391\":1}}],[\"用户单位时间的请求数\",{\"1\":{\"385\":1}}],[\"用户\",{\"1\":{\"312\":1}}],[\"用户访问的数据属于高频数据并且不会经常改变的话\",{\"1\":{\"300\":1}}],[\"用户只能看到该事务创建\",{\"1\":{\"286\":1}}],[\"用户无法手动操作意向锁\",{\"1\":{\"240\":1}}],[\"用户变量\",{\"1\":{\"229\":1}}],[\"用户数据协议\",{\"1\":{\"173\":1}}],[\"用户数据在redis中过期\",{\"1\":{\"149\":1}}],[\"用户最终的体验都是部分服务不可用\",{\"1\":{\"165\":1}}],[\"用户提交用户名\",{\"1\":{\"146\":1}}],[\"用户不存在\",{\"1\":{\"146\":1}}],[\"用户还可通过接口主动查询支付结果\",{\"1\":{\"96\":1}}],[\"用户的真实ip\",{\"1\":{\"52\":1}}],[\"用户的身份认证\",{\"1\":{\"2\":1}}],[\"用户再发起read调用\",{\"1\":{\"22\":1}}],[\"用户栈指针\",{\"1\":{\"8\":1}}],[\"用户态进程主动要求切换到内核态的一种方式\",{\"1\":{\"3\":1}}],[\"用户态切换到内核态的三种方式\",{\"1\":{\"3\":1}}],[\"用户态运行的进程可以直接读取用户程序的数据\",{\"1\":{\"3\":1}}],[\"用户态\",{\"1\":{\"3\":1}}],[\"屏障是一种同步原语\",{\"1\":{\"7\":1}}],[\"屏障\",{\"1\":{\"7\":1}}],[\"sweep\",{\"1\":{\"674\":2,\"683\":2}}],[\"swap\",{\"0\":{\"368\":1},\"1\":{\"581\":1,\"583\":1}}],[\"s0\",{\"1\":{\"662\":1}}],[\"sfence\",{\"1\":{\"579\":1}}],[\"sftp\",{\"1\":{\"172\":1,\"191\":1}}],[\"s4\",{\"1\":{\"498\":5}}],[\"s3\",{\"1\":{\"498\":4}}],[\"s2\",{\"1\":{\"498\":3}}],[\"s1\",{\"0\":{\"497\":1},\"1\":{\"498\":6,\"662\":1}}],[\"skuitemvo\",{\"1\":{\"613\":1}}],[\"skuinfoentity\",{\"1\":{\"613\":1}}],[\"skuid和秒杀场次的对应正确性校验\",{\"1\":{\"162\":1}}],[\"skuid\",{\"1\":{\"158\":1,\"613\":1}}],[\"sku\",{\"1\":{\"613\":1}}],[\"sku基本信息的获取\",{\"1\":{\"613\":1}}],[\"skill\",{\"1\":{\"486\":1}}],[\"skiplist\",{\"1\":{\"382\":2}}],[\"safepoint\",{\"1\":{\"724\":1}}],[\"save\",{\"0\":{\"363\":1},\"1\":{\"363\":2,\"409\":1}}],[\"sadd\",{\"1\":{\"315\":1,\"332\":1,\"393\":1}}],[\"sdiffstore\",{\"1\":{\"393\":1,\"394\":1}}],[\"sdiff\",{\"1\":{\"345\":1,\"362\":1,\"393\":1,\"394\":1}}],[\"sds\",{\"1\":{\"311\":9,\"382\":2,\"383\":3}}],[\"sun\",{\"1\":{\"714\":3}}],[\"sunionstore\",{\"1\":{\"393\":1,\"394\":1}}],[\"sunion\",{\"1\":{\"345\":1,\"362\":1,\"393\":1,\"394\":1}}],[\"super\",{\"0\":{\"695\":1},\"1\":{\"695\":1}}],[\"supplyasync\",{\"1\":{\"613\":3}}],[\"supports\",{\"1\":{\"447\":1}}],[\"survivorratio=6\",{\"1\":{\"726\":1}}],[\"survivorratio\",{\"1\":{\"726\":1}}],[\"survivor空间或者老年代空间\",{\"1\":{\"684\":1}}],[\"survivor\",{\"1\":{\"662\":4,\"726\":2}}],[\"sum\",{\"1\":{\"396\":1,\"476\":2}}],[\"submit\",{\"1\":{\"612\":1}}],[\"subquery\",{\"1\":{\"243\":3}}],[\"sub\",{\"1\":{\"150\":1,\"306\":1}}],[\"smembers\",{\"1\":{\"345\":1,\"362\":1,\"393\":1}}],[\"smtp\",{\"1\":{\"80\":1,\"172\":2,\"191\":3}}],[\"sleep方法是thread类的静态本地方法\",{\"1\":{\"566\":1}}],[\"sleep\",{\"0\":{\"566\":1},\"1\":{\"566\":3}}],[\"slave节点拒绝任何客户端请求\",{\"1\":{\"431\":1}}],[\"slave节点断开又恢复\",{\"1\":{\"422\":1}}],[\"slave节点断开太久\",{\"1\":{\"422\":1}}],[\"slave节点第一次连接时\",{\"1\":{\"422\":1}}],[\"slave提交自己的offset到master\",{\"1\":{\"422\":1}}],[\"slave完成同步时也会记录当前同步的offset\",{\"1\":{\"420\":1}}],[\"slave则会继承master节点的replid\",{\"1\":{\"420\":1}}],[\"slaveof\",{\"1\":{\"418\":1}}],[\"slaac\",{\"1\":{\"210\":1}}],[\"slow\",{\"1\":{\"346\":1}}],[\"slower\",{\"1\":{\"346\":2}}],[\"slowlog\",{\"1\":{\"346\":3}}],[\"slots\",{\"1\":{\"430\":1}}],[\"slot\",{\"1\":{\"333\":1,\"334\":1}}],[\"spi机制表示扩展机制\",{\"1\":{\"462\":1}}],[\"spi实现的核心\",{\"1\":{\"462\":1}}],[\"spin\",{\"1\":{\"377\":1}}],[\"spop\",{\"1\":{\"315\":1,\"393\":1,\"394\":1}}],[\"spring容器会进行扫描\",{\"1\":{\"461\":1}}],[\"spring容器的启动流程\",{\"0\":{\"453\":1}}],[\"springmvc零配置\",{\"0\":{\"458\":1}}],[\"springmvc的核心组件有哪些\",{\"0\":{\"457\":1}}],[\"springmvc中的一次请求流程\",{\"1\":{\"456\":1}}],[\"springmvc处理请求的底层原理\",{\"0\":{\"456\":1}}],[\"springmvc\",{\"0\":{\"454\":1,\"455\":1}}],[\"spring启动结束\",{\"1\":{\"453\":1}}],[\"spring本身没有提供bean的线程安全策略\",{\"1\":{\"451\":1}}],[\"spring框架中的bean是线程安全的吗\",{\"0\":{\"451\":1}}],[\"spring为什么要使用三级缓存来解决循环依赖\",{\"0\":{\"450\":1}}],[\"springaop是通过动态代理机制\",{\"1\":{\"449\":1}}],[\"springaop怎么工作的\",{\"0\":{\"449\":1}}],[\"spring事务失效的原因\",{\"0\":{\"448\":1}}],[\"spring事务传播机制\",{\"0\":{\"447\":1}}],[\"spring事务\",{\"0\":{\"445\":1},\"1\":{\"448\":1}}],[\"spring发现有多个构造方法的时候\",{\"1\":{\"443\":1}}],[\"spring中一个bean的创建大概分为以下几个步骤\",{\"1\":{\"438\":1}}],[\"spring中bean创建的生命周期\",{\"0\":{\"438\":1}}],[\"spring中的设计模式\",{\"0\":{\"437\":1}}],[\"spring是一个轻量级的控制反转\",{\"1\":{\"434\":1}}],[\"spring是什么\",{\"0\":{\"434\":1}}],[\"spring\",{\"0\":{\"433\":1,\"464\":1},\"1\":{\"437\":6,\"462\":1,\"463\":12,\"507\":1}}],[\"springcache中的\",{\"1\":{\"152\":1}}],[\"springcloud\",{\"1\":{\"136\":1}}],[\"springschedule定时任务上架秒杀商品\",{\"1\":{\"136\":1}}],[\"springsecurity完成多微服务下的用户登录验证和状态刷新\",{\"1\":{\"136\":1}}],[\"springsecurity\",{\"1\":{\"136\":1}}],[\"springboot中使用\",{\"1\":{\"507\":1}}],[\"springboot中的spring\",{\"0\":{\"462\":1}}],[\"springboot的启动流程\",{\"0\":{\"463\":1}}],[\"springboot在启动的过程中\",{\"1\":{\"462\":1}}],[\"springbootconfiguration\",{\"1\":{\"461\":3}}],[\"springbootapplication\",{\"1\":{\"461\":2,\"463\":1}}],[\"springbootapplication是一个复合注解\",{\"1\":{\"461\":1}}],[\"springbootapplication注解的作用\",{\"0\":{\"461\":1}}],[\"springboot\",{\"0\":{\"454\":1,\"460\":1},\"1\":{\"136\":1,\"137\":1,\"507\":1}}],[\"snapshot\",{\"1\":{\"284\":1}}],[\"s\",{\"1\":{\"239\":1,\"240\":2,\"285\":1,\"501\":3}}],[\"srandmember\",{\"1\":{\"315\":1,\"393\":1,\"394\":1}}],[\"sr\",{\"0\":{\"205\":1}}],[\"scavenge\",{\"0\":{\"680\":1},\"1\":{\"681\":1,\"682\":2}}],[\"scard\",{\"1\":{\"393\":1,\"394\":1}}],[\"scan\",{\"1\":{\"16\":9}}],[\"score2\",{\"1\":{\"396\":1}}],[\"score1\",{\"1\":{\"396\":1}}],[\"score\",{\"1\":{\"345\":1,\"362\":1,\"395\":3,\"396\":5,\"405\":1}}],[\"scheduledthreadpool\",{\"1\":{\"604\":2,\"607\":1}}],[\"scheduled\",{\"1\":{\"159\":1}}],[\"scheduled进行定时上架商品\",{\"1\":{\"158\":1}}],[\"script\",{\"1\":{\"155\":2}}],[\"sscan\",{\"1\":{\"362\":1}}],[\"ssh\",{\"1\":{\"172\":2,\"191\":5}}],[\"ssl\",{\"1\":{\"62\":7,\"180\":2,\"191\":1}}],[\"sstf\",{\"1\":{\"16\":3}}],[\"stw\",{\"1\":{\"724\":1}}],[\"starters\",{\"1\":{\"463\":1}}],[\"start\",{\"1\":{\"230\":1,\"387\":2,\"396\":4,\"399\":2,\"568\":2}}],[\"statement\",{\"1\":{\"729\":1}}],[\"state>=0\",{\"1\":{\"624\":1}}],[\"state<0\",{\"1\":{\"624\":1}}],[\"state=state+1\",{\"1\":{\"624\":1}}],[\"state=state\",{\"1\":{\"624\":2}}],[\"stateless\",{\"1\":{\"210\":1}}],[\"state\",{\"1\":{\"120\":1,\"622\":2,\"624\":5,\"625\":6}}],[\"static则子类不能重写方法\",{\"1\":{\"480\":1}}],[\"static\",{\"1\":{\"53\":1,\"54\":2,\"436\":1,\"487\":1,\"503\":2,\"505\":1,\"514\":1,\"520\":2,\"521\":3,\"522\":2,\"523\":2,\"524\":3,\"546\":1,\"579\":1,\"588\":1,\"704\":1}}],[\"stock\",{\"1\":{\"158\":1}}],[\"stop\",{\"1\":{\"109\":1,\"678\":1,\"684\":1}}],[\"stomp\",{\"1\":{\"78\":1,\"80\":1}}],[\"str4\",{\"1\":{\"499\":2}}],[\"str\",{\"1\":{\"497\":2,\"499\":2,\"501\":3}}],[\"str3\",{\"1\":{\"484\":3,\"499\":3}}],[\"str2\",{\"1\":{\"484\":4,\"499\":5}}],[\"str1\",{\"1\":{\"484\":6,\"499\":5}}],[\"strlen\",{\"1\":{\"384\":1}}],[\"stringtablesize\",{\"1\":{\"647\":2}}],[\"stringtable\",{\"1\":{\"647\":2}}],[\"string对象使用+进行拼接\",{\"1\":{\"496\":1}}],[\"string类本身也被final修饰导致不能被继承\",{\"1\":{\"495\":1}}],[\"string类型的value超过10kb\",{\"1\":{\"336\":1}}],[\"string为何不可变\",{\"0\":{\"495\":1}}],[\"string是不可变的\",{\"1\":{\"494\":1}}],[\"stringbuilder没有添加同步锁\",{\"1\":{\"494\":1}}],[\"stringbuilder\",{\"0\":{\"494\":1,\"496\":1}}],[\"stringbuffer和stringbuilder是对对象本身进行操作\",{\"1\":{\"494\":1}}],[\"stringbuffer\",{\"0\":{\"494\":1}}],[\"string\",{\"0\":{\"309\":1,\"310\":1,\"311\":1,\"312\":1,\"383\":1,\"493\":1,\"494\":1,\"497\":2,\"498\":1},\"1\":{\"100\":3,\"146\":1,\"150\":2,\"155\":2,\"297\":1,\"308\":1,\"309\":3,\"310\":4,\"311\":2,\"382\":2,\"383\":3,\"389\":1,\"436\":1,\"476\":1,\"480\":3,\"484\":4,\"495\":1,\"497\":4,\"498\":6,\"499\":9,\"501\":2,\"503\":1,\"647\":1,\"671\":1,\"712\":2,\"714\":1,\"726\":4}}],[\"stream\",{\"1\":{\"63\":1,\"139\":1,\"306\":3,\"388\":1}}],[\"student\",{\"1\":{\"30\":2}}],[\"sourcekey2\",{\"1\":{\"402\":1}}],[\"sourcekey1\",{\"1\":{\"402\":1}}],[\"sorted\",{\"0\":{\"395\":1},\"1\":{\"297\":1,\"306\":1,\"313\":1,\"345\":2,\"362\":2,\"395\":2,\"404\":1,\"405\":1}}],[\"soft\",{\"1\":{\"120\":1}}],[\"some\",{\"1\":{\"52\":5}}],[\"sockets\",{\"1\":{\"9\":1}}],[\"sift\",{\"1\":{\"539\":3}}],[\"sismember\",{\"1\":{\"393\":1}}],[\"singlethreadscheduledexecutor\",{\"1\":{\"607\":1}}],[\"singlethreadexector\",{\"1\":{\"607\":1}}],[\"singlethreadexecutor\",{\"1\":{\"604\":2}}],[\"singleton=new\",{\"1\":{\"579\":1}}],[\"singleton==null\",{\"1\":{\"579\":2}}],[\"singletoninstance\",{\"1\":{\"524\":2}}],[\"singleton\",{\"1\":{\"451\":1,\"520\":7,\"521\":8,\"522\":9,\"523\":11,\"524\":7,\"525\":2,\"579\":8}}],[\"singletonfactories\",{\"1\":{\"450\":1}}],[\"singletonobjects\",{\"1\":{\"450\":1}}],[\"singletonlist\",{\"1\":{\"376\":1}}],[\"sinterstore\",{\"1\":{\"393\":1,\"394\":1}}],[\"sinter\",{\"1\":{\"345\":1,\"362\":1,\"393\":1,\"394\":1}}],[\"since\",{\"1\":{\"181\":2}}],[\"simple\",{\"1\":{\"172\":1,\"191\":1,\"243\":1,\"311\":1,\"383\":1}}],[\"simpleexecutor\",{\"1\":{\"35\":1}}],[\"signature\",{\"1\":{\"150\":2}}],[\"signal\",{\"1\":{\"9\":1}}],[\"size>\",{\"1\":{\"719\":2,\"720\":1}}],[\"size设置一次写入临时文件的大小\",{\"1\":{\"57\":1}}],[\"size设置临时文件的最大值\",{\"1\":{\"57\":1}}],[\"size\",{\"1\":{\"57\":1,\"414\":1}}],[\"size进行设置\",{\"1\":{\"57\":1}}],[\"sql定义了四个隔离级别\",{\"1\":{\"282\":1}}],[\"sql2\",{\"1\":{\"230\":1}}],[\"sql1\",{\"1\":{\"230\":1}}],[\"sql语句会经过分析器\",{\"1\":{\"226\":1}}],[\"sql\",{\"1\":{\"29\":5,\"30\":3,\"32\":1,\"34\":1,\"230\":1,\"243\":2,\"248\":2,\"278\":1,\"282\":1}}],[\"shutdown\",{\"1\":{\"725\":1}}],[\"short\",{\"1\":{\"469\":1,\"471\":1}}],[\"shortest\",{\"1\":{\"16\":2,\"174\":1}}],[\"shell\",{\"1\":{\"172\":1,\"191\":1}}],[\"shanghai\",{\"1\":{\"109\":1}}],[\"sha256\",{\"1\":{\"62\":1}}],[\"share\",{\"1\":{\"53\":1,\"62\":2,\"108\":2,\"241\":2,\"284\":1,\"285\":2,\"292\":1}}],[\"shared\",{\"1\":{\"9\":1,\"240\":1}}],[\"segment\",{\"1\":{\"550\":1,\"551\":3}}],[\"segment的个数固定默认16\",{\"1\":{\"550\":1}}],[\"sequential\",{\"1\":{\"380\":2}}],[\"seq=y\",{\"1\":{\"193\":1,\"195\":1}}],[\"seq=x\",{\"1\":{\"193\":1,\"195\":2}}],[\"serial\",{\"0\":{\"678\":1,\"681\":1},\"1\":{\"650\":1,\"678\":1,\"679\":3,\"681\":1}}],[\"serialversionuid用来给jvm识别的\",{\"1\":{\"505\":1}}],[\"serialversionuid的作用是版本控制\",{\"1\":{\"505\":1}}],[\"serialversionuid\",{\"0\":{\"505\":1},\"1\":{\"505\":1}}],[\"serializable\",{\"1\":{\"282\":2,\"495\":1}}],[\"serializable隔离级别是通过锁来实现的\",{\"1\":{\"234\":1}}],[\"servletregistration\",{\"1\":{\"458\":1}}],[\"servlet\",{\"1\":{\"458\":2}}],[\"servletexception\",{\"1\":{\"458\":1}}],[\"servletcontext\",{\"1\":{\"458\":3}}],[\"server的maxmemory\",{\"1\":{\"342\":1}}],[\"server的确认\",{\"1\":{\"129\":1}}],[\"server确认了\",{\"1\":{\"194\":2}}],[\"server确认了对方发送正常\",{\"1\":{\"194\":1}}],[\"server端到nginx端的连接\",{\"1\":{\"141\":1}}],[\"server一定要配置port\",{\"1\":{\"139\":1}}],[\"server到mq订阅方部分采用ack确认机制\",{\"1\":{\"129\":1}}],[\"server会主动修改消息状态\",{\"1\":{\"129\":1}}],[\"server发送rollback\",{\"1\":{\"129\":1}}],[\"server将消息commit\",{\"1\":{\"129\":1}}],[\"server时\",{\"1\":{\"129\":1}}],[\"server提供的服务时\",{\"1\":{\"97\":1}}],[\"server\",{\"1\":{\"48\":3,\"51\":2,\"53\":2,\"58\":1,\"59\":4,\"60\":10,\"61\":2,\"62\":3,\"63\":2,\"65\":1,\"66\":1,\"97\":1,\"139\":6,\"142\":3,\"197\":1,\"328\":5,\"726\":2}}],[\"served\",{\"1\":{\"16\":1}}],[\"services\",{\"1\":{\"109\":1}}],[\"service\",{\"1\":{\"16\":1,\"74\":1,\"146\":1,\"451\":1}}],[\"send\",{\"1\":{\"193\":1}}],[\"sentinel给所有其他slave发送配置从节点命令slaveof\",{\"1\":{\"427\":1}}],[\"sentinel给备选slave1节点发送slaveof\",{\"1\":{\"427\":1}}],[\"sentinel会将一个slaver提升为master\",{\"1\":{\"424\":1}}],[\"sentinel中设置rt\",{\"1\":{\"165\":1}}],[\"sentinel用来熔断降级限流\",{\"1\":{\"137\":1}}],[\"sentinel框架熔断降级的流量错峰保证在秒杀高流量的情况下项目稳定\",{\"1\":{\"136\":1}}],[\"sentinel\",{\"1\":{\"136\":1,\"137\":1,\"297\":1,\"376\":1}}],[\"seo\",{\"1\":{\"180\":2}}],[\"seconds\",{\"1\":{\"376\":1,\"384\":1}}],[\"second\",{\"1\":{\"300\":1}}],[\"secure\",{\"1\":{\"172\":1,\"191\":2}}],[\"securitycontextholder可以看成一个threadlocal用来在一次会话中共享数据\",{\"1\":{\"146\":1}}],[\"securitycontextholder\",{\"1\":{\"146\":2}}],[\"seckillfallbackservice\",{\"1\":{\"165\":1}}],[\"seckill\",{\"1\":{\"158\":1,\"165\":1}}],[\"seckillskuprice\",{\"1\":{\"158\":1}}],[\"seckillskuvo\",{\"1\":{\"158\":1}}],[\"secret\",{\"1\":{\"150\":1}}],[\"seata\",{\"1\":{\"122\":1}}],[\"session\",{\"1\":{\"62\":1,\"309\":1,\"380\":1,\"385\":1,\"451\":2}}],[\"setaccessible\",{\"1\":{\"510\":1}}],[\"setauthentication\",{\"1\":{\"146\":1}}],[\"setlockwatchdogtimeout\",{\"1\":{\"376\":1}}],[\"setinfo\",{\"1\":{\"613\":1}}],[\"setint\",{\"1\":{\"29\":1}}],[\"setifabsent\",{\"1\":{\"374\":1}}],[\"set命令将activedefrag设置为yes即可\",{\"1\":{\"350\":1}}],[\"setex\",{\"1\":{\"326\":2}}],[\"setbit\",{\"1\":{\"316\":3,\"399\":1,\"400\":1}}],[\"setnx\",{\"1\":{\"309\":1,\"374\":5,\"384\":1,\"385\":1}}],[\"setnx占位成功表示这个用户没有买过商品\",{\"1\":{\"158\":1}}],[\"setreturncallback\",{\"1\":{\"100\":1}}],[\"setmandatory\",{\"1\":{\"100\":1}}],[\"set\",{\"0\":{\"314\":1,\"315\":1,\"392\":1,\"395\":1,\"529\":1,\"535\":1},\"1\":{\"52\":5,\"297\":1,\"299\":1,\"306\":1,\"308\":1,\"313\":1,\"314\":2,\"315\":1,\"326\":1,\"345\":4,\"350\":5,\"362\":4,\"374\":1,\"375\":2,\"382\":2,\"384\":1,\"385\":2,\"392\":3,\"395\":4,\"404\":1,\"405\":1,\"528\":1,\"529\":1,\"530\":1,\"536\":1,\"598\":1,\"599\":2,\"600\":1,\"629\":1,\"684\":1}}],[\"select标识符\",{\"1\":{\"243\":1}}],[\"selectone\",{\"1\":{\"146\":1}}],[\"selector\",{\"1\":{\"22\":2}}],[\"select>\",{\"1\":{\"30\":1}}],[\"select\",{\"1\":{\"30\":1,\"34\":3,\"239\":1,\"241\":5,\"243\":4,\"271\":2,\"284\":3,\"285\":4,\"292\":2,\"729\":1}}],[\"seek\",{\"1\":{\"16\":1}}],[\"semaphores\",{\"1\":{\"9\":1}}],[\"semaphore\",{\"0\":{\"624\":1},\"1\":{\"7\":1,\"158\":2,\"620\":1,\"624\":9}}],[\"sychronized修饰方法\",{\"0\":{\"588\":1}}],[\"syn+ack\",{\"1\":{\"193\":1}}],[\"syn\",{\"1\":{\"193\":3}}],[\"synchronousqueue等等皆是基于\",{\"1\":{\"620\":1}}],[\"synchronousqueue\",{\"1\":{\"607\":2}}],[\"synchronousqueue同步队列\",{\"1\":{\"604\":1}}],[\"synchronized锁优化\",{\"0\":{\"614\":1}}],[\"synchronized关键字与wait\",{\"1\":{\"594\":1}}],[\"synchronized底层原理\",{\"0\":{\"589\":1}}],[\"synchronized和各种lock来实现原子性\",{\"1\":{\"577\":1}}],[\"synchronized\",{\"0\":{\"586\":1,\"587\":1,\"590\":1,\"594\":1},\"1\":{\"7\":1,\"377\":1,\"522\":1,\"523\":1,\"550\":1,\"551\":2,\"577\":1,\"578\":1,\"579\":2,\"587\":1,\"588\":4,\"589\":5,\"590\":3,\"592\":1,\"594\":1,\"595\":1,\"624\":1,\"714\":1}}],[\"sync\",{\"1\":{\"153\":1,\"422\":1,\"592\":4}}],[\"system\",{\"1\":{\"100\":1,\"172\":1,\"184\":1,\"191\":1,\"243\":3,\"436\":2,\"448\":2,\"476\":2,\"480\":2,\"484\":5,\"498\":3,\"499\":1,\"501\":1,\"503\":2,\"507\":2,\"714\":2}}],[\"symlink\",{\"1\":{\"15\":1}}],[\"symbolic\",{\"1\":{\"15\":2}}],[\"但很有必要\",{\"1\":{\"703\":1}}],[\"但若有空闲线程可以复用\",{\"1\":{\"604\":1}}],[\"但可能会导致某些线程永远无法获取到锁\",{\"1\":{\"593\":1}}],[\"但会对机器的\",{\"1\":{\"416\":1}}],[\"但体积更小\",{\"1\":{\"416\":1}}],[\"但和\",{\"1\":{\"395\":1}}],[\"但也有少部分\",{\"1\":{\"362\":1}}],[\"但也支持\",{\"1\":{\"172\":1}}],[\"但实际还有一些后台线程用于执行一些比较耗时的操作\",{\"1\":{\"324\":1}}],[\"但通过io多路复用程序来监听多个套接字\",{\"1\":{\"320\":1}}],[\"但由于\",{\"1\":{\"291\":1}}],[\"但它们生成\",{\"1\":{\"290\":1}}],[\"但幻读仍有可能发生\",{\"1\":{\"282\":1}}],[\"但还是不推荐这么做\",{\"1\":{\"278\":1}}],[\"但查询条件未遵守最左匹配原则\",{\"1\":{\"278\":1}}],[\"但加锁的开销也最大\",{\"1\":{\"237\":1}}],[\"但同时还要发送确认\",{\"1\":{\"203\":1}}],[\"但对称加密的密钥用服务器方的证书进行了非对称加密\",{\"1\":{\"180\":1}}],[\"但未满足条件\",{\"1\":{\"179\":1}}],[\"但在这个阶段结束\",{\"1\":{\"683\":1}}],[\"但在该\",{\"1\":{\"174\":1}}],[\"但在实际业务处理中\",{\"1\":{\"101\":1}}],[\"但\",{\"1\":{\"174\":1,\"214\":1,\"311\":1,\"538\":1,\"684\":1}}],[\"但后者已经被提议来取代前者\",{\"1\":{\"174\":1}}],[\"但不包括在方法内部声明的局部变量\",{\"1\":{\"696\":1}}],[\"但不包含资源预留存\",{\"1\":{\"172\":1}}],[\"但不能保证数据的原子性\",{\"1\":{\"578\":1,\"590\":1}}],[\"但不能响应错误或者超时\",{\"1\":{\"114\":1}}],[\"但不存在于缓存中\",{\"1\":{\"358\":1}}],[\"但最终达到一致状态\",{\"1\":{\"120\":1}}],[\"但这里的匹配规则有些不同\",{\"1\":{\"90\":1}}],[\"但容易出现饥饿问题\",{\"1\":{\"16\":1}}],[\"但为其分配了\",{\"1\":{\"12\":1}}],[\"但无法被进一步使用\",{\"1\":{\"10\":1}}],[\"但是可以作为\",{\"1\":{\"713\":1}}],[\"但是可能会造成过多的key没有被删除\",{\"1\":{\"327\":1}}],[\"但是自定义的类加载器加载的类是可能被卸载的\",{\"1\":{\"707\":1}}],[\"但是低版本的jvm不会向上兼容高版本的\",{\"1\":{\"692\":1}}],[\"但是cms是追求最小的停顿时间为目标\",{\"1\":{\"685\":1}}],[\"但是微观上是在各个region之间标记复制\",{\"1\":{\"685\":1}}],[\"但是这个参数只支持serial和parnew\",{\"1\":{\"686\":1}}],[\"但是这个组合在g1出现后已经被废弃了\",{\"1\":{\"685\":1}}],[\"但是这种io模型仍然存在问题\",{\"1\":{\"22\":1}}],[\"但是还是保留了分代的概念\",{\"1\":{\"684\":1}}],[\"但是对象之间存在循环引用\",{\"1\":{\"666\":1}}],[\"但是出现溢出的概率比原来的永久代小很多\",{\"1\":{\"645\":1}}],[\"但是被检测到不可能存在共享数据竞争的锁进行消除\",{\"1\":{\"616\":1}}],[\"但是当前运行的线程数是小于最大线程数的\",{\"1\":{\"608\":1}}],[\"但是当并发数量增大的时候\",{\"1\":{\"21\":1}}],[\"但是小于最大线程数\",{\"1\":{\"608\":1}}],[\"但是从\",{\"1\":{\"585\":1}}],[\"但是没义务保证多线程之间语义的一致\",{\"1\":{\"571\":1}}],[\"但是范围过大不可能直接放入内存中进行计算\",{\"1\":{\"548\":1}}],[\"但是范围查询字段的后面的字段无法使用到联合索引\",{\"1\":{\"271\":1}}],[\"但是作为null的key只能有一个\",{\"1\":{\"543\":1}}],[\"但是不称为引用传递\",{\"1\":{\"503\":1}}],[\"但是不代表它的应用场景少\",{\"1\":{\"304\":1}}],[\"但是线程不安全\",{\"1\":{\"494\":1}}],[\"但是能implements多个接口\",{\"1\":{\"487\":1}}],[\"但是能重载\",{\"1\":{\"485\":1}}],[\"但是父类中不存在的方法\",{\"1\":{\"486\":1}}],[\"但是每次插入数据时均需要申请新的堆空间\",{\"1\":{\"538\":1}}],[\"但是每一个英雄的技能各有不同\",{\"1\":{\"486\":1}}],[\"但是每个线程都有自己的程序计数器\",{\"1\":{\"5\":1}}],[\"但是会提供方法来操作属性\",{\"1\":{\"486\":1}}],[\"但是方法内的代码不同\",{\"1\":{\"480\":1}}],[\"但是bservice进行属性赋值\",{\"1\":{\"450\":1}}],[\"但是名字不同\",{\"1\":{\"444\":1}}],[\"但是名称必须是不同的\",{\"1\":{\"435\":1}}],[\"但是存在多个不同参数的有参构造方法\",{\"1\":{\"443\":1}}],[\"但是存在\",{\"1\":{\"428\":1}}],[\"但是aof重写时会占用大量cpu和内存资源\",{\"1\":{\"416\":1}}],[\"但是体积更小\",{\"1\":{\"414\":1}}],[\"但是需要借助于condition接口与newcondition\",{\"1\":{\"594\":1}}],[\"但是需要明确\",{\"1\":{\"362\":1}}],[\"但是需要控制同一时刻访问此资源的最大线程数量\",{\"1\":{\"7\":1}}],[\"但是有少部分o\",{\"1\":{\"345\":1}}],[\"但是之前已经发生的写操作不会撤销\",{\"1\":{\"334\":1}}],[\"但是redis\",{\"1\":{\"323\":1}}],[\"但是给缓存加一个比较短的过期时间\",{\"1\":{\"302\":1}}],[\"但是使用\",{\"1\":{\"300\":1}}],[\"但是innodb\",{\"1\":{\"282\":1}}],[\"但是幻读或不可重复读仍有可能发生\",{\"1\":{\"282\":1}}],[\"但是维护索引的成本也是不小的\",{\"1\":{\"275\":1}}],[\"但是允许数据为null\",{\"1\":{\"264\":1}}],[\"但是两者实现方式有所不同\",{\"1\":{\"262\":1}}],[\"但是两者实现方式不同\",{\"1\":{\"228\":1}}],[\"但是哈希算法有hash冲突问题\",{\"1\":{\"258\":1}}],[\"但是主库和从库的数据存在延时\",{\"1\":{\"246\":1}}],[\"但是缓存同时也带来了额外的开销\",{\"1\":{\"229\":1}}],[\"但是在\",{\"1\":{\"704\":1}}],[\"但是在多线程下还是会出现数据覆盖问题\",{\"1\":{\"549\":1}}],[\"但是在a=1的二级索引记录的范围里\",{\"1\":{\"271\":1}}],[\"但是在符合a>1条件的二级索引记录的范围里\",{\"1\":{\"271\":1}}],[\"但是在日常开发中不建议使用外键\",{\"1\":{\"228\":1}}],[\"但是在路由的时候会丢失header\",{\"1\":{\"51\":1}}],[\"但是如果查询条件是以下几种\",{\"1\":{\"271\":1}}],[\"但是如果服务器宕机\",{\"1\":{\"146\":1}}],[\"但是如果客户端网速很慢\",{\"1\":{\"57\":1}}],[\"但是消息可能接收不到\",{\"1\":{\"132\":1}}],[\"但是提供超高的吞吐量\",{\"1\":{\"79\":1}}],[\"但是由于它基于erlang开发\",{\"1\":{\"79\":1}}],[\"但是多个接口对应的映射必须只有一个\",{\"1\":{\"30\":1}}],[\"但是参数不同\",{\"1\":{\"30\":1}}],[\"但是\",{\"1\":{\"16\":1,\"30\":1,\"180\":1,\"219\":1,\"238\":1,\"285\":1,\"299\":2,\"300\":1,\"304\":1,\"590\":1,\"712\":1,\"716\":1,\"725\":1}}],[\"但是该进程仍在运行\",{\"1\":{\"10\":1}}],[\"但是其父进程仍在运行\",{\"1\":{\"10\":1}}],[\"但只有一个线程可以对共享资源进行写操作\",{\"1\":{\"7\":1}}],[\"关键点在于这二者都存在一个并发标记的步骤\",{\"1\":{\"687\":1}}],[\"关键字修饰的接口方法\",{\"1\":{\"706\":1}}],[\"关键字类似\",{\"1\":{\"592\":1}}],[\"关键字解决的是多个线程之间访问资源的同步性\",{\"1\":{\"590\":1}}],[\"关键字可以修饰方法以及代码块\",{\"1\":{\"590\":1}}],[\"关键字可以保证变量的可见性\",{\"1\":{\"578\":1}}],[\"关键字只能用于变量而\",{\"1\":{\"590\":1}}],[\"关键字是线程同步的轻量级实现\",{\"1\":{\"590\":1}}],[\"关键字加到实例方法上是给对象实例上锁\",{\"1\":{\"588\":1}}],[\"关键字加到\",{\"1\":{\"588\":1}}],[\"关键字的使用方式主要有下面\",{\"1\":{\"588\":1}}],[\"关键字两者都能保证\",{\"1\":{\"578\":1,\"590\":1}}],[\"关键字能保证数据的可见性\",{\"1\":{\"578\":1,\"590\":1}}],[\"关键词和各种\",{\"1\":{\"7\":1}}],[\"关闭自动提交\",{\"1\":{\"446\":1}}],[\"关联从节点\",{\"1\":{\"418\":1}}],[\"关系型数据库通常都是执行命令之前记录日志\",{\"1\":{\"413\":1}}],[\"关系型数据库都有acid特性\",{\"1\":{\"231\":1}}],[\"关系模型表明了数据库中所存储的数据之间的联系\",{\"1\":{\"224\":1}}],[\"关系中\",{\"1\":{\"219\":2}}],[\"关于查看运行状态\",{\"1\":{\"109\":1}}],[\"关于\",{\"0\":{\"0\":1,\"45\":1}}],[\"中花费的\",{\"1\":{\"725\":1}}],[\"中是没有与之对应的类的\",{\"1\":{\"711\":1}}],[\"中更小的一个值\",{\"1\":{\"662\":1}}],[\"中每熬过一次\",{\"1\":{\"662\":1}}],[\"中就会出现\",{\"1\":{\"600\":1}}],[\"中使用的\",{\"1\":{\"600\":1}}],[\"中实现的\",{\"1\":{\"592\":1}}],[\"中synchronized和reentrantlock等独占锁就是悲观锁思想的实现\",{\"1\":{\"582\":1}}],[\"中java\",{\"1\":{\"581\":1}}],[\"中被引入的\",{\"1\":{\"539\":1}}],[\"中被称为\",{\"1\":{\"380\":1}}],[\"中也是用到了适配器模式适配controller\",{\"1\":{\"437\":1}}],[\"中存储的就是对象的句柄地址\",{\"1\":{\"657\":1}}],[\"中存储的直接就是对象的地址\",{\"1\":{\"656\":1}}],[\"中存储的地理位置信息的经纬度数据通过\",{\"1\":{\"405\":1}}],[\"中存在\",{\"1\":{\"303\":1}}],[\"中存在的队头阻塞问题\",{\"1\":{\"190\":1}}],[\"中储存的数字值减一\",{\"1\":{\"384\":1}}],[\"中储存的数字值增一\",{\"1\":{\"384\":1}}],[\"中数据的最小单元\",{\"1\":{\"380\":1}}],[\"中级调度\",{\"1\":{\"368\":1}}],[\"中指定排名范围\",{\"1\":{\"345\":1,\"362\":1}}],[\"中指定排名范围内的所有元素\",{\"1\":{\"345\":1,\"362\":1}}],[\"中指定范围内的元素\",{\"1\":{\"345\":1,\"362\":1}}],[\"中所有的键值对\",{\"1\":{\"345\":1,\"362\":1}}],[\"中任意选择数据淘汰\",{\"1\":{\"328\":2}}],[\"中挑选最不经常使用的数据淘汰\",{\"1\":{\"328\":1}}],[\"中挑选最近最少使用的数据淘汰\",{\"1\":{\"328\":1}}],[\"中挑选将要过期的数据淘汰\",{\"1\":{\"328\":1}}],[\"中有一个叫做\",{\"1\":{\"313\":1}}],[\"中最简单同时也是最常用的一个数据结构\",{\"1\":{\"309\":1,\"383\":1}}],[\"中最小的事务\",{\"1\":{\"288\":1}}],[\"中增加的\",{\"1\":{\"306\":1}}],[\"中不存在对应的数据\",{\"1\":{\"303\":1}}],[\"中不存在\",{\"1\":{\"303\":1}}],[\"中服务端把\",{\"1\":{\"303\":1}}],[\"中读取数据\",{\"1\":{\"302\":1,\"303\":1}}],[\"中出现的子查询将被标记为\",{\"1\":{\"243\":1}}],[\"中主要使用\",{\"1\":{\"181\":1}}],[\"中新加入了大量的状态码\",{\"1\":{\"181\":1}}],[\"中通过binding\",{\"1\":{\"84\":1}}],[\"中间还必须经过exchange\",{\"1\":{\"84\":1}}],[\"中间件本身\",{\"1\":{\"97\":1}}],[\"中间件协议\",{\"1\":{\"81\":1}}],[\"中间件同产品\",{\"1\":{\"74\":1}}],[\"中间件云原生\",{\"0\":{\"40\":1,\"134\":1}}],[\"中引入了\",{\"1\":{\"23\":1}}],[\"中\",{\"0\":{\"20\":1},\"1\":{\"30\":1,\"66\":1,\"84\":2,\"174\":1,\"175\":2,\"181\":1,\"219\":3,\"220\":1,\"243\":1,\"248\":1,\"314\":1,\"317\":2,\"346\":1,\"374\":1,\"393\":3,\"395\":1,\"396\":1,\"402\":2,\"405\":1,\"437\":1,\"578\":1,\"662\":1,\"689\":1,\"710\":1}}],[\"中的永久代\",{\"1\":{\"671\":1}}],[\"中的共享资源\",{\"1\":{\"624\":1}}],[\"中的一个关键字\",{\"1\":{\"587\":1}}],[\"中的方法抛出异常的时候\",{\"1\":{\"459\":1}}],[\"中的元素\",{\"1\":{\"405\":1}}],[\"中的分布式锁自带自动续期机制\",{\"1\":{\"376\":1}}],[\"中的大部分命令都是\",{\"1\":{\"362\":1}}],[\"中的所有元素\",{\"1\":{\"345\":1,\"362\":1}}],[\"中的数据\",{\"1\":{\"302\":1}}],[\"中的历史版本\",{\"1\":{\"286\":1}}],[\"中的信息会不断变化\",{\"1\":{\"8\":1}}],[\"中的\",{\"1\":{\"7\":2,\"29\":1,\"210\":2,\"287\":1,\"302\":2,\"314\":1,\"374\":1,\"377\":1,\"386\":1,\"389\":1,\"392\":2,\"437\":1}}],[\"中断\",{\"1\":{\"3\":1,\"592\":1}}],[\"因此称为类变量\",{\"1\":{\"704\":1}}],[\"因此除了\",{\"1\":{\"695\":1}}],[\"因此g1的记忆集是一个哈希表\",{\"1\":{\"687\":1}}],[\"因此会产生内存碎片\",{\"1\":{\"685\":1}}],[\"因此会有较大的计算开销\",{\"1\":{\"260\":1}}],[\"因此传统的锁机制就称为\",{\"1\":{\"618\":1}}],[\"因此创建n+n个核心线程\",{\"1\":{\"609\":1}}],[\"因此这种策略会降低对于新任务提交速度\",{\"1\":{\"606\":1}}],[\"因此当其他cpu需要读取这个变量时\",{\"1\":{\"579\":1}}],[\"因此需要先通过取模运算\",{\"1\":{\"548\":1}}],[\"因此从二级缓存中拿去aservice进行依赖注入\",{\"1\":{\"450\":1}}],[\"因此spring无法感知\",{\"1\":{\"448\":1}}],[\"因此slave断开太久就会导致没有备份的数据被覆盖\",{\"1\":{\"421\":1}}],[\"因此slave做数据同步\",{\"1\":{\"420\":1}}],[\"因此\",{\"1\":{\"401\":1,\"415\":1,\"607\":1,\"689\":1}}],[\"因此innodb表数据文件本身就是索引\",{\"1\":{\"262\":1}}],[\"因此被称为平衡二叉树\",{\"1\":{\"260\":1}}],[\"因此哈希表可以快速检索数据\",{\"1\":{\"258\":1}}],[\"因此每发送完一个分组需要设置一个超时计时器\",{\"1\":{\"203\":1}}],[\"因此不需要保证线程安全\",{\"1\":{\"451\":1}}],[\"因此不会出现循环依赖\",{\"1\":{\"450\":1}}],[\"因此不会存在并发问题\",{\"1\":{\"155\":1}}],[\"因此不能代理声明final类型的类和方法\",{\"1\":{\"516\":1}}],[\"因此不能通过b=2来进一步减少需要扫描的记录数量\",{\"1\":{\"271\":1}}],[\"因此不能会话保持\",{\"1\":{\"60\":1}}],[\"因此库存工作单中需要添加字段保证只会释放一次库存\",{\"1\":{\"155\":1}}],[\"因此消息需要序列化和反序列化\",{\"1\":{\"86\":1}}],[\"因此长时间存储数据是非常好的\",{\"1\":{\"85\":1}}],[\"因此有了一致性hash算法\",{\"1\":{\"60\":1}}],[\"因此将静态文件交给nginx处理\",{\"1\":{\"55\":1}}],[\"因此叫做全量同步\",{\"1\":{\"420\":1}}],[\"因此叫\",{\"1\":{\"16\":1}}],[\"因此线程之间的相互通信无需调用内核\",{\"1\":{\"6\":1}}],[\"因为g1的分区是按region分的\",{\"1\":{\"687\":1}}],[\"因为用户线程可能会不断的更新引用域\",{\"1\":{\"683\":1}}],[\"因为方法区的gc效率很低\",{\"1\":{\"647\":1}}],[\"因为它是无界队列\",{\"1\":{\"634\":1}}],[\"因为它在传输过程中不会对数据进行加密\",{\"1\":{\"172\":1,\"191\":1}}],[\"因为公平锁为了保证时间上的绝对顺序\",{\"1\":{\"593\":1}}],[\"因为sleep\",{\"1\":{\"567\":1}}],[\"因为锁的问题\",{\"1\":{\"543\":1}}],[\"因为redis每秒都会发送一定数量的心跳包\",{\"1\":{\"430\":1}}],[\"因为数据完整性不如aof\",{\"1\":{\"416\":1}}],[\"因为数据在地址栏上不可见\",{\"1\":{\"175\":1}}],[\"因为时不时地创建一个\",{\"1\":{\"416\":1}}],[\"因为内存有限\",{\"1\":{\"326\":1}}],[\"因为缓存的写入速度是比数据库的写入速度快很多\",{\"1\":{\"302\":1}}],[\"因为会造成数据库和缓存的数据不一致问题\",{\"1\":{\"302\":1}}],[\"因为可以把缓存中的数据持久化到磁盘上\",{\"1\":{\"299\":1}}],[\"因为索引是需要占用磁盘空间的\",{\"1\":{\"277\":1}}],[\"因为对于联合索引\",{\"1\":{\"271\":1}}],[\"因为有查询优化器\",{\"1\":{\"271\":1}}],[\"因为二级索引的叶子节点存放的是主键\",{\"1\":{\"267\":1}}],[\"因为b+树是多路平衡树\",{\"1\":{\"266\":1}}],[\"因为b+树本身就是一棵多叉平衡树\",{\"1\":{\"266\":1}}],[\"因为红黑树在插入和删除节点时只需进行\",{\"1\":{\"261\":1}}],[\"因为红黑树的平衡性相对较弱\",{\"1\":{\"261\":1}}],[\"因为不会自动平衡\",{\"1\":{\"259\":1}}],[\"因为hash索引不支持顺序和范围查询\",{\"1\":{\"258\":1}}],[\"因为确定了学号或者是身份证就能确定姓名\",{\"1\":{\"219\":1}}],[\"因为现在还不知道网络的符合情况\",{\"1\":{\"201\":1}}],[\"因为服务器收到客户端断开连接的请求时\",{\"1\":{\"196\":1}}],[\"因为\",{\"1\":{\"175\":1,\"180\":1}}],[\"因为一个\",{\"1\":{\"174\":1,\"214\":1}}],[\"因为诚哥写的就是恐龙商城\",{\"1\":{\"136\":1}}],[\"因为前面也说了rpc是双向直接网络通讯\",{\"1\":{\"75\":1}}],[\"因为key不再重复\",{\"1\":{\"31\":1}}],[\"因为磁头移动方向上可能已经没有请求需要处理了\",{\"1\":{\"16\":1}}],[\"因为互斥对象只有一个\",{\"1\":{\"7\":1}}],[\"有三个步骤需要stw\",{\"1\":{\"687\":1}}],[\"有以下特点\",{\"1\":{\"684\":1}}],[\"有以下解决办法\",{\"1\":{\"360\":1}}],[\"有地方引用的时候就将计数器+1\",{\"1\":{\"666\":1}}],[\"有两种模式\",{\"1\":{\"624\":1}}],[\"有两个构造函数\",{\"1\":{\"612\":1}}],[\"有一个任务\",{\"1\":{\"611\":1}}],[\"有一定的消息重复通知机制\",{\"1\":{\"131\":1}}],[\"有公平锁\",{\"1\":{\"592\":1}}],[\"有要求使用treeset\",{\"1\":{\"536\":1}}],[\"有序\",{\"1\":{\"530\":1}}],[\"有序性\",{\"1\":{\"523\":1,\"577\":1}}],[\"有序集合\",{\"0\":{\"395\":1},\"1\":{\"308\":1,\"382\":1}}],[\"有参构造和无参构造\",{\"1\":{\"485\":1}}],[\"有很多单例模式的实现方法例如双检查法\",{\"1\":{\"435\":1}}],[\"有点像是\",{\"1\":{\"395\":1}}],[\"有点类似于\",{\"1\":{\"314\":1,\"392\":1}}],[\"有遍历的需求可以使用\",{\"1\":{\"362\":1}}],[\"有时候也会全表扫描\",{\"1\":{\"362\":1}}],[\"有什么关系\",{\"0\":{\"612\":1}}],[\"有什么用\",{\"0\":{\"587\":1,\"598\":1}}],[\"有什么作用\",{\"0\":{\"505\":1}}],[\"有什么危害\",{\"0\":{\"337\":1,\"341\":1}}],[\"有什么区别\",{\"0\":{\"210\":1,\"228\":1,\"237\":1,\"590\":1,\"594\":1}}],[\"有对应的\",{\"1\":{\"311\":1}}],[\"有主题和消费组的概念\",{\"1\":{\"306\":1}}],[\"有灾难恢复机制\",{\"1\":{\"299\":1}}],[\"有何不同\",{\"1\":{\"262\":1}}],[\"有可能是多个列的长度和\",{\"1\":{\"243\":1}}],[\"有可能丢失\",{\"1\":{\"197\":1}}],[\"有哪几类行锁\",{\"0\":{\"238\":1}}],[\"有哪些常见的\",{\"0\":{\"19\":1}}],[\"有确认\",{\"1\":{\"188\":1}}],[\"有些文章中提到\",{\"1\":{\"175\":1}}],[\"有副作用\",{\"1\":{\"175\":1}}],[\"有3种确认方式\",{\"1\":{\"101\":1}}],[\"有效避免了消息丢失的风险\",{\"1\":{\"77\":1}}],[\"有效地进行流量削峰\",{\"1\":{\"75\":1}}],[\"有效减少后端压力\",{\"1\":{\"55\":1}}],[\"有效利用cpu资源\",{\"1\":{\"6\":1}}],[\"有了对集合中的元素根据键排序的能力\",{\"1\":{\"544\":1}}],[\"有了对集合内元素的搜索的能力\",{\"1\":{\"544\":1}}],[\"有了一些改进\",{\"1\":{\"210\":1}}],[\"有了序列号能够将接收到的数据根据序列号排序\",{\"1\":{\"199\":1}}],[\"有了namespace\",{\"1\":{\"31\":1}}],[\"有了进程为什么还需要线程\",{\"0\":{\"6\":1}}],[\"有名管道以磁盘文件的方式存在\",{\"1\":{\"9\":1}}],[\"有名管道严格遵循\",{\"1\":{\"9\":1}}],[\"有名管道\",{\"1\":{\"9\":1}}],[\"有删改\",{\"1\":{\"0\":1}}],[\"jar等\",{\"1\":{\"711\":1}}],[\"jar\",{\"1\":{\"711\":5}}],[\"java对象最小是16字节\",{\"1\":{\"729\":1}}],[\"java文件\",{\"1\":{\"709\":1}}],[\"java文件经过javac编译之后变成\",{\"1\":{\"467\":1}}],[\"java为每一个类都准备了一张方法表来存放类中所有的方法\",{\"1\":{\"705\":1}}],[\"java语言规范\",{\"1\":{\"703\":1}}],[\"java虚拟机规范\",{\"1\":{\"703\":1}}],[\"java程序中通常有大量的字符串等待回收\",{\"1\":{\"647\":1}}],[\"java内存结构和运行时区域有关\",{\"1\":{\"574\":1}}],[\"java内存结构和java内存模型的区别\",{\"0\":{\"574\":1}}],[\"java内存模型\",{\"0\":{\"570\":1}}],[\"java集合二\",{\"0\":{\"541\":1}}],[\"java集合由两大接口派生而来\",{\"1\":{\"528\":1}}],[\"java集合一\",{\"0\":{\"527\":1}}],[\"java变成\",{\"1\":{\"512\":1}}],[\"java反射\",{\"0\":{\"506\":1}}],[\"java序列化\",{\"0\":{\"504\":1}}],[\"java只有值传递\",{\"0\":{\"503\":1}}],[\"java值传递\",{\"0\":{\"500\":1}}],[\"java中动态代理中invocationhandler接口和proxy类是核心\",{\"1\":{\"514\":1}}],[\"java中通过实现serializable接口实现序列化功能\",{\"1\":{\"504\":1}}],[\"java中如果两个对象相同则hashcode\",{\"1\":{\"492\":1}}],[\"java中的wait\",{\"1\":{\"381\":1}}],[\"java中的nio有一个非常重要的选择器\",{\"1\":{\"22\":1}}],[\"java中的nio可以看做是i\",{\"1\":{\"22\":1}}],[\"java中的nio于java\",{\"1\":{\"22\":1}}],[\"java8可以用default关键字在接口中定义默认方法\",{\"1\":{\"487\":1}}],[\"java基础\",{\"0\":{\"526\":1}}],[\"java基础二\",{\"0\":{\"481\":1}}],[\"java基础一\",{\"0\":{\"465\":1}}],[\"java有8种基本数据类型\",{\"1\":{\"469\":1}}],[\"java有自动的垃圾回收机制\",{\"1\":{\"468\":1}}],[\"java的类是单继承的\",{\"1\":{\"468\":1}}],[\"java不支持通过指针来直接访问内存\",{\"1\":{\"468\":1}}],[\"java和c++都是面向对象的语言\",{\"1\":{\"468\":1}}],[\"java等\",{\"1\":{\"466\":1}}],[\"javascript\",{\"1\":{\"78\":1,\"81\":1}}],[\"java\",{\"0\":{\"20\":1,\"37\":1,\"46\":1,\"468\":1},\"1\":{\"7\":2,\"23\":1,\"74\":2,\"90\":1,\"314\":1,\"374\":1,\"376\":1,\"377\":1,\"392\":1,\"395\":1,\"495\":1,\"498\":6,\"515\":1,\"578\":1,\"581\":1,\"582\":1,\"587\":2,\"613\":1,\"620\":1,\"627\":1,\"630\":1,\"642\":1,\"644\":2,\"647\":1,\"651\":1,\"657\":1,\"663\":1,\"672\":2,\"676\":1,\"684\":2,\"689\":4,\"693\":1,\"695\":6,\"698\":1,\"704\":1,\"706\":1,\"711\":3,\"712\":1,\"721\":2,\"725\":1,\"726\":3}}],[\"javaguide和bilibili等网课\",{\"1\":{\"0\":1}}],[\"java菜鸟\",{\"1\":{\"0\":1}}],[\"juc常见并发容器\",{\"0\":{\"627\":1}}],[\"jmm确保所有线程看到这个变量的值是一致的\",{\"1\":{\"579\":1}}],[\"jmm和java的并发编程有关\",{\"1\":{\"574\":1}}],[\"jmm是java定义的并发编程相关的一组规范\",{\"1\":{\"572\":1}}],[\"j指向左右孩子中大的那个\",{\"1\":{\"539\":1}}],[\"j<=high\",{\"1\":{\"539\":1}}],[\"j\",{\"1\":{\"539\":10}}],[\"jit完成一次编译之后\",{\"1\":{\"467\":1}}],[\"jre是java运行时环境\",{\"1\":{\"466\":1}}],[\"jre\",{\"0\":{\"466\":1},\"1\":{\"711\":1}}],[\"jvm重要参数\",{\"0\":{\"717\":1}}],[\"jvm检查两个java类是否相同的依据\",{\"1\":{\"714\":1}}],[\"jvm中内置了三个classloader\",{\"1\":{\"711\":1}}],[\"jvm中对象的创建\",{\"0\":{\"648\":1}}],[\"jvm垃圾回收\",{\"0\":{\"658\":1}}],[\"jvm内存结构\",{\"0\":{\"637\":1}}],[\"jvm可以对这两个操作进行重排序\",{\"1\":{\"576\":1}}],[\"jvm能理解的代码就是字节码\",{\"1\":{\"467\":1}}],[\"jvm是java虚拟机\",{\"1\":{\"466\":1}}],[\"jvm\",{\"0\":{\"466\":1,\"557\":1,\"737\":1},\"1\":{\"578\":1,\"589\":1,\"594\":1,\"645\":1,\"647\":1,\"670\":1,\"689\":1,\"706\":1,\"710\":1,\"711\":2,\"723\":1,\"725\":3,\"726\":3}}],[\"jetty等\",{\"1\":{\"463\":1}}],[\"join操作\",{\"1\":{\"254\":1}}],[\"join\",{\"1\":{\"243\":3}}],[\"jwt由三个部分构成\",{\"1\":{\"150\":1}}],[\"jwt\",{\"0\":{\"150\":1},\"1\":{\"150\":1}}],[\"js\",{\"1\":{\"55\":1}}],[\"jpg\",{\"1\":{\"54\":1}}],[\"jpg会请求\",{\"1\":{\"54\":1}}],[\"jdk8\",{\"1\":{\"706\":1}}],[\"jdk8中的源码\",{\"1\":{\"495\":1}}],[\"jdk代理需要实现接口的类才能作为目标对象\",{\"1\":{\"515\":1}}],[\"jdk动态代理的效率要更好\",{\"1\":{\"516\":1}}],[\"jdk动态代理需要目标类实现接口或直接代理接口\",{\"1\":{\"516\":1}}],[\"jdk动态代理和cglib动态代理的区别\",{\"0\":{\"516\":1}}],[\"jdk动态代理\",{\"0\":{\"514\":1},\"1\":{\"507\":1,\"513\":1}}],[\"jdk是功能齐全的sdk\",{\"1\":{\"466\":1}}],[\"jdk\",{\"0\":{\"466\":1,\"551\":2},\"1\":{\"30\":2,\"551\":1,\"585\":1,\"627\":2,\"645\":2,\"704\":1,\"707\":1,\"711\":1,\"713\":1,\"721\":2}}],[\"jdk1\",{\"0\":{\"546\":1,\"547\":1},\"1\":{\"5\":1,\"389\":1,\"530\":4,\"532\":1,\"534\":1,\"538\":2,\"539\":1,\"543\":1,\"546\":2,\"547\":1,\"549\":2,\"550\":5,\"551\":5,\"599\":1,\"615\":1,\"647\":2,\"671\":3,\"680\":1,\"681\":1,\"721\":1}}],[\"jdbctemplate\",{\"1\":{\"437\":1}}],[\"jdbc\",{\"1\":{\"29\":1}}],[\"线程本地分配缓存\",{\"1\":{\"730\":1}}],[\"线程本地分配缓冲区\",{\"1\":{\"650\":1}}],[\"线程执行的\",{\"1\":{\"684\":1}}],[\"线程开始对未标记的区域做清扫\",{\"1\":{\"683\":1}}],[\"线程无法保证可达性分析的实时性\",{\"1\":{\"683\":1}}],[\"线程的消亡而消亡\",{\"1\":{\"640\":1}}],[\"线程的生命周期和状态\",{\"0\":{\"561\":1}}],[\"线程尝试释放许可证\",{\"1\":{\"624\":1}}],[\"线程尝试获取许可证\",{\"1\":{\"624\":1}}],[\"线程等待队列\",{\"1\":{\"622\":1}}],[\"线程工厂\",{\"1\":{\"605\":1}}],[\"线程池处理任务的流程了解吗\",{\"0\":{\"608\":1}}],[\"线程池中常用的阻塞队列有哪些\",{\"0\":{\"607\":1}}],[\"线程池中的线程数量大于\",{\"1\":{\"605\":1}}],[\"线程池中若有空闲线程\",{\"1\":{\"604\":1}}],[\"线程池的饱和策略有哪些\",{\"0\":{\"606\":1}}],[\"线程池的最大线程数\",{\"1\":{\"605\":1}}],[\"线程池的核心线程数量\",{\"1\":{\"605\":1}}],[\"线程池的主要参数\",{\"0\":{\"605\":1}}],[\"线程池的线程数量不确定\",{\"1\":{\"604\":1}}],[\"线程池是管理一系列线程的资源池\",{\"1\":{\"602\":1}}],[\"线程池\",{\"0\":{\"601\":1}}],[\"线程启动规则\",{\"1\":{\"576\":1}}],[\"线程会自动苏醒\",{\"1\":{\"566\":1}}],[\"线程不会自动苏醒\",{\"1\":{\"566\":1}}],[\"线程不安全\",{\"1\":{\"533\":1}}],[\"线程不安全法\",{\"1\":{\"519\":1}}],[\"线程调用了start\",{\"1\":{\"561\":1}}],[\"线程已经创建但是没有调用start\",{\"1\":{\"561\":1}}],[\"线程共有的\",{\"0\":{\"643\":1}}],[\"线程共有\",{\"1\":{\"556\":1}}],[\"线程是否安全\",{\"1\":{\"543\":1}}],[\"线程安全的\",{\"1\":{\"627\":2}}],[\"线程安全实现方式\",{\"1\":{\"551\":2}}],[\"线程安全法\",{\"1\":{\"519\":1}}],[\"线程安全\",{\"0\":{\"522\":1},\"1\":{\"494\":1,\"519\":1,\"523\":1,\"524\":1,\"533\":1}}],[\"线程上下文切换等问题\",{\"1\":{\"322\":1}}],[\"线程数\",{\"1\":{\"299\":1}}],[\"线程模式后面会详细介绍到\",{\"1\":{\"298\":1}}],[\"线程读取\",{\"1\":{\"248\":1}}],[\"线程将接收的\",{\"1\":{\"248\":1}}],[\"线程负责接收\",{\"1\":{\"248\":1}}],[\"线程来发送\",{\"1\":{\"248\":1}}],[\"线程向主库请求更新的\",{\"1\":{\"248\":1}}],[\"线程首先发起select调用\",{\"1\":{\"22\":1}}],[\"线程依然是阻塞的\",{\"1\":{\"22\":1}}],[\"线程间的同步的方式有哪些\",{\"0\":{\"7\":1}}],[\"线程更加轻量\",{\"1\":{\"6\":1}}],[\"线程私有的\",{\"0\":{\"639\":1}}],[\"线程私有\",{\"1\":{\"5\":1,\"470\":2,\"640\":1}}],[\"线程又称为轻量级进程\",{\"1\":{\"5\":1,\"556\":1}}],[\"线程\",{\"0\":{\"556\":1},\"1\":{\"5\":1}}],[\"当父类加载器无法加载时\",{\"1\":{\"714\":1}}],[\"当父类的加载器为空\",{\"1\":{\"714\":1}}],[\"当父类的加载器不为空\",{\"1\":{\"714\":1}}],[\"当遇到new\",{\"1\":{\"706\":1}}],[\"当需要调用一个类的方法的时候\",{\"1\":{\"705\":1}}],[\"当程序执行方法的时候\",{\"1\":{\"705\":1}}],[\"当这一块的内存使用完后\",{\"1\":{\"675\":1}}],[\"当垃圾回收器准备回收一个对象时\",{\"1\":{\"670\":1}}],[\"当累积的某个年龄大小超过了\",{\"1\":{\"662\":1}}],[\"当它的年龄增加到一定程度\",{\"1\":{\"662\":1}}],[\"当对象大于tlab剩余空内存或者tlab内存耗尽的时候\",{\"1\":{\"650\":1}}],[\"当常量池无法再申请到内存时会抛出\",{\"1\":{\"646\":1}}],[\"当队列容量满时\",{\"1\":{\"632\":1}}],[\"当count值为0则会将被阻塞的线程唤醒\",{\"1\":{\"626\":1}}],[\"当cpu写数据时\",{\"1\":{\"579\":1}}],[\"当调用\",{\"1\":{\"625\":1}}],[\"当获取锁失败的时候线程不会立马阻塞\",{\"1\":{\"615\":1}}],[\"当线程使用\",{\"1\":{\"625\":1}}],[\"当线程数大于核心线程数时\",{\"1\":{\"605\":1}}],[\"当线程切换回来的时候能够知道上次运行到哪里了\",{\"1\":{\"558\":1}}],[\"当有一个新的任务提交时\",{\"1\":{\"604\":1}}],[\"当有任务要处理时\",{\"1\":{\"602\":1}}],[\"当单个链表的长度大于8\",{\"1\":{\"547\":1}}],[\"当元素个数超过负载因子\",{\"1\":{\"543\":1}}],[\"当真正对数组进行添加元素操作时\",{\"1\":{\"532\":1}}],[\"当链表长度大于阈值\",{\"1\":{\"530\":1}}],[\"当使用该方法时\",{\"1\":{\"522\":1}}],[\"当使用到联合索引时\",{\"1\":{\"243\":1}}],[\"当代理类调用方法的时候\",{\"1\":{\"515\":1}}],[\"当你使用代理对象调用方法的时候实际会调用到这个方法\",{\"1\":{\"514\":1}}],[\"当集群发生故障转移时\",{\"1\":{\"424\":1}}],[\"当故障实例恢复之后也是以新的master为主节点\",{\"1\":{\"424\":1}}],[\"当子进程完成创建新\",{\"1\":{\"414\":1}}],[\"当aof变得太大时\",{\"1\":{\"414\":1}}],[\"当redis重启时\",{\"1\":{\"411\":1}}],[\"当redis实例故障之后\",{\"1\":{\"408\":1}}],[\"当该锁被释放之后\",{\"1\":{\"380\":1}}],[\"当其他进程过度消耗\",{\"1\":{\"369\":1}}],[\"当慢查询日志超过设定的最大记录条数之后\",{\"1\":{\"346\":1}}],[\"当内存不足以容纳新写入的数据时\",{\"1\":{\"342\":1}}],[\"当内存不足以容纳新写入数据时\",{\"1\":{\"328\":2}}],[\"当执行当前读时\",{\"1\":{\"292\":1}}],[\"当读取记录时\",{\"1\":{\"289\":1}}],[\"当事务回滚时用于将数据恢复到修改前的样子\",{\"1\":{\"289\":1}}],[\"当操作涉及跨多个共享变量时\",{\"1\":{\"585\":1}}],[\"当操作符左右两边的数据类型不一致时\",{\"1\":{\"278\":1}}],[\"当操作系统创建一个新进程时\",{\"1\":{\"8\":1}}],[\"当操作系统接收到进程的系统调用请求时\",{\"1\":{\"3\":1}}],[\"当没有显示的指定表的主键时\",{\"1\":{\"263\":1}}],[\"当二叉查找树不平衡时\",{\"1\":{\"259\":1}}],[\"当二叉查找树是平衡的时候\",{\"1\":{\"259\":1}}],[\"当堆表中的数据进行增删改的时候\",{\"1\":{\"256\":1}}],[\"当查询条件使用了多个索引时\",{\"1\":{\"243\":1}}],[\"当连表查询时\",{\"1\":{\"243\":1}}],[\"当前活跃对象+需要晋升的对象\",{\"1\":{\"731\":1}}],[\"当前类\",{\"0\":{\"695\":1},\"1\":{\"695\":1}}],[\"当前虚拟机的垃圾收集都采用分代收集算法\",{\"1\":{\"676\":1}}],[\"当前节点在队列中的状态\",{\"1\":{\"622\":1}}],[\"当前可以同时运行的线程数量变为最大线程数\",{\"1\":{\"605\":1}}],[\"当前method方法的参数\",{\"1\":{\"514\":1}}],[\"当前读\",{\"1\":{\"241\":1,\"282\":1,\"285\":1}}],[\"当前时间\",{\"1\":{\"158\":1}}],[\"当然是使用对象的操作而不是线程的操作\",{\"1\":{\"567\":1}}],[\"当然学号属性取值是唯一的\",{\"1\":{\"219\":1}}],[\"当然也可以不遵循这种约定\",{\"1\":{\"175\":1}}],[\"当然也可以编写自\",{\"1\":{\"81\":1}}],[\"当然也可以编写自己的插件\",{\"1\":{\"78\":1}}],[\"当一个接口中定义了\",{\"1\":{\"706\":1}}],[\"当一个对象到\",{\"1\":{\"667\":1}}],[\"当一个方法要调用其他方法\",{\"1\":{\"641\":1}}],[\"当一个线程对共享变量进行修改\",{\"1\":{\"577\":1}}],[\"当一个线程到达屏障时\",{\"1\":{\"7\":1}}],[\"当一个节点对应的客户端释放锁之后\",{\"1\":{\"381\":1}}],[\"当一台设备更换了网络\",{\"1\":{\"213\":1}}],[\"当网络设备发送ip数据包时\",{\"1\":{\"209\":1}}],[\"当网络拥塞时\",{\"1\":{\"199\":1}}],[\"当接收方来不及处理发送方的数据\",{\"1\":{\"199\":1}}],[\"当发送方发送数据之后\",{\"1\":{\"199\":1}}],[\"当主机发出\",{\"1\":{\"185\":1}}],[\"当301\",{\"1\":{\"179\":1}}],[\"当我们使用浏览器浏览网页的时候\",{\"1\":{\"172\":1,\"191\":1}}],[\"当用户点击多次提交订单的时候应该保证只会产生一个唯一的订单\",{\"1\":{\"155\":1}}],[\"当交换机到队列路由失败时才会执行returncallback\",{\"1\":{\"100\":1}}],[\"当多个不同的用户使用同一个rabbitmq\",{\"1\":{\"97\":1}}],[\"当消息在一个队列中变成死信\",{\"1\":{\"93\":1}}],[\"当路由不到时\",{\"1\":{\"92\":1}}],[\"当后台处理完成\",{\"1\":{\"23\":1}}],[\"当客户端数据到了之后才会为其服务\",{\"1\":{\"22\":1}}],[\"当应用程序发起\",{\"1\":{\"18\":1}}],[\"当应用程序需要执行某些特权指令的时候就会发生系统调用\",{\"1\":{\"3\":1}}],[\"当采用固定比例比如\",{\"1\":{\"12\":1}}],[\"当进程执行时\",{\"1\":{\"8\":1}}],[\"当\",{\"1\":{\"3\":1,\"278\":2,\"311\":2,\"345\":2,\"346\":1,\"362\":2,\"416\":1,\"459\":1,\"625\":1,\"629\":1,\"660\":1}}],[\"当外围设备完成用户请求操作之后\",{\"1\":{\"3\":1}}],[\"内置了多种优化过后的数据结构实现\",{\"1\":{\"298\":1}}],[\"内置了多种数据类型实现\",{\"1\":{\"297\":1}}],[\"内未收到确认消息\",{\"1\":{\"199\":1}}],[\"内\",{\"1\":{\"174\":1}}],[\"内直接书写带有物理分页的参数来完成物理分页功能\",{\"1\":{\"34\":1}}],[\"内部的核心类库\",{\"1\":{\"711\":1}}],[\"内部通过链表\",{\"1\":{\"627\":1}}],[\"内部通过一个\",{\"1\":{\"626\":1}}],[\"内部采用的是\",{\"1\":{\"607\":1}}],[\"内部方法使用synchronized修饰\",{\"1\":{\"543\":1}}],[\"内部方法的事务在spring中会失效\",{\"1\":{\"448\":1}}],[\"内部都是通过linkedhashmap实现\",{\"1\":{\"530\":1}}],[\"内部实现也差不多\",{\"1\":{\"389\":1}}],[\"内部包含daoauthenticationprovider用来查找用户数据并认证\",{\"1\":{\"146\":1}}],[\"内部用内存队列做排队\",{\"1\":{\"102\":1}}],[\"内部\",{\"1\":{\"29\":1,\"32\":1}}],[\"内部内存碎片\",{\"1\":{\"12\":1}}],[\"内核将数据从内核空间拷贝到用户空间\",{\"1\":{\"18\":1}}],[\"内核等待\",{\"1\":{\"18\":1}}],[\"内核态运行的进程集合可以访问计算机的任何资源\",{\"1\":{\"3\":1}}],[\"内核态\",{\"1\":{\"3\":1}}],[\"内存占用是非常高的\",{\"1\":{\"684\":1}}],[\"内存足够不会回收\",{\"1\":{\"670\":1}}],[\"内存分配和回收原则\",{\"0\":{\"659\":1}}],[\"内存分配完成后\",{\"1\":{\"651\":1}}],[\"内存对齐存放\",{\"1\":{\"654\":1}}],[\"内存屏障通常有三种\",{\"1\":{\"579\":1}}],[\"内存不够的时候会将部分数据写入外存\",{\"1\":{\"368\":1}}],[\"内存不足操作\",{\"1\":{\"299\":1}}],[\"内存交换\",{\"0\":{\"368\":1}}],[\"内存碎片清理所占用\",{\"1\":{\"350\":2}}],[\"内存碎片率=操作系统分配的内存\",{\"1\":{\"350\":1}}],[\"内存碎片率大于\",{\"1\":{\"350\":1}}],[\"内存碎片占用空间达到\",{\"1\":{\"350\":1}}],[\"内存的分配方式有\",{\"1\":{\"650\":1}}],[\"内存的分配和管理\",{\"1\":{\"2\":1}}],[\"内存的访问速度是磁盘的上千倍\",{\"1\":{\"298\":1}}],[\"内存数据库\",{\"1\":{\"297\":1}}],[\"内存管理\",{\"0\":{\"11\":1}}],[\"内存空间\",{\"1\":{\"8\":1}}],[\"以cms为例\",{\"1\":{\"732\":1}}],[\"以避免收缩\",{\"1\":{\"726\":1}}],[\"以后可以用来查找泄漏\",{\"1\":{\"725\":1}}],[\"以后由数组+链表\",{\"1\":{\"530\":1}}],[\"以便在内存不足的情况下执行\",{\"1\":{\"725\":1}}],[\"以便让应用程序自己决定如何去获取所需的类\",{\"1\":{\"711\":1}}],[\"以便它们可以跨网络传播并到达正确的目的地\",{\"1\":{\"174\":1,\"208\":1}}],[\"以保证其描述的信息符合\",{\"1\":{\"703\":1}}],[\"以用于描述某些场景专有的信息\",{\"1\":{\"698\":1}}],[\"以极高概率满足\",{\"1\":{\"684\":1}}],[\"以减少加锁和解锁的次数\",{\"1\":{\"617\":1}}],[\"以一种易于理解和解析的格式包含所有操作的日志\",{\"1\":{\"416\":1}}],[\"以判断文件是否完整\",{\"1\":{\"415\":1}}],[\"以此减少查找时间\",{\"1\":{\"547\":1}}],[\"以此来完成\",{\"1\":{\"414\":1}}],[\"以此实现非锁定读\",{\"1\":{\"289\":1}}],[\"以上的命令\",{\"1\":{\"345\":1,\"362\":1}}],[\"以上两者都是为了集群的大部分可用\",{\"1\":{\"165\":1}}],[\"以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果\",{\"1\":{\"278\":1}}],[\"以\",{\"1\":{\"278\":1,\"376\":1}}],[\"以太网地址等\",{\"1\":{\"213\":1}}],[\"以外\",{\"1\":{\"174\":1}}],[\"以降低系统复杂性和提高灵活性\",{\"1\":{\"144\":1}}],[\"以下几种情况必须对类进行初始化\",{\"1\":{\"706\":1}}],[\"以下几种查询条件就能利用联合索引\",{\"1\":{\"271\":1}}],[\"以下字段适合创建索引\",{\"1\":{\"274\":1}}],[\"以下针对我简历上的三个项目进行复习\",{\"1\":{\"135\":1}}],[\"以下列举将表中level\",{\"1\":{\"33\":1}}],[\"以支付宝支付系统为例\",{\"1\":{\"133\":1}}],[\"以异步的方式完成交易\",{\"1\":{\"132\":1}}],[\"以及被\",{\"1\":{\"711\":1}}],[\"以及以前的版本中与\",{\"1\":{\"681\":1}}],[\"以及\",{\"1\":{\"306\":1,\"399\":1}}],[\"以及消费者从broker中消费数据的整个流程\",{\"1\":{\"86\":1}}],[\"以及设备启动等功能\",{\"1\":{\"2\":1}}],[\"以实现从多方面进行扩展\",{\"1\":{\"78\":1,\"81\":1}}],[\"以轮训方式分发请求\",{\"1\":{\"60\":1}}],[\"以至于不能满足任意进程所需要的内存分配请求\",{\"1\":{\"12\":1}}],[\"以防止非法用户对系统资源的访问和操作\",{\"1\":{\"2\":1}}],[\"以提供高效可靠的网络服务\",{\"1\":{\"2\":1}}],[\"网卡软中断等网络问题也可能会导致\",{\"1\":{\"370\":1}}],[\"网站\",{\"1\":{\"314\":1,\"394\":1}}],[\"网站用于收集java知识点\",{\"1\":{\"0\":1}}],[\"网际协议\",{\"1\":{\"174\":1,\"208\":1}}],[\"网关微服务实现集群状态下的负载均衡\",{\"1\":{\"136\":1}}],[\"网速稳定且快\",{\"1\":{\"57\":1}}],[\"网络延迟\",{\"1\":{\"370\":1}}],[\"网络问题\",{\"0\":{\"370\":1}}],[\"网络设备根据目的\",{\"1\":{\"209\":1}}],[\"网络地址转换\",{\"1\":{\"174\":1,\"210\":1,\"211\":1}}],[\"网络地址转换协议\",{\"1\":{\"174\":1}}],[\"网络层\",{\"0\":{\"174\":1,\"207\":1}}],[\"网络是计算机系统中连接不同计算机的方式\",{\"1\":{\"2\":1}}],[\"网络管理\",{\"1\":{\"2\":1}}],[\"的同步策略\",{\"1\":{\"726\":1}}],[\"的实例来减少不必要的内存使用\",{\"1\":{\"726\":1}}],[\"的实现类\",{\"1\":{\"612\":1}}],[\"的实现为一个\",{\"1\":{\"386\":1}}],[\"的实现依赖于\",{\"1\":{\"286\":1}}],[\"的实现\",{\"0\":{\"286\":1},\"1\":{\"663\":1}}],[\"的最大大小\",{\"1\":{\"721\":1}}],[\"的最大线程数是\",{\"1\":{\"607\":1}}],[\"的fgc阈值\",{\"1\":{\"721\":1}}],[\"的永久代\",{\"1\":{\"721\":1}}],[\"的大小\",{\"1\":{\"721\":1}}],[\"的大版本号\",{\"1\":{\"692\":1}}],[\"的全部要求\",{\"1\":{\"703\":1}}],[\"的全称为\",{\"1\":{\"620\":1}}],[\"的全称是\",{\"1\":{\"583\":1}}],[\"的访问标记\",{\"1\":{\"694\":1}}],[\"的常量值等\",{\"1\":{\"693\":1}}],[\"的常见应用场景如下\",{\"1\":{\"309\":1,\"314\":1}}],[\"的小版本号\",{\"1\":{\"692\":1}}],[\"的文件\",{\"1\":{\"689\":1}}],[\"的由来\",{\"1\":{\"684\":1}}],[\"的另一个大优势\",{\"1\":{\"684\":1}}],[\"的条件则相对苛刻许多\",{\"1\":{\"672\":1}}],[\"的对象\",{\"0\":{\"668\":1}}],[\"的对象作为起点\",{\"1\":{\"667\":1}}],[\"的映射关系\",{\"1\":{\"647\":1}}],[\"的映射表\",{\"1\":{\"389\":1}}],[\"的内置类加载器本身没有父类加载器\",{\"1\":{\"713\":1}}],[\"的内存\",{\"1\":{\"640\":1}}],[\"的内部元素并不是按照放入的时间排序\",{\"1\":{\"607\":1}}],[\"的线程安全版本\",{\"1\":{\"634\":1}}],[\"的特性\",{\"1\":{\"633\":1}}],[\"的初始值为\",{\"1\":{\"626\":1}}],[\"的操作来减少\",{\"1\":{\"625\":1}}],[\"的使用简单\",{\"1\":{\"624\":1}}],[\"的这些缺陷\",{\"1\":{\"613\":1}}],[\"的记录\",{\"1\":{\"600\":1}}],[\"的弱引用\",{\"1\":{\"600\":1}}],[\"的原子指令\",{\"1\":{\"583\":1}}],[\"的原生字符串\",{\"1\":{\"383\":1}}],[\"的思想很简单\",{\"1\":{\"583\":1}}],[\"的方法会执行线程的准备工作\",{\"1\":{\"568\":1}}],[\"的概念\",{\"1\":{\"550\":1}}],[\"的形式\",{\"1\":{\"550\":1}}],[\"的底层数据结构类似都是采用\",{\"1\":{\"550\":1}}],[\"的底层实现\",{\"0\":{\"545\":1}}],[\"的底层实现是什么\",{\"0\":{\"311\":1}}],[\"的幂次方\",{\"0\":{\"548\":1}}],[\"的幂次方进行内存分配时\",{\"1\":{\"12\":1}}],[\"的升序排序\",{\"1\":{\"544\":1}}],[\"的主体\",{\"1\":{\"530\":2,\"550\":1}}],[\"的引用保存在字符串常量池中\",{\"1\":{\"498\":1}}],[\"的引用\",{\"1\":{\"497\":2}}],[\"的相应类型的缓存数据\",{\"1\":{\"471\":1}}],[\"的核心功能之一是自动配置\",{\"1\":{\"463\":1}}],[\"的核心容器\",{\"1\":{\"463\":1}}],[\"的入口是一个主要的配置类\",{\"1\":{\"463\":1}}],[\"的bean\",{\"1\":{\"444\":1}}],[\"的增强或通知\",{\"1\":{\"437\":1}}],[\"的增大\",{\"1\":{\"362\":1}}],[\"的容器框架\",{\"1\":{\"434\":1}}],[\"的插槽上\",{\"1\":{\"430\":1}}],[\"的数字来验证\",{\"1\":{\"415\":1}}],[\"的数据结构\",{\"1\":{\"607\":1}}],[\"的数据结构经常被用在各种排行榜的场景\",{\"1\":{\"313\":1}}],[\"的数据安全性不如\",{\"1\":{\"416\":1}}],[\"的数据是存在内存中的\",{\"1\":{\"297\":1}}],[\"的数据版本均可见\",{\"1\":{\"288\":1}}],[\"的数据版本均不可见\",{\"1\":{\"288\":1}}],[\"的数据传输服务\",{\"1\":{\"173\":2}}],[\"的计数场景\",{\"1\":{\"403\":1}}],[\"的计数结果并不是一个精确值\",{\"1\":{\"401\":1}}],[\"的空间大小更大\",{\"1\":{\"726\":1}}],[\"的空间\",{\"1\":{\"401\":1}}],[\"的空间就能存储接近2^64个不同元素\",{\"1\":{\"401\":1}}],[\"的存储结构做了优化\",{\"1\":{\"401\":1}}],[\"的存在\",{\"1\":{\"239\":1}}],[\"的场景\",{\"1\":{\"400\":1}}],[\"的范围来获取元素的列表\",{\"1\":{\"395\":1}}],[\"的元素个数\",{\"1\":{\"399\":1}}],[\"的元素\",{\"1\":{\"387\":1}}],[\"的分布式可重入锁\",{\"1\":{\"376\":1}}],[\"的分配和管理等\",{\"1\":{\"2\":1}}],[\"的吞吐量\",{\"1\":{\"369\":1}}],[\"的阻塞点\",{\"1\":{\"366\":1}}],[\"的性能产生影响\",{\"1\":{\"350\":1}}],[\"的性能更高\",{\"1\":{\"237\":1}}],[\"的命令\",{\"1\":{\"345\":1}}],[\"的交集\",{\"1\":{\"345\":1,\"362\":1}}],[\"的多线程只是在网络数据的读写上使用\",{\"1\":{\"323\":1}}],[\"的唯一计数\",{\"1\":{\"317\":1,\"402\":1}}],[\"的长度为什么是\",{\"0\":{\"548\":1}}],[\"的长度获取直接读取\",{\"1\":{\"311\":1}}],[\"的长度限制\",{\"1\":{\"175\":1}}],[\"的一半\",{\"1\":{\"310\":1}}],[\"的一种特例\",{\"1\":{\"243\":1}}],[\"的缓存\",{\"1\":{\"309\":1}}],[\"的应用场景是什么\",{\"0\":{\"314\":1}}],[\"的应用场景有哪些\",{\"0\":{\"309\":1}}],[\"的应用层协议\",{\"1\":{\"175\":1}}],[\"的写性能非常高\",{\"1\":{\"304\":1}}],[\"的读写\",{\"1\":{\"304\":1}}],[\"的问题\",{\"1\":{\"303\":1}}],[\"的情况\",{\"1\":{\"300\":1}}],[\"的时候\",{\"1\":{\"550\":1,\"605\":1,\"721\":1}}],[\"的时候开始清理\",{\"1\":{\"350\":2}}],[\"的时间复杂度内插入和删除元素\",{\"1\":{\"539\":1}}],[\"的时间复杂度更小\",{\"1\":{\"345\":2,\"362\":2}}],[\"的时间内收到了\",{\"1\":{\"197\":1}}],[\"的时机却不同\",{\"1\":{\"290\":1}}],[\"的差异\",{\"0\":{\"290\":1}}],[\"的事务\",{\"1\":{\"288\":1}}],[\"的结合体\",{\"1\":{\"395\":1}}],[\"的结合\",{\"1\":{\"282\":1}}],[\"的隔离级别\",{\"1\":{\"282\":1}}],[\"的前后条件中有一个列没有索引\",{\"1\":{\"278\":1}}],[\"的自增主键\",{\"1\":{\"263\":1}}],[\"的表中\",{\"1\":{\"263\":1}}],[\"的要求\",{\"1\":{\"220\":1}}],[\"的不同的属性子集\",{\"1\":{\"219\":1}}],[\"的优势还包括\",{\"1\":{\"210\":1}}],[\"的拥塞控制是怎么实现的\",{\"0\":{\"201\":1}}],[\"的接收端只允许发送端发送接收端缓冲区能接纳的数据\",{\"1\":{\"199\":1}}],[\"的话\",{\"1\":{\"197\":1,\"304\":1,\"624\":2,\"625\":1}}],[\"的缩写\",{\"1\":{\"191\":1,\"222\":1}}],[\"的协议有哪些\",{\"0\":{\"191\":2}}],[\"的传输效率要比\",{\"1\":{\"188\":1}}],[\"的作用是什么\",{\"0\":{\"184\":1}}],[\"的区别主要体现在实现线程安全的方式上不同\",{\"1\":{\"550\":1}}],[\"的区别在于元素出队顺序是与优先级相关的\",{\"1\":{\"539\":1}}],[\"的区别和共同点\",{\"0\":{\"299\":1}}],[\"的区别\",{\"0\":{\"182\":1,\"188\":1,\"468\":1,\"494\":1,\"538\":1,\"543\":1,\"550\":1,\"568\":1}}],[\"的区别是什么\",{\"0\":{\"29\":1}}],[\"的路由选择协议\",{\"1\":{\"174\":1}}],[\"的非常安全的网络传输协议的主要原因\",{\"1\":{\"172\":1,\"191\":1}}],[\"的消息中间件\",{\"1\":{\"78\":1}}],[\"的转义\",{\"1\":{\"66\":1}}],[\"的resulttype\",{\"1\":{\"30\":1}}],[\"的值理解为许可证的数量\",{\"1\":{\"624\":1}}],[\"的值确定的情况下\",{\"1\":{\"219\":1}}],[\"的值\",{\"1\":{\"30\":1,\"332\":2,\"362\":1,\"374\":1,\"384\":5,\"624\":3}}],[\"的取值方式为使用反射从参数对象中获取\",{\"1\":{\"29\":1}}],[\"的\",{\"0\":{\"551\":1},\"1\":{\"29\":1,\"30\":4,\"173\":2,\"180\":2,\"190\":1,\"243\":1,\"263\":1,\"304\":1,\"311\":1,\"383\":2,\"386\":1,\"389\":1,\"405\":1,\"416\":1,\"550\":1,\"600\":1,\"607\":1,\"612\":1,\"620\":1,\"624\":1,\"625\":1,\"684\":1}}],[\"的参数\",{\"1\":{\"30\":1,\"726\":1}}],[\"的参数设置方法\",{\"1\":{\"29\":1}}],[\"的参数占位符\",{\"1\":{\"29\":1}}],[\"的改进版\",{\"1\":{\"23\":1}}],[\"的执行是由操作系统的内核来完成的\",{\"1\":{\"18\":1}}],[\"的网络通信的基本操作单元\",{\"1\":{\"9\":1}}],[\"的请求或释放\",{\"1\":{\"2\":1}}],[\"写完之后\",{\"1\":{\"629\":1}}],[\"写屏障\",{\"1\":{\"579\":1}}],[\"写出rdb文件都比较耗时\",{\"1\":{\"408\":1}}],[\"写到队列中的消息\",{\"1\":{\"360\":1}}],[\"写写互斥\",{\"1\":{\"239\":1}}],[\"写写下加锁\",{\"1\":{\"152\":1}}],[\"写作x\",{\"1\":{\"219\":1}}],[\"写在stream中\",{\"1\":{\"139\":1}}],[\"写在http模块中基于内容和协议的交换\",{\"1\":{\"139\":1,\"142\":1}}],[\"写操作频繁的话会导致cache中数据频繁被删除\",{\"1\":{\"302\":1}}],[\"写操作的响应有一定的延时\",{\"1\":{\"113\":1}}],[\"写操作之后读操作能获得最新的数据\",{\"1\":{\"113\":1}}],[\"写主数据库失败\",{\"1\":{\"113\":1}}],[\"写主数据库成功\",{\"1\":{\"113\":1}}],[\"写入也不会阻塞读取操作\",{\"1\":{\"628\":1}}],[\"写入到\",{\"1\":{\"248\":1,\"303\":1}}],[\"写入主数据库后数据同步到从数据库\",{\"1\":{\"114\":1}}],[\"写入主数据库后要将数据同步到从数据库\",{\"1\":{\"113\":1}}],[\"写入完成之后的数据同步时\",{\"1\":{\"113\":1}}],[\"写入\",{\"1\":{\"109\":1,\"302\":1}}],[\"写\",{\"1\":{\"2\":1,\"302\":1,\"303\":1}}],[\"唤醒等待线程\",{\"1\":{\"381\":1}}],[\"唤醒\",{\"1\":{\"2\":1}}],[\"阻塞状态\",{\"1\":{\"561\":1}}],[\"阻塞队列可以通过加锁来实现\",{\"1\":{\"630\":1}}],[\"阻塞队列\",{\"1\":{\"540\":1,\"631\":1}}],[\"阻塞等\",{\"1\":{\"8\":1}}],[\"阻塞\",{\"1\":{\"2\":1,\"370\":1}}],[\"撤销cancel\",{\"1\":{\"123\":1}}],[\"撤销\",{\"1\":{\"2\":1}}],[\"希望能对学java的同学提供一点帮助\",{\"1\":{\"0\":1}}],[\"秋招面经\",{\"1\":{\"0\":1}}],[\"摄影爱好者\",{\"1\":{\"0\":1}}],[\"摸鱼王者\",{\"1\":{\"0\":1}}],[\"杭州某电计算机专业研二学生\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,xt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(ot(t,D[s],n)):e==="search"?self.postMessage(nt(t,D[s],n)):self.postMessage({suggestions:ot(t,D[s],n),results:nt(t,D[s],n)})};
//# sourceMappingURL=index.js.map
